{
  "name": "HumanEval_9_rolling_max",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; From a given list of integers, generate a list of rolling maximum element found until given moment\n;; in the sequence.\n;; >>> (rolling_max (list 1 2 3 2 3 4 2))\n;; (list 1 2 3 3 3 4 4)\n(define (rolling_max numbers)\n",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))\n    (check-equal? (candidate (list 4 3 2 1)) (list 4 4 4 4))\n    (check-equal? (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100))\n))\n\n(test-humaneval)",
  "completions": [
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((new_max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max new_max)\n            (let ((new_new_max (car (cdr (cdr numbers))))\n                  (result (cons max new_max new_new_max)))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list result)\n                (let ((new_result (car (cdr (cdr (cdr numbers))))\n                       (new_new_result (car (cdr (cdr (cdr (cdr numbers)))))))\n                  (if (null? (cdr (cdr (cdr (cdr (cdr numbers))))))\n                    (list result new_result new_new_result)\n                    (let ((new_new_new_result (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((new_max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max new_max)\n            (let ((new_new_max (car (cdr (cdr numbers))))\n                  (result (cons max new_max (cons new_max new_new_max))))\n              (cons max new_max new_new_max result)))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                  (car numbers)\n                  (if (null? (cdr (cdr result)))\n                    (car (cdr numbers))\n                    (if (null? (cdr (cdr (cdr result))))\n                      (car (cdr (cdr (cdr numbers))))\n                      (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (c",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (cdr (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car next)))\n              (if (null? (cdr next))\n                (list max)\n                (let ((next (cdr (cdr next))))\n                  (if (null? next)\n                    (list max)\n                    (let ((max (car next)))\n                      (if (null? (cdr next))\n                        (list max)\n                        (let ((next (cdr (cdr next))))\n                          (if (null? next)\n                            (list max)\n                            (let ((max (car next)))\n                              (if (null? (cdr next))\n                                (list max)\n                                (let ((next (cdr (cdr next))))\n                                  (if (null? next)\n                                    (list max)\n                                    (let ((max (car next)))\n                                      (if (null? (cdr next))\n                                        (list max)\n                                        (let ((next (cdr (cdr next))))\n                                          (if (null? next)\n                                            (list max)\n                                            (let ((max (car next)))\n                                              (if (null? (cdr next))\n                                                (list max)\n                                                (let ((next (cdr (cdr next))))\n                                                  (if (null? next)\n                                                    (list max)\n                                                    (let ((max (car next)))\n                                                      (if (null? (cdr next))\n                                                        (list max)\n                                                        (let ((next (cdr (cdr next))))\n                                                         (if (null? next)\n                                                           (list max)\n                                                           (let ((max (car next)))\n                                ",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((n (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers)))))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list max)\n                (list max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((result (list)))\n      (for-each (lambda (n)\n                  (if (null? (cdr n))\n                    (list (car n) (car (cdr n)))\n                    (if (null? (cdr (cdr n)))\n                        (list (car n) (car (car (cdr n))))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (list (car n) (car (car (car (cdr n))))))))\n                  numbers))\n      (return result)))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (result (cons max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers))\n      result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (rolling_max-helper n)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car (cdr n)))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-helper n)\n    (cond\n      ((>= n 0) (list))\n      ((< n 0) (list))\n      ((= n 0) (list))\n      ((< n numbers)\n        (cons (car numbers)\n          (rolling_max-helper (+ n (cdr numbers)))))))\n  (rolling_max-helper 0 numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n)))))\n                                (car (cdr (cdr (cdr n)))))\n                            (car (cdr (cdr (cdr (cdr (cdr n))))))))))))\n    (result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n))\n                    (append result (car n))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers)))))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list max)\n                (list max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (car (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car next))\n                  (next (cdr next)))\n              (if (null? next)\n                (list max)\n                (let ((max (car next))\n                      (next (cdr next)))\n                  (if (null? next)\n                    (list max)\n                    (let ((max (car next))\n                          (next (cdr next)))\n                      (if (null? next)\n                        (list max)\n                        (let ((max (car next))\n                              (next (cdr next)))\n                          (if (null? next)\n                            (list max)\n                            (let ((max (car next))\n                                  (next (cdr next)))\n                              (if (null? next)\n                                (list max)\n                                (let ((max (car next))\n                                      (next (cdr next)))\n                                  (if (null? next)\n                                    (list max)\n                                    (let ((max (car next))\n                                          (next (cdr next)))\n                                      (if (null? next)\n                                        (list max)\n                                        (let ((max (car next))\n                                              (next (cdr next)))\n                                          (if (null? next)\n                                            (list max)\n                                            (let ((max (car next))\n                                                  (next (cdr next)))\n                                              (if (null? next)\n                                                (list max)\n                                                (let ((max (car next))\n                                                      (next (cdr next)))\n                                                  (if (null? next)\n                                                    (list max)\n                                                    (let ((max (car next))\n                                                          (next (cdr next)))\n                                                        (if (null?",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (append result (car n))\n                  (append result (car n) (car (cdr n))))\n                numbers)\n      (set! result (cons (car (first (cdr n))), result))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((new_max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max new_max)\n            (let ((new_max (car (cdr (cdr numbers))))\n                  (new_max_list (cons max new_max)))\n              (let ((new_max_list (cons max new_max)))\n                (if (null? (cdr (cdr (cdr numbers))))\n                  (list new_max_list)\n                  (let ((new_max_list (cons new_max_list)))\n                    (list new_max_list))))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n)))\n                (cons (car n) result))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max-numbers)\n    (define (rolling_max-numbers-numbers)\n      (define (rolling_max-numbers-numbers-numbers)\n        (define (rolling_max-numbers-numbers-numbers-numbers)\n          (define (rolling_max-numbers-numbers-numbers-numbers-numbers)\n            (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers)\n              (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                  (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                    (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                      (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                        (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                          (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                            (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                              (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                                (define (rolling_max-numbers-numbers-numbers-",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (rolling_max-helper (cdr numbers))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  (cons (car n) result))\n              numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (list (car n) (car (cdr n)))\n                  (if (null? (cdr (cdr n)))\n                      (list (car n) (car (car (cdr n))))\n                      (if (null? (cdr (cdr (cdr n))))\n                          (list (car n) (car (car (car (cdr n))))))))\n                numbers))\n    (return result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (car numbers)\n                    (if (null? (cdr (cdr result)))\n                        (car (cdr numbers))\n                        (if (null? (cdr (cdr (cdr result))))\n                            (car (cdr (cdr (cdr numbers))))\n                            (car (cdr (cdr (cdr (cdr numbers))))))))\n                  (car numbers))\n              (result (cons n result))))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max_helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max_helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max_helper (cdr numbers))))\n    (rolling_max_helper n)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max_helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max_helper (cdr n))))\n    (rolling_max_helper (numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (if (null? (cdr n))\n        (list (car n))\n        (cons (car n) (rolling_max-helper (cdr n))))))\n  (if (null? numbers)\n    (list)\n    (rolling_max-helper (reverse numbers))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (append result (car n))\n                  (append result (car n))\n                  (append result (car n))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((max_numbers (list)))\n    (for-each\n      (lambda (n)\n        (if (null? max_numbers)\n          (append max_numbers (list n))\n          (if (> (car n) (car max_numbers))\n            (set-cdr! (cdr max_numbers) (car n))\n            (set-cdr! max_numbers (car n))))))\n    (reverse max_numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (list (car n) (car (cdr n)))\n                    (if (null? (cdr (cdr n)))\n                        (list (car (car n)) (car (car (cdr n))))\n                        (list (car (car n)) (car (car (cdr n)))))))\n      numbers\n      (append result (car (car n))))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n))\n                    (append result (car n))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max-iteration numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers) (rolling_max-iteration (cdr numbers))))))\n  (rolling_max-iteration numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((new_max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max new_max)\n            (let ((new_new_max (car (cdr (cdr numbers))))\n                  (result (cons max new_max (cons new_max new_new_max))))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list result)\n                (let ((new_result (car (cdr (cdr (cdr numbers))))\n                       (new_new_result (car (cdr (cdr (cdr (cdr numbers)))))))\n                  (if (null? (cdr (cdr (cdr (cdr numbers))))))\n                    (list result new_result new_new_result)\n                    (let ((new_new_new_result (car (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                      (if (null? (cdr (cdr (cdr (cdr (cdr numbers))))))\n                        (list result new_result new_new_result new_new_new_result)\n                        (let ((new_new_new_new_result (car (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                              (result (cons max new_max new_new_max new_new_new_max)\n                                      (cons new_max new_new_max new_new_new_max)\n                                      (cons new_new_max new_new_new_max new_new_new_new_max)\n                                      (cons new_new_new_max new_new_new_new_max new_new_new_new_max)\n                                      (cons new_new_new_new_max new_new_new_new_max new_new_new_new_new_max)\n                                      (cons new_new_new_new_new_max new_new_new_new",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers)\n              (set! result (cons (car (car n)) result))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n) (car (cdr n)) (car n))))\n                numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-helper n)\n    (cond\n      ((= n 0) (list))\n      ((< n 0) (list (rolling_max-helper (- n 1))))\n      (else (cons (max numbers) (rolling_max-helper (- n 1))))))\n  (rolling_max-helper numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (result (cons max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (if (null? (cdr n))\n        (car n)\n        (if (null? (cdr (cdr n)))\n          (car (cdr n))\n          (if (null? (cdr (cdr (cdr n))))\n            (car (cdr (cdr (cdr n))))\n            (rolling_max-helper (cdr n))))))))",
    "  (define (rolling_max_helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max_helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max_helper (cdr numbers))))\n    (rolling_max_helper (numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  numbers)\n              (result (cons (car n) result))))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (result (cons max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (car (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car next)))\n              (if (null? (cdr next))\n                (list max)\n                (let ((next (car (cdr next))))\n                  (if (null? next)\n                    (list max)\n                    (let ((max (car next)))\n                      (if (null? (cdr next))\n                        (list max)\n                        (let ((max (car (cdr next))))\n                          (if (null? (cdr (cdr next)))\n                            (list max)\n                            (let ((max (car (cdr (cdr next))))\n                                  (if (null? (cdr (cdr (cdr next))))\n                                    (list max)\n                                    (let ((max (car (cdr (cdr (cdr next))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (rolling_max-helper (cdr numbers))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers)\n          (rolling_max-recursion (cdr numbers))))))\n  (rolling_max-recursion numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (mapcar (lambda (n) (if (null? n) max n)) (cdr numbers)))\n    ))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    []\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max_iteration numbers)\n    (if (empty? numbers)\n      (list)\n      (if (null? numbers)\n        (list)\n        (if (null? (cdr numbers))\n          (list (car numbers))\n          (cons (car numbers) (rolling_max_iteration (cdr numbers))))))))\n",
    "  (if (null? numbers)\n    (list)\n    (let ((result (list)))\n      (for-each (lambda (n)\n                  (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n))\n                  )\n                numbers)\n        (set result (cons (car (car n)) result))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n)))))\n                                (car (cdr (cdr (cdr n))))\n                                (car (cdr (cdr (cdr (cdr (cdr n))))))))))))\n      (append result (car numbers)))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? result)\n                    (result n)\n                    (if (null? (cdr result))\n                        (cdr result)\n                        (if (> (car result) (car n))\n                            (set! result (cons (car n) result))\n                            (set! result (cons (car result) result))))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (car (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car (cdr (cdr numbers)))))\n              (if (null? max)\n                (list max)\n                (let ((next (car (cdr (cdr (cdr numbers)))))\n                      (if (null? next)\n                        (list max)\n                        (let ((max (car (cdr (cdr (cdr (cdr numbers))))))))\n                          (if (null? max)\n                            (list max)\n                            (let ((next (car (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                                (if (null? next)\n                                  (list max)\n                                  (let ((max (car (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                                        (if (null? max)\n                                          (list max)\n                                          (let ((next (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))))))\n                                        (if (null? max)\n                                          (list max)\n                                          (let ((max (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers)\n          (rolling_max-recursion (cdr numbers))))))\n  (rolling_max-recursion numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers)))))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list max)\n                (let ((max (car (cdr (cdr (cdr numbers)))))\n                      (list max max)))))\n          ))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-rec numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers) (rolling_max-rec (cdr numbers))))))\n  (rolling_max-rec numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max-recursion numbers)\n    (if (null? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? (cdr numbers))\n          (list max)\n          (let ((max (rolling_max-recursion (cdr numbers))))\n            (if (null? max)\n              (list)\n              (list max max)\n              (rolling_max-recursion (cdr numbers) (cons max max))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? (cdr numbers))\n          (list max)\n          (let ((max (rolling_max-recursion (cdr numbers))))\n            (let ((max (if (null? max)\n                                 (car numbers)\n                                 max)))\n              (let ((max (if (null? max)\n                                 (car numbers)\n                                 max)))\n                (let ((max (if (null? max)\n                                 (car numbers)\n                                 max)))\n                  (list max))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (list n)\n                    (if (null? (cdr (cdr n)))\n                        (list n)\n                        (append (list n) (rolling_max (cdr n))))))\n      numbers\n      (append result (car n))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-recursion numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (car numbers)\n        (cons (car numbers) (rolling_max-recursion (cdr numbers))))))\n  (rolling_max-recursion numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (while (< (length numbers) (length result))\n      (if (> (car numbers) (car result))\n        (setcar result (car numbers)))\n      (setcar numbers (cdr numbers)))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (car numbers)\n                    (if (null? (cdr (cdr result)))\n                        (car (cdr numbers))\n                        (if (null? (cdr (cdr (cdr result))))\n                            (car (cdr (cdr (cdr numbers))))\n                            (car (cdr (cdr (cdr (cdr numbers))))))))\n                  (cons (car numbers) result))))\n  (car result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (list n)\n                    (if (null? (cdr (cdr result)))\n                        (list n)\n                        (setq result (cons (car result) (rolling_max (cdr result) (cons n (car n))))))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max-recursion numbers)\n    (if (empty? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? (cdr numbers))\n          (list max)\n          (let ((max (rolling_max-recursion (cdr numbers))))\n            (let ((max (if (null? max) (car numbers) max)))\n              (let ((max (if (null? max) (car numbers) max)))\n                (list max))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers)))))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list max)\n                (let ((max (car (cdr (cdr (cdr numbers)))))\n                      (list max max)))))\n          )\n        )\n      )\n    )\n  )\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n)\n                                      (car (cdr n))\n                                      (car (car (cdr n)))))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (car (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (if (null? max)\n                    (list max)\n                    (let ((max (car (cdr (cdr (cdr numbers)))))))))))))\n      (let ((next (car (cdr numbers))))\n        (if (null? next)\n          (list max)\n          (let ((max (car (cdr (cdr (cdr numbers))))))\n            (if (null? max)\n              (list max)\n              (let ((max (car (cdr (cdr (cdr (cdr numbers))))))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  (append result (car n)))\n              numbers)\n    (return result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (cons (car n) result))\n                (cons (car n) (if (null? (cdr n))\n                                 (cons (car n) result))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-helper n)\n    (cond\n      ((> n 0) (cons (car numbers) (rolling_max-helper (- n 1))))\n      ((= n 0) (car numbers))\n      (else (cons (car numbers) (rolling_max-helper n))))\n    (rolling_max-helper n)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list n)\n      (let ((max (car n))\n            (n (cdr n)))\n        (if (null? n)\n          (list max)\n          (let ((max (car n))\n                (n (cdr n)))\n            (if (null? n)\n              (list max)\n              (let ((max (car n))\n                    (n (cdr n)))\n                (if (null? n)\n                  (list max)\n                  (let ((max (car n))\n                        (n (cdr n)))\n                    (if (null? n)\n                      (list max)\n                      (let ((max (car n))\n                            (n (cdr n)))\n                        (if (null? n)\n                          (list max)\n                          (let ((max (car n))\n                                (n (cdr n)))\n                            (if (null? n)\n                              (list max)\n                              (let ((max (car n))\n                                    (n (cdr n)))\n                                (if (null? n)\n                                  (list max)\n                                  (let ((max (car n))\n                                        (n (cdr n)))\n                                    (if (null? n)\n                                      (list max)\n                                      (let ((max (car n))\n                                            (n (cdr n)))\n                                        (if (null? n)\n                                          (list max)\n                                          (let ((max (car n))\n                                                (n (cdr n)))\n                                            (if (null? n)\n                                              (list max)\n                                              (let ((max (car n))\n                                                   (n (cdr n)))\n                                                (if (null? n)\n                                                  (list max)\n                                                  (let ((max (car n))\n                                                         (n (cdr n)))\n                                                    (if (null? n)\n                                                      (list max)\n                                    ",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (result (cons max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n) (car (cdr n)) (car n))))\n                numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (cons (car n) result)\n                    (let ((max (car n))\n                          (new_n (cdr n)))\n                      (if (null? new_n)\n                        (cons max result)\n                        (let ((new_max (car new_n)))\n                          (if (null? (cdr new_n))\n                            (cons new_max result)\n                            (let ((new_new_n (cdr new_n)))\n                              (if (null? new_new_n)\n                                (cons new_max result)\n                                (let ((new_new_max (car new_new_n)))\n                                  (if (null? (cdr new_new_n))\n                                    (cons new_new_max result)\n                                    (cons new_max result))))))))))))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n))\n                    (append result (car n))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    []\n    (cons (max numbers) (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max_helper numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? numbers)\n        (list)\n        (if (null? numbers)\n          (list)\n          (if (null? numbers)\n            (list)\n            (if (null? numbers)\n              (list)\n              (if (null? numbers)\n                (list)\n                (if (null? numbers)\n                  (list)\n                  (if (null? numbers)\n                    (list)\n                    (if (null? numbers)\n                      (list)\n                      (if (null? numbers)\n                        (list)\n                        (if (null? numbers)\n                          (list)\n                          (if (null? numbers)\n                            (list)\n                            (if (null? numbers)\n                              (list)\n                              (if (null? numbers)\n                                (list)\n                                (if (null? numbers)\n                                  (list)\n                                  (if (null? numbers)\n                                    (list)\n                                    (if (null? numbers)\n                                      (list)\n                                      (if (null? numbers)\n                                        (list)\n                                        (if (null? numbers)\n                                          (list)\n                                          (if (null? numbers)\n                                            (list)\n                                            (if (null? numbers)\n                                              (list)\n                                              (if (null? numbers)\n                                                (list)\n                                                (if (null? numbers)\n                                                  (list)\n                                                  (if (null? numbers)\n                                                    (list)\n                                                    (if (null? numbers)\n                                                      (list)\n                                                      (if (null? numbers)\n                                                        (list)\n                                                        (if (null? numbers)\n                                                          (list)\n                                                          (if (null? numbers)\n                                                            (list)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n)\n                                      (car (cdr n))\n                                      (car n))))\n                numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-recursion numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers) (rolling_max-recursion (cdr numbers)))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (list (car n) (car (cdr n)))\n                  (if (null? (cdr (cdr n)))\n                    (list (car n) (car (cdr n)))\n                    (if (null? (cdr (cdr (cdr n))))\n                      (list (car n) (car (cdr (cdr n))))\n                      (list (car n) (car (cdr (cdr (cdr n))))))))\n                numbers))\n      (result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  (append result (car n)))\n              numbers))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    []\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-recursion numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers) (rolling_max-recursion (cdr numbers))))))\n  (rolling_max-recursion numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (cons (car n) result))\n                (cons (car n) result))\n               numbers\n               (reverse result)))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (rolling_max-helper (cdr numbers))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (null? (cdr n)) (car n) (max (car n) (car (cdr n)))))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n)))\n                (cdr n))\n              numbers))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((max (car numbers)))\n    (if (null? (cdr numbers))\n      max\n      (rolling_max (cdr numbers)))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n))\n                    (append result (car n))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    []\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        [max]\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            [max]\n            (let ((max (car (cdr (cdr numbers))))\n                  (if (null? (cdr (cdr (cdr numbers))))\n                    [max]\n                    (let ((max (car (cdr (cdr (cdr numbers))))))))))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n) (car (cdr n)) (car n))))\n                numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-rec numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (car numbers)\n        (if (null? (cdr (cdr numbers)))\n          (car (cdr numbers))\n          (if (null? (cdr (cdr (cdr numbers))))\n            (car (cdr (cdr (cdr numbers))))\n            (rolling_max-rec (cdr numbers)))))))\n  (rolling_max-rec numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (if (null? numbers)\n    []\n    (cons (max numbers)\n      (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (car (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car (cdr (cdr numbers)))))\n              (if (null? max)\n                (list max)\n                (let ((next (car (cdr (cdr (cdr numbers))))))\n                  (if (null? next)\n                    (list max)\n                    (let ((max (car (cdr (cdr (cdr (cdr numbers))))))))\n                      (if (null? max)\n                        (list max)\n                        (let ((next (car (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                          (if (null? next)\n                            (list max)\n                            (let ((max (car (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                                  (if (null? max)\n                                      (list max)\n                                      (let ((next (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))))))\n                                      (if (null? max)\n                                        (list max)\n                                        (let ((max (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  numbers)\n              (result (cons (car n) result))))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max_helper)\n    (if (null? numbers)\n      (list)\n      (list (car numbers) (rolling_max_helper (cdr numbers))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((result (cons max (rolling_max (cdr numbers))))\n              (max (car numbers)))\n          (if (null? (cdr numbers))\n            (list max)\n            (let ((result (cons max (rolling_max (cdr numbers))))\n                  (max (car numbers)))\n              (if (null? (cdr numbers))\n                (list max)\n                (let ((result (cons max (rolling_max (cdr numbers))))\n                      (max (car numbers)))\n                  (if (null? (cdr numbers))\n                    (list max)\n                    (let ((result (cons max (rolling_max (cdr numbers))))\n                          (max (car numbers)))\n                      (if (null? (cdr numbers))\n                        (list max)\n                        (let ((result (cons max (rolling_max (cdr numbers))))\n                              (max (car numbers)))\n                          (if (null? (cdr numbers))\n                            (list max)\n                            (let ((result (cons max (rolling_max (cdr numbers))))\n                                  (max (car numbers)))\n                              (if (null? (cdr numbers))\n                                (list max)\n                                (let ((result (cons max (rolling_max (cdr numbers))))\n                                      (max (car numbers)))\n                                  (if (null? (cdr numbers))\n                                    (list max)\n                                    (let ((result (cons max (rolling_max (cdr numbers))))\n                                          (max (car numbers)))\n                                      (if (null? (cdr numbers))\n                                        (list max)\n                                        (let ((result (cons max (rolling_max (cdr numbers))))\n                                              (max (car numbers)))\n                                          (if (null? (cdr numbers))\n                                            (list max)\n                                            (let ((result (cons max (rolling_max (cdr numbers))))\n                                                  (max (car numbers)))\n                                              (if (null? (",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (rolling_max-helper (cdr numbers))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers)))))\n              (list max max))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-recursion numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (let ((max (car numbers)))\n          (if (null? (cdr numbers))\n            (list max)\n            (let ((max (rolling_max-recursion (cdr numbers))))\n              (list max max))))))))\n",
    "  (if (null? numbers)\n    (list)\n    (let ((result (list)))\n      (for-each (lambda (n)\n                  (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                              (car (cdr (cdr (cdr (cdr n))))))))\n                  numbers)\n        (result (cons (car n) result))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((numbers (cdr numbers)))\n          (if (null? numbers)\n            (list max)\n            (let ((max (car numbers)))\n              (if (null? (cdr numbers))\n                (list max)\n                (let ((numbers (cdr numbers)))\n                  (if (null? numbers)\n                    (list max)\n                    (let ((max (car numbers)))\n                      (if (null? (cdr numbers))\n                        (list max)\n                        (let ((numbers (cdr numbers)))\n                          (if (null? numbers)\n                            (list max)\n                            (let ((max (car numbers)))\n                              (if (null? (cdr numbers))\n                                (list max)\n                                (let ((numbers (cdr numbers)))\n                                  (if (null? numbers)\n                                    (list max)\n                                    (let ((max (car numbers)))\n                                      (if (null? (cdr numbers))\n                                        (list max)\n                                        (let ((numbers (cdr numbers)))\n                                          (if (null? numbers)\n                                            (list max)\n                                            (let ((max (car numbers)))\n                                              (if (null? (cdr numbers))\n                                                (list max)\n                                                (let ((numbers (cdr numbers)))\n                                                  (if (null? numbers)\n                                                    (list max)\n                                                    (let ((max (car numbers)))\n                                                      (if (null? (cdr numbers))\n                                                        (list max)\n                                                        (let ((numbers (cdr numbers)))\n                                                         (if (null? numbers)\n                                                           (list max))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (result (cons max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((max (car numbers)))\n    (if (null? (cdr numbers))\n      max\n      (rolling_max (cdr numbers)))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))\n    (rolling_max-helper (cdr numbers))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (car numbers)\n                    (if (null? (cdr (cdr result)))\n                        (car (cdr numbers))\n                        (if (null? (cdr (cdr (cdr result))))\n                            (car (cdr (cdr (cdr numbers))))\n                            (if (null? (cdr (cdr (cdr (cdr numbers))))))\n                                (car (cdr (cdr (cdr (cdr (cdr numbers)))))))))))\n      (result (cons n result))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((max_numbers (list)))\n    (while (< (length numbers) (length max_numbers))\n      (let ((i (length numbers)))\n        (if (> (car numbers) (car max_numbers))\n          (setq max_numbers (append max_numbers (list (car numbers) (car max_numbers)))\n            (setq numbers (cdr numbers)))\n          (setq max_numbers (append max_numbers (list (car max_numbers) (car numbers)))\n            (setq numbers (cdr numbers)))\n          (setq max_numbers (append max_numbers (list (car max_numbers) (car max_numbers)))\n            (setq numbers (cdr numbers))))))\n    max_numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list n)\n      (cons (car n) (rolling_max-helper (cdr n))))\n    (if (null? numbers)\n      (list 0)\n      (cons (car numbers) (rolling_max-helper (cdr numbers))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n)))\n                (cdr n))\n               numbers\n               (append result (car n))))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? (cdr numbers))\n          (list max)\n          (let ((max (rolling_max-recursion (cdr numbers))))\n            (if (null? max)\n              (list)\n              (list max max)\n            )\n          )\n        )\n      )\n    )\n  )\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((new_max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max new_max)\n            (let ((new_new_max (car (cdr (cdr numbers))))\n                  (result (cons max new_max new_new_max)))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list result)\n                (let ((new_result (car (cdr (cdr (cdr numbers))))))\n                  (if (null? (cdr (cdr (cdr (cdr numbers))))))\n                    (list new_result result)\n                    (let ((new_new_result (car (cdr (cdr (cdr (cdr numbers)))))))\n                      (if (null? (cdr (cdr (cdr (cdr (cdr numbers))))))\n                        (list new_new_result result)\n                        (let ((new_new_new_result (car (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                              (list new_new_result new_new_new_result))\n                          (if (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))))\n                            (list new_new_result new_new_new_result result)\n                            (let ((new_new_new_new_result (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n) (car (cdr n)) (car n))))\n                numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max_recursion numbers)\n    (if (empty? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? max)\n          (list)\n          (let ((max (car numbers)))\n            (if (null? max)\n              (list)\n              (let ((max (car numbers)))\n                (if (null? max)\n                  (list)\n                  (let ((max (car numbers)))\n                    (if (null? max)\n                      (list)\n                      (let ((max (car numbers)))\n                        (if (null? max)\n                          (list)\n                          (let ((max (car numbers)))\n                            (if (null? max)\n                              (list)\n                              (let ((max (car numbers)))\n                                (if (null? max)\n                                  (list)\n                                  (let ((max (car numbers)))\n                                    (if (null? max)\n                                      (list)\n                                      (let ((max (car numbers)))\n                                        (if (null? max)\n                                          (list)\n                                          (let ((max (car numbers)))\n                                            (if (null? max)\n                                              (list)\n                                              (let ((max (car numbers)))\n                                                (if (null? max)\n                                                  (list)\n                                                  (let ((max (car numbers)))\n                                                    (if (null? max)\n                                                      (list)\n                                                      (let ((max (car numbers)))\n                                                        (if (null? max)\n                                                          (list)\n                                                          (let ((max (car numbers)))\n                                                            (if (null? max)\n                                                              (list)\n                                                              (let ((max (car numbers)))\n                                                                (if (null? max)\n                                                                  (list)\n                                                                  (let ((max (car numbers)))\n                                                                    (if (null? max)\n                                                                      ",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((result (cons max (rolling_max (cdr numbers))))\n              (max (car numbers)))\n          (if (null? (cdr numbers))\n            (list max)\n            (let ((result (cons max (rolling_max (cdr numbers))))\n                  (max (car numbers)))\n              (if (null? (cdr numbers))\n                (list max)\n                (let ((result (cons max (rolling_max (cdr numbers))))\n                      (max (car numbers)))\n                  (if (null? (cdr numbers))\n                    (list max)\n                    (let ((result (cons max (rolling_max (cdr numbers))))\n                          (max (car numbers)))\n                      (if (null? (cdr numbers))\n                        (list max)\n                        (let ((result (cons max (rolling_max (cdr numbers))))\n                              (max (car numbers)))\n                          (if (null? (cdr numbers))\n                            (list max)\n                            (let ((result (cons max (rolling_max (cdr numbers))))\n                                  (max (car numbers)))\n                              (if (null? (cdr numbers))\n                                (list max)\n                                (let ((result (cons max (rolling_max (cdr numbers))))\n                                      (max (car numbers)))\n                                  (if (null? (cdr numbers))\n                                    (list max)\n                                    (let ((result (cons max (rolling_max (cdr numbers))))\n                                          (max (car numbers)))\n                                      (if (null? (cdr numbers))\n                                        (list max)\n                                        (let ((result (cons max (rolling_max (cdr numbers))))\n                                              (max (car numbers)))\n                                          (if (null? (cdr numbers))\n                                            (list max)\n                                            (let ((result (cons max (rolling_max (cdr numbers))))\n                                                  (max (car numbers)))\n                                              (if (null? (",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers)\n          (rolling_max-recursion (cdr numbers))))))\n  (rolling_max-recursion numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((new_max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max new_max)\n            (let ((new_new_max (car (cdr (cdr numbers))))\n                  (result (cons max new_max new_new_max)))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list result)\n                (let ((new_result (car (cdr (cdr (cdr numbers))))))\n                  (if (null? (cdr (cdr (cdr (cdr numbers))))))\n                    (list new_result result)\n                    (let ((new_new_result (car (cdr (cdr (cdr (cdr numbers)))))))\n                      (if (null? (cdr (cdr (cdr (cdr (cdr numbers))))))\n                        (list new_new_result result)\n                        (let ((new_new_new_result (car (cdr (cdr (cdr (cdr (cdr (cdr numbers))))))))\n                              (result (cons new_max new_new_max new_new_result new_new_new_result))))))))))))))))))))\n",
    "  (let ((max (car numbers)))\n    (if (null? (cdr numbers))\n      max\n      (rolling_max (cdr numbers))))\n  (car numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max_helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max_helper (cdr n))))\n    (rolling_max_helper (numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    []\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-helper)\n    (cond\n      ((null? numbers) 0)\n      ((= (car numbers) (car (cdr numbers))) (car numbers))\n      (else (rolling_max-helper (cdr numbers))))\n    (car (rolling_max-helper)))\n  (rolling_max-helper))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max-recursion numbers)\n    (if (empty? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? max)\n          (list)\n          (let ((max (car numbers)))\n            (if (null? max)\n              (list)\n              (let ((max (car numbers)))\n                (if (null? max)\n                  (list)\n                  (let ((max (car numbers)))\n                    (if (null? max)\n                      (list)\n                      (let ((max (car numbers)))\n                        (if (null? max)\n                          (list)\n                          (let ((max (car numbers)))\n                            (if (null? max)\n                              (list)\n                              (let ((max (car numbers)))\n                                (if (null? max)\n                                  (list)\n                                  (let ((max (car numbers)))\n                                    (if (null? max)\n                                      (list)\n                                      (let ((max (car numbers)))\n                                        (if (null? max)\n                                          (list)\n                                          (let ((max (car numbers)))\n                                            (if (null? max)\n                                              (list)\n                                              (let ((max (car numbers)))\n                                                (if (null? max)\n                                                  (list)\n                                                  (let ((max (car numbers)))\n                                                    (if (null? max)\n                                                      (list)\n                                                      (let ((max (car numbers)))\n                                                        (if (null? max)\n                                                          (list)\n                                                          (let ((max (car numbers)))\n                                                            (if (null? max)\n                                                              (list)\n                                                              (let ((max (car numbers)))\n                                                                (if (null? max)\n                                                                  (list)\n                                                                  (let ((max (car numbers)))\n                                                                    (if (null? max)\n                                                                      ",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  (cons (car n) result))\n              numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (cdr (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car next)))\n              (if (null? (cdr next))\n                (list max)\n                (let ((next (cdr (cdr next))))\n                  (if (null? next)\n                    (list max)\n                    (let ((max (car next)))\n                      (if (null? (cdr next))\n                        (list max)\n                        (let ((next (cdr (cdr next))))\n                          (if (null? next)\n                            (list max)\n                            (let ((max (car next)))\n                              (if (null? (cdr next))\n                                (list max)\n                                (let ((next (cdr (cdr next))))\n                                  (if (null? next)\n                                    (list max)\n                                    (let ((max (car next)))\n                                      (if (null? (cdr next))\n                                        (list max)\n                                        (let ((next (cdr (cdr next))))\n                                          (if (null? next)\n                                            (list max)\n                                            (let ((max (car next)))\n                                              (if (null? (cdr next))\n                                                (list max)\n                                                (let ((next (cdr (cdr next))))\n                                                  (if (null? next)\n                                                    (list max)\n                                                    (let ((max (car next)))\n                                                      (if (null? (cdr next))\n                                                        (list max)\n                                                        (let ((next (cdr (cdr next))))\n                                                         (if (null? next)\n                                                           (list max)\n                                                           (let ((max (car next)))\n                                ",
    "  (let ((max_numbers (list)))\n    (while (< (length numbers) (length max_numbers))\n      (let ((n (car numbers)))\n        (if (null? max_numbers)\n          (max_numbers (list n))\n          (if (< (car max_numbers) n)\n            (max_numbers (cons n (cdr max_numbers)))\n            (max_numbers (cons n (cons n (cdr max_numbers)))))))\n    (max_numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (result (cons max max))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (append result (car n))\n                  (append result (if (> (car n) (car (cdr result))) (car n) (car (cdr n))))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (list n)\n                    (if (null? (cdr (cdr n)))\n                        (list (car n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (list (car (car n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (list (car (car (car n)))\n                                  (car (car (car (car n))))))))))\n      numbers\n      (append result (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (car (",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list)\n      (if (null? (cdr n))\n        (list (car n))\n        (cons (car n) (rolling_max-helper (cdr n)))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max-recursion numbers)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (let ((max (car numbers)))\n          (if (null? (cdr numbers))\n            (list max)\n            (let ((max (car numbers)))\n              (if (null? (cdr numbers))\n                (list max)\n                (let ((max (car numbers)))\n                  (if (null? (cdr numbers))\n                    (list max)\n                    (let ((max (car numbers)))\n                      (if (null? (cdr numbers))\n                        (list max)\n                        (let ((max (car numbers)))\n                          (if (null? (cdr numbers))\n                            (list max)\n                            (let ((max (car numbers)))\n                              (if (null? (cdr numbers))\n                                (list max)\n                                (let ((max (car numbers)))\n                                  (if (null? (cdr numbers))\n                                    (list max)\n                                    (let ((max (car numbers)))\n                                      (if (null? (cdr numbers))\n                                        (list max)\n                                        (let ((max (car numbers)))\n                                          (if (null? (cdr numbers))\n                                            (list max)\n                                            (let ((max (car numbers)))\n                                              (if (null? (cdr numbers))\n                                                (list max)\n                                                (let ((max (car numbers)))\n                                                  (if (null? (cdr numbers))\n                                                    (list max)\n                                                    (let ((max (car numbers)))\n                                                      (if (null? (cdr numbers))\n                                                        (list max)\n                                                        (let ((max (car numbers)))\n                                                         (if (null? (cdr numbers))\n                                                           (list max)\n                                                           (let ((max (car numbers)))\n                                  ",
    "  (define (rolling_max-numbers)\n    (define (rolling_max-numbers-numbers)\n      (define (rolling_max-numbers-numbers-numbers)\n        (define (rolling_max-numbers-numbers-numbers-numbers)\n          (define (rolling_max-numbers-numbers-numbers-numbers-numbers)\n            (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers)\n              (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                  (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                    (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                      (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                        (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                          (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                            (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                              (define (rolling_max-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers-numbers)\n                                (define (rolling_max-numbers-numbers-numbers-",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (list n)\n                    (if (null? (cdr (cdr result)))\n                        (list n)\n                        (if (null? (cdr (cdr (cdr result))))\n                            (list n)\n                            (if (null? (cdr (cdr (cdr (cdr result))))))\n                                (list n))))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (mapcar (lambda (x) (if (null? x) max x))\n           (cdr numbers)))\n  )\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  (append result (car n)))\n              (numbers))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((max_numbers (list)))\n    (while (< (length numbers) (length max_numbers))\n      (let ((max_number (car max_numbers)))\n        (if (null? max_numbers)\n          (set! max_numbers (list numbers))\n          (set! max_numbers (cons max_number (cdr max_numbers))))))\n    (max_numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (if (null? (cdr numbers))\n        (list (car numbers))\n        (cons (car numbers)\n          (rolling_max-recursion (cdr numbers))))))\n  (rolling_max-recursion numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers)))\n              (result (cons max (rolling_max (cdr numbers)))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (append result (car n))\n                  (append result (car n))\n                  (append result (car n))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n)\n                                      (car (cdr n))\n                                      (car (car (cdr n))))))\n                numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (cdr (cdr numbers))))\n          (let ((result (cons max (rolling_max next))))\n            (if (null? next)\n              result\n              (let ((next (cdr next)))\n                (let ((result (cons max (rolling_max next))))\n                  (if (null? next)\n                    result\n                    (let ((next (cdr next)))\n                      (let ((result (cons max (rolling_max next))))\n                        (if (null? next)\n                          result\n                          (let ((next (cdr next)))\n                            (let ((result (cons max (rolling_max next))))\n                              (if (null? next)\n                                result\n                                (let ((next (cdr next)))\n                                  (let ((result (cons max (rolling_max next))))\n                                    (if (null? next)\n                                      result\n                                      (let ((next (cdr next))))\n                                      (let ((result (cons max (rolling_max next))))\n                                        (if (null? next)\n                                          result\n                                          (let ((next (cdr next))))\n                                          (let ((result (cons max (rolling_max next))))\n                                            (if (null? next)\n                                              result\n                                              (let ((next (cdr next))))\n                                              (let ((result (cons max (rolling_max next))))\n                                                (if (null? next)\n                                                  result\n                                                  (let ((next (cdr next))))\n                                                  (let ((result (cons max (rolling_max next))))\n                                                    (if (null? next)\n                                                      result\n                                                      (let ((next (cdr next))))\n                                                      (let ((result (cons max (rolling_max next))))\n                                                        (if (null? next)\n                                                          result\n",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (list (car n) (car (cdr n)))\n                  (if (null? (cdr (cdr n)))\n                      (list (car n) (car (car (cdr n))))\n                      (if (null? (cdr (cdr (cdr n))))\n                          (list (car n) (car (car (car (cdr n))))))))\n                numbers))\n    (return result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n)))))\n                                (car (cdr (cdr (cdr n))))\n                                (car (cdr (cdr (cdr (cdr (cdr n))))))))))))\n      (append result (car numbers)))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (car (cdr numbers))))\n          (if (null? (cdr (cdr numbers)))\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (result (cons max (list max))))\n              (if (null? (cdr (cdr (cdr numbers))))\n                (list result)\n                (let ((result (cons max (list result))))\n                  (if (null? (cdr (cdr (cdr (cdr numbers))))))\n                    (list result)\n                    (let ((result (cons max (list result))))\n                      (if (null? (cdr (cdr (cdr (cdr (cdr numbers))))))\n                        (list result)\n                        (let ((result (cons max (list result))))\n                          (if (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (c",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers)\n              (car (cdr result))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n      (if (null? result)\n        (result n)\n        (if (> n numbers)\n          (result n)\n          (result (append result n))))\n      numbers))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n)))))\n                                (car (cdr (cdr (cdr n))))\n                                (car (cdr (cdr (cdr (cdr (cdr n))))))))))))\n      (append result (car numbers)))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (null? (cdr (cdr n)))\n                                       (car (cdr n))\n                                       (car (cdr (cdr n))))))))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers)\n      (set! result (cons (car (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (",
    "  (if (empty? numbers)\n    []\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (list n)\n                    (if (null? (cdr (cdr result)))\n                        (list n)\n                        (setq result (cons (car result) (rolling_max (cdr result) (list n))))))))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3)",
    "  (let ((result (list)))\n    (while (< (length numbers) 1)\n      (let ((current (numbers)))\n        (if (null? current)\n          (result)\n          (if (> (car current) (car result))\n            (set-cdr result (cons (car current) result)))\n          (set-cdr result (cons (car current) result))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-helper n)\n    (if (null? n)\n      (list n)\n      (let ((max (car n)))\n        (if (null? (cdr n))\n          (list max)\n          (let ((max (rolling_max-helper (cdr n))))\n            (list max max))))))\n  (rolling_max-helper numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (cdr (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car next)))\n              (if (null? (cdr next))\n                (list max)\n                (let ((next (cdr (cdr next))))\n                  (if (null? next)\n                    (list max)\n                    (let ((max (car next)))\n                      (if (null? (cdr next))\n                        (list max)\n                        (let ((next (cdr (cdr next))))\n                          (if (null? next)\n                            (list max)\n                            (let ((max (car next)))\n                              (if (null? (cdr next))\n                                (list max)\n                                (let ((next (cdr (cdr next))))\n                                  (if (null? next)\n                                    (list max)\n                                    (let ((max (car next))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (list (car n) (car (cdr n)))\n                    (if (null? (cdr (cdr n)))\n                        (list (car n) (car (car (cdr n))))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (list (car n) (car (car (car (cdr n))))))))\n                numbers))\n    (return result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((max_numbers (list)))\n    (while (< (length numbers) (length max_numbers))\n      (let ((max_number (car max_numbers)))\n        (if (> (car numbers) max_number)\n          (setq max_numbers (append max_numbers (list (car numbers) (car max_number)))\n            (setq max_number (car max_numbers)))\n          (setq max_numbers (append max_numbers (list (car numbers) (car max_number)))\n            (setq max_number (car max_numbers))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (car max_number))))\n      (setq max_numbers (append max_numbers (list (car numbers) (",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (list n)\n                    (if (null? (cdr (cdr n)))\n                        (list (car n) (car (cdr n)))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (list (car (car n)) (car (car (cdr n))))\n                            (list (car (car n)) (car (car (cdr n))))))))\n                numbers))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? (cdr numbers))\n          (list max)\n          (let ((max (rolling_max-recursion (cdr numbers))))\n            (if (null? (cdr (cdr numbers)))\n              (list max)\n              (let ((max (rolling_max-recursion (cdr (cdr numbers))))\n                    (list max max))))))))\n    (rolling_max-recursion)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (list n)\n                    (if (null? (cdr (cdr result)))\n                        (list n)\n                        (setq result (cons n result))))\n                numbers))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max-recursion numbers)\n    (if (null? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? (cdr numbers))\n          (list max)\n          (let ((max (rolling_max-recursion (cdr numbers))))\n            (if (null? max)\n              (list)\n              (list max max)\n              (rolling_max-recursion (cdr numbers) (cons max max))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car (cdr n)))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (define (rolling_max_helper n)\n    (if (null? n)\n      (list)\n      (cons (car n) (rolling_max_helper (cdr n))))\n    (rolling_max_helper numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car (cdr n)))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr result))\n                    (list (car numbers) (car n))\n                    (if (null? (cdr (cdr result)))\n                        (list (car (car result)) (car n))\n                        (if (null? (cdr (cdr (cdr result))))\n                            (list (car (car (cdr result))) (car n))\n                            (list (car (car (cdr (cdr result)))) (car n))))))\n                numbers))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  (append result (car n)))\n              (numbers)))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n))))))\n                                (car (cdr (cdr (cdr (cdr n))))))))\n                  (append result (car n)))\n              numbers))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((result (list)))\n      (while (not (null? numbers))\n        (let ((current (car numbers)))\n          (if (null? result)\n            (result current)\n            (if (null? (cdr result))\n              (setcar result current)\n              (setcar result (if (null? (cdr result)) current\n                                  (if (null? (cdr (cdr result))) current\n                                    (car (cdr (cdr result))))))))\n          (setcar result (car numbers))\n          (setcdr result (cdr numbers)))))\n  (numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((max (rolling_max (cdr numbers))))\n          (list max max))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? result)\n                    (result n)\n                    (if (> n numbers)\n                        (result n)\n                        (result (append result (list n))))))\n               numbers))\n  result)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (if (null? numbers)\n    (list)\n    (cons (car numbers) (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (define (rolling_max-recursion)\n    (if (null? numbers)\n      (list)\n      (let ((max (car numbers)))\n        (if (null? (cdr numbers))\n          (list max)\n          (let ((max (rolling_max-recursion (cdr numbers))))\n            (list max max))))))\n  (rolling_max-recursion)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((result (list)))\n      (for-each (lambda (n)\n                  (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (if (car n) (car (cdr n)) (car n))))\n                 numbers))\n      (reverse result))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n))\n                    (append result (car n))))\n      numbers))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((max (car numbers)))\n    (if (null? (cdr numbers))\n      max\n      (let ((curr (car numbers)))\n        (if (null? (cdr numbers))\n          (car numbers)\n          (if (null? (cdr numbers))\n            (car numbers)\n            (if (null? (cdr numbers))\n              (car numbers)\n              (if (null? (cdr numbers))\n                (car numbers)\n                (if (null? (cdr numbers))\n                  (car numbers)\n                  (if (null? (cdr numbers))\n                    (car numbers)\n                    (if (null? (cdr numbers))\n                      (car numbers)\n                      (if (null? (cdr numbers))\n                        (car numbers)\n                        (if (null? (cdr numbers))\n                          (car numbers)\n                          (if (null? (cdr numbers))\n                            (car numbers)\n                            (if (null? (cdr numbers))\n                              (car numbers)\n                              (if (null? (cdr numbers))\n                                (car numbers)\n                                (if (null? (cdr numbers))\n                                  (car numbers)\n                                  (if (null? (cdr numbers))\n                                    (car numbers)\n                                    (if (null? (cdr numbers))\n                                      (car numbers)\n                                      (if (null? (cdr numbers))\n                                        (car numbers)\n                                        (if (null? (cdr numbers))\n                                          (car numbers)\n                                          (if (null? (cdr numbers))\n                                            (car numbers)\n                                            (if (null? (cdr numbers))\n                                              (car numbers)\n                                              (if (null? (cdr numbers))\n                                                (car numbers)\n                                                (if (null? (cdr numbers))\n                                                  (car numbers)\n                                                  (if (null? (cdr numbers))\n                                                    (car numbers)\n                                                    (if (null? (cdr numbers))\n                                                      (car numbers)\n",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? result)\n                    (result n)\n                    (if (> (car n) (car result))\n                        (set-cdr! result (cons n (car result)))))))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)",
    "  (if (null? numbers)\n    []\n    (cons (max numbers)\n      (rolling_max (cdr numbers))))\n)\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result ()))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (cons (car n) result)\n                    (let ((max (car n))\n                          (cdr n))\n                      (if (null? cdr n)\n                          (cons max result)\n                          (let ((max (car (cdr n)))\n                                (cdr (cdr n)))\n                            (if (null? cdr (cdr n))\n                               (cons max result)\n                               (cons max (cons max result))))))))\n      numbers))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (car n)\n                    (if (null? (cdr (cdr n)))\n                        (car (cdr n))\n                        (if (null? (cdr (cdr (cdr n))))\n                            (car (cdr (cdr n)))\n                            (if (null? (cdr (cdr (cdr (cdr n)))))\n                                (car (cdr (cdr (cdr n))))\n                                (car (cdr (cdr (cdr (cdr (cdr n))))))))))))\n      (append result (car numbers)))\n    result))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    []\n    (cons (car numbers)\n      (rolling_max (cdr numbers))))\n  )\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (if (null? (cdr numbers))\n      (list (car numbers))\n      (cons (car numbers)\n         (rolling_max (cdr numbers))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((max-value (car numbers)))\n    (if (null? numbers)\n      max-value\n      (let ((max-value (car (cdr numbers))))\n        (if (null? (cdr numbers))\n          max-value\n          (let ((max-value (car (cdr (cdr numbers))))\n                (result (cons max-value max-value))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 3)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                    (append result (car n))\n                    (append result (car n) (car (cdr n))))\n                numbers))\n    (reverse result)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 2)",
    "  (let ((result (list)))\n    (for-each (lambda (n)\n                (if (null? (cdr n))\n                  (car n)\n                  (if (null? (cdr (cdr n)))\n                    (car (cdr n))\n                    (if (null? (cdr (cdr (cdr n))))\n                      (car (cdr (cdr n)))\n                      (if (null? (cdr (cdr (cdr (cdr n)))))\n                        (car (cdr (cdr (cdr n))))\n                        (car (cdr (cdr (cdr (cdr (cdr n))))))))))))\n    (append result numbers)))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 2 3 3)",
    "  (if (null? numbers)\n    (list)\n    (let ((max (car numbers)))\n      (if (null? (cdr numbers))\n        (list max)\n        (let ((next (car (cdr numbers))))\n          (if (null? next)\n            (list max)\n            (let ((max (car (cdr (cdr numbers))))\n                  (if (null? max)\n                    (list max)\n                    (let ((next (car (cdr (cdr (cdr numbers))))))\n                      (if (null? next)\n                        (list max)\n                        (let ((max (car (cdr (cdr (cdr (cdr numbers))))))))\n                          (list max))))))))))))))\n\n;; From a given list of integers, generate a list of rolling minimum element found until given moment\n;; in the sequence.\n;; >>> (rolling_min (list 1 2 3 2 3 4 2))\n;; (list 1 2 2 2 3 2)"
  ],
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ]
}