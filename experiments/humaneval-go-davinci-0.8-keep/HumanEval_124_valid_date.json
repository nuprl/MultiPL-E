{
  "name": "HumanEval_124_valid_date",
  "language": "go_test.go",
  "prompt": "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You have to write a function which validates a given date string and\n// returns True if the date is valid otherwise False.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// for example: \n// valid_date('03-11-2000') => True\n// valid_date('15-01-2012') => False\n// valid_date('04-0-2040') => False\n// valid_date('06-04-2020') => True\n// valid_date('06/04/2020') => False\nfunc valid_date(date string) bool {\n",
  "tests": "func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "completions": [
    "    if date == \"\" {\n        return false\n    }\n    // TODO: Write your code here\n    return false\n}\n",
    "    return true\n}\n",
    "    return false\n}\n",
    "    return false\n}\n",
    "\tvalid := false\n\treturn valid\n}\n",
    "    // your code here\n    return false\n}\n",
    "    // split date into parts\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n    // split date into components\n    month, err1 := strconv.Atoi(parts[0])\n    day, err2 := strconv.Atoi(parts[1])\n    year, err3 := strconv.Atoi(parts[2])\n    if err1 != nil || err2 != nil || err3 != nil {\n        return false\n    }\n    // check for valid month\n    if month < 1 || month > 12 {\n        return false\n    }\n    // check for valid day\n    switch month {\n    case 1, 3, 5, 7, 8, 10, 12:\n        if day < 1 || day > 31 {\n            return false\n        }\n    case 4, 6, 9, 11:\n        if day < 1 || day > 30 {\n            return false\n        }\n    case 2:\n        if day < 1 || day > 29 {\n            return false\n        }\n    }\n    // year must be greater than zero\n    if year < 1 {\n        return false\n    }\n    return true\n}\n",
    "    if len(date) <= 0 {\n        return false\n    }\n    var m, d, y int\n    var err error\n    _, err = fmt.Sscanf(date, \"%d-%d-%d\", &m, &d, &y)\n    if err != nil {\n        return false\n    }\n    if m < 1 || m > 12 {\n        return false\n    }\n    if m == 2 {\n        if d < 1 || d > 29 {\n            return false\n        }\n    } else if m == 4 || m == 6 || m == 9 || m == 11 {\n        if d < 1 || d > 30 {\n            return false\n        }\n    } else {\n        if d < 1 || d > 31 {\n            return false\n        }\n    }\n    return true\n}\n",
    "    if date == \"\" {\n        return false\n    }\n    return true\n}\n",
    "    // TODO: Implement\n    return false\n}\n",
    "    return false\n}\n",
    "    _, err := fmt.Sscanf(date, \"%d-%d-%d\", nil, nil, nil)\n    return err == nil\n}\n",
    "    return false\n}\n",
    "    // your code here\n    return false\n}\n",
    "    // \u8fd9\u91cc\u5148\u5047\u8bbe\u7ed9\u5b9a\u7684\u8f93\u5165\u662f\u6b63\u786e\u7684\n    // \u4ee5\u540e\u518d\u8fdb\u884c\u9519\u8bef\u5904\u7406\n    // \u601d\u8def\uff1a\u5148\u901a\u8fc7\u5b57\u7b26\u4e32\u5207\u7247\uff0c\u53d6\u51fa\u6708\u4efd\u3001\u65e5\u671f\u3001\u5e74\u4efd\n    // \u7136\u540e\u5224\u65ad\u6708\u4efd\u3001\u65e5\u671f\u3001\u5e74\u4efd\u662f\u5426\u5728\u8303\u56f4\u5185\uff0c\u662f\u5426\u6ee1\u8db3\u5c5e\u6027\n    if len(date) == 0 {\n        return false\n    }\n    dateArr := []string{}\n    dateArr = append(dateArr, date[0:2])\n    dateArr = append(dateArr, date[3:5])\n    dateArr = append(dateArr, date[6:10])\n    month := dateArr[0]\n    day := dateArr[1]\n    year := dateArr[2]\n    if len(month) != 2 || len(day) != 2 || len(year) != 4 {\n        return false\n    }\n    if month != \"01\" && month != \"02\" && month != \"03\" && month != \"04\" && month != \"05\" && month != \"06\" && month != \"07\" && month != \"08\" && month != \"09\" && month != \"10\" && month != \"11\" && month != \"12\" {\n        return false\n    }\n    if day != \"01\" && day != \"02\" && day != \"03\" && day != \"04\" && day != \"05\" && day != \"06\" && day != \"07\" && day != \"08\" && day != \"09\" && day != \"10\" && day != \"11\" && day != \"12\" && day != \"13\" && day != \"14\" && day != \"15\" && day != \"16\" && day != \"17\" && day != \"18\" && day != \"19\" && day != \"20\" && day != \"",
    "    valid_month := []int{1,3,5,7,8,10,12}\n    var month, day, year int\n    var count int\n    for i := 0; i < len(date); i++ {\n        if date[i] == '-' {\n            count++\n            switch count {\n            case 1:\n                month = string_to_int(date[:i])\n            case 2:\n                day = string_to_int(date[i-2:i])\n            }\n        }\n    }\n    year = string_to_int(date[len(date)-4:])\n    if year < 0 || month < 0 || day < 0 {\n        return false\n    }\n    switch month {\n    case 2:\n        if day > 29 {\n            return false\n        }\n    case 4,6,9,11:\n        if day > 30 {\n            return false\n        }\n    default:\n        if !contains(valid_month, month) {\n            return false\n        }\n        if day > 31 {\n            return false\n        }\n    }\n    return true\n}\n",
    "    // Your code here!\n}\n",
    "    // your code here\n    return false\n}\n",
    "\t// your code here\n    if len(date) != 10 {\n        return false\n    }\n    fmt.Println(date)\n    return true\n}\n",
    "\t/*\n\tvar month int\n\tvar day int\n\tvar year int\n\tvar err = fmt.Errorf(\"Error\")\n\tvar b = true\n\tvar errArr []error\n\t// check the format\n\tvar r = regexp.MustCompile(`(\\d{2})(\\/|-)(\\d{2})(\\/|-)(\\d{4})`)\n\tvar s = r.ReplaceAllString(date, \"$1-$3-$5\")\n\tif errArr != nil {\n\t\treturn errArr\n\t}\n\tb, err := regexp.MatchString(`^\\d{4}-\\d{2}-\\d{2}$`, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !b {\n\t\treturn err\n\t}\n\t// check numbers of days\n\tmonth, err = strconv.Atoi(s[0:2])\n\tif err != nil {\n\t\treturn err\n\t}\n\tday, err = strconv.Atoi(s[3:5])\n\tif err != nil {\n\t\treturn err\n\t}\n\tyear, err = strconv.Atoi(s[6:10])\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch month {\n\tcase 1, 3, 5, 7, 8, 10, 12:\n\t\tif day < 1 || day > 31 {\n\t\t\treturn err\n\t\t}\n\tcase 4, 6, 9, 11:\n\t\tif day < 1 || day > 30 {\n\t\t\treturn err\n\t\t}\n\tcase 2:\n\t\tif day < 1 || day > 29 {\n\t\t\treturn err\n\t\t}\n\t}\n\t// check months\n\tif month < 1 || month > 12 {\n\t\treturn err\n\t}\n\t*/\n\treturn true\n}\n"
  ],
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ]
}