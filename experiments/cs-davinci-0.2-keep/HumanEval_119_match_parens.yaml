name: HumanEval_119_match_parens
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You are given a list of two strings, both strings consist of\
  \ open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is\
  \ to check if it is possible to concatenate the two strings in\n    // some order,\
  \ that the resulting string will be good.\n    // A string S is considered to be\
  \ good if and only if all parentheses in S\n    // are balanced. For example: the\
  \ string '(())()' is good, while the string\n    // '())' is not.\n    // Return\
  \ 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n   \
  \ // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
  \ ')']) == 'No'\n    public static string MatchParens(List<string> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(MatchParens((new\
  \ List<string>(new string[]{(string)\"()(\", (string)\")\"}))).Equals((\"Yes\")));\n\
  \    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\")\", (string)\"\
  )\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"\
  (()(())\", (string)\"())())\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new\
  \ List<string>(new string[]{(string)\")())\", (string)\"(()()(\"}))).Equals((\"\
  Yes\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"\
  (())))\", (string)\"(()())((\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new\
  \ List<string>(new string[]{(string)\"()\", (string)\"())\"}))).Equals((\"No\")));\n\
  \    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"(()(\", (string)\"\
  ()))()\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new List<string>(new\
  \ string[]{(string)\"((((\", (string)\"((())\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new\
  \ List<string>(new string[]{(string)\")(()\", (string)\"(()(\"}))).Equals((\"No\"\
  )));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\")(\"\
  , (string)\")(\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new\
  \ string[]{(string)\"(\", (string)\")\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new\
  \ List<string>(new string[]{(string)\")\", (string)\"(\"}))).Equals((\"Yes\")));\n\
  \    }\n\n}\n"
completions: ["        var s1 = lst[0];\n        var s2 = lst[1];\n        var s =\
    \ s1 + s2;\n        var stack = new Stack<char>();\n        foreach (var c in\
    \ s) {\n            if (c == '(') {\n                stack.Push(c);\n        \
    \    } else {\n                if (stack.Count == 0) {\n                    return\
    \ \"No\";\n                }\n                stack.Pop();\n            }\n  \
    \      }\n        return stack.Count == 0 ? \"Yes\" : \"No\";", "        // TODO:\
    \ Implement this function.\n        return \"\";", "        // TODO: Implement\
    \ this function.\n        return \"\";", "        int count = 0;\n        foreach\
    \ (string s in lst) {\n            foreach (char c in s) {\n                if\
    \ (c == '(') {\n                    count++;\n                } else {\n     \
    \               count--;\n                }\n                if (count < 0) {\n\
    \                    return \"No\";\n                }\n            }\n      \
    \  }\n        return count == 0 ? \"Yes\" : \"No\";", "        // TODO: Implement\
    \ this function.\n        return \"\";", "        int open1 = 0;\n        int\
    \ open2 = 0;\n        int close1 = 0;\n        int close2 = 0;\n        foreach\
    \ (string s in lst) {\n            foreach (char c in s) {\n                if\
    \ (c == '(') {\n                    if (s == lst[0]) {\n                     \
    \   open1++;\n                    } else {\n                        open2++;\n\
    \                    }\n                } else {\n                    if (s ==\
    \ lst[0]) {\n                        close1++;\n                    } else {\n\
    \                        close2++;\n                    }\n                }\n\
    \            }\n        }\n        if (open1 > close2 || open2 > close1) {\n \
    \           return \"No\";\n        }\n        return \"Yes\";", "        // TODO:\
    \ Implement this function\n        return \"\";", "        // Your code here\n\
    \        return \"\";", "        int count = 0;\n        foreach (string s in\
    \ lst) {\n            foreach (char c in s) {\n                if (c == '(') {\n\
    \                    count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";", "        // TODO: Implement this function\n        return\
    \ \"\";", "        // TODO: Implement this function\n        return \"\";", " \
    \       int count = 0;\n        foreach (string s in lst) {\n            foreach\
    \ (char c in s) {\n                if (c == '(') {\n                    count++;\n\
    \                } else {\n                    count--;\n                }\n \
    \               if (count < 0) {\n                    return \"No\";\n       \
    \         }\n            }\n        }\n        return count == 0 ? \"Yes\" : \"\
    No\";", "        int count = 0;\n        foreach (string s in lst) {\n       \
    \     foreach (char c in s) {\n                if (c == '(') {\n             \
    \       count++;\n                } else {\n                    count--;\n   \
    \             }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";", "        // TODO: Implement this function\n        return\
    \ \"\";", "        var s1 = lst[0];\n        var s2 = lst[1];\n        var s =\
    \ s1 + s2;\n        var stack = new Stack<char>();\n        foreach (var c in\
    \ s) {\n            if (c == '(') {\n                stack.Push(c);\n        \
    \    } else {\n                if (stack.Count == 0) {\n                    return\
    \ \"No\";\n                }\n                stack.Pop();\n            }\n  \
    \      }\n        return stack.Count == 0 ? \"Yes\" : \"No\";", "        // TODO:\
    \ Implement this function\n        return \"\";", "        var s1 = lst[0];\n\
    \        var s2 = lst[1];\n        var s1_open = s1.Count(c => c == '(');\n  \
    \      var s1_close = s1.Count(c => c == ')');\n        var s2_open = s2.Count(c\
    \ => c == '(');\n        var s2_close = s2.Count(c => c == ')');\n        if (s1_open\
    \ == s1_close && s2_open == s2_close) {\n            return \"Yes\";\n       \
    \ }\n        if (s1_open == s1_close) {\n            return s2_open == s2_close\
    \ + 1 ? \"Yes\" : \"No\";\n        }\n        if (s2_open == s2_close) {\n   \
    \         return s1_open == s1_close + 1 ? \"Yes\" : \"No\";\n        }\n    \
    \    return \"No\";", "        // TODO: Implement this function\n        return\
    \ \"\";", "        // TODO: Implement this function\n        return \"\";", " \
    \       int open = 0;\n        int close = 0;\n        foreach (string s in lst)\
    \ {\n            foreach (char c in s) {\n                if (c == '(') {\n  \
    \                  open++;\n                } else {\n                    close++;\n\
    \                }\n            }\n        }\n        if (open == close) {\n \
    \           return \"Yes\";\n        } else {\n            return \"No\";\n  \
    \      }"]
stop_tokens:
- "\n    }\n"
