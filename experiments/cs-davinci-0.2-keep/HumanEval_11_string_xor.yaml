name: HumanEval_11_string_xor
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n\
  \    // Perform binary XOR on these inputs and return result also as a string.\n\
  \    // >>> string_xor('010', '110')\n    // '100'\n    public static string StringXor(string\
  \ a, string b) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(StringXor((\"\
  111000\"), (\"101010\")).Equals((\"010010\")));\n    Debug.Assert(StringXor((\"\
  1\"), (\"1\")).Equals((\"0\")));\n    Debug.Assert(StringXor((\"0101\"), (\"0000\"\
  )).Equals((\"0101\")));\n    }\n\n}\n"
completions: ["        // Convert input strings to bytes\n        byte[] a_bytes =\
    \ Encoding.ASCII.GetBytes(a);\n        byte[] b_bytes = Encoding.ASCII.GetBytes(b);\n\
    \        // XOR the bytes\n        byte[] c_bytes = new byte[a_bytes.Length];\n\
    \        for (int i = 0; i < a_bytes.Length; i++) {\n            c_bytes[i] =\
    \ (byte)(a_bytes[i] ^ b_bytes[i]);\n        }\n        // Convert the result back\
    \ to a string\n        return Encoding.ASCII.GetString(c_bytes);", "        var\
    \ result = new StringBuilder();\n        for (int i = 0; i < a.Length; i++) {\n\
    \            result.Append(a[i] ^ b[i]);\n        }\n        return result.ToString();",
  "        if (a.Length != b.Length) {\n            throw new ArgumentException(\"\
    Strings must be of equal length\");\n        }\n        StringBuilder sb = new\
    \ StringBuilder();\n        for (int i = 0; i < a.Length; i++) {\n           \
    \ sb.Append(a[i] ^ b[i]);\n        }\n        return sb.ToString();", "      \
    \  var result = new StringBuilder();\n        for (int i = 0; i < a.Length; i++)\
    \ {\n            result.Append(a[i] ^ b[i]);\n        }\n        return result.ToString();",
  "        var sb = new StringBuilder();\n        for (int i = 0; i < a.Length; i++)\
    \ {\n            sb.Append(a[i] ^ b[i]);\n        }\n        return sb.ToString();",
  "        if (a.Length != b.Length) {\n            throw new ArgumentException(\"\
    Strings must be of equal length.\");\n        }\n        var sb = new StringBuilder();\n\
    \        for (int i = 0; i < a.Length; i++) {\n            sb.Append(a[i] == b[i]\
    \ ? '0' : '1');\n        }\n        return sb.ToString();", "        var result\
    \ = new StringBuilder();\n        for (int i = 0; i < a.Length; i++) {\n     \
    \       result.Append(a[i] ^ b[i]);\n        }\n        return result.ToString();",
  "        var result = new StringBuilder();\n        for (int i = 0; i < a.Length;\
    \ i++) {\n            result.Append(a[i] ^ b[i]);\n        }\n        return result.ToString();",
  "        var sb = new StringBuilder();\n        for (int i = 0; i < a.Length; i++)\
    \ {\n            sb.Append(a[i] ^ b[i]);\n        }\n        return sb.ToString();",
  "        var result = new StringBuilder();\n        for (int i = 0; i < a.Length;\
    \ i++) {\n            result.Append(a[i] ^ b[i]);\n        }\n        return result.ToString();",
  "        var result = new StringBuilder();\n        for (int i = 0; i < a.Length;\
    \ i++) {\n            result.Append(a[i] ^ b[i]);\n        }\n        return result.ToString();",
  "        Debug.Assert(a.Length == b.Length);\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < a.Length; i++) {\n            sb.Append(a[i] == b[i]\
    \ ? '0' : '1');\n        }\n        return sb.ToString();", "        if (a.Length\
    \ != b.Length) {\n            throw new ArgumentException(\"Strings must be of\
    \ equal length\");\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < a.Length; i++) {\n            sb.Append(a[i] ^ b[i]);\n\
    \        }\n        return sb.ToString();", "        // Convert input strings\
    \ to byte arrays\n        var aBytes = a.Select(x => Convert.ToByte(x.ToString())).ToArray();\n\
    \        var bBytes = b.Select(x => Convert.ToByte(x.ToString())).ToArray();\n\
    \n        // Compute XOR of each byte\n        var xorBytes = aBytes.Zip(bBytes,\
    \ (x, y) => (byte)(x ^ y)).ToArray();\n\n        // Convert result to string\n\
    \        return string.Join(\"\", xorBytes.Select(x => x.ToString()));", "   \
    \     Debug.Assert(a.Length == b.Length);\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < a.Length; i++) {\n            sb.Append((a[i] ==\
    \ b[i]) ? '0' : '1');\n        }\n        return sb.ToString();", "        if\
    \ (a.Length != b.Length) {\n            throw new ArgumentException(\"a and b\
    \ must be of equal length\");\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < a.Length; i++) {\n            sb.Append(a[i] ^ b[i]);\n\
    \        }\n        return sb.ToString();", "        if (a.Length != b.Length)\
    \ {\n            throw new ArgumentException(\"Strings must be of equal length\"\
    );\n        }\n        var result = new StringBuilder();\n        for (int i =\
    \ 0; i < a.Length; i++) {\n            result.Append(a[i] ^ b[i]);\n        }\n\
    \        return result.ToString();", "        if (a.Length != b.Length) {\n  \
    \          throw new ArgumentException(\"Strings must be of equal length\");\n\
    \        }\n        var sb = new StringBuilder();\n        for (int i = 0; i <\
    \ a.Length; i++) {\n            sb.Append(a[i] ^ b[i]);\n        }\n        return\
    \ sb.ToString();", "        var result = new StringBuilder();\n        for (int\
    \ i = 0; i < a.Length; i++) {\n            result.Append(a[i] ^ b[i]);\n     \
    \   }\n        return result.ToString();", "        var result = new StringBuilder();\n\
    \        for (int i = 0; i < a.Length; i++) {\n            result.Append(a[i]\
    \ == b[i] ? '0' : '1');\n        }\n        return result.ToString();"]
stop_tokens:
- "\n    }\n"
