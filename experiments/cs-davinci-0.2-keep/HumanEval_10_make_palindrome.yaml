name: HumanEval_10_make_palindrome
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Find the shortest palindrome that begins with a supplied string.\n\
  \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
  \ string that is a palindrome.\n    // - Append to the end of the string reverse\
  \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
  \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
  \    // 'catac'\n    public static string MakePalindrome(string str) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(MakePalindrome((\"\
  \")).Equals((\"\")));\n    Debug.Assert(MakePalindrome((\"x\")).Equals((\"x\")));\n\
  \    Debug.Assert(MakePalindrome((\"xyz\")).Equals((\"xyzyx\")));\n    Debug.Assert(MakePalindrome((\"\
  xyx\")).Equals((\"xyx\")));\n    Debug.Assert(MakePalindrome((\"jerry\")).Equals((\"\
  jerryrrej\")));\n    }\n\n}\n"
completions: ["        var sb = new StringBuilder(str);\n        var palindrome =\
    \ FindLongestPalindrome(str);\n        var prefix = str.Substring(0, str.Length\
    \ - palindrome.Length);\n        sb.Append(new string(prefix.Reverse().ToArray()));\n\
    \        return sb.ToString();", "        if (str.Length == 0) {\n           \
    \ return str;\n        }\n        int longest_palindrome_suffix_length = LongestPalindromeSuffixLength(str);\n\
    \        string prefix = str.Substring(0, str.Length - longest_palindrome_suffix_length);\n\
    \        return str + Reverse(prefix);", "        // Find the longest palindromic\
    \ suffix.\n        int suffix_len = 0;\n        for (int i = 0; i < str.Length;\
    \ i++) {\n            if (str[i] == str[str.Length - 1 - i]) {\n             \
    \   suffix_len++;\n            } else {\n                break;\n            }\n\
    \        }\n        // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        return str + new string(str.Substring(0,\
    \ str.Length - suffix_len).Reverse().ToArray());", "        var s = str + '\\\
    0' + new string(str.Reverse().ToArray());\n        var z = new int[s.Length];\n\
    \        for (int i = 1, l = 0, r = 0; i < s.Length; i++) {\n            if (i\
    \ <= r)\n                z[i] = Math.Min(r - i + 1, z[i - l]);\n            while\
    \ (i + z[i] < s.Length && s[z[i]] == s[i + z[i]])\n                z[i]++;\n \
    \           if (i + z[i] - 1 > r) {\n                l = i;\n                r\
    \ = i + z[i] - 1;\n            }\n        }\n        return str + new string(str.Substring(0,\
    \ str.Length - z[s.Length - 1]).Reverse().ToArray());", "        int n = str.Length;\n\
    \        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n      \
    \      p[i] = 0;\n        }\n        for (int i = 1; i < n; i++) {\n         \
    \   int j = p[i - 1];\n            while (j > 0 && str[i] != str[j]) {\n     \
    \           j = p[j - 1];\n            }\n            if (str[i] == str[j]) {\n\
    \                j++;\n            }\n            p[i] = j;\n        }\n     \
    \   int suffix_len = p[n - 1];\n        string prefix = str.Substring(0, n - suffix_len);\n\
    \        string suffix = str.Substring(n - suffix_len);\n        return str +\
    \ Reverse(prefix);", "        var n = str.Length;\n        var z = new int[n];\n\
    \        z[0] = 0;\n        for (int i = 1, l = 0, r = 0; i < n; i++) {\n    \
    \        if (i <= r) {\n                z[i] = Math.Min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && str[z[i]] == str[i + z[i]])\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        var suffix = z[n - 1];\n        var prefix = str.Substring(0,\
    \ n - suffix);\n        return str + new string(prefix.Reverse().ToArray());",
  "        var s = str;\n        var t = new string(str.Reverse().ToArray());\n  \
    \      var n = s.Length;\n        var z = new int[n + n + 1];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n + n + 1; ++i) {\n            if (i <= r) {\n    \
    \            z[i] = Math.Min(r - i + 1, z[i - l]);\n            }\n          \
    \  while (i + z[i] < n + n + 1 && s[z[i]] == t[i + z[i]]) {\n                ++z[i];\n\
    \            }\n            if (i + z[i] - 1 > r) {\n                l = i;\n\
    \                r = i + z[i] - 1;\n            }\n        }\n        var max\
    \ = 0;\n        for (int i = 1; i < n + n + 1; ++i) {\n            if (i + z[i]\
    \ == n + n + 1) {\n                max = Math.Max(max, z[i]);\n            }\n\
    \        }\n        return str + new string(str.Substring(max).Reverse().ToArray());",
  "        if (str.Length == 0) {\n            return str;\n        }\n        int\
    \ n = str.Length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n          \
    \      z[i] = Math.Min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && str[z[i]] == str[i + z[i]]) {\n                z[i]++;\n  \
    \          }\n            if (i + z[i] - 1 > r) {\n                l = i;\n  \
    \              r = i + z[i] - 1;\n            }\n        }\n        int max_z\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + z[i] == n)\
    \ {\n                max_z = z[i];\n            }\n        }\n        return str\
    \ + new string(str.Take(n - max_z).Reverse().ToArray());", "        var s = str;\n\
    \        var t = str.Reverse().ToArray();\n        var n = s.Length;\n       \
    \ var z = new int[2 * n + 1];\n        for (int i = 1, l = 0, r = 0; i < 2 * n\
    \ + 1; ++i) {\n            int ii = i % 2 == 1 ? (i + 1) / 2 : n - (i / 2);\n\
    \            if (i <= r) {\n                z[i] = Math.Min(r - i + 1, z[2 * l\
    \ - i]);\n            }\n            while (ii + z[i] < n && ii - z[i] >= 0 &&\
    \ s[ii + z[i]] == t[ii - z[i]]) {\n                ++z[i];\n            }\n  \
    \          if (i + z[i] - 1 > r) {\n                l = i;\n                r\
    \ = i + z[i] - 1;\n            }\n        }\n        var max_z = 0;\n        var\
    \ max_i = 0;\n        for (int i = 1; i < 2 * n + 1; ++i) {\n            if (i\
    \ % 2 == 1 && z[i] > max_z) {\n                max_z = z[i];\n               \
    \ max_i = i;\n            }\n        }\n        var prefix = str.Substring(0,\
    \ (max_i - max_z) / 2);\n        return str + new string(prefix.Reverse().ToArray());",
  "        int n = str.Length;\n        // Find the longest postfix that is a palindrome.\n\
    \        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n      \
    \      p[i] = 0;\n        }\n        for (int i = 1; i < n; i++) {\n         \
    \   int j = p[i - 1];\n            while (j > 0 && str[i] != str[j]) {\n     \
    \           j = p[j - 1];\n            }\n            if (str[i] == str[j]) {\n\
    \                j++;\n            }\n            p[i] = j;\n        }\n     \
    \   // Append reverse of a prefix that comes before the palindromic suffix.\n\
    \        int prefix_length = n - p[n - 1];\n        return str + new string(str.Substring(0,\
    \ prefix_length).Reverse().ToArray());", "        var n = str.Length;\n      \
    \  var z = new int[n];\n        z[0] = 0;\n        for (int i = 1, l = 0, r =\
    \ 0; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.Min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && str[z[i]]\
    \ == str[i + z[i]]) {\n                z[i]++;\n            }\n            if\
    \ (i + z[i] - 1 > r) {\n                l = i;\n                r = i + z[i] -\
    \ 1;\n            }\n        }\n        var prefix = str.Substring(0, n - z[n\
    \ - 1]);\n        var suffix = str.Substring(n - z[n - 1]);\n        return str\
    \ + new string(prefix.Reverse().ToArray());", "        if (str.Length == 0) {\n\
    \            return str;\n        }\n        int[] z = new int[str.Length];\n\
    \        z[0] = 0;\n        int l = 0;\n        int r = 0;\n        for (int i\
    \ = 1; i < str.Length; i++) {\n            if (i <= r) {\n                z[i]\
    \ = Math.Min(r - i + 1, z[i - l]);\n            }\n            while (i + z[i]\
    \ < str.Length && str[z[i]] == str[i + z[i]]) {\n                z[i]++;\n   \
    \         }\n            if (i + z[i] - 1 > r) {\n                l = i;\n   \
    \             r = i + z[i] - 1;\n            }\n        }\n        int max_z =\
    \ 0;\n        int max_z_i = 0;\n        for (int i = 0; i < str.Length; i++) {\n\
    \            if (z[i] > max_z) {\n                max_z = z[i];\n            \
    \    max_z_i = i;\n            }\n        }\n        string prefix = str.Substring(0,\
    \ max_z_i);\n        string suffix = str.Substring(max_z_i + max_z);\n       \
    \ return str + new string(prefix.Reverse().ToArray()) + suffix;", "        var\
    \ n = str.Length;\n        var z = new int[n];\n        z[0] = n;\n        var\
    \ l = 0;\n        var r = 0;\n        for (var i = 1; i < n; i++) {\n        \
    \    if (i <= r) {\n                z[i] = Math.Min(r - i + 1, z[i - l]);\n  \
    \          }\n            while (i + z[i] < n && str[z[i]] == str[i + z[i]]) {\n\
    \                z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        var suffix = str.Substring(n - z[n - 1]);\n        var prefix\
    \ = str.Substring(0, n - z[n - 1]);\n        var reverse = new string(prefix.Reverse().ToArray());\n\
    \        return str + reverse;", "        var len = str.Length;\n        var suffix\
    \ = new int[len];\n        for (int i = 0; i < len; i++) {\n            suffix[i]\
    \ = 0;\n        }\n        for (int i = 1; i < len; i++) {\n            int j\
    \ = suffix[i - 1];\n            while (j > 0 && str[i] != str[j]) {\n        \
    \        j = suffix[j - 1];\n            }\n            if (str[i] == str[j])\
    \ {\n                j++;\n            }\n            suffix[i] = j;\n       \
    \ }\n        var prefix = str.Substring(0, len - suffix[len - 1]);\n        var\
    \ reverse = new string(prefix.Reverse().ToArray());\n        return str + reverse;",
  "        if (str.Length == 0) {\n            return str;\n        }\n        var\
    \ suffix = FindLongestPalindromicSuffix(str);\n        var prefix = str.Substring(0,\
    \ str.Length - suffix.Length);\n        return str + new string(prefix.Reverse().ToArray());",
  "        var n = str.Length;\n        var suffix = new int[n];\n        for (int\
    \ i = 0; i < n; i++) {\n            suffix[i] = -1;\n        }\n        for (int\
    \ i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n         \
    \       if (str[i - j] == str[i]) {\n                    suffix[i] = j;\n    \
    \            } else {\n                    break;\n                }\n       \
    \     }\n        }\n        var prefix = new int[n];\n        for (int i = 0;\
    \ i < n; i++) {\n            prefix[i] = -1;\n        }\n        for (int i =\
    \ n - 1; i >= 0; i--) {\n            for (int j = 0; j <= n - 1 - i; j++) {\n\
    \                if (str[i + j] == str[i]) {\n                    prefix[i] =\
    \ j;\n                } else {\n                    break;\n                }\n\
    \            }\n        }\n        var best = 0;\n        for (int i = 0; i <\
    \ n; i++) {\n            if (suffix[i] == prefix[i]) {\n                best =\
    \ i;\n            }\n        }\n        var sb = new StringBuilder();\n      \
    \  sb.Append(str);\n        for (int i = best - 1; i >= 0; i--) {\n          \
    \  sb.Append(str[i]);\n        }\n        return sb.ToString();", "        var\
    \ rev = str.Reverse().ToArray();\n        var s = str + new string(rev);\n   \
    \     var z = ZAlgorithm(s);\n        var n = str.Length;\n        var i = n;\n\
    \        while (i < s.Length && z[i] == n - i) {\n            i++;\n        }\n\
    \        var prefix = str.Substring(0, n - (i - n));\n        return str + new\
    \ string(prefix.Reverse().ToArray());", "        // Find the longest palindromic\
    \ suffix of the string.\n        var suffix = LongestPalindromicSuffix(str);\n\
    \        // Reverse the prefix of the string that comes before the palindromic\
    \ suffix.\n        var prefix = new string(str.Take(str.Length - suffix.Length).Reverse().ToArray());\n\
    \        // Return the concatenation of the prefix, the original string, and the\
    \ suffix.\n        return prefix + str + suffix;", "        var sb = new StringBuilder(str);\n\
    \        var reversed = new string(str.Reverse().ToArray());\n        var longest_suffix\
    \ = LongestCommonSubstring(str, reversed);\n        var prefix = str.Substring(0,\
    \ str.Length - longest_suffix.Length);\n        sb.Append(new string(prefix.Reverse().ToArray()));\n\
    \        return sb.ToString();", "        if (str.Length == 0) return str;\n \
    \       int n = str.Length;\n        int[] z = new int[n];\n        z[0] = n;\n\
    \        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n          \
    \  if (i > r) {\n                l = r = i;\n                while (r < n && str[r\
    \ - l] == str[r]) r++;\n                z[i] = r - l;\n                r--;\n\
    \            } else {\n                int k = i - l;\n                if (z[k]\
    \ < r - i + 1) {\n                    z[i] = z[k];\n                } else {\n\
    \                    l = i;\n                    while (r < n && str[r - l] ==\
    \ str[r]) r++;\n                    z[i] = r - l;\n                    r--;\n\
    \                }\n            }\n        }\n        int max_z = 0;\n       \
    \ for (int i = 1; i < n; i++) {\n            if (z[i] == n - i && max_z >= n -\
    \ i) {\n                return str + new string(str.Substring(0, i).Reverse().ToArray());\n\
    \            }\n            max_z = Math.Max(max_z, z[i]);\n        }\n      \
    \  return str + new string(str.Reverse().ToArray());"]
stop_tokens:
- "\n    }\n"
