name: HumanEval_10_make_palindrome
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Find the shortest palindrome that begins with a supplied\
  \ string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of\
  \ supplied string that is a palindrome.\n    // - Append to the end of the string\
  \ reverse of a string prefix that comes before the palindromic suffix.\n    // >>>\
  \ make_palindrome('')\n    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n\
  \    // >>> make_palindrome('cata')\n    // 'catac'\n    public static String makePalindrome(String\
  \ string) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        int n = string.length();\n        if (n == 0) {\n         \
    \   return string;\n        }\n        int i = n - 1;\n        while (i >= 0)\
    \ {\n            if (string.charAt(i) == string.charAt(0)) {\n               \
    \ if (isPalindrome(string.substring(0, i + 1))) {\n                    break;\n\
    \                }\n            }\n            i--;\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string.substring(i + 1));\n        sb.reverse();\n  \
    \      return string + sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();\n", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ max_palindrome_length = 0;\n        for (int i = 0; i < length; i++) {\n   \
    \         int palindrome_length = 0;\n            int left = i;\n            int\
    \ right = i;\n            while (left >= 0 && right < length && string.charAt(left)\
    \ == string.charAt(right)) {\n                palindrome_length = right - left\
    \ + 1;\n                left--;\n                right++;\n            }\n   \
    \         if (palindrome_length > max_palindrome_length) {\n                max_palindrome_length\
    \ = palindrome_length;\n            }\n            palindrome_length = 0;\n  \
    \          left = i;\n            right = i + 1;\n            while (left >= 0\
    \ && right < length && string.charAt(left) == string.charAt(right)) {\n      \
    \          palindrome_length = right - left + 1;\n                left--;\n  \
    \              right++;\n            }\n            if (palindrome_length > max_palindrome_length)\
    \ {\n                max_palindrome_length = palindrome_length;\n            }\n\
    \        }\n        StringBuilder builder = new StringBuilder();\n        builder.append(string);\n\
    \        for (int i = length - max_palindrome_length - 1; i >= 0; i--) {\n   \
    \         builder.append(string.charAt(i));\n        }\n        return builder.toString();\n",
  "        // >>> make_palindrome('')\n        // ''\n        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        // >>> make_palindrome('cat')\n\
    \        // 'catac'\n        // >>> make_palindrome('cata')\n        // 'catac'\n\
    \        // >>> make_palindrome('catac')\n        // 'catac'\n        // >>> make_palindrome('cataca')\n\
    \        // 'catacacat'\n        // >>> make_palindrome('catacacat')\n       \
    \ // 'catacacat'\n        // >>> make_palindrome('catacacatac')\n        // 'catacacatacacatac'\n\
    \        // >>> make_palindrome('catacacatacacatac')\n        // 'catacacatacacatac'\n\
    \        // >>> make_palindrome('catacacatacacataca')\n        // 'catacacatacacatacacatacacat'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacat')\n        // 'catacacatacacatacacatacacat'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacatac')\n        // 'catacacatacacatacacatacacatacacatacacatacacatac'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacatacacatacacatacacatac')\n\
    \        // 'catacacatacacatacacatacacatacacatacacatacacatac'\n        // >>>\
    \ make_palindrome('catacacatacacatacacatacacatacacatacacatacacataca')\n      \
    \  // 'catacacatacacatacacatacacatacacatacacatacacatacacatacacatacacatacacatacacat'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacatacacatacacatacacatacacatacacatacac",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int maxLength = 0;\n        int maxLengthIndex = 0;\n        for (int i\
    \ = 0; i < string.length(); i++) {\n            int length = 0;\n            for\
    \ (int j = 0; j <= i; j++) {\n                if (string.charAt(i - j) == string.charAt(i\
    \ + j)) {\n                    length += 1;\n                } else {\n      \
    \              break;\n                }\n            }\n            if (length\
    \ > maxLength) {\n                maxLength = length;\n                maxLengthIndex\
    \ = i;\n            }\n        }\n        String prefix = string.substring(0,\
    \ maxLengthIndex - maxLength + 1);\n        String suffix = string.substring(maxLengthIndex\
    \ + maxLength);\n        return string + new StringBuilder(prefix).reverse().toString()\
    \ + suffix;\n", "        int n = string.length();\n        int i = 0;\n      \
    \  int j = n - 1;\n        while (i < j) {\n            if (string.charAt(i) !=\
    \ string.charAt(j)) {\n                break;\n            }\n            i++;\n\
    \            j--;\n        }\n        if (i >= j) {\n            return string;\n\
    \        }\n        StringBuilder builder = new StringBuilder();\n        builder.append(string.substring(i));\n\
    \        builder.reverse();\n        builder.append(string);\n        return builder.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int length = string.length();\n        int[] z = new int[length];\n   \
    \     int left = 0;\n        int right = 0;\n        for (int i = 1; i < length;\
    \ i++) {\n            if (i > right) {\n                left = right = i;\n  \
    \              while (right < length && string.charAt(right) == string.charAt(right\
    \ - left)) {\n                    right++;\n                }\n              \
    \  z[i] = right - left;\n                right--;\n            } else {\n    \
    \            int k = i - left;\n                if (z[k] < right - i + 1) {\n\
    \                    z[i] = z[k];\n                } else {\n                \
    \    left = i;\n                    while (right < length && string.charAt(right)\
    \ == string.charAt(right - left)) {\n                        right++;\n      \
    \              }\n                    z[i] = right - left;\n                 \
    \   right--;\n                }\n            }\n        }\n        int max = 0;\n\
    \        int max_index = 0;\n        for (int i = 0; i < length; i++) {\n    \
    \        if (z[i] > max) {\n                max = z[i];\n                max_index\
    \ = i;\n            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = max_index + max; i < length; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int i = string.length() - 1;\n        while (i >= 0) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                break;\n            }\n\
    \            i--;\n        }\n        return string + reverse(string.substring(0,\
    \ i));\n", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int palindromeSuffixLength = findLongestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - palindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;\n", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        int i = string.length() -\
    \ 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                break;\n            }\n            i--;\n        }\n    \
    \    String prefix = string.substring(0, i);\n        String suffix = string.substring(i);\n\
    \        return string + reverse(prefix);\n", "        int length = string.length();\n\
    \        int maxPalindromeLength = 0;\n        for (int i = 0; i < length; i++)\
    \ {\n            int palindromeLength = 0;\n            int j = 0;\n         \
    \   while (i - j >= 0 && i + j < length && string.charAt(i - j) == string.charAt(i\
    \ + j)) {\n                palindromeLength = 2 * j + 1;\n                j++;\n\
    \            }\n            if (palindromeLength > maxPalindromeLength) {\n  \
    \              maxPalindromeLength = palindromeLength;\n            }\n      \
    \      palindromeLength = 0;\n            j = 0;\n            while (i - j >=\
    \ 0 && i + j + 1 < length && string.charAt(i - j) == string.charAt(i + j + 1))\
    \ {\n                palindromeLength = 2 * j + 2;\n                j++;\n   \
    \         }\n            if (palindromeLength > maxPalindromeLength) {\n     \
    \           maxPalindromeLength = palindromeLength;\n            }\n        }\n\
    \        StringBuilder builder = new StringBuilder();\n        for (int i = 0;\
    \ i < length - maxPalindromeLength; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        for (int i = length - 1; i >= length - maxPalindromeLength;\
    \ i--) {\n            builder.append(string.charAt(i));\n        }\n        return\
    \ builder.toString();\n", "        int n = string.length();\n        int i = 0;\n\
    \        int j = n - 1;\n        while (i < j) {\n            if (string.charAt(i)\
    \ != string.charAt(j)) {\n                break;\n            }\n            i++;\n\
    \            j--;\n        }\n        if (i >= j) {\n            return string;\n\
    \        }\n        StringBuilder sb = new StringBuilder(string);\n        for\
    \ (int k = i; k >= 0; k--) {\n            sb.append(string.charAt(k));\n     \
    \   }\n        return sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        String reversed = sb.reverse().toString();\n        StringBuilder result\
    \ = new StringBuilder(string);\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            if (string.substring(i).equals(reversed.substring(0, string.length()\
    \ - i))) {\n                result.append(reversed.substring(string.length() -\
    \ i));\n                break;\n            }\n        }\n        return result.toString();\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int longestPalindrome = 0;\n        for (int i = 0; i < n;\
    \ i++) {\n            if (i + z[i] == n) {\n                longestPalindrome\
    \ = z[i];\n                break;\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = n - longestPalindrome - 1; i\
    \ >= 0; i--) {\n            sb.append(string.charAt(i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();\n", "        int n = string.length();\n       \
    \ int[] p = new int[n];\n        int c = 0, r = 0;\n        for (int i = 1; i\
    \ < n; i++) {\n            int mirror = 2 * c - i;\n            if (i < r) {\n\
    \                p[i] = Math.min(r - i, p[mirror]);\n            }\n         \
    \   while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1 + p[i])\
    \ == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n            }\n\
    \            if (i + p[i] > r) {\n                c = i;\n                r =\
    \ i + p[i];\n            }\n        }\n        int max_i = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (p[i] > p[max_i]) {\n                max_i\
    \ = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = max_i + p[max_i]; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      int n = string.length();\n        int[] p = new int[n];\n        for (int\
    \ i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        int c = 0;\n\
    \        int r = 0;\n        for (int i = 1; i < n; i++) {\n            int i_mirror\
    \ = 2 * c - i;\n            if (r > i) {\n                p[i] = Math.min(r -\
    \ i, p[i_mirror]);\n            }\n            while (i + 1 + p[i] < n && i -\
    \ 1 - p[i] >= 0 && string.charAt(i + 1 + p[i]) == string.charAt(i - 1 - p[i]))\
    \ {\n                p[i]++;\n            }\n            if (i + p[i] > r) {\n\
    \                c = i;\n                r = i + p[i];\n            }\n      \
    \  }\n        int max_len = 0;\n        int center_index = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + p[i] == n && p[i] > max_len) {\n \
    \               max_len = p[i];\n                center_index = i;\n         \
    \   }\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(string.substring(0,\
    \ center_index - max_len));\n        sb.reverse();\n        sb.append(string);\n\
    \        return sb.toString();\n", "        int n = string.length();\n       \
    \ int[] z = new int[n];\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\n\
    \            if (i <= r)\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\n\
    \                ++z[i];\n            if (i + z[i] - 1 > r) {\n              \
    \  l = i;\n                r = i + z[i] - 1;\n            }\n        }\n     \
    \   int longestPalindromeSuffix = 0;\n        for (int i = 1; i < n; ++i) {\n\
    \            if (i + z[i] == n) {\n                longestPalindromeSuffix = i;\n\
    \                break;\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder();\n        for (int i = 0; i < n - longestPalindromeSuffix;\
    \ ++i) {\n            builder.append(string.charAt(i));\n        }\n        builder.append(string);\n\
    \        return builder.toString();\n", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int maxPalindromeLength = 0;\n\
    \        int maxPalindromeIndex = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindromeLength = 0;\n            int j = i;\n    \
    \        int k = string.length() - 1;\n            while (j >= 0 && k >= 0 &&\
    \ string.charAt(j) == string.charAt(k)) {\n                palindromeLength++;\n\
    \                j--;\n                k--;\n            }\n            if (palindromeLength\
    \ > maxPalindromeLength) {\n                maxPalindromeLength = palindromeLength;\n\
    \                maxPalindromeIndex = i;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        for (int i = maxPalindromeIndex\
    \ - maxPalindromeLength + 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();\n", "        String reversed =\
    \ new StringBuilder(string).reverse().toString();\n        String result = string\
    \ + reversed;\n        for (int i = 0; i < string.length(); i++) {\n         \
    \   if (string.substring(0, i).equals(reversed.substring(reversed.length() - i)))\
    \ {\n                result = string + reversed.substring(i);\n              \
    \  break;\n            }\n        }\n        return result;\n", "        int n\
    \ = string.length();\n        if (n == 0) {\n            return string;\n    \
    \    }\n        int[] z = new int[n];\n        z[0] = n;\n        int l = 0;\n\
    \        int r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i\
    \ <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n           \
    \ }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        int max_i = 0;\n        for\
    \ (int i = 0; i < n; i++) {\n            if (z[i] == n - i && z[i] > max) {\n\
    \                max = z[i];\n                max_i = i;\n            }\n    \
    \    }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ 0; i < n - max; i++) {\n            sb.append(string.charAt(n - 1 - i));\n \
    \       }\n        sb.append(string);\n        return sb.toString();\n", "   \
    \     int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ 0;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n      \
    \  }\n        sb.append(string);\n        return sb.toString();\n", "        int\
    \ n = string.length();\n        int[] z = new int[n];\n        int l = 0, r =\
    \ 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n     \
    \           z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n           \
    \ while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n \
    \               z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int longestPalindromeSuffix = 0;\n        for (int i = 1; i\
    \ < n; i++) {\n            if (i + z[i] == n) {\n                longestPalindromeSuffix\
    \ = Math.max(longestPalindromeSuffix, z[i]);\n            }\n        }\n     \
    \   StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n - longestPalindromeSuffix;\
    \ i++) {\n            sb.append(string.charAt(i));\n        }\n        for (int\
    \ i = n - 1; i >= longestPalindromeSuffix; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();\n", "        int n = string.length();\n\
    \        int i = n - 1;\n        while (i >= 0) {\n            if (isPalindrome(string,\
    \ i)) {\n                break;\n            }\n            i--;\n        }\n\
    \        StringBuilder sb = new StringBuilder(string);\n        sb.append(reverse(string.substring(0,\
    \ n - i - 1)));\n        return sb.toString();\n", "        int length = string.length();\n\
    \        int i = 0;\n        int j = length - 1;\n        while (i < j) {\n  \
    \          if (string.charAt(i) != string.charAt(j)) {\n                break;\n\
    \            }\n            i++;\n            j--;\n        }\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        for (int k = i - 1; k >= 0; k--)\
    \ {\n            builder.append(string.charAt(k));\n        }\n        return\
    \ builder.toString();\n", "        // >>> make_palindrome('cat')\n        // 'catac'\n\
    \        // >>> make_palindrome('cata')\n        // 'catac'\n        // >>> make_palindrome('cataa')\n\
    \        // 'cataacat'\n        // >>> make_palindrome('cataac')\n        // 'cataacat'\n\
    \        // >>> make_palindrome('cataacat')\n        // 'cataacat'\n        //\
    \ >>> make_palindrome('cataacata')\n        // 'cataacataacat'\n        // >>>\
    \ make_palindrome('cataacataa')\n        // 'cataacataacat'\n        // >>> make_palindrome('cataacataac')\n\
    \        // 'cataacataacat'\n        // >>> make_palindrome('cataacataaca')\n\
    \        // 'cataacataacaacat'\n        // >>> make_palindrome('cataacataacaa')\n\
    \        // 'cataacataacaacat'\n        // >>> make_palindrome('cataacataacaac')\n\
    \        // 'cataacataacaacat'\n        // >>> make_palindrome('cataacataacaaca')\n\
    \        // 'cataacataacaacaacat'\n        // >>> make_palindrome('cataacataacaacaa')\n\
    \        // 'cataacataacaacaacat'\n        // >>> make_palindrome('cataacataacaacaac')\n\
    \        // 'cataacataacaacaacat'\n        // >>> make_palindrome('cataacataacaacaaca')\n\
    \        // 'cataacataacaacaacaacat'\n        // >>> make_palindrome('cataacataacaacaacaa')\n\
    \        // 'cataacataacaacaacaacat'\n        // >>> make_palindrome('cataacataacaacaacaac')\n\
    \        // 'cataacataacaacaacaacat'\n        // >>> make_palindrome('cataacataacaacaacaaca')\n\
    \        // 'cataacataacaacaacaacaacat'\n        // >>> make_palindrome('cataac",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_palindrome_length = 0;\n        int max_palindrome_index = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int palindrome_length\
    \ = 0;\n            int j = 0;\n            while (i - j >= 0 && i + j < string.length()\
    \ && string.charAt(i - j) == string.charAt(i + j)) {\n                palindrome_length\
    \ = 2 * j + 1;\n                j++;\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_index = i;\n            }\n        }\n       \
    \ for (int i = 0; i < string.length() - 1; i++) {\n            int palindrome_length\
    \ = 0;\n            int j = 0;\n            while (i - j >= 0 && i + 1 + j < string.length()\
    \ && string.charAt(i - j) == string.charAt(i + 1 + j)) {\n                palindrome_length\
    \ = 2 * j + 2;\n                j++;\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_index = i;\n            }\n        }\n       \
    \ StringBuilder builder = new StringBuilder();\n        builder.append(string.substring(0,\
    \ max_palindrome_index + 1));\n        builder.append(new StringBuilder(string.substring(0,\
    \ max_palindrome_index + 1)).reverse());\n        return builder.toString();\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n  \
    \          }\n        }\n        StringBuilder sb = new StringBuilder();\n   \
    \     for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int palindromeSuffixLength = findPalindromeSuffixLength(string);\n    \
    \    String prefix = string.substring(0, string.length() - palindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;\n", "        StringBuilder builder = new\
    \ StringBuilder(string);\n        int length = string.length();\n        for (int\
    \ i = 0; i < length; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                builder.append(builder.substring(0, length - i).reverse());\n\
    \                break;\n            }\n        }\n        return builder.toString();\n",
  "        StringBuilder sb = new StringBuilder(string);\n        int n = string.length();\n\
    \        int i = 0;\n        while (i < n) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                sb.append(new StringBuilder(string.substring(0, i)).reverse());\n\
    \                break;\n            }\n            i++;\n        }\n        return\
    \ sb.toString();\n", "        int n = string.length();\n        int i = 0;\n \
    \       int j = n - 1;\n        int k = 0;\n        while (i < j) {\n        \
    \    if (string.charAt(i) == string.charAt(j)) {\n                i++;\n     \
    \           j--;\n            } else {\n                i = 0;\n             \
    \   k++;\n                j = n - 1 - k;\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string.substring(k + 1));\n        sb.reverse();\n  \
    \      return string + sb.toString();\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (z[i] == n - i && i > max) {\n        \
    \        max = i;\n            }\n        }\n        StringBuilder builder = new\
    \ StringBuilder();\n        for (int i = max; i < n; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        for (int i = 0; i < max; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();\n", "        int n = string.length();\n\
    \        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n      \
    \      p[i] = 0;\n        }\n        for (int i = 1; i < n; i++) {\n         \
    \   int j = p[i - 1];\n            while (j > 0 && string.charAt(i) != string.charAt(j))\
    \ {\n                j = p[j - 1];\n            }\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                j++;\n            }\n            p[i]\
    \ = j;\n        }\n        StringBuilder sb = new StringBuilder();\n        for\
    \ (int i = 0; i < n - p[n - 1]; i++) {\n            sb.append(string.charAt(n\
    \ - 1 - i));\n        }\n        sb.append(string);\n        return sb.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_palindrome_length = 0;\n        int max_palindrome_start = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int palindrome_length\
    \ = 0;\n            int palindrome_start = i;\n            int j = 0;\n      \
    \      while (i - j >= 0 && i + j < string.length() && string.charAt(i - j) ==\
    \ string.charAt(i + j)) {\n                palindrome_length = 2 * j + 1;\n  \
    \              palindrome_start = i - j;\n                j++;\n            }\n\
    \            if (palindrome_length > max_palindrome_length) {\n              \
    \  max_palindrome_length = palindrome_length;\n                max_palindrome_start\
    \ = palindrome_start;\n            }\n            palindrome_length = 0;\n   \
    \         palindrome_start = i;\n            j = 0;\n            while (i - j\
    \ >= 0 && i + j + 1 < string.length() && string.charAt(i - j) == string.charAt(i\
    \ + j + 1)) {\n                palindrome_length = 2 * j + 2;\n              \
    \  palindrome_start = i - j;\n                j++;\n            }\n          \
    \  if (palindrome_length > max_palindrome_length) {\n                max_palindrome_length\
    \ = palindrome_length;\n                max_palindrome_start = palindrome_start;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string.substring(max_palindrome_start + max_palindrome_length));\n\
    \        builder.reverse();\n        builder.append(string);\n        return builder.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int suffixLength = longestPalindromicSuffix(string);\n        String prefix\
    \ = string.substring(0, string.length() - suffixLength);\n        String reversePrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;\n",
  "        StringBuilder builder = new StringBuilder(string);\n        int i = string.length()\
    \ - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                builder.append(new StringBuilder(string.substring(0, i)).reverse());\n\
    \                break;\n            }\n            i--;\n        }\n        return\
    \ builder.toString();\n", "        // >>> make_palindrome('')\n        // ''\n\
    \        if (string.length() == 0) {\n            return string;\n        }\n\
    \        // >>> make_palindrome('cat')\n        // 'catac'\n        // >>> make_palindrome('cata')\n\
    \        // 'catac'\n        // >>> make_palindrome('cataa')\n        // 'cataacat'\n\
    \        // >>> make_palindrome('catac')\n        // 'catac'\n        // >>> make_palindrome('cataca')\n\
    \        // 'catacacat'\n        // >>> make_palindrome('catacat')\n        //\
    \ 'catacat'\n        // >>> make_palindrome('catacata')\n        // 'catacatacat'\n\
    \        // >>> make_palindrome('catacatac')\n        // 'catacatac'\n       \
    \ // >>> make_palindrome('catacataca')\n        // 'catacatacacat'\n        //\
    \ >>> make_palindrome('catacatacat')\n        // 'catacatacat'\n        // >>>\
    \ make_palindrome('catacatacata')\n        // 'catacatacatacat'\n        // >>>\
    \ make_palindrome('catacatacatac')\n        // 'catacatacatac'\n        // >>>\
    \ make_palindrome('catacatacataca')\n        // 'catacatacatacacat'\n        //\
    \ >>> make_palindrome('catacatacatacat')\n        // 'catacatacatacat'\n     \
    \   // >>> make_palindrome('catacatacatacata')\n        // 'catacatacatacatacat'\n\
    \        // >>> make_palindrome('catacatacatacatac')\n        // 'catacatacatacatac'\n\
    \        // >>> make_palindrome('catacatacatacataca')\n        // 'catacatacatacatacacat'\n\
    \        // >>> make_palindrome('catacatacatacatacat')\n        // 'catacatacatacatacat'\n\
    \       ", "        int n = string.length();\n        int[] z = new int[n];\n\
    \        z[0] = n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            if (i > r) {\n                l = r = i;\n             \
    \   while (r < n && string.charAt(r - l) == string.charAt(r)) {\n            \
    \        r++;\n                }\n                z[i] = r - l;\n            \
    \    r--;\n            } else {\n                int k = i - l;\n            \
    \    if (z[k] < r - i + 1) {\n                    z[i] = z[k];\n             \
    \   } else {\n                    l = i;\n                    while (r < n &&\
    \ string.charAt(r - l) == string.charAt(r)) {\n                        r++;\n\
    \                    }\n                    z[i] = r - l;\n                  \
    \  r--;\n                }\n            }\n        }\n        int max = 0;\n \
    \       for (int i = 0; i < n; i++) {\n            if (z[i] == i + 1) {\n    \
    \            max = i + 1;\n            }\n        }\n        StringBuilder sb\
    \ = new StringBuilder();\n        for (int i = max; i < n; i++) {\n          \
    \  sb.append(string.charAt(i));\n        }\n        sb.append(string);\n     \
    \   return sb.toString();\n", "        if (string.length() == 0) {\n         \
    \   return string;\n        }\n        int palindromeEnd = string.length();\n\
    \        for (int i = string.length() - 1; i >= 0; i--) {\n            if (string.charAt(i)\
    \ == string.charAt(palindromeEnd - 1)) {\n                palindromeEnd--;\n \
    \           }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = 0; i < string.length() - palindromeEnd; i++) {\n       \
    \     builder.append(string.charAt(i));\n        }\n        return builder.toString();\n",
  "        StringBuilder sb = new StringBuilder(string);\n        int i = 0;\n   \
    \     int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                i++;\n                j--;\n       \
    \     } else {\n                i = 0;\n                j--;\n            }\n\
    \        }\n        return sb.append(sb.reverse().substring(0, string.length()\
    \ - i)).toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        int i = 0;\n        while (i < n) {\n        \
    \    if (sb.substring(i).equals(rev.substring(0, n - i))) {\n                break;\n\
    \            }\n            i++;\n        }\n        return sb.append(rev.substring(n\
    \ - i)).toString();\n", "        int length = string.length();\n        if (length\
    \ == 0) {\n            return string;\n        }\n        int[] z = zFunction(string);\n\
    \        int maxPalindromeLength = z[length];\n        String prefix = string.substring(0,\
    \ length - maxPalindromeLength);\n        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;\n", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        int max_palindrome_length\
    \ = 0;\n        int max_palindrome_start = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindrome_length = 0;\n            int palindrome_start\
    \ = i;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindrome_length = 2 *\
    \ j + 1;\n                    palindrome_start = i - j;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if (palindrome_length > max_palindrome_length) {\n                max_palindrome_length\
    \ = palindrome_length;\n                max_palindrome_start = palindrome_start;\n\
    \            }\n        }\n        for (int i = 0; i < string.length() - 1; i++)\
    \ {\n            int palindrome_length = 0;\n            int palindrome_start\
    \ = i;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + 1 + j)) {\n                    palindrome_length =\
    \ 2 * j + 2;\n                    palindrome_start = i - j;\n                }\
    \ else {\n                    break;\n                }\n            }\n     \
    \       if (palindrome_length > max_palindrome_length) {\n                max_palindrome_length\
    \ = palindrome_length;\n                max_palindrome_start = palindrome_start;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string);\n        for (int i = max_palindrome_start -\
    \ 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n        }\n\
    \        return builder.toString();\n", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int palindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - palindromeSuffixLength);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;\n", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        return string + reverse(prefix);\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int i = string.length() - 1;\n        while (i >= 0) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                return string + reverse(string.substring(0,\
    \ i));\n            }\n            i--;\n        }\n        return string;\n",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int[] z = new int[n];\n        z[0] = n;\n        int l =\
    \ 0;\n        int r = 0;\n        for (int i = 1; i < n; i++) {\n            if\
    \ (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n        \
    \    }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        int maxIndex = 0;\n     \
    \   for (int i = 0; i < n; i++) {\n            if (z[i] > max) {\n           \
    \     max = z[i];\n                maxIndex = i;\n            }\n        }\n \
    \       StringBuilder sb = new StringBuilder();\n        for (int i = maxIndex\
    \ + max; i < n; i++) {\n            sb.append(string.charAt(i));\n        }\n\
    \        for (int i = 0; i < maxIndex; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();\n", "        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversedPrefix;\n",
  "        int n = string.length();\n        int[] p = new int[n];\n        p[0] =\
    \ 0;\n        for (int i = 1; i < n; i++) {\n            int j = p[i - 1];\n \
    \           while (j > 0 && string.charAt(i) != string.charAt(j)) {\n        \
    \        j = p[j - 1];\n            }\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                j++;\n            }\n            p[i] = j;\n        }\n \
    \       int suffix_length = n - p[n - 1];\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        for (int i = 0; i < suffix_length; i++) {\n\
    \            builder.append(string.charAt(i));\n        }\n        return builder.toString();\n",
  "        int length = string.length();\n        int index = length - 1;\n      \
    \  while (index >= 0) {\n            if (isPalindrome(string, index)) {\n    \
    \            break;\n            }\n            index -= 1;\n        }\n     \
    \   String prefix = string.substring(0, index + 1);\n        StringBuilder builder\
    \ = new StringBuilder(prefix);\n        builder.reverse();\n        return string\
    \ + builder.toString();\n", "        int n = string.length();\n        int[] z\
    \ = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max_z = 0;\n        for\
    \ (int i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n              \
    \  max_z = z[i];\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = n - max_z - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      // >>> make_palindrome('')\n        // ''\n        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        // >>> make_palindrome('cat')\n\
    \        // 'catac'\n        // >>> make_palindrome('cata')\n        // 'catac'\n\
    \        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        // >>> longest_palindromic_postfix('cat')\n        // 't'\n        //\
    \ >>> longest_palindromic_postfix('cata')\n        // 'ata'\n        String longestPalindromicPostfix\
    \ = longestPalindromicPostfix(string);\n        // >>> reverse('cat')\n      \
    \  // 'tac'\n        // >>> reverse('cata')\n        // 'atac'\n        // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n        // >>> string + reverse(string[:-len(longest_palindromic_postfix)])\n\
    \        // 'catac'\n        // >>> string + reverse(string[:-len('ata')])\n \
    \       // 'catac'\n        return string + reverse(string.substring(0, string.length()\
    \ - longestPalindromicPostfix.length()));\n", "        int n = string.length();\n\
    \        int[] p = new int[n];\n        int c = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            int mirror = 2 * c - i;\n            if (i <\
    \ r) {\n                p[i] = Math.min(r - i, p[mirror]);\n            }\n  \
    \          while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1\
    \ + p[i]) == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n       \
    \     }\n            if (i + p[i] > r) {\n                c = i;\n           \
    \     r = i + p[i];\n            }\n        }\n        int max = 0;\n        for\
    \ (int i = 1; i < n; i++) {\n            if (i + p[i] == n) {\n              \
    \  max = p[i];\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      StringBuilder sb = new StringBuilder(string);\n        int n = string.length();\n\
    \        for (int i = n - 1; i >= 0; i--) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                sb.append(string.substring(0, i));\n                return\
    \ sb.reverse().toString();\n            }\n        }\n        return sb.reverse().toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int longestPalindromeSuffix = longestPalindromeSuffix(string);\n      \
    \  StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(string.substring(0,\
    \ string.length() - longestPalindromeSuffix)));\n        return builder.toString();\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n    \
    \        if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n  \
    \          }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = n - max - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i > r) {\n\
    \                l = r = i;\n                while (r < n && string.charAt(r -\
    \ l) == string.charAt(r)) {\n                    r++;\n                }\n   \
    \             z[i] = r - l;\n                r--;\n            } else {\n    \
    \            int k = i - l;\n                if (z[k] < r - i + 1) {\n       \
    \             z[i] = z[k];\n                } else {\n                    l =\
    \ i;\n                    while (r < n && string.charAt(r - l) == string.charAt(r))\
    \ {\n                        r++;\n                    }\n                   \
    \ z[i] = r - l;\n                    r--;\n                }\n            }\n\
    \        }\n        int max_z = 0;\n        for (int i = 1; i < n; i++) {\n  \
    \          if (z[i] == n - i && z[i] > max_z) {\n                max_z = z[i];\n\
    \            }\n        }\n        StringBuilder sb = new StringBuilder();\n \
    \       for (int i = 0; i < n - max_z; i++) {\n            sb.append(string.charAt(n\
    \ - i - 1));\n        }\n        sb.append(string);\n        return sb.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        // >>> make_palindrome('cataa')\n\
    \        // 'cataacat'\n        // >>> make_palindrome('cataaa')\n        // 'cataaacat'\n\
    \        // >>> make_palindrome('cataaaa')\n        // 'cataaaacat'\n        //\
    \ >>> make_palindrome('cataaaaa')\n        // 'cataaaaacat'\n        // >>> make_palindrome('cataaaaaa')\n\
    \        // 'cataaaaaacat'\n        // >>> make_palindrome('cataaaaaaa')\n   \
    \     // 'cataaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaa')\n    \
    \    // 'cataaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaa')\n   \
    \     // 'cataaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaaaaaaaacat'\n        // >>> make_palindrome('cataaaaaaaaaaaaaaaaa')\n\
    \        // 'cataaaaaaaaaaaaaaaaacat'\n        // >>> make_palindrome", "    \
    \    if (string.length() == 0) {\n            return string;\n        }\n    \
    \    int palindromeSuffixLength = longestPalindromeSuffixLength(string);\n   \
    \     StringBuilder result = new StringBuilder(string);\n        for (int i =\
    \ 0; i < string.length() - palindromeSuffixLength; i++) {\n            result.append(string.charAt(i));\n\
    \        }\n        return result.toString();\n", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int[] z\
    \ = new int[n];\n        z[0] = n;\n        int l = 0;\n        int r = 0;\n \
    \       for (int i = 1; i < n; i++) {\n            if (i <= r) {\n           \
    \     z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n       \
    \         z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n      \
    \          l = i;\n                r = i + z[i] - 1;\n            }\n        }\n\
    \        int longestPalindromeSuffix = z[0];\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = n - 1; i >= longestPalindromeSuffix; i--) {\n          \
    \  sb.append(string.charAt(i));\n        }\n        sb.append(string);\n     \
    \   return sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder rev = new StringBuilder(string).reverse();\n        int\
    \ n = string.length();\n        for (int i = 0; i < n; i++) {\n            if\
    \ (sb.substring(i).equals(rev.substring(0, n - i))) {\n                return\
    \ sb.append(rev.substring(n - i)).toString();\n            }\n        }\n    \
    \    return sb.append(rev.substring(1)).toString();\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int palindromeSuffixLength\
    \ = 0;\n        for (int i = string.length() - 1; i >= 0; i--) {\n           \
    \ if (isPalindrome(string.substring(i))) {\n                palindromeSuffixLength\
    \ = string.length() - i;\n                break;\n            }\n        }\n \
    \       String prefix = string.substring(0, string.length() - palindromeSuffixLength);\n\
    \        StringBuilder sb = new StringBuilder(prefix);\n        return string\
    \ + sb.reverse().toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        StringBuilder sb_rev = new StringBuilder(string).reverse();\n       \
    \ int n = string.length();\n        int i = 0;\n        for (; i < n; i++) {\n\
    \            if (sb.substring(i).equals(sb_rev.substring(0, n - i))) {\n     \
    \           break;\n            }\n        }\n        return sb.append(sb_rev.substring(n\
    \ - i)).toString();\n", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;\n", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        int max_palindrome_length\
    \ = 0;\n        int max_palindrome_start = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindrome_length = 0;\n            int palindrome_start\
    \ = i;\n            for (int j = 0; j < string.length() - i; j++) {\n        \
    \        if (string.charAt(i + j) == string.charAt(string.length() - 1 - j)) {\n\
    \                    palindrome_length += 1;\n                } else {\n     \
    \               break;\n                }\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_start = palindrome_start;\n            }\n   \
    \     }\n        StringBuilder builder = new StringBuilder();\n        builder.append(string);\n\
    \        for (int i = 0; i < string.length() - max_palindrome_length; i++) {\n\
    \            builder.append(string.charAt(string.length() - 1 - i));\n       \
    \ }\n        return builder.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();\n", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        StringBuilder builder =\
    \ new StringBuilder();\n        builder.append(string.substring(0, i));\n    \
    \    builder.append(makePalindrome(string.substring(i, j + 1)));\n        builder.append(string.substring(i));\n\
    \        return builder.toString();\n", "        int length = string.length();\n\
    \        if (length == 0) {\n            return string;\n        }\n        int\
    \ i = length - 1;\n        while (i >= 0) {\n            if (isPalindrome(string,\
    \ i)) {\n                break;\n            }\n            i--;\n        }\n\
    \        String prefix = string.substring(0, i + 1);\n        String reverse =\
    \ new StringBuilder(prefix).reverse().toString();\n        return string + reverse;\n",
  "        // >>> make_palindrome('')\n        // ''\n        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        // >>> make_palindrome('cat')\n\
    \        // 'catac'\n        // >>> make_palindrome('cata')\n        // 'catac'\n\
    \        int palindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(new\
    \ StringBuilder(string.substring(0, string.length() - palindromeSuffixLength)).reverse());\n\
    \        return builder.toString();\n", "        StringBuilder builder = new StringBuilder(string);\n\
    \        int length = string.length();\n        for (int i = length - 1; i >=\
    \ 0; i--) {\n            if (isPalindrome(string.substring(i))) {\n          \
    \      builder.append(new StringBuilder(string.substring(0, i)).reverse());\n\
    \                break;\n            }\n        }\n        return builder.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_palindrome_length = 0;\n        int max_palindrome_index = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int palindrome_length\
    \ = 0;\n            int j = 0;\n            while (i - j >= 0 && i + j < string.length()\
    \ && string.charAt(i - j) == string.charAt(i + j)) {\n                palindrome_length\
    \ = 2 * j + 1;\n                j++;\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_index = i;\n            }\n        }\n       \
    \ for (int i = 0; i < string.length() - 1; i++) {\n            int palindrome_length\
    \ = 0;\n            int j = 0;\n            while (i - j >= 0 && i + 1 + j < string.length()\
    \ && string.charAt(i - j) == string.charAt(i + 1 + j)) {\n                palindrome_length\
    \ = 2 * j + 2;\n                j++;\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_index = i;\n            }\n        }\n       \
    \ StringBuilder builder = new StringBuilder();\n        builder.append(string);\n\
    \        for (int i = 0; i < string.length() - max_palindrome_length; i++) {\n\
    \            builder.append(string.charAt(string.length() - 1 - i));\n       \
    \ }\n        return builder.toString();\n", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        // Find the longest palindromic\
    \ suffix.\n        int suffix_length = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   suffix_length = string.length() - i;\n                break;\n           \
    \ }\n        }\n        // Append the reverse of the prefix to the end of the\
    \ string.\n        String prefix = string.substring(0, string.length() - suffix_length);\n\
    \        return string + reverse(prefix);\n", "        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        StringBuilder reversedPrefix\
    \ = new StringBuilder(prefix);\n        reversedPrefix.reverse();\n        return\
    \ string + reversedPrefix.toString();\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max_z = 0;\n        for\
    \ (int i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n              \
    \  max_z = z[i];\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = n - max_z - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n      \
    \  }\n        return string + sb.toString();\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        z[0] = 0;\n        int l = 0, r = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n          \
    \      z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n       \
    \         z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n      \
    \          l = i;\n                r = i + z[i] - 1;\n            }\n        }\n\
    \        int longest = 0;\n        for (int i = 1; i < n; i++) {\n           \
    \ if (z[i] == i) {\n                longest = i;\n            }\n        }\n \
    \       StringBuilder sb = new StringBuilder();\n        for (int i = longest\
    \ + 1; i < n; i++) {\n            sb.append(string.charAt(i));\n        }\n  \
    \      sb.append(string);\n        return sb.toString();\n", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(0,\
    \ string.length() - i));\n        return sb.toString();\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        // >>> make_palindrome('cataa')\n\
    \        // 'cataacat'\n        // >>> make_palindrome('catac')\n        // 'catac'\n\
    \        // >>> make_palindrome('cataca')\n        // 'catacacat'\n        //\
    \ >>> make_palindrome('catacac')\n        // 'catacac'\n        // >>> make_palindrome('catacaca')\n\
    \        // 'catacacacat'\n        // >>> make_palindrome('catacacac')\n     \
    \   // 'catacacac'\n        // >>> make_palindrome('catacacaca')\n        // 'catacacacacat'\n\
    \        // >>> make_palindrome('catacacacac')\n        // 'catacacacac'\n   \
    \     // >>> make_palindrome('catacacacaca')\n        // 'catacacacacacat'\n \
    \       // >>> make_palindrome('catacacacacac')\n        // 'catacacacacac'\n\
    \        // >>> make_palindrome('catacacacacaca')\n        // 'catacacacacacacat'\n\
    \        // >>> make_palindrome('catacacacacacac')\n        // 'catacacacacacac'\n\
    \        // >>> make_palindrome('catacacacacacaca')\n        // 'catacacacacacacacat'\n\
    \        // >>> make_palindrome('catacacacacacacac')\n        // 'catacacacacacacac'\n\
    \        // >>> make_palindrome('catacacacacacacaca')\n        // 'catacacacacacacacacat'\n\
    \        // >>> make_palindrome('catacacacacacacacac')\n        // 'catacacacacacacacac'\n\
    \       ", "        int n = string.length();\n        int[] z = new int[n];\n\
    \        z[0] = 0;\n        int l = 0, r = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1,\
    \ z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max_z = 0;\n        for\
    \ (int i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n              \
    \  max_z = z[i];\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = n - max_z - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      if (string.length() == 0) {\n            return string;\n        }\n  \
    \      StringBuilder sb = new StringBuilder(string);\n        int i = string.length()\
    \ - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                break;\n            }\n            i--;\n        }\n    \
    \    sb.append(new StringBuilder(string.substring(0, i)).reverse());\n       \
    \ return sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int max_palindrome_length = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindrome_length = 0;\n            for (int j = 0;\
    \ j < string.length() - i; j++) {\n                if (string.charAt(i + j) ==\
    \ string.charAt(string.length() - 1 - j)) {\n                    palindrome_length++;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if (palindrome_length > max_palindrome_length) {\n  \
    \              max_palindrome_length = palindrome_length;\n            }\n   \
    \     }\n        for (int i = 0; i < string.length() - max_palindrome_length;\
    \ i++) {\n            sb.append(string.charAt(string.length() - 1 - i));\n   \
    \     }\n        return sb.toString();\n", "        StringBuilder builder = new\
    \ StringBuilder(string);\n        String reverse = builder.reverse().toString();\n\
    \        String result = string + reverse.substring(reverse.indexOf(string) +\
    \ string.length());\n        return result;\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (z[i] == n - i) {\n                max\
    \ = z[i];\n                break;\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = 0; i < n - max; i++) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        sb.reverse();\n   \
    \     sb.append(string);\n        return sb.toString();\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int max_palindrome_length\
    \ = 0;\n        int max_palindrome_start = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindrome_length = 0;\n            for (int j = 0;\
    \ i - j >= 0 && i + j < string.length(); j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindrome_length = 2 *\
    \ j + 1;\n                } else {\n                    break;\n             \
    \   }\n            }\n            if (palindrome_length > max_palindrome_length)\
    \ {\n                max_palindrome_length = palindrome_length;\n            \
    \    max_palindrome_start = i - palindrome_length / 2;\n            }\n      \
    \  }\n        StringBuilder result = new StringBuilder(string);\n        for (int\
    \ i = max_palindrome_start - 1; i >= 0; i--) {\n            result.append(string.charAt(i));\n\
    \        }\n        return result.toString();\n", "        StringBuilder sb =\
    \ new StringBuilder(string);\n        int i = 0;\n        int j = string.length()\
    \ - 1;\n        while (i < j) {\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                i++;\n                j--;\n            } else {\n      \
    \          i = 0;\n                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(0,\
    \ string.length() - i));\n        return sb.toString();\n", "        int length\
    \ = string.length();\n        int i = length - 1;\n        while (i >= 0) {\n\
    \            if (isPalindrome(string, i)) {\n                break;\n        \
    \    }\n            i--;\n        }\n        String prefix = string.substring(0,\
    \ i + 1);\n        StringBuilder builder = new StringBuilder(prefix);\n      \
    \  builder.reverse();\n        return string + builder.toString();\n", "     \
    \   int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int[] z = new int[n];\n        int l = 0, r = 0;\n       \
    \ for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i]\
    \ = Math.min(r - i + 1, z[i - l]);\n            }\n            while (i + z[i]\
    \ < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n                z[i]++;\n\
    \            }\n            if (i + z[i] - 1 > r) {\n                l = i;\n\
    \                r = i + z[i] - 1;\n            }\n        }\n        int max_z\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + z[i] == n)\
    \ {\n                max_z = Math.max(max_z, z[i]);\n            }\n        }\n\
    \        StringBuilder builder = new StringBuilder();\n        for (int i = 0;\
    \ i < n - max_z; i++) {\n            builder.append(string.charAt(i));\n     \
    \   }\n        for (int i = n - 1; i >= max_z; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversedPrefix;\n",
  "        String result = string;\n        int length = string.length();\n      \
    \  for (int i = 0; i < length; i++) {\n            String prefix = string.substring(0,\
    \ length - i);\n            String suffix = string.substring(length - i);\n  \
    \          if (isPalindrome(suffix)) {\n                result = prefix + new\
    \ StringBuilder(prefix).reverse().toString();\n                break;\n      \
    \      }\n        }\n        return result;\n", "        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversedPrefix;\n",
  "        StringBuilder sb = new StringBuilder(string);\n        StringBuilder rev\
    \ = new StringBuilder(string).reverse();\n        int n = string.length();\n \
    \       int i = 0;\n        while (i < n) {\n            if (sb.substring(i).equals(rev.substring(0,\
    \ n - i))) {\n                break;\n            }\n            i++;\n      \
    \  }\n        return sb.append(rev.substring(n - i)).toString();\n", "       \
    \ int n = string.length();\n        StringBuilder sb = new StringBuilder(string);\n\
    \        for (int i = 0; i < n; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                sb.append(reverse(string.substring(0, i)));\n           \
    \     break;\n            }\n        }\n        return sb.toString();\n", "  \
    \      int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (z[i] == n - i && i > max) {\n                max = i;\n         \
    \   }\n        }\n        StringBuilder sb = new StringBuilder();\n        for\
    \ (int i = max; i < n; i++) {\n            sb.append(string.charAt(i));\n    \
    \    }\n        for (int i = 0; i < max; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int longest = 0;\n        for\
    \ (int i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n              \
    \  longest = Math.max(longest, z[i]);\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        sb.append(string);\n        for (int i =\
    \ n - longest - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();\n", "        if (string.isEmpty()) {\n\
    \            return string;\n        }\n        int length = string.length();\n\
    \        int[] z = new int[length];\n        int left = 0;\n        int right\
    \ = 0;\n        for (int i = 1; i < length; i++) {\n            if (i > right)\
    \ {\n                left = right = i;\n                while (right < length\
    \ && string.charAt(right) == string.charAt(right - left)) {\n                \
    \    right++;\n                }\n                z[i] = right - left;\n     \
    \           right--;\n            } else {\n                int k = i - left;\n\
    \                if (z[k] < right - i + 1) {\n                    z[i] = z[k];\n\
    \                } else {\n                    left = i;\n                   \
    \ while (right < length && string.charAt(right) == string.charAt(right - left))\
    \ {\n                        right++;\n                    }\n               \
    \     z[i] = right - left;\n                    right--;\n                }\n\
    \            }\n        }\n        int max = 0;\n        int maxIndex = 0;\n \
    \       for (int i = 0; i < length; i++) {\n            if (z[i] > max) {\n  \
    \              max = z[i];\n                maxIndex = i;\n            }\n   \
    \     }\n        StringBuilder builder = new StringBuilder();\n        for (int\
    \ i = maxIndex + max; i < length; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int longest = 0;\n        for (int i = 1; i < n; i++) {\n\
    \            if (z[i] == n - i && i > longest) {\n                longest = i;\n\
    \            }\n        }\n        StringBuilder sb = new StringBuilder();\n \
    \       for (int i = 0; i < n - longest; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.reverse();\n        sb.append(string);\n        return\
    \ sb.toString();\n", "        // >>> make_palindrome('')\n        // ''\n    \
    \    if (string.length() == 0) {\n            return string;\n        }\n    \
    \    // >>> make_palindrome('cat')\n        // 'catac'\n        // >>> make_palindrome('cata')\n\
    \        // 'catac'\n        int length = string.length();\n        int i = 0;\n\
    \        while (i < length) {\n            if (string.charAt(i) == string.charAt(length\
    \ - 1)) {\n                i++;\n                length--;\n            } else\
    \ {\n                break;\n            }\n        }\n        if (i == length)\
    \ {\n            return string;\n        }\n        String suffix = string.substring(i);\n\
    \        String prefix = string.substring(0, i);\n        StringBuilder builder\
    \ = new StringBuilder(prefix);\n        builder.reverse();\n        return string\
    \ + builder.toString();\n", "        int length = string.length();\n        if\
    \ (length == 0) {\n            return string;\n        }\n        int suffixLength\
    \ = 0;\n        for (int i = 0; i < length; i++) {\n            if (string.charAt(i)\
    \ == string.charAt(length - 1 - i)) {\n                suffixLength++;\n     \
    \       } else {\n                break;\n            }\n        }\n        StringBuilder\
    \ builder = new StringBuilder(string);\n        for (int i = 0; i < length - suffixLength;\
    \ i++) {\n            builder.append(string.charAt(length - 1 - i));\n       \
    \ }\n        return builder.toString();\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max_z = 0;\n        for\
    \ (int i = 1; i < n; i++) {\n            if (i + z[i] == n) {\n              \
    \  max_z = Math.max(max_z, z[i]);\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = 0; i < n - max_z; i++) {\n \
    \           sb.append(string.charAt(i));\n        }\n        for (int i = n -\
    \ 1; i >= max_z; i--) {\n            sb.append(string.charAt(i));\n        }\n\
    \        return sb.toString();\n", "        // >>> make_palindrome('')\n     \
    \   // ''\n        if (string.length() == 0) {\n            return string;\n \
    \       }\n        // >>> make_palindrome('cat')\n        // 'catac'\n       \
    \ // >>> make_palindrome('cata')\n        // 'catac'\n        // >>> make_palindrome('catac')\n\
    \        // 'catac'\n        // >>> make_palindrome('cataca')\n        // 'catacacat'\n\
    \        // >>> make_palindrome('catacacat')\n        // 'catacacat'\n       \
    \ // >>> make_palindrome('catacacatac')\n        // 'catacacatacacatac'\n    \
    \    // >>> make_palindrome('catacacatacacatac')\n        // 'catacacatacacatac'\n\
    \        // >>> make_palindrome('catacacatacacataca')\n        // 'catacacatacacatacacatacacat'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacat')\n        // 'catacacatacacatacacatacacat'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacatac')\n        // 'catacacatacacatacacatacacatacacatacacatacacatac'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacatacacatacacatacacatac')\n\
    \        // 'catacacatacacatacacatacacatacacatacacatacacatac'\n        // >>>\
    \ make_palindrome('catacacatacacatacacatacacatacacatacacatacacataca')\n      \
    \  // 'catacacatacacatacacatacacatacacatacacatacacatacacatacacatacacatacacatacacat'\n\
    \        // >>> make_palindrome('catacacatacacatacacatacacatacacatacacatacacatacacatacacatacac",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_palindrome_length = 0;\n        int max_palindrome_start = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int palindrome_length\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (string.charAt(i\
    \ - j) == string.charAt(i + j)) {\n                    palindrome_length = 2 *\
    \ j + 1;\n                } else {\n                    break;\n             \
    \   }\n            }\n            if (palindrome_length > max_palindrome_length)\
    \ {\n                max_palindrome_length = palindrome_length;\n            \
    \    max_palindrome_start = i - palindrome_length / 2;\n            }\n      \
    \  }\n        for (int i = 0; i < string.length() - 1; i++) {\n            int\
    \ palindrome_length = 0;\n            for (int j = 0; j <= i; j++) {\n       \
    \         if (string.charAt(i - j) == string.charAt(i + 1 + j)) {\n          \
    \          palindrome_length = 2 * j + 2;\n                } else {\n        \
    \            break;\n                }\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_start = i - palindrome_length / 2 + 1;\n     \
    \       }\n        }\n        StringBuilder builder = new StringBuilder();\n \
    \       builder.append(string);\n        for (int i = max_palindrome_start - 1;\
    \ i >= 0; i--) {\n            builder.append(string.charAt(i));\n        }\n \
    \       return builder.toString();\n", "        // >>> make_palindrome('')\n \
    \       // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - longestPalindromeSuffixLength)).reverse().toString();\n", "        int n =\
    \ string.length();\n        StringBuilder sb = new StringBuilder(string);\n  \
    \      for (int i = 0; i < n; i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                sb.append(new StringBuilder(string.substring(0, i)).reverse());\n\
    \                return sb.toString();\n            }\n        }\n        return\
    \ sb.toString();\n", "        int n = string.length();\n        int[] p = new\
    \ int[n];\n        for (int i = 1; i < n; i++) {\n            int j = p[i - 1];\n\
    \            while (j > 0 && string.charAt(i) != string.charAt(j)) {\n       \
    \         j = p[j - 1];\n            }\n            if (string.charAt(i) == string.charAt(j))\
    \ {\n                j++;\n            }\n            p[i] = j;\n        }\n \
    \       int prefix_length = n - p[n - 1];\n        StringBuilder sb = new StringBuilder(string);\n\
    \        for (int i = prefix_length - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();\n", "        StringBuilder sb = new\
    \ StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int n = string.length();\n        for (int i = 0; i < n; i++) {\n   \
    \         if (string.substring(i).equals(rev.substring(0, n - i))) {\n       \
    \         return sb.append(rev.substring(n - i)).toString();\n            }\n\
    \        }\n        return sb.append(rev.substring(1)).toString();\n", "     \
    \   if (string.length() == 0) {\n            return string;\n        }\n     \
    \   int i = string.length() - 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                break;\n            }\n            i--;\n        }\n    \
    \    return string + reverse(string.substring(0, i));\n", "        int length\
    \ = string.length();\n        if (length == 0) {\n            return string;\n\
    \        }\n        int[] z = new int[length];\n        int left = 0;\n      \
    \  int right = 0;\n        for (int i = 1; i < length; i++) {\n            if\
    \ (i > right) {\n                left = right = i;\n                while (right\
    \ < length && string.charAt(right) == string.charAt(right - left)) {\n       \
    \             right++;\n                }\n                z[i] = right - left;\n\
    \                right--;\n            } else {\n                int k = i - left;\n\
    \                if (z[k] < right - i + 1) {\n                    z[i] = z[k];\n\
    \                } else {\n                    left = i;\n                   \
    \ while (right < length && string.charAt(right) == string.charAt(right - left))\
    \ {\n                        right++;\n                    }\n               \
    \     z[i] = right - left;\n                    right--;\n                }\n\
    \            }\n        }\n        int palindromeLength = 0;\n        for (int\
    \ i = 1; i < length; i++) {\n            if (i + z[i] == length) {\n         \
    \       palindromeLength = z[i];\n                break;\n            }\n    \
    \    }\n        StringBuilder builder = new StringBuilder();\n        for (int\
    \ i = length - palindromeLength - 1; i >= 0; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        builder.append(string);\n        return builder.toString();\n",
  "        StringBuilder sb = new StringBuilder(string);\n        String reverse =\
    \ sb.reverse().toString();\n        StringBuilder result = new StringBuilder();\n\
    \        for (int i = 0; i < string.length(); i++) {\n            if (string.substring(i).equals(reverse.substring(0,\
    \ string.length() - i))) {\n                result.append(string.substring(0,\
    \ i));\n                result.append(reverse);\n                return result.toString();\n\
    \            }\n        }\n        return \"\";\n", "        int n = string.length();\n\
    \        int i = n - 1;\n        while (i >= 0) {\n            if (isPalindrome(string,\
    \ i)) {\n                break;\n            }\n            i--;\n        }\n\
    \        String prefix = string.substring(0, i + 1);\n        String suffix =\
    \ string.substring(i + 1);\n        return string + reverse(prefix);\n", "   \
    \     if (string.length() == 0) {\n            return string;\n        }\n   \
    \     int max_palindrome_length = 0;\n        int max_palindrome_start = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int palindrome_length\
    \ = 0;\n            int palindrome_start = i;\n            int j = i;\n      \
    \      int k = string.length() - 1;\n            while (j >= 0 && k >= 0 && string.charAt(j)\
    \ == string.charAt(k)) {\n                palindrome_length += 2;\n          \
    \      palindrome_start = j;\n                j--;\n                k--;\n   \
    \         }\n            if (palindrome_length > max_palindrome_length) {\n  \
    \              max_palindrome_length = palindrome_length;\n                max_palindrome_start\
    \ = palindrome_start;\n            }\n        }\n        StringBuilder sb = new\
    \ StringBuilder();\n        sb.append(string);\n        for (int i = max_palindrome_start\
    \ - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n        }\n \
    \       return sb.toString();\n", "        // >>> make_palindrome('')\n      \
    \  // ''\n        if (string.length() == 0) {\n            return string;\n  \
    \      }\n        // >>> make_palindrome('cat')\n        // 'catac'\n        //\
    \ >>> make_palindrome('cata')\n        // 'catac'\n        int length = string.length();\n\
    \        int i = length - 1;\n        while (i >= 0) {\n            if (string.charAt(i)\
    \ == string.charAt(0)) {\n                if (isPalindrome(string.substring(0,\
    \ i + 1))) {\n                    return string + reverse(string.substring(i +\
    \ 1));\n                }\n            }\n            i -= 1;\n        }\n   \
    \     return string + reverse(string.substring(1));\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int maxPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                maxPalindromeSuffixLength = string.length() - i;\n      \
    \          break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - maxPalindromeSuffixLength);\n        StringBuilder sb = new\
    \ StringBuilder(prefix);\n        sb.reverse();\n        return string + sb.toString();\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n    \
    \        if (z[i] == n - i) {\n                max = Math.max(max, z[i]);\n  \
    \          }\n        }\n        StringBuilder sb = new StringBuilder();\n   \
    \     for (int i = 0; i < n - max; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        for (int i = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;\n",
  "        int n = string.length();\n        int[] p = new int[n];\n        for (int\
    \ i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        int c = 0;\n\
    \        int r = 0;\n        for (int i = 1; i < n; i++) {\n            int i_mirror\
    \ = 2 * c - i;\n            if (r > i) {\n                p[i] = Math.min(r -\
    \ i, p[i_mirror]);\n            }\n            while (i + 1 + p[i] < n && i -\
    \ 1 - p[i] >= 0 && string.charAt(i + 1 + p[i]) == string.charAt(i - 1 - p[i]))\
    \ {\n                p[i]++;\n            }\n            if (i + p[i] > r) {\n\
    \                c = i;\n                r = i + p[i];\n            }\n      \
    \  }\n        int max_len = 0;\n        int center_index = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i + p[i] == n && p[i] > max_len) {\n \
    \               max_len = p[i];\n                center_index = i;\n         \
    \   }\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(string.substring(0,\
    \ center_index - max_len));\n        sb.reverse();\n        sb.append(string);\n\
    \        return sb.toString();\n", "        int n = string.length();\n       \
    \ if (n == 0) {\n            return string;\n        }\n        int i = n - 1;\n\
    \        while (i >= 0) {\n            if (string.charAt(i) == string.charAt(0))\
    \ {\n                int j = 0;\n                while (j < i) {\n           \
    \         if (string.charAt(j) != string.charAt(i - j)) {\n                  \
    \      break;\n                    }\n                    j += 1;\n          \
    \      }\n                if (j == i) {\n                    break;\n        \
    \        }\n            }\n            i -= 1;\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int j = i - 1; j >= 0; j -= 1) {\n \
    \           sb.append(string.charAt(j));\n        }\n        sb.append(string);\n\
    \        return sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();\n", "        // Write your code here\n\
    \        // To print results to the standard output you can use System.out.println()\n\
    \        // Example: System.out.println(\"Hello world!\");\n        int n = string.length();\n\
    \        int[] z = new int[n];\n        z[0] = n;\n        int l = 0, r = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            if (i > r) {\n           \
    \     l = r = i;\n                while (r < n && string.charAt(r - l) == string.charAt(r))\
    \ {\n                    r++;\n                }\n                z[i] = r - l;\n\
    \                r--;\n            } else {\n                int k = i - l;\n\
    \                if (z[k] < r - i + 1) {\n                    z[i] = z[k];\n \
    \               } else {\n                    l = i;\n                    while\
    \ (r < n && string.charAt(r - l) == string.charAt(r)) {\n                    \
    \    r++;\n                    }\n                    z[i] = r - l;\n        \
    \            r--;\n                }\n            }\n        }\n        int max\
    \ = 0;\n        for (int i = 0; i < n; i++) {\n            if (z[i] == i + 1)\
    \ {\n                max = i + 1;\n            }\n        }\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = max; i < n; i++) {\n       \
    \     sb.append(string.charAt(i));\n        }\n        sb.append(string);\n  \
    \      return sb.toString();\n", "        int n = string.length();\n        int[]\
    \ z = new int[n];\n        z[0] = 0;\n        for (int i = 1, l = 0, r = 0; i\
    \ < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r -\
    \ i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (z[i] == n - i) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder();\n        for (int i = max; i < n; i++) {\n          \
    \  builder.append(string.charAt(i));\n        }\n        builder.reverse();\n\
    \        builder.append(string);\n        return builder.toString();\n", "   \
    \     int len = string.length();\n        int i = 0;\n        int j = len - 1;\n\
    \        while (i < j) {\n            if (string.charAt(i) != string.charAt(j))\
    \ {\n                break;\n            }\n            i++;\n            j--;\n\
    \        }\n        if (i >= j) {\n            return string;\n        }\n   \
    \     StringBuilder sb = new StringBuilder(string);\n        for (int k = 0; k\
    \ < len - i; k++) {\n            sb.append(string.charAt(len - k - 1));\n    \
    \    }\n        return sb.toString();\n", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int max_palindrome_length = 0;\n\
    \        int max_palindrome_start = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindrome_length = 0;\n            int palindrome_start\
    \ = i;\n            int j = i;\n            int k = i;\n            while (j >=\
    \ 0 && k < string.length() && string.charAt(j) == string.charAt(k)) {\n      \
    \          palindrome_length += 2;\n                palindrome_start = j;\n  \
    \              j--;\n                k++;\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_start = palindrome_start;\n            }\n   \
    \         palindrome_length = 1;\n            palindrome_start = i;\n        \
    \    j = i - 1;\n            k = i + 1;\n            while (j >= 0 && k < string.length()\
    \ && string.charAt(j) == string.charAt(k)) {\n                palindrome_length\
    \ += 2;\n                palindrome_start = j;\n                j--;\n       \
    \         k++;\n            }\n            if (palindrome_length > max_palindrome_length)\
    \ {\n                max_palindrome_length = palindrome_length;\n            \
    \    max_palindrome_start = palindrome_start;\n            }\n        }\n    \
    \    StringBuilder sb = new StringBuilder();\n        sb.append(string.substring(0,\
    \ max_palindrome_start));\n        sb.append(string.substring(max_palindrome_start\
    \ + max_palindrome_length));\n        sb.reverse();\n        sb.append(string);\n\
    \        return sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        return sb.append(sb.reverse().substring(string.length()\
    \ - i)).toString();\n", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int max = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            for (int j = i; j < string.length(); j++) {\n          \
    \      if (isPalindrome(string.substring(i, j + 1))) {\n                    max\
    \ = Math.max(max, j - i + 1);\n                }\n            }\n        }\n \
    \       StringBuilder builder = new StringBuilder(string);\n        builder.append(new\
    \ StringBuilder(string.substring(0, string.length() - max)).reverse());\n    \
    \    return builder.toString();\n", "        int n = string.length();\n      \
    \  int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i]\
    \ = 0;\n        }\n        int c = 0;\n        int r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            int mirror = 2 * c - i;\n            if (i <\
    \ r) {\n                p[i] = Math.min(r - i, p[mirror]);\n            }\n  \
    \          while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && string.charAt(i + 1\
    \ + p[i]) == string.charAt(i - 1 - p[i])) {\n                p[i]++;\n       \
    \     }\n            if (i + p[i] > r) {\n                c = i;\n           \
    \     r = i + p[i];\n            }\n        }\n        int max_len = 0;\n    \
    \    int center_index = 0;\n        for (int i = 1; i < n; i++) {\n          \
    \  if (i - p[i] == 0) {\n                if (p[i] > max_len) {\n             \
    \       max_len = p[i];\n                    center_index = i;\n             \
    \   }\n            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string.substring(max_len));\n        builder.reverse();\n\
    \        builder.append(string);\n        return builder.toString();\n", "   \
    \     if (string.length() == 0) {\n            return string;\n        }\n   \
    \     int max_length = 0;\n        int max_index = 0;\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            int length = 0;\n            int left\
    \ = i;\n            int right = i;\n            while (left >= 0 && right < string.length()\
    \ && string.charAt(left) == string.charAt(right)) {\n                length =\
    \ right - left + 1;\n                left--;\n                right++;\n     \
    \       }\n            if (length > max_length) {\n                max_length\
    \ = length;\n                max_index = left + 1;\n            }\n          \
    \  length = 0;\n            left = i;\n            right = i + 1;\n          \
    \  while (left >= 0 && right < string.length() && string.charAt(left) == string.charAt(right))\
    \ {\n                length = right - left + 1;\n                left--;\n   \
    \             right++;\n            }\n            if (length > max_length) {\n\
    \                max_length = length;\n                max_index = left + 1;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string.substring(max_index + max_length));\n        builder.reverse();\n\
    \        builder.append(string);\n        return builder.toString();\n", "   \
    \     // >>> make_palindrome('')\n        // ''\n        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        // >>> make_palindrome('cat')\n\
    \        // 'catac'\n        // >>> make_palindrome('cata')\n        // 'catac'\n\
    \        // >>> make_palindrome('cataa')\n        // 'cataacat'\n        // >>>\
    \ make_palindrome('cataaa')\n        // 'cataaacat'\n        // >>> make_palindrome('catac')\n\
    \        // 'catac'\n        // >>> make_palindrome('cataca')\n        // 'catacacat'\n\
    \        // >>> make_palindrome('catacaa')\n        // 'catacaa'\n        // >>>\
    \ make_palindrome('catacaaa')\n        // 'catacaaacat'\n        // >>> make_palindrome('catacaaaa')\n\
    \        // 'catacaaaacat'\n        // >>> make_palindrome('catacaaaaa')\n   \
    \     // 'catacaaaaacat'\n        // >>> make_palindrome('catacaaaaaa')\n    \
    \    // 'catacaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaa')\n   \
    \     // 'catacaaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaaa')\n\
    \        // 'catacaaaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaaaa')\n\
    \        // 'catacaaaaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaaaaa')\n\
    \        // 'catacaaaaaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaaaaaa')\n\
    \        // 'catacaaaaaaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaaaaaaa')\n\
    \        // 'catacaaaaaaaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaaaaaaaa')\n\
    \        // 'catacaaaaaaaaaaaaacat'\n        // >>> make_palindrome('catacaaaaaaaaaaaaaa')\n\
    \        // 'catacaaaaaaaaaaaaaacat'\n        // >>> make", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int[] z\
    \ = new int[n];\n        z[0] = 0;\n        int l = 0;\n        int r = 0;\n \
    \       for (int i = 1; i < n; i++) {\n            if (i > r) {\n            \
    \    l = r = i;\n                while (r < n && string.charAt(r) == string.charAt(r\
    \ - l)) {\n                    r++;\n                }\n                z[i] =\
    \ r - l;\n                r--;\n            } else {\n                int k =\
    \ i - l;\n                if (z[k] < r - i + 1) {\n                    z[i] =\
    \ z[k];\n                } else {\n                    l = i;\n              \
    \      while (r < n && string.charAt(r) == string.charAt(r - l)) {\n         \
    \               r++;\n                    }\n                    z[i] = r - l;\n\
    \                    r--;\n                }\n            }\n        }\n     \
    \   int max = 0;\n        int maxIndex = 0;\n        for (int i = 0; i < n; i++)\
    \ {\n            if (z[i] > max) {\n                max = z[i];\n            \
    \    maxIndex = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < n - max; i++) {\n            sb.append(string.charAt(n\
    \ - i - 1));\n        }\n        sb.append(string);\n        return sb.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_suffix_length = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   max_suffix_length = string.length() - i;\n                break;\n       \
    \     }\n        }\n        StringBuilder builder = new StringBuilder(string);\n\
    \        for (int i = 0; i < string.length() - max_suffix_length; i++) {\n   \
    \         builder.append(string.charAt(string.length() - max_suffix_length - i\
    \ - 1));\n        }\n        return builder.toString();\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int max_palindrome_length\
    \ = 0;\n        int max_palindrome_start = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindrome_length = 0;\n            int palindrome_start\
    \ = 0;\n            for (int j = 0; j < string.length() - i; j++) {\n        \
    \        if (string.charAt(i + j) == string.charAt(string.length() - 1 - j)) {\n\
    \                    palindrome_length++;\n                    palindrome_start\
    \ = i;\n                } else {\n                    break;\n               \
    \ }\n            }\n            if (palindrome_length > max_palindrome_length)\
    \ {\n                max_palindrome_length = palindrome_length;\n            \
    \    max_palindrome_start = palindrome_start;\n            }\n        }\n    \
    \    StringBuilder result = new StringBuilder(string);\n        for (int i = 0;\
    \ i < string.length() - max_palindrome_length; i++) {\n            result.append(string.charAt(max_palindrome_start\
    \ + i));\n        }\n        return result.toString();\n", "        int n = string.length();\n\
    \        if (n == 0) {\n            return string;\n        }\n        int[] z\
    \ = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i\
    \ - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();\n", "        StringBuilder builder = new\
    \ StringBuilder(string);\n        StringBuilder reverse = new StringBuilder(string).reverse();\n\
    \        int index = 0;\n        while (index < string.length()) {\n         \
    \   if (builder.toString().equals(reverse.toString())) {\n                break;\n\
    \            }\n            builder.append(reverse.charAt(index));\n         \
    \   index += 1;\n        }\n        return builder.toString();\n", "        int\
    \ n = string.length();\n        int[] z = new int[n];\n        int l = 0, r =\
    \ 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n     \
    \           z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n           \
    \ while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i])) {\n \
    \               z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n\
    \                l = i;\n                r = i + z[i] - 1;\n            }\n  \
    \      }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n      \
    \      if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n    \
    \        }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = 0; i < n - max; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        for (int i = n - 1; i >= max; i--) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        // >>> make_palindrome('catt')\n\
    \        // 'cattac'\n        // >>> make_palindrome('catta')\n        // 'cattaac'\n\
    \        // >>> make_palindrome('cattac')\n        // 'cattac'\n        // >>>\
    \ make_palindrome('cattaca')\n        // 'cattacaac'\n        // >>> make_palindrome('cattacac')\n\
    \        // 'cattacac'\n        // >>> make_palindrome('cattacaca')\n        //\
    \ 'cattacacaac'\n        // >>> make_palindrome('cattacacac')\n        // 'cattacacac'\n\
    \        // >>> make_palindrome('cattacacaca')\n        // 'cattacacacaac'\n \
    \       // >>> make_palindrome('cattacacacac')\n        // 'cattacacacac'\n  \
    \      // >>> make_palindrome('cattacacacaca')\n        // 'cattacacacacaac'\n\
    \        // >>> make_palindrome('cattacacacacac')\n        // 'cattacacacacac'\n\
    \        // >>> make_palindrome('cattacacacacaca')\n        // 'cattacacacacacaac'\n\
    \        // >>> make_palindrome('cattacacacacacac')\n        // 'cattacacacacacac'\n\
    \        // >>> make_palindrome('cattacacacacacaca')\n        // 'cattacacacacacacaac'\n\
    \        // >>> make_palindrome('cattacacacacacacac')\n        // 'cattacacacacacacac'\n\
    \        // >>> make_palindrome('cattacacacacacacaca')\n        // 'cattacacacacac",
  "        int n = string.length();\n        int[] z = new int[n];\n        for (int\
    \ i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n              \
    \  z[i] = Math.min(r - i + 1, z[i - l]);\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; ++i)\n\
    \            if (z[i] == n - i)\n                max = i;\n        return string\
    \ + new StringBuilder(string.substring(0, n - max)).reverse().toString();\n",
  "        int n = string.length();\n        int[] p = new int[n];\n        for (int\
    \ i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        int center =\
    \ 0;\n        int right = 0;\n        for (int i = 1; i < n; i++) {\n        \
    \    int mirror = 2 * center - i;\n            if (right > i) {\n            \
    \    p[i] = Math.min(right - i, p[mirror]);\n            }\n            while\
    \ (i + p[i] + 1 < n && i - p[i] - 1 >= 0 && string.charAt(i + p[i] + 1) == string.charAt(i\
    \ - p[i] - 1)) {\n                p[i]++;\n            }\n            if (i +\
    \ p[i] > right) {\n                center = i;\n                right = i + p[i];\n\
    \            }\n        }\n        int max_len = 0;\n        int center_index\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i - p[i] == 0)\
    \ {\n                if (p[i] > max_len) {\n                    max_len = p[i];\n\
    \                    center_index = i;\n                }\n            }\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ center_index + max_len + 1; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int n = string.length();\n        int[] p = new int[n];\n        int c\
    \ = 0;\n        int r = 0;\n        for (int i = 1; i < n; i++) {\n          \
    \  int mirror = 2 * c - i;\n            if (i < r) {\n                p[i] = Math.min(r\
    \ - i, p[mirror]);\n            }\n            while (i + 1 + p[i] < n && i -\
    \ 1 - p[i] >= 0 && string.charAt(i + 1 + p[i]) == string.charAt(i - 1 - p[i]))\
    \ {\n                p[i]++;\n            }\n            if (i + p[i] > r) {\n\
    \                c = i;\n                r = i + p[i];\n            }\n      \
    \  }\n        int max_len = 0;\n        int center_index = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i - p[i] == 0) {\n                if (p[i]\
    \ > max_len) {\n                    max_len = p[i];\n                    center_index\
    \ = i;\n                }\n            }\n        }\n        StringBuilder sb\
    \ = new StringBuilder();\n        for (int i = center_index + max_len; i < n;\
    \ i++) {\n            sb.append(string.charAt(i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();\n", "        int n = string.length();\n       \
    \ int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i]\
    \ = 0;\n        }\n        for (int i = 1; i < n; i++) {\n            int j =\
    \ p[i - 1];\n            while (j > 0 && string.charAt(i) != string.charAt(j))\
    \ {\n                j = p[j - 1];\n            }\n            if (string.charAt(i)\
    \ == string.charAt(j)) {\n                j++;\n            }\n            p[i]\
    \ = j;\n        }\n        int suffix_length = p[n - 1];\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (int i = 0; i < n - suffix_length; i++)\
    \ {\n            sb.append(string.charAt(i));\n        }\n        sb.reverse();\n\
    \        sb.append(string);\n        return sb.toString();\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        return string + reverse(prefix);\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_palindrome_suffix_length = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   max_palindrome_suffix_length = string.length() - i;\n                break;\n\
    \            }\n        }\n        String prefix = string.substring(0, string.length()\
    \ - max_palindrome_suffix_length);\n        StringBuilder sb = new StringBuilder(prefix);\n\
    \        sb.reverse();\n        return string + sb.toString();\n", "        if\
    \ (string.length() == 0) {\n            return string;\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string);\n        int i = string.length() - 1;\n    \
    \    while (i >= 0) {\n            if (isPalindrome(string.substring(i))) {\n\
    \                break;\n            }\n            i--;\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i - 1));\n        return sb.toString();\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        int length = string.length();\n\
    \        int i = length - 1;\n        while (i >= 0) {\n            if (isPalindrome(string,\
    \ i)) {\n                break;\n            }\n            i--;\n        }\n\
    \        String prefix = string.substring(0, i + 1);\n        StringBuilder sb\
    \ = new StringBuilder(prefix);\n        sb.reverse();\n        return string +\
    \ sb.toString();\n", "        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = 0;\n        int j = string.length() - 1;\n        while (i <\
    \ j) {\n            if (string.charAt(i) == string.charAt(j)) {\n            \
    \    i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                j--;\n            }\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i));\n        return sb.toString();\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        // >>> make_palindrome('cataa')\n\
    \        // 'cataacat'\n        // >>> make_palindrome('catac')\n        // 'catac'\n\
    \        // >>> make_palindrome('cataca')\n        // 'catacacat'\n        //\
    \ >>> make_palindrome('catacat')\n        // 'catacat'\n        // >>> make_palindrome('catacata')\n\
    \        // 'catacatacat'\n        // >>> make_palindrome('catacatac')\n     \
    \   // 'catacatac'\n        // >>> make_palindrome('catacataca')\n        // 'catacatacacat'\n\
    \        // >>> make_palindrome('catacatacat')\n        // 'catacatacat'\n   \
    \     // >>> make_palindrome('catacatacata')\n        // 'catacatacatacat'\n \
    \       // >>> make_palindrome('catacatacatac')\n        // 'catacatacatac'\n\
    \        // >>> make_palindrome('catacatacataca')\n        // 'catacatacatacacat'\n\
    \        // >>> make_palindrome('catacatacatacat')\n        // 'catacatacatacat'\n\
    \        // >>> make_palindrome('catacatacatacata')\n        // 'catacatacatacatacat'\n\
    \        // >>> make_palindrome('catacatacatacatac')\n        // 'catacatacatacatac'\n\
    \        // >>> make_palindrome('catacatacatacataca')\n        // 'catacatacatacatacacat'\n\
    \        // >>> make_palindrome('catacatacatacatacat')\n        // 'catacatacatacatacat'\n\
    \       ", "        if (string.length() == 0) {\n            return string;\n\
    \        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffixLength);\n\
    \        return string + reverse(prefix);\n", "        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        String reversePrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversePrefix;\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_length = 0;\n        int max_index = 0;\n        for (int i = 0;\
    \ i < string.length(); i++) {\n            int length = 0;\n            for (int\
    \ j = 0; j < string.length() - i; j++) {\n                if (string.charAt(i\
    \ + j) == string.charAt(string.length() - 1 - j)) {\n                    length++;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if (length > max_length) {\n                max_length\
    \ = length;\n                max_index = i;\n            }\n        }\n      \
    \  StringBuilder builder = new StringBuilder();\n        builder.append(string.substring(0,\
    \ max_index));\n        builder.append(string.substring(max_index + max_length));\n\
    \        builder.reverse();\n        builder.append(string);\n        return builder.toString();\n",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int[] z = new int[n];\n        z[0] = 0;\n        int l =\
    \ 0;\n        int r = 0;\n        for (int i = 1; i < n; i++) {\n            if\
    \ (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n        \
    \    }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max_z = 0;\n        int max_z_index = 0;\n\
    \        for (int i = 0; i < n; i++) {\n            if (z[i] > max_z) {\n    \
    \            max_z = z[i];\n                max_z_index = i;\n            }\n\
    \        }\n        StringBuilder sb = new StringBuilder();\n        for (int\
    \ i = max_z_index - max_z + 1; i < max_z_index; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i > r) {\n                l = r = i;\n                while (r < n\
    \ && string.charAt(r - l) == string.charAt(r)) {\n                    r++;\n \
    \               }\n                z[i] = r - l;\n                r--;\n     \
    \       } else {\n                int k = i - l;\n                if (z[k] < r\
    \ - i + 1) {\n                    z[i] = z[k];\n                } else {\n   \
    \                 l = i;\n                    while (r < n && string.charAt(r\
    \ - l) == string.charAt(r)) {\n                        r++;\n                \
    \    }\n                    z[i] = r - l;\n                    r--;\n        \
    \        }\n            }\n        }\n        int max_z = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (z[i] == i) {\n                max_z =\
    \ i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = max_z; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_palindrome_length = 0;\n        int max_palindrome_start = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int palindrome_length\
    \ = 0;\n            int palindrome_start = i;\n            for (int j = 0; j <\
    \ string.length() - i; j++) {\n                if (string.charAt(i + j) == string.charAt(string.length()\
    \ - 1 - j)) {\n                    palindrome_length++;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if (palindrome_length > max_palindrome_length) {\n                max_palindrome_length\
    \ = palindrome_length;\n                max_palindrome_start = palindrome_start;\n\
    \            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        builder.append(string);\n        for (int i = 0; i < string.length()\
    \ - max_palindrome_length; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();\n", "        StringBuilder builder\
    \ = new StringBuilder(string);\n        int length = string.length();\n      \
    \  int i = 0;\n        while (i < length) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                builder.append(new StringBuilder(string.substring(0, i)).reverse());\n\
    \                break;\n            }\n            i++;\n        }\n        return\
    \ builder.toString();\n", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int longestPalindromeSuffix = longestPalindromeSuffix(string);\n\
    \        String prefix = string.substring(0, string.length() - longestPalindromeSuffix);\n\
    \        String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversedPrefix;\n", "        if (string.length() == 0)\
    \ {\n            return string;\n        }\n        int i = string.length() -\
    \ 1;\n        while (i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                break;\n            }\n            i--;\n        }\n    \
    \    String prefix = string.substring(0, i);\n        StringBuilder sb = new StringBuilder(prefix);\n\
    \        sb.reverse();\n        return string + sb.toString();\n", "        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder rev = new StringBuilder(string).reverse();\n\
    \        int n = string.length();\n        int i = 0;\n        while (i < n) {\n\
    \            if (sb.substring(i).equals(rev.substring(0, n - i))) {\n        \
    \        break;\n            }\n            i++;\n        }\n        return sb.append(rev.substring(n\
    \ - i)).toString();\n", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int[] z = zFunction(string);\n        int maxPalindromeSuffix\
    \ = 0;\n        for (int i = 1; i < z.length; i++) {\n            if (z[i] ==\
    \ i) {\n                maxPalindromeSuffix = i;\n            }\n        }\n \
    \       String prefix = string.substring(0, string.length() - maxPalindromeSuffix);\n\
    \        StringBuilder sb = new StringBuilder();\n        sb.append(string);\n\
    \        sb.append(reverse(prefix));\n        return sb.toString();\n", "    \
    \    if (string.length() == 0) {\n            return string;\n        }\n    \
    \    int longestPalindromeSuffixLength = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffixLength = string.length() - i;\n                break;\n\
    \            }\n        }\n        String prefix = string.substring(0, string.length()\
    \ - longestPalindromeSuffixLength);\n        StringBuilder sb = new StringBuilder(prefix);\n\
    \        sb.reverse();\n        return string + sb.toString();\n", "        if\
    \ (string.length() == 0) {\n            return string;\n        }\n        int\
    \ palindromeEnd = string.length();\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   palindromeEnd = i;\n                break;\n            }\n        }\n   \
    \     StringBuilder builder = new StringBuilder(string);\n        builder.append(new\
    \ StringBuilder(string.substring(0, palindromeEnd)).reverse());\n        return\
    \ builder.toString();\n", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int max_palindrome_length = 0;\n        int max_palindrome_start\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            int palindrome_length\
    \ = 0;\n            int palindrome_start = 0;\n            for (int j = 0; j <\
    \ string.length() - i; j++) {\n                if (string.charAt(i + j) == string.charAt(string.length()\
    \ - 1 - j)) {\n                    palindrome_length++;\n                    palindrome_start\
    \ = i;\n                } else {\n                    break;\n               \
    \ }\n            }\n            if (palindrome_length > max_palindrome_length)\
    \ {\n                max_palindrome_length = palindrome_length;\n            \
    \    max_palindrome_start = palindrome_start;\n            }\n        }\n    \
    \    String prefix = string.substring(0, max_palindrome_start);\n        StringBuilder\
    \ sb = new StringBuilder(prefix);\n        sb.reverse();\n        return string\
    \ + sb.toString();\n", "        // >>> make_palindrome('')\n        // ''\n  \
    \      if (string.length() == 0) {\n            return string;\n        }\n  \
    \      // >>> make_palindrome('cat')\n        // 'catac'\n        // >>> make_palindrome('cata')\n\
    \        // 'catac'\n        int suffix_length = longestPalindromicSuffix(string);\n\
    \        String prefix = string.substring(0, string.length() - suffix_length);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(prefix));\n\
    \        return builder.toString();\n", "        if (string.length() == 0) {\n\
    \            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = longestPalindromeSuffixLength(string);\n        String prefix = string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength);\n        return string + reverse(prefix);\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ n;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (z[i] == i) {\n                max = i;\n            }\n \
    \       }\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = n - 1; i >= max; i--) {\n            sb.append(string.charAt(i));\n      \
    \  }\n        return string + sb.toString();\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        int longestPalindromeSuffix\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffix = i;\n            }\n        }\n\
    \        return string + reverse(string.substring(0, string.length() - longestPalindromeSuffix));\n",
  "        int n = string.length();\n        if (n == 0) {\n            return string;\n\
    \        }\n        int i = 0;\n        int j = n - 1;\n        while (i < j)\
    \ {\n            if (string.charAt(i) != string.charAt(j)) {\n               \
    \ break;\n            }\n            i++;\n            j--;\n        }\n     \
    \   if (i >= j) {\n            return string;\n        }\n        String prefix\
    \ = string.substring(0, i);\n        String suffix = string.substring(i);\n  \
    \      String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return suffix + reversedPrefix + suffix;\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n                max\
    \ = Math.max(max, z[i]);\n            }\n        }\n        StringBuilder sb =\
    \ new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--) {\n   \
    \         sb.append(string.charAt(i));\n        }\n        sb.append(string);\n\
    \        return sb.toString();\n", "        if (string.length() == 0) {\n    \
    \        return string;\n        }\n        int palindromeSuffixLength = 0;\n\
    \        for (int i = string.length() - 1; i >= 0; i--) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeSuffixLength = string.length() - i;\n         \
    \       break;\n            }\n        }\n        StringBuilder sb = new StringBuilder(string);\n\
    \        sb.append(reverse(string.substring(0, string.length() - palindromeSuffixLength)));\n\
    \        return sb.toString();\n", "        if (string.length() == 0) {\n    \
    \        return string;\n        }\n        StringBuilder sb = new StringBuilder(string);\n\
    \        int i = string.length() - 1;\n        while (i >= 0) {\n            if\
    \ (isPalindrome(string.substring(i))) {\n                break;\n            }\n\
    \            i--;\n        }\n        sb.append(sb.reverse().substring(string.length()\
    \ - i - 1));\n        return sb.toString();\n", "        int length = string.length();\n\
    \        int i = length - 1;\n        while (i >= 0) {\n            if (isPalindrome(string,\
    \ i)) {\n                break;\n            }\n            i--;\n        }\n\
    \        String prefix = string.substring(0, i + 1);\n        String reversedPrefix\
    \ = new StringBuilder(prefix).reverse().toString();\n        return string + reversedPrefix;\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (i + z[i] == n) {\n                max = Math.max(max, z[i]);\n  \
    \          }\n        }\n        StringBuilder sb = new StringBuilder();\n   \
    \     for (int i = n - max - 1; i >= 0; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      int n = string.length();\n        int[] z = new int[n];\n        z[0] =\
    \ 0;\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n     \
    \       if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int longestPalindromeSuffix = z[n - 1];\n     \
    \   String prefix = string.substring(0, n - longestPalindromeSuffix);\n      \
    \  String suffix = new StringBuilder(prefix).reverse().toString();\n        return\
    \ string + suffix;\n", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int max_length = 0;\n        int max_index = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int length =\
    \ 0;\n            int j = i;\n            int k = string.length() - 1;\n     \
    \       while (j < k) {\n                if (string.charAt(j) == string.charAt(k))\
    \ {\n                    length++;\n                    j++;\n               \
    \     k--;\n                } else {\n                    break;\n           \
    \     }\n            }\n            if (length > max_length) {\n             \
    \   max_length = length;\n                max_index = i;\n            }\n    \
    \    }\n        StringBuilder builder = new StringBuilder();\n        builder.append(string.substring(0,\
    \ max_index));\n        builder.append(string.substring(max_index + max_length));\n\
    \        builder.reverse();\n        builder.append(string);\n        return builder.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int longestPalindromeSuffix = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string.substring(i))) {\n             \
    \   longestPalindromeSuffix = i;\n            }\n        }\n        return string\
    \ + reverse(string.substring(0, string.length() - longestPalindromeSuffix));\n",
  "        int n = string.length();\n        int[] p = new int[n];\n        for (int\
    \ i = 0; i < n; i++) {\n            p[i] = 0;\n        }\n        int center =\
    \ 0;\n        int right = 0;\n        for (int i = 1; i < n; i++) {\n        \
    \    int mirror = 2 * center - i;\n            if (right > i) {\n            \
    \    p[i] = Math.min(right - i, p[mirror]);\n            }\n            while\
    \ (i + p[i] + 1 < n && i - p[i] - 1 >= 0 && string.charAt(i + p[i] + 1) == string.charAt(i\
    \ - p[i] - 1)) {\n                p[i]++;\n            }\n            if (i +\
    \ p[i] > right) {\n                center = i;\n                right = i + p[i];\n\
    \            }\n        }\n        int max_len = 0;\n        int center_index\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i - p[i] == 0)\
    \ {\n                if (p[i] > max_len) {\n                    max_len = p[i];\n\
    \                    center_index = i;\n                }\n            }\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        for (int i =\
    \ center_index + max_len + 1; i < n; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (z[i] == n - i && z[i] > max) {\n                max = z[i];\n   \
    \         }\n        }\n        return string + new StringBuilder(string.substring(0,\
    \ n - max)).reverse().toString();\n", "        int n = string.length();\n    \
    \    if (n == 0) {\n            return string;\n        }\n        int[] z = new\
    \ int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n\
    \            if (i <= r) {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n\
    \            }\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i])) {\n                z[i]++;\n            }\n            if (i + z[i]\
    \ - 1 > r) {\n                l = i;\n                r = i + z[i] - 1;\n    \
    \        }\n        }\n        int max_i = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            if (z[i] == i) {\n                max_i = i;\n         \
    \   }\n        }\n        StringBuilder sb = new StringBuilder();\n        for\
    \ (int i = n - 1; i >= max_i; i--) {\n            sb.append(string.charAt(i));\n\
    \        }\n        sb.append(string);\n        return sb.toString();\n", "  \
    \      if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int longestPalindromeSuffix = longestPalindromeSuffix(string);\n      \
    \  String prefix = string.substring(0, string.length() - longestPalindromeSuffix);\n\
    \        String reversePrefix = new StringBuilder(prefix).reverse().toString();\n\
    \        return string + reversePrefix;\n", "        // >>> make_palindrome('')\n\
    \        // ''\n        if (string.length() == 0) {\n            return string;\n\
    \        }\n        // >>> make_palindrome('cat')\n        // 'catac'\n      \
    \  // >>> make_palindrome('cata')\n        // 'catac'\n        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return string + new StringBuilder(string.substring(0, string.length()\
    \ - longestPalindromeSuffixLength)).reverse().toString();\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int max_palindrome_length\
    \ = 0;\n        int max_palindrome_start = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int palindrome_length = 0;\n            int palindrome_start\
    \ = i;\n            for (int j = 0; j < string.length() - i; j++) {\n        \
    \        if (string.charAt(i + j) == string.charAt(string.length() - 1 - j)) {\n\
    \                    palindrome_length++;\n                } else {\n        \
    \            break;\n                }\n            }\n            if (palindrome_length\
    \ > max_palindrome_length) {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_start = palindrome_start;\n            }\n   \
    \     }\n        String prefix = string.substring(0, max_palindrome_start);\n\
    \        StringBuilder sb = new StringBuilder(prefix);\n        sb.reverse();\n\
    \        return string + sb.toString();\n", "        int n = string.length();\n\
    \        int[] p = new int[n];\n        int c = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            int i_mirror = 2 * c - i;\n            p[i]\
    \ = (r > i) ? Math.min(r - i, p[i_mirror]) : 0;\n            while (i + 1 + p[i]\
    \ < n && i - 1 - p[i] >= 0 && string.charAt(i + 1 + p[i]) == string.charAt(i -\
    \ 1 - p[i])) {\n                p[i]++;\n            }\n            if (i + p[i]\
    \ > r) {\n                c = i;\n                r = i + p[i];\n            }\n\
    \        }\n        int max_len = 0;\n        int center_index = 0;\n        for\
    \ (int i = 1; i < n; i++) {\n            if (i - p[i] == 0) {\n              \
    \  if (p[i] > max_len) {\n                    max_len = p[i];\n              \
    \      center_index = i;\n                }\n            }\n        }\n      \
    \  String prefix = string.substring(0, center_index - max_len);\n        StringBuilder\
    \ sb = new StringBuilder(prefix);\n        sb.reverse();\n        return string\
    \ + sb.toString();\n", "        if (string.length() == 0) {\n            return\
    \ string;\n        }\n        int longestPalindromeSuffixLength = longestPalindromeSuffixLength(string);\n\
    \        StringBuilder builder = new StringBuilder(string);\n        builder.append(reverse(string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength)));\n        return builder.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int palindromeEnd = string.length();\n        for (int i = string.length()\
    \ - 1; i >= 0; i--) {\n            if (string.charAt(i) == string.charAt(palindromeEnd\
    \ - 1)) {\n                palindromeEnd--;\n            }\n        }\n      \
    \  StringBuilder sb = new StringBuilder(string);\n        for (int i = 0; i <\
    \ string.length() - palindromeEnd; i++) {\n            sb.append(string.charAt(i));\n\
    \        }\n        return sb.toString();\n", "        if (string.length() ==\
    \ 0) {\n            return string;\n        }\n        int longestPalindromeSuffixLength\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffixLength = string.length() - i;\n  \
    \              break;\n            }\n        }\n        return string + reverse(string.substring(0,\
    \ string.length() - longestPalindromeSuffixLength));\n", "        int length =\
    \ string.length();\n        int[] z = new int[length];\n        z[0] = 0;\n  \
    \      int left = 0;\n        int right = 0;\n        for (int i = 1; i < length;\
    \ i++) {\n            if (i > right) {\n                left = right = i;\n  \
    \              while (right < length && string.charAt(right) == string.charAt(right\
    \ - left)) {\n                    right++;\n                }\n              \
    \  z[i] = right - left;\n                right--;\n            } else {\n    \
    \            int k = i - left;\n                if (z[k] < right - i + 1) {\n\
    \                    z[i] = z[k];\n                } else {\n                \
    \    left = i;\n                    while (right < length && string.charAt(right)\
    \ == string.charAt(right - left)) {\n                        right++;\n      \
    \              }\n                    z[i] = right - left;\n                 \
    \   right--;\n                }\n            }\n        }\n        int max = 0;\n\
    \        int maxIndex = 0;\n        for (int i = 0; i < length; i++) {\n     \
    \       if (z[i] > max) {\n                max = z[i];\n                maxIndex\
    \ = i;\n            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = maxIndex - max + 1; i < maxIndex + 1; i++) {\n         \
    \   builder.append(string.charAt(i));\n        }\n        builder.append(string);\n\
    \        return builder.toString();\n", "        int n = string.length();\n  \
    \      int i = 0;\n        while (i < n / 2 && string.charAt(i) == string.charAt(n\
    \ - i - 1)) {\n            i++;\n        }\n        if (i == n / 2) {\n      \
    \      return string;\n        }\n        StringBuilder sb = new StringBuilder(string.substring(i));\n\
    \        sb.reverse();\n        return string + sb.toString();\n", "        int\
    \ n = string.length();\n        int[] z = new int[n];\n        z[0] = 0;\n   \
    \     int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if\
    \ (i > r) {\n                l = r = i;\n                while (r < n && string.charAt(r\
    \ - l) == string.charAt(r)) {\n                    r++;\n                }\n \
    \               z[i] = r - l;\n                r--;\n            } else {\n  \
    \              int k = i - l;\n                if (z[k] < r - i + 1) {\n     \
    \               z[i] = z[k];\n                } else {\n                    l\
    \ = i;\n                    while (r < n && string.charAt(r - l) == string.charAt(r))\
    \ {\n                        r++;\n                    }\n                   \
    \ z[i] = r - l;\n                    r--;\n                }\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (z[i] == i) {\n                max = i;\n            }\n        }\n\
    \        StringBuilder sb = new StringBuilder();\n        for (int i = max + 1;\
    \ i < n; i++) {\n            sb.append(string.charAt(i));\n        }\n       \
    \ sb.append(string);\n        return sb.toString();\n", "        String reversed\
    \ = new StringBuilder(string).reverse().toString();\n        String palindrome\
    \ = string + reversed;\n        for (int i = 0; i < string.length(); i++) {\n\
    \            String prefix = string.substring(0, i);\n            String postfix\
    \ = string.substring(i);\n            if (postfix.equals(reversed.substring(0,\
    \ postfix.length()))) {\n                return prefix + palindrome;\n       \
    \     }\n        }\n        return palindrome;\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int longestPalindromeSuffix\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindromeSuffix = i;\n            }\n        }\n\
    \        return string + new StringBuilder(string.substring(0, longestPalindromeSuffix)).reverse().toString();\n",
  "        int length = string.length();\n        for (int i = length; i >= 0; i--)\
    \ {\n            if (isPalindrome(string.substring(i))) {\n                return\
    \ string + new StringBuilder(string.substring(0, i)).reverse().toString();\n \
    \           }\n        }\n        return string;\n", "        int n = string.length();\n\
    \        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n       \
    \     if (string.charAt(i) != string.charAt(j)) {\n                break;\n  \
    \          }\n            i++;\n            j--;\n        }\n        if (i >=\
    \ j) {\n            return string;\n        }\n        String suffix = string.substring(i);\n\
    \        String prefix = string.substring(0, i);\n        StringBuilder sb = new\
    \ StringBuilder(suffix);\n        sb.reverse();\n        return prefix + sb.toString()\
    \ + suffix;\n", "        StringBuilder sb = new StringBuilder(string);\n     \
    \   int n = string.length();\n        int i = n - 1;\n        while (i >= 0) {\n\
    \            if (isPalindrome(string.substring(i))) {\n                break;\n\
    \            }\n            i--;\n        }\n        sb.append(sb.substring(0,\
    \ n - i - 1).reverse());\n        return sb.toString();\n", "        if (string.length()\
    \ == 0) {\n            return string;\n        }\n        int max_suffix_length\
    \ = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                max_suffix_length = string.length() - i;\n              \
    \  break;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - max_suffix_length);\n        StringBuilder sb = new StringBuilder(prefix);\n\
    \        sb.reverse();\n        return string + sb.toString();\n", "        if\
    \ (string.length() == 0) {\n            return string;\n        }\n        StringBuilder\
    \ sb = new StringBuilder(string);\n        StringBuilder sb2 = new StringBuilder(string);\n\
    \        sb2.reverse();\n        StringBuilder sb3 = new StringBuilder();\n  \
    \      int i = 0;\n        while (i < sb.length() && sb.charAt(i) == sb2.charAt(i))\
    \ {\n            sb3.append(sb.charAt(i));\n            i++;\n        }\n    \
    \    sb3.reverse();\n        sb.append(sb3);\n        return sb.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int max_palindrome_length = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (isPalindrome(string, i)) {\n                max_palindrome_length\
    \ = i + 1;\n            }\n        }\n        String prefix = string.substring(0,\
    \ string.length() - max_palindrome_length);\n        StringBuilder builder = new\
    \ StringBuilder(string);\n        builder.append(reverse(prefix));\n        return\
    \ builder.toString();\n", "        int n = string.length();\n        int[] z =\
    \ new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            if (i <= r)\n                z[i] = Math.min(r - i + 1, z[i -\
    \ l]);\n            while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i\
    \ + z[i]))\n                z[i]++;\n            if (i + z[i] - 1 > r) {\n   \
    \             l = i;\n                r = i + z[i] - 1;\n            }\n     \
    \   }\n        int max = 0;\n        for (int i = 1; i < n; i++)\n           \
    \ if (z[i] == n - i)\n                max = Math.max(max, z[i]);\n        StringBuilder\
    \ builder = new StringBuilder();\n        for (int i = n - max - 1; i >= 0; i--)\n\
    \            builder.append(string.charAt(i));\n        return string + builder.toString();\n",
  "        if (string.length() == 0) {\n            return string;\n        }\n  \
    \      int maxPalindromeLength = 0;\n        int maxPalindromeCenter = 0;\n  \
    \      for (int i = 0; i < string.length(); i++) {\n            int palindromeLength\
    \ = 0;\n            int palindromeCenter = i;\n            while (palindromeCenter\
    \ - palindromeLength >= 0 && palindromeCenter + palindromeLength < string.length())\
    \ {\n                if (string.charAt(palindromeCenter - palindromeLength) ==\
    \ string.charAt(palindromeCenter + palindromeLength)) {\n                    palindromeLength++;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if (palindromeLength > maxPalindromeLength) {\n     \
    \           maxPalindromeLength = palindromeLength;\n                maxPalindromeCenter\
    \ = palindromeCenter;\n            }\n        }\n        StringBuilder builder\
    \ = new StringBuilder(string);\n        for (int i = maxPalindromeCenter - maxPalindromeLength\
    \ + 1; i < maxPalindromeCenter; i++) {\n            builder.append(string.charAt(i));\n\
    \        }\n        return builder.toString();\n", "        StringBuilder sb =\
    \ new StringBuilder(string);\n        int palindromeEnd = string.length();\n \
    \       for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                palindromeEnd = i;\n                break;\n            }\n\
    \        }\n        for (int i = 0; i < palindromeEnd; i++) {\n            sb.append(string.charAt(palindromeEnd\
    \ - i - 1));\n        }\n        return sb.toString();\n", "        int n = string.length();\n\
    \        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && string.charAt(z[i])\
    \ == string.charAt(i + z[i])) {\n                z[i]++;\n            }\n    \
    \        if (i + z[i] - 1 > r) {\n                l = i;\n                r =\
    \ i + z[i] - 1;\n            }\n        }\n        int longestPalindromeSuffix\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (i + z[i] == n)\
    \ {\n                longestPalindromeSuffix = Math.max(longestPalindromeSuffix,\
    \ z[i]);\n            }\n        }\n        StringBuilder builder = new StringBuilder();\n\
    \        for (int i = n - longestPalindromeSuffix - 1; i >= 0; i--) {\n      \
    \      builder.append(string.charAt(i));\n        }\n        builder.append(string);\n\
    \        return builder.toString();\n", "        int n = string.length();\n  \
    \      int i = 0;\n        int j = n - 1;\n        int k = 0;\n        while (i\
    \ < j) {\n            if (string.charAt(i) == string.charAt(j)) {\n          \
    \      i++;\n                j--;\n            } else {\n                i = 0;\n\
    \                k++;\n                j = n - 1 - k;\n            }\n       \
    \ }\n        return string + new StringBuilder(string.substring(0, n - k)).reverse().toString();\n",
  "        int n = string.length();\n        int[] z = new int[n];\n        int l\
    \ = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && string.charAt(z[i]) == string.charAt(i + z[i]))\
    \ {\n                z[i]++;\n            }\n            if (i + z[i] - 1 > r)\
    \ {\n                l = i;\n                r = i + z[i] - 1;\n            }\n\
    \        }\n        int max = 0;\n        for (int i = 1; i < n; i++) {\n    \
    \        if (z[i] == n - i && i > max) {\n                max = i;\n         \
    \   }\n        }\n        return string + new StringBuilder(string.substring(0,\
    \ max)).reverse().toString();\n"]
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- "    }\n}"
- "    }\n\n"
