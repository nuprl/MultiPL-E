name: HumanEval_119_match_parens
language: java
results:
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"No\";\n        } else if (count1 < 0 && count2 > 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpzrlnd7d_.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int cnt = 0;\n        for (String s : lst) {\n            for (int i\
    \ = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n   \
    \                 cnt++;\n                } else {\n                    cnt--;\n\
    \                }\n                if (cnt < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return cnt ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpuwe9b1dy.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa15vm0xx.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp046cw_qh.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmptq1jm4ll.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmptvqwqp12.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpiy46_h8e.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 < 0 || c2 < 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 == c2) {\n            return \"Yes\";\n        }\n  \
    \      return \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp4t1ale9b.java:52)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ n1 = s1.length();\n        int n2 = s2.length();\n        int c1 = 0;\n    \
    \    int c2 = 0;\n        for (int i = 0; i < n1; i++) {\n            if (s1.charAt(i)\
    \ == '(') {\n                c1++;\n            } else {\n                c1--;\n\
    \            }\n        }\n        for (int i = 0; i < n2; i++) {\n          \
    \  if (s2.charAt(i) == '(') {\n                c2++;\n            } else {\n \
    \               c2--;\n            }\n        }\n        if (c1 == 0 && c2 ==\
    \ 0) {\n            return \"Yes\";\n        }\n        if (c1 == 0 && c2 != 0)\
    \ {\n            return \"No\";\n        }\n        if (c1 != 0 && c2 == 0) {\n\
    \            return \"No\";\n        }\n        if (c1 > 0 && c2 < 0) {\n    \
    \        return \"No\";\n        }\n        if (c1 < 0 && c2 > 0) {\n        \
    \    return \"No\";\n        }\n        if (c1 > 0 && c2 > 0) {\n            if\
    \ (c1 == c2) {\n                return \"Yes\";\n            } else {\n      \
    \          return \"No\";\n            }\n        }\n        if (c1 < 0 && c2\
    \ < 0) {\n            if (c1 == c2) {\n                return \"Yes\";\n     \
    \       } else {\n                return \"No\";\n            }\n        }\n \
    \       return \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpy3dn7g2m.java:74)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpr67m8jxp.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpswilb3l6.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprjqa1ggo.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 ==\
    \ count2) {\n                return \"Yes\";\n            } else {\n         \
    \       return \"No\";\n            }\n        }\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp12csogyn.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 != 0) {\n            return \"No\";\n\
    \        }\n        if (c1 != 0 && c2 == 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n      \
    \  }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n        }\n\
    \        if (c1 < 0 && c2 > 0) {\n            if (c1 * -1 > c2) {\n          \
    \      return \"No\";\n            }\n        }\n        if (c1 > 0 && c2 < 0)\
    \ {\n            if (c2 * -1 > c1) {\n                return \"No\";\n       \
    \     }\n        }\n        return \"Yes\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp7_3dyvj7.java:77)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmphao_gjs8.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqghjq61k.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp7qdcgkbw.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int n = lst.size();\n        int[] open = new int[n];\n        int[]\
    \ close = new int[n];\n        for (int i = 0; i < n; i++) {\n            String\
    \ s = lst.get(i);\n            for (int j = 0; j < s.length(); j++) {\n      \
    \          if (s.charAt(j) == '(') {\n                    open[i]++;\n       \
    \         } else {\n                    close[i]++;\n                }\n     \
    \       }\n        }\n        int totalOpen = 0;\n        int totalClose = 0;\n\
    \        for (int i = 0; i < n; i++) {\n            totalOpen += open[i];\n  \
    \          totalClose += close[i];\n        }\n        if (totalOpen != totalClose)\
    \ {\n            return \"No\";\n        }\n        int[] dp = new int[totalOpen\
    \ + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j\
    \ <= totalOpen; j++) {\n                if (j >= open[i]) {\n                \
    \    dp[j] = Math.max(dp[j], dp[j - open[i]] + close[i]);\n                }\n\
    \            }\n        }\n        return dp[totalOpen] == totalOpen ? \"Yes\"\
    \ : \"No\";\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpt6djidfy.java:58)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n     \
    \           if (c == '(') {\n                    count++;\n                } else\
    \ {\n                    count--;\n                }\n                if (count\
    \ < 0) {\n                    return \"No\";\n                }\n            }\n\
    \        }\n        return count == 0 ? \"Yes\" : \"No\";\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpd6f8w1c5.java:42)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmptiytd9eb.java:52)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqr3f7wip.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Write your code here\n        // To print results to the standard\
    \ output you can use System.out.println()\n        // Example: System.out.println(\"\
    Hello world!\");\n        return \"\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqid38woh.java:28)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int balance = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                balance++;\n\
    \            } else {\n                balance--;\n            }\n           \
    \ if (balance < 0) {\n                return \"No\";\n            }\n        }\n\
    \        return balance == 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpj8lfa055.java:42)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int a = 0;\n        int b = 0;\n        for (String s : lst) {\n    \
    \        for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    a++;\n                } else {\n            \
    \        a--;\n                }\n            }\n        }\n        for (String\
    \ s : lst) {\n            for (int i = 0; i < s.length(); i++) {\n           \
    \     if (s.charAt(i) == ')') {\n                    b++;\n                } else\
    \ {\n                    b--;\n                }\n            }\n        }\n \
    \       if (a == 0 && b == 0) {\n            return \"Yes\";\n        } else {\n\
    \            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpycyd706u.java:58)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 ==\
    \ count2) {\n                return \"Yes\";\n            } else {\n         \
    \       return \"No\";\n            }\n        }\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp1k0ry7qk.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpx2u19uds.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        if\
    \ (open == close) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpebwhn7rv.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        if\
    \ (open == close) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpgxofux6a.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 < 0) {\n            return \"Yes\";\n\
    \        }\n        if (c1 > 0 && c2 == 0) {\n            return \"Yes\";\n  \
    \      }\n        if (c1 < 0 && c2 == 0) {\n            return \"Yes\";\n    \
    \    }\n        if (c1 < 0 && c2 < 0) {\n            if (c1 + c2 == 0) {\n   \
    \             return \"Yes\";\n            }\n        }\n        if (c1 > 0 &&\
    \ c2 > 0) {\n            if (c1 + c2 == 0) {\n                return \"Yes\";\n\
    \            }\n        }\n        return \"No\";\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcfuakaok.java:65)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxx5r3kdc.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 > 0 && c2 < 0) {\n            return \"Yes\";\n \
    \       }\n        if (c1 < 0 && c2 > 0) {\n            return \"Yes\";\n    \
    \    }\n        return \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmps6z2akxr.java:54)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpzqi0adab.java:68)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int n = lst.size();\n        int[] open = new int[n];\n        int[]\
    \ close = new int[n];\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < lst.get(i).length(); j++) {\n                if (lst.get(i).charAt(j)\
    \ == '(') {\n                    open[i]++;\n                } else {\n      \
    \              close[i]++;\n                }\n            }\n        }\n    \
    \    int o = 0;\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n \
    \           o += open[i];\n            c += close[i];\n        }\n        if (o\
    \ == c) {\n            return \"Yes\";\n        }\n        return \"No\";\n\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpzws2mcwn.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close && s2_open\
    \ == s2_close + 1) {\n            return \"Yes\";\n        }\n        if (s1_open\
    \ == s1_close + 1 && s2_open == s2_close) {\n            return \"Yes\";\n   \
    \     }\n        return \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0qsg5_xj.java:54)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfcogby4u.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close && s2_open\
    \ != s2_close) {\n            if (s2_open > s2_close) {\n                return\
    \ \"Yes\";\n            } else {\n                return \"No\";\n           \
    \ }\n        }\n        if (s1_open != s1_close && s2_open == s2_close) {\n  \
    \          if (s1_open > s1_close) {\n                return \"Yes\";\n      \
    \      } else {\n                return \"No\";\n            }\n        }\n  \
    \      if (s1_open > s1_close && s2_open > s2_close) {\n            return \"\
    Yes\";\n        }\n        return \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmphlfnjqic.java:65)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ cnt1 = 0;\n        int cnt2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                cnt1++;\n       \
    \     } else {\n                cnt1--;\n            }\n        }\n        for\
    \ (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n\
    \                cnt2++;\n            } else {\n                cnt2--;\n    \
    \        }\n        }\n        if (cnt1 == 0 && cnt2 == 0) {\n            return\
    \ \"Yes\";\n        }\n        if (cnt1 == 0 && cnt2 != 0) {\n            if (cnt2\
    \ > 0) {\n                return \"No\";\n            }\n            for (int\
    \ i = 0; i < s1.length(); i++) {\n                if (s1.charAt(i) == '(') {\n\
    \                    cnt2++;\n                } else {\n                    cnt2--;\n\
    \                }\n                if (cnt2 == 0) {\n                    return\
    \ \"Yes\";\n                }\n            }\n            return \"No\";\n   \
    \     }\n        if (cnt1 != 0 && cnt2 == 0) {\n            if (cnt1 < 0) {\n\
    \                return \"No\";\n            }\n            for (int i = 0; i\
    \ < s2.length(); i++) {\n                if (s2.charAt(i) == '(') {\n        \
    \            cnt1++;\n                } else {\n                    cnt1--;\n\
    \                }\n                if (cnt1 == 0) {\n                    return\
    \ \"Yes\";\n                }\n            }\n            return \"No\";\n   \
    \     }\n        if (cnt1 < 0 && cnt2 > 0) {\n            return \"No\";\n   \
    \     }\n        if (cnt1 > 0 && cnt2 < 0) {\n            return \"No\";\n   \
    \     }\n        if (cnt1 < 0 && cnt2 < 0) {\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplmcuzc3x.java:83: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 != 0) {\n            return \"No\";\n\
    \        }\n        if (c1 != 0 && c2 == 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n      \
    \  }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n        }\n\
    \        if (c1 > 0 && c2 < 0) {\n            if (c1 == -c2) {\n             \
    \   return \"Yes\";\n            } else {\n                return \"No\";\n  \
    \          }\n        }\n        if (c1 < 0 && c2 > 0) {\n            if (c2 ==\
    \ -c1) {\n                return \"Yes\";\n            } else {\n            \
    \    return \"No\";\n            }\n        }\n        return \"No\";\n\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpk6hkx2oy.java:81)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s = lst.get(0) + lst.get(1);\n        int count = 0;\n       \
    \ for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\
    \ {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n        return count == 0 ? \"Yes\" : \"No\";\n\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8jxfnwka.java:40)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpe7d_0iep.java:68)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpc_lkkv0t.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpslvhzlko.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqbrv3sjv.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // TODO: Implement this method\n        return \"\";\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxs9b8ga4.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3er3lvwe.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s = lst.get(0) + lst.get(1);\n        int count = 0;\n       \
    \ for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\
    \ {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n        return count == 0 ? \"Yes\" : \"No\";\n\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwww3dsq0.java:40)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close && s2_open\
    \ > s2_close) {\n            return \"Yes\";\n        }\n        if (s1_open >\
    \ s1_close && s2_open == s2_close) {\n            return \"Yes\";\n        }\n\
    \        if (s1_open > s1_close && s2_open > s2_close) {\n            return \"\
    Yes\";\n        }\n        return \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpzumnsm7v.java:57)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int n = lst.size();\n        int[] open = new int[n];\n        int[]\
    \ close = new int[n];\n        for (int i = 0; i < n; i++) {\n            String\
    \ s = lst.get(i);\n            for (int j = 0; j < s.length(); j++) {\n      \
    \          if (s.charAt(j) == '(') {\n                    open[i]++;\n       \
    \         } else {\n                    close[i]++;\n                }\n     \
    \       }\n        }\n        int o = 0;\n        int c = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            o += open[i];\n            c += close[i];\n\
    \            if (c > o) {\n                return \"No\";\n            }\n   \
    \     }\n        return \"Yes\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0tkg2u3k.java:50)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwlin0xr4.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Write your code here\n        return \"\";\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0lhvquwa.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // TODO: Implement this function\n        return \"\";\n\n    }\n   \
    \ public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmp9o9xh1.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s = \"\";\n        for (String str : lst) {\n            s +=\
    \ str;\n        }\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        return\
    \ count == 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplfj6v0zl.java:43)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // TODO: Implement this function\n        return \"\";\n\n    }\n   \
    \ public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjb_68e0h.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpvpemavju.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int n = s.length();\n        int count = 0;\n        for\
    \ (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '(') {\n         \
    \       count++;\n            } else {\n                count--;\n           \
    \ }\n            if (count < 0) {\n                return \"No\";\n          \
    \  }\n        }\n        if (count == 0) {\n            return \"Yes\";\n    \
    \    } else {\n            return \"No\";\n        }\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpkrtykf6c.java:47)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2fg14szb.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n      \
    \  }\n        return \"Yes\";\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfvvj8uq5.java:54)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 > 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_1ixql_t.java:57)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyckebp9b.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        return\
    \ open == close ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8wshoqiu.java:45)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ n1 = s1.length();\n        int n2 = s2.length();\n        int n = n1 + n2;\n\
    \        int[] a = new int[n];\n        for (int i = 0; i < n1; i++) {\n     \
    \       if (s1.charAt(i) == '(') {\n                a[i] = 1;\n            } else\
    \ {\n                a[i] = -1;\n            }\n        }\n        for (int i\
    \ = 0; i < n2; i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  a[n1 + i] = 1;\n            } else {\n                a[n1 + i] = -1;\n   \
    \         }\n        }\n        int[] b = new int[n];\n        b[0] = a[0];\n\
    \        for (int i = 1; i < n; i++) {\n            b[i] = b[i - 1] + a[i];\n\
    \        }\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++)\
    \ {\n            c[i] = b[i] + n;\n        }\n        int[] d = new int[2 * n];\n\
    \        for (int i = 0; i < n; i++) {\n            d[c[i]]++;\n        }\n  \
    \      for (int i = 0; i < 2 * n; i++) {\n            if (d[i] > 1) {\n      \
    \          return \"Yes\";\n            }\n        }\n        return \"No\";\n\
    \n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpvldvcywf.java:65)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppw4998w6.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 ==\
    \ count2) {\n                return \"Yes\";\n            } else {\n         \
    \       return \"No\";\n            }\n        }\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpelayt1_3.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ n1 = s1.length();\n        int n2 = s2.length();\n        int c1 = 0;\n    \
    \    int c2 = 0;\n        for (int i = 0; i < n1; i++) {\n            if (s1.charAt(i)\
    \ == '(') {\n                c1++;\n            } else {\n                c1--;\n\
    \            }\n        }\n        for (int i = 0; i < n2; i++) {\n          \
    \  if (s2.charAt(i) == '(') {\n                c2++;\n            } else {\n \
    \               c2--;\n            }\n        }\n        if (c1 == 0 && c2 ==\
    \ 0) {\n            return \"Yes\";\n        }\n        if (c1 == 0 && c2 != 0)\
    \ {\n            return \"No\";\n        }\n        if (c1 != 0 && c2 == 0) {\n\
    \            return \"No\";\n        }\n        if (c1 > 0 && c2 < 0) {\n    \
    \        return \"No\";\n        }\n        if (c1 < 0 && c2 > 0) {\n        \
    \    return \"No\";\n        }\n        if (c1 > 0 && c2 > 0) {\n            return\
    \ \"Yes\";\n        }\n        if (c1 < 0 && c2 < 0) {\n            return \"\
    Yes\";\n        }\n        return \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa9g9nipy.java:66)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyq2h3frv.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6ft94tph.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        if\
    \ (open == close) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpr2p4omhl.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close && s2_open\
    \ < s2_close) {\n            return \"No\";\n        }\n        if (s1_open <\
    \ s1_close && s2_open == s2_close) {\n            return \"No\";\n        }\n\
    \        if (s1_open < s1_close && s2_open < s2_close) {\n            return \"\
    No\";\n        }\n        if (s1_open > s1_close && s2_open > s2_close) {\n  \
    \          return \"No\";\n        }\n        return \"Yes\";\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9gomb0d6.java:62)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s = \"\";\n        for (String str : lst) {\n            s +=\
    \ str;\n        }\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        return\
    \ count == 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpw0all8z8.java:43)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpgm9r6rt8.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        return\
    \ open == close ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpsc369tqo.java:45)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int cnt = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                cnt++;\n    \
    \        } else {\n                cnt--;\n            }\n            if (cnt\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (cnt == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_nj3yq52.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int l = 0;\n        int r = 0;\n        for (String s : lst) {\n    \
    \        for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    l++;\n                } else {\n            \
    \        r++;\n                }\n            }\n        }\n        if (l == r)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp1oxcvvq8.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfm_w4qff.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n      \
    \  }\n        if (c1 > 0 && c2 < 0) {\n            if (c1 == -c2) {\n        \
    \        return \"Yes\";\n            }\n            return \"No\";\n        }\n\
    \        if (c1 < 0 && c2 > 0) {\n            if (c2 == -c1) {\n             \
    \   return \"Yes\";\n            }\n            return \"No\";\n        }\n  \
    \      return \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpp3h768s8.java:73)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 != 0) {\n            if (c2 > 0) {\n \
    \               return \"No\";\n            }\n            for (int i = 0; i <\
    \ s1.length(); i++) {\n                if (s1.charAt(i) == '(') {\n          \
    \          c2++;\n                } else {\n                    c2--;\n      \
    \          }\n                if (c2 == 0) {\n                    return \"Yes\"\
    ;\n                }\n            }\n            return \"No\";\n        }\n \
    \       if (c1 != 0 && c2 == 0) {\n            if (c1 > 0) {\n               \
    \ return \"No\";\n            }\n            for (int i = 0; i < s2.length();\
    \ i++) {\n                if (s2.charAt(i) == '(') {\n                    c1++;\n\
    \                } else {\n                    c1--;\n                }\n    \
    \            if (c1 == 0) {\n                    return \"Yes\";\n           \
    \     }\n            }\n            return \"No\";\n        }\n        if (c1\
    \ > 0 && c2 > 0) {\n            return \"No\";\n        }\n        if (c1 < 0\
    \ && c2 < 0) {\n            return \"No\";\n        }\n        if (c1 < 0 && c2\
    \ > 0) {\n            if (c1 + c2 > 0) {\n                return \"No\";\n   \
    \         }\n            for (int\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbi64cuy8.java:84: error: not a statement\n            for (int\n\
    \                 ^\n/tmp/tmpbi64cuy8.java:84: error: ';' expected\n         \
    \   for (int\n                    ^\n/tmp/tmpbi64cuy8.java:85: error: illegal\
    \ start of expression\n    }\n    ^\n/tmp/tmpbi64cuy8.java:86: error: illegal\
    \ start of expression\n    public static void main(String[] args) {\n    ^\n4\
    \ errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Write your code here\n        // To print results to the standard\
    \ output you can use System.out.println()\n        // Example: System.out.println(\"\
    Hello world!\");\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n\
    \        int c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                c1++;\n    \
    \        } else {\n                c1--;\n            }\n        }\n        for\
    \ (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n\
    \                c2++;\n            } else {\n                c2--;\n        \
    \    }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        } else if (c1 == 0 && c2 < 0) {\n            return \"Yes\";\n    \
    \    } else if (c1 > 0 && c2 == 0) {\n            return \"Yes\";\n        } else\
    \ if (c1 > 0 && c2 < 0) {\n            return \"Yes\";\n        } else {\n   \
    \         return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjm3pd3c_.java:58)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open + s2_open == s1_close + s2_close) {\n\
    \            return \"Yes\";\n        } else {\n            return \"No\";\n \
    \       }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpc2kzvfxw.java:58)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpat24wjvi.java:68)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3) || isGood(s4))\
    \ {\n            return \"Yes\";\n        }\n        return \"No\";\n\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplp9zy0sz.java:25: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmplp9zy0sz.java:25: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0d72fozj.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"No\";\n        } else if (count1 > 0 && count2 > 0)\
    \ {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpf9vyz9tw.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        if (lst.size() != 2) {\n            throw new IllegalArgumentException(\"\
    lst must have 2 elements\");\n        }\n        String s1 = lst.get(0);\n   \
    \     String s2 = lst.get(1);\n        if (s1.length() == 0 && s2.length() ==\
    \ 0) {\n            return \"Yes\";\n        }\n        if (s1.length() == 0)\
    \ {\n            return matchParens(s2);\n        }\n        if (s2.length() ==\
    \ 0) {\n            return matchParens(s1);\n        }\n        String s1_tail\
    \ = s1.substring(1);\n        String s2_tail = s2.substring(1);\n        if (s1.charAt(0)\
    \ == '(') {\n            if (s2.charAt(0) == '(') {\n                return matchParens(s1_tail,\
    \ s2);\n            } else {\n                return matchParens(s1, s2_tail);\n\
    \            }\n        } else {\n            if (s2.charAt(0) == '(') {\n   \
    \             return matchParens(s1, s2_tail);\n            } else {\n       \
    \         return matchParens(s1_tail, s2_tail);\n            }\n        }\n\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeu84xlbb.java:30: error: incompatible types: String cannot be converted\
    \ to ArrayList<String>\n            return matchParens(s2);\n                \
    \               ^\n/tmp/tmpeu84xlbb.java:33: error: incompatible types: String\
    \ cannot be converted to ArrayList<String>\n            return matchParens(s1);\n\
    \                               ^\n/tmp/tmpeu84xlbb.java:39: error: method matchParens\
    \ in class Problem cannot be applied to given types;\n                return matchParens(s1_tail,\
    \ s2);\n                       ^\n  required: ArrayList<String>\n  found:    String,String\n\
    \  reason: actual and formal argument lists differ in length\n/tmp/tmpeu84xlbb.java:41:\
    \ error: method matchParens in class Problem cannot be applied to given types;\n\
    \                return matchParens(s1, s2_tail);\n                       ^\n\
    \  required: ArrayList<String>\n  found:    String,String\n  reason: actual and\
    \ formal argument lists differ in length\n/tmp/tmpeu84xlbb.java:45: error: method\
    \ matchParens in class Problem cannot be applied to given types;\n           \
    \     return matchParens(s1, s2_tail);\n                       ^\n  required:\
    \ ArrayList<String>\n  found:    String,String\n  reason: actual and formal argument\
    \ lists differ in length\n/tmp/tmpeu84xlbb.java:47: error: method matchParens\
    \ in class Problem cannot be applied to given types;\n                return matchParens(s1_tail,\
    \ s2_tail);\n                       ^\n  required: ArrayList<String>\n  found:\
    \    String,String\n  reason: actual and formal argument lists differ in length\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n6 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s = lst.get(0) + lst.get(1);\n        int c = 0;\n        for\
    \ (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n\
    \                c++;\n            } else {\n                c--;\n          \
    \  }\n            if (c < 0) {\n                return \"No\";\n            }\n\
    \        }\n        return c == 0 ? \"Yes\" : \"No\";\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfw7y10hp.java:40)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        Stack<Character> stack = new Stack<Character>();\n   \
    \     for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\
    \            if (c == '(') {\n                stack.push(c);\n            } else\
    \ {\n                if (stack.isEmpty()) {\n                    return \"No\"\
    ;\n                } else {\n                    stack.pop();\n              \
    \  }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"\
    No\";\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3s9ufi05.java:44)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            if (count2 > 0) {\n                return \"No\";\n      \
    \      } else {\n                return \"Yes\";\n            }\n        } else\
    \ if (count1 != 0 && count2 == 0) {\n            if (count1 > 0) {\n         \
    \       return \"Yes\";\n            } else {\n                return \"No\";\n\
    \            }\n        } else {\n            if (count1 > 0 && count2 > 0) {\n\
    \                return \"No\";\n            } else if (count1 < 0 && count2 <\
    \ 0) {\n                return \"No\";\n            } else {\n               \
    \ return \"Yes\";\n            }\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9wodac18.java:67)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa2yanmlp.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxg6vd2tc.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpod4v2wdt.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ cnt = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if (s1.charAt(i)\
    \ == '(') {\n                cnt++;\n            } else {\n                cnt--;\n\
    \            }\n        }\n        for (int i = 0; i < s2.length(); i++) {\n \
    \           if (s2.charAt(i) == '(') {\n                cnt++;\n            }\
    \ else {\n                cnt--;\n            }\n        }\n        if (cnt ==\
    \ 0) {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpp70eufg6.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int n = lst.size();\n        if (n == 0) return \"Yes\";\n        int[]\
    \ cnt = new int[n];\n        for (int i = 0; i < n; i++) {\n            String\
    \ s = lst.get(i);\n            for (int j = 0; j < s.length(); j++) {\n      \
    \          if (s.charAt(j) == '(') cnt[i]++;\n                else cnt[i]--;\n\
    \            }\n        }\n        int sum = 0;\n        for (int i = 0; i < n;\
    \ i++) {\n            sum += cnt[i];\n            if (sum < 0) return \"No\";\n\
    \        }\n        return \"Yes\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplgqcfqad.java:43)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpif2dt3wk.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyh08txzo.java:52)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ cnt1 = 0;\n        int cnt2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                cnt1++;\n       \
    \     } else {\n                cnt1--;\n            }\n        }\n        for\
    \ (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n\
    \                cnt2++;\n            } else {\n                cnt2--;\n    \
    \        }\n        }\n        if (cnt1 == 0 && cnt2 == 0) {\n            return\
    \ \"Yes\";\n        }\n        if (cnt1 < 0 && cnt2 < 0) {\n            return\
    \ \"No\";\n        }\n        if (cnt1 < 0 && cnt2 > 0) {\n            return\
    \ \"Yes\";\n        }\n        if (cnt1 > 0 && cnt2 < 0) {\n            return\
    \ \"Yes\";\n        }\n        return \"No\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmphj5yzlpe.java:57)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpluc4uf63.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpx9ddt0te.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwtxaadnx.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpot0do1mt.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpudp35e4z.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9s48mpia.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 > 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp87mdb8ev.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        if (lst.size() != 2) {\n            throw new IllegalArgumentException(\"\
    lst must have exactly 2 elements\");\n        }\n        String s1 = lst.get(0);\n\
    \        String s2 = lst.get(1);\n        if (s1.length() == 0) {\n          \
    \  return isGood(s2) ? \"Yes\" : \"No\";\n        }\n        if (s2.length() ==\
    \ 0) {\n            return isGood(s1) ? \"Yes\" : \"No\";\n        }\n       \
    \ return isGood(s1 + s2) || isGood(s2 + s1) ? \"Yes\" : \"No\";\n\n    }\n   \
    \ public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv5pcf2zw.java:27: error: cannot find symbol\n            return\
    \ isGood(s2) ? \"Yes\" : \"No\";\n                   ^\n  symbol:   method isGood(String)\n\
    \  location: class Problem\n/tmp/tmpv5pcf2zw.java:30: error: cannot find symbol\n\
    \            return isGood(s1) ? \"Yes\" : \"No\";\n                   ^\n  symbol:\
    \   method isGood(String)\n  location: class Problem\n/tmp/tmpv5pcf2zw.java:32:\
    \ error: cannot find symbol\n        return isGood(s1 + s2) || isGood(s2 + s1)\
    \ ? \"Yes\" : \"No\";\n               ^\n  symbol:   method isGood(String)\n \
    \ location: class Problem\n/tmp/tmpv5pcf2zw.java:32: error: cannot find symbol\n\
    \        return isGood(s1 + s2) || isGood(s2 + s1) ? \"Yes\" : \"No\";\n     \
    \                             ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n4 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (char c : s.toCharArray()) {\n                if (c == '(') {\n\
    \                    open++;\n                } else {\n                    close++;\n\
    \                }\n            }\n        }\n        if (open == close) {\n \
    \           return \"Yes\";\n        }\n        return \"No\";\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpspfsk2uu.java:48)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 >\
    \ 0 && count2 > 0) {\n                return \"No\";\n            } else if (count1\
    \ < 0 && count2 < 0) {\n                return \"No\";\n            } else {\n\
    \                return \"Yes\";\n            }\n        }\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpgb7gq8o7.java:59)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        if\
    \ (open == close) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp89avpn0c.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 +\
    \ count2 == 0) {\n                return \"Yes\";\n            } else {\n    \
    \            return \"No\";\n            }\n        }\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpm2153z9r.java:64)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // TODO: Implement this function\n        return \"\";\n\n    }\n   \
    \ public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5n64ibk7.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmps8pc9h29.java:68)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpvqm2iwd6.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        return \"\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpt9uwe278.java:25)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close && s2_open\
    \ < s2_close) {\n            return \"No\";\n        }\n        if (s1_open <\
    \ s1_close && s2_open == s2_close) {\n            return \"No\";\n        }\n\
    \        if (s1_open < s1_close && s2_open < s2_close) {\n            return \"\
    No\";\n        }\n        if (s1_open > s1_close && s2_open > s2_close) {\n  \
    \          return \"No\";\n        }\n        return \"Yes\";\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpia8eep2z.java:62)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        if\
    \ (open == close) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpnipo_u8e.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpdso8l7ak.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmph44eallm.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp7tudwu93.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s = lst.get(0) + lst.get(1);\n        int count = 0;\n       \
    \ for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\
    \ {\n                count++;\n            } else {\n                count--;\n\
    \            }\n            if (count < 0) {\n                return \"No\";\n\
    \            }\n        }\n        return count == 0 ? \"Yes\" : \"No\";\n\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpt49tz23s.java:40)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"No\";\n        } else if (count1 > 0 && count2 > 0)\
    \ {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpc5f3bdo_.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp7exhkbs7.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjrdt8zb4.java:52)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa9u38hrj.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmptvsgflgc.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpaqg2fxud.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpvb48pu8h.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa1h_a7pc.java:68)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpvpj8he_e.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        return \"\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpu5_97oun.java:25)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int cnt = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                cnt++;\n    \
    \        } else {\n                cnt--;\n            }\n            if (cnt\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (cnt == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmz48ennc.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == count2) {\n     \
    \       return \"Yes\";\n        } else {\n            return \"No\";\n      \
    \  }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpdq77hszl.java:47)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 > 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp4qt_b208.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        if\
    \ (open == close) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp9ph4i7bn.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        return null;\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke\
    \ \"String.equals(Object)\" because the return value of \"Problem.matchParens(java.util.ArrayList)\"\
    \ is null\n\tat Problem.main(tmphhkrsogo.java:25)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 < 0) {\n            return \"Yes\";\n\
    \        }\n        if (c1 > 0 && c2 == 0) {\n            return \"Yes\";\n  \
    \      }\n        if (c1 < 0 && c2 == 0) {\n            return \"Yes\";\n    \
    \    }\n        if (c1 > 0 && c2 < 0) {\n            return \"Yes\";\n       \
    \ }\n        if (c1 < 0 && c2 > 0) {\n            return \"Yes\";\n        }\n\
    \        return \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv71rxkpa.java:63)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpz8mggn1k.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Fill in your code here\n        return \"\";\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpodc1dxbs.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        if\
    \ (s1.length() == 0) {\n            return isGood(s2) ? \"Yes\" : \"No\";\n  \
    \      }\n        if (s2.length() == 0) {\n            return isGood(s1) ? \"\
    Yes\" : \"No\";\n        }\n        if (s1.charAt(0) == '(') {\n            return\
    \ matchParens(new ArrayList<String>(Arrays.asList(s1.substring(1), s2))) == \"\
    Yes\" ? \"Yes\" : matchParens(new ArrayList<String>(Arrays.asList(s1, s2.substring(1))));\n\
    \        }\n        if (s2.charAt(0) == '(') {\n            return matchParens(new\
    \ ArrayList<String>(Arrays.asList(s1, s2.substring(1)))) == \"Yes\" ? \"Yes\"\
    \ : matchParens(new ArrayList<String>(Arrays.asList(s1.substring(1), s2)));\n\
    \        }\n        return \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmptdvmqbzf.java:24: error: cannot find symbol\n            return\
    \ isGood(s2) ? \"Yes\" : \"No\";\n                   ^\n  symbol:   method isGood(String)\n\
    \  location: class Problem\n/tmp/tmptdvmqbzf.java:27: error: cannot find symbol\n\
    \            return isGood(s1) ? \"Yes\" : \"No\";\n                   ^\n  symbol:\
    \   method isGood(String)\n  location: class Problem\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyzaotf2z.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        if\
    \ (open == close) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpesaz56h_.java:49)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s = lst.get(0) + lst.get(1);\n        int cnt = 0;\n        for\
    \ (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n\
    \                cnt++;\n            } else {\n                cnt--;\n      \
    \      }\n            if (cnt < 0) {\n                return \"No\";\n       \
    \     }\n        }\n        return \"Yes\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpem1cjbiu.java:40)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Write your code here\n        // To print results to the standard\
    \ output you can use System.out.println()\n        // Example: System.out.println(\"\
    Hello world!\");\n        return \"\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwwdr76s4.java:28)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (char\
    \ c : s.toCharArray()) {\n                if (c == '(') {\n                  \
    \  count++;\n                } else {\n                    count--;\n        \
    \        }\n                if (count < 0) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return count == 0 ? \"\
    Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp76oykhsv.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpubwevtfu.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa92449sk.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 > 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpo046vafs.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpikwq6j3p.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 >\
    \ 0 && count2 > 0) {\n                return \"No\";\n            } else if (count1\
    \ < 0 && count2 < 0) {\n                return \"No\";\n            } else {\n\
    \                return \"Yes\";\n            }\n        }\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcdqnwu7n.java:59)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp90ch1vah.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int count = 0;\n        for (String s : lst) {\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   count++;\n                } else {\n                    count--;\n\
    \                }\n                if (count < 0) {\n                    return\
    \ \"No\";\n                }\n            }\n        }\n        return count ==\
    \ 0 ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpj6j79etd.java:41)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp7sna6x79.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmnh25sdh.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int cnt = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                cnt++;\n    \
    \        } else {\n                cnt--;\n            }\n            if (cnt\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (cnt == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpkd9bv86y.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 != 0) {\n            return \"No\";\n\
    \        }\n        if (c1 != 0 && c2 == 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n      \
    \  }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n        }\n\
    \        if (c1 > 0 && c2 < 0) {\n            if (c1 + c2 == 0) {\n          \
    \      return \"Yes\";\n            } else {\n                return \"No\";\n\
    \            }\n        }\n        if (c1 < 0 && c2 > 0) {\n            if (c1\
    \ + c2 == 0) {\n                return \"Yes\";\n            } else {\n      \
    \          return \"No\";\n            }\n        }\n        return \"No\";\n\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmbopc3pe.java:81)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        Stack<Character> st = new Stack<Character>();\n      \
    \  for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\
    \            if (c == '(') {\n                st.push(c);\n            } else\
    \ {\n                if (st.isEmpty()) {\n                    return \"No\";\n\
    \                } else {\n                    st.pop();\n                }\n\
    \            }\n        }\n        if (st.isEmpty()) {\n            return \"\
    Yes\";\n        } else {\n            return \"No\";\n        }\n\n    }\n   \
    \ public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpap9cs8no.java:48)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close && s2_open\
    \ != s2_close) {\n            if (s2_open > s2_close) {\n                return\
    \ \"Yes\";\n            } else {\n                return \"No\";\n           \
    \ }\n        }\n        if (s1_open != s1_close && s2_open == s2_close) {\n  \
    \          if (s1_open > s1_close) {\n                return \"Yes\";\n      \
    \      } else {\n                return \"No\";\n            }\n        }\n  \
    \      if (s1_open != s1_close && s2_open != s2_close) {\n            if (s1_open\
    \ > s1_close && s2_open > s2_close) {\n                return \"Yes\";\n     \
    \       } else {\n                return \"No\";\n            }\n        }\n \
    \       return \"No\";\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpgmu04x5y.java:69)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int n = lst.size();\n        int[] open = new int[n];\n        int[]\
    \ close = new int[n];\n        for (int i = 0; i < n; i++) {\n            String\
    \ s = lst.get(i);\n            for (int j = 0; j < s.length(); j++) {\n      \
    \          if (s.charAt(j) == '(') {\n                    open[i]++;\n       \
    \         } else {\n                    close[i]++;\n                }\n     \
    \       }\n        }\n        int sumOpen = 0;\n        int sumClose = 0;\n  \
    \      for (int i = 0; i < n; i++) {\n            sumOpen += open[i];\n      \
    \      sumClose += close[i];\n        }\n        if (sumOpen != sumClose) {\n\
    \            return \"No\";\n        }\n        int minOpen = Integer.MAX_VALUE;\n\
    \        int minClose = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++)\
    \ {\n            minOpen = Math.min(minOpen, open[i]);\n            minClose =\
    \ Math.min(minClose, close[i]);\n        }\n        if (minOpen == 0 || minClose\
    \ == 0) {\n            return \"No\";\n        }\n        return \"Yes\";\n\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpdy1nat6i.java:56)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // TODO: Implement me!\n        return \"\";\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqgva3mmk.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"No\";\n        } else if (count1 > 0 && count2 > 0)\
    \ {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxzyn2qy2.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 < 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else {\n            return \"No\";\n        }\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmphmhabhjf.java:60)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmps0z0h7yh.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppjg01e3s.java:52)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        int open = 0;\n        int close = 0;\n        for (String s : lst) {\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    open++;\n                } else {\n         \
    \           close++;\n                }\n            }\n        }\n        return\
    \ open == close ? \"Yes\" : \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp74e5a4in.java:45)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // TODO: Implement this method\n        return \"\";\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpc33vc9os.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmptrx475ja.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 >\
    \ 0 && count2 > 0) {\n                return \"No\";\n            } else if (count1\
    \ < 0 && count2 < 0) {\n                return \"No\";\n            } else {\n\
    \                return \"Yes\";\n            }\n        }\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpgzy_5zqs.java:59)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close) {\n\
    \            return \"Yes\";\n        }\n        if (s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        return \"No\";\n\n    }\n   \
    \ public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2sswd708.java:54)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplxqt2zin.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 != 0) {\n            return \"No\";\n\
    \        }\n        if (c1 != 0 && c2 == 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n      \
    \  }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n        }\n\
    \        if (c1 < 0 && c2 > 0) {\n            return \"Yes\";\n        }\n   \
    \     if (c1 > 0 && c2 < 0) {\n            return \"Yes\";\n        }\n      \
    \  return \"No\";\n\n    }\n    public static void main(String[] args) {\n   \
    \ assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpaa0uqdqp.java:66)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        Stack<Character> stack = new Stack<Character>();\n   \
    \     for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\
    \            if (c == '(') {\n                stack.push(c);\n            } else\
    \ {\n                if (stack.isEmpty()) {\n                    return \"No\"\
    ;\n                } else {\n                    stack.pop();\n              \
    \  }\n            }\n        }\n        return stack.isEmpty() ? \"Yes\" : \"\
    No\";\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpy_qxks5m.java:44)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6f61t7rx.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpls3s554k.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0) {\n            return \"No\";\n        }\n\
    \        if (c2 == 0) {\n            return \"No\";\n        }\n        if (c1\
    \ > 0 && c2 > 0) {\n            return \"No\";\n        }\n        if (c1 < 0\
    \ && c2 < 0) {\n            return \"No\";\n        }\n        if (c1 > 0 && c2\
    \ < 0) {\n            if (c1 == -c2) {\n                return \"Yes\";\n    \
    \        }\n            return \"No\";\n        }\n        if (c1 < 0 && c2 >\
    \ 0) {\n            if (c2 == -c1) {\n                return \"Yes\";\n      \
    \      }\n            return \"No\";\n        }\n        return \"No\";\n\n  \
    \  }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwjxattui.java:79)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if\
    \ (s1.charAt(i) == '(') {\n                count++;\n            } else {\n  \
    \              count--;\n            }\n        }\n        for (int i = 0; i <\
    \ s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n              \
    \  count++;\n            } else {\n                count--;\n            }\n \
    \       }\n        if (count == 0) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpp61jao8p.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int cnt = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                cnt++;\n    \
    \        } else {\n                cnt--;\n            }\n            if (cnt\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (cnt == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpih9h3jos.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (char c : s1.toCharArray()) {\n  \
    \          if (c == '(') {\n                c1++;\n            } else {\n    \
    \            c1--;\n            }\n        }\n        for (char c : s2.toCharArray())\
    \ {\n            if (c == '(') {\n                c2++;\n            } else {\n\
    \                c2--;\n            }\n        }\n        if (c1 == 0 && c2 ==\
    \ 0) {\n            return \"Yes\";\n        }\n        if (c1 == 0 && c2 != 0)\
    \ {\n            return \"No\";\n        }\n        if (c1 != 0 && c2 == 0) {\n\
    \            return \"No\";\n        }\n        if (c1 > 0 && c2 < 0) {\n    \
    \        return \"No\";\n        }\n        if (c1 < 0 && c2 > 0) {\n        \
    \    return \"No\";\n        }\n        if (c1 > 0 && c2 > 0) {\n            return\
    \ \"Yes\";\n        }\n        if (c1 < 0 && c2 < 0) {\n            return \"\
    Yes\";\n        }\n        return \"No\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwhpf_l6z.java:64)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6_wq4f9t.java:68)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpue_ndll_.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 >\
    \ 0 && count2 > 0) {\n                return \"No\";\n            } else if (count1\
    \ < 0 && count2 < 0) {\n                return \"No\";\n            } else {\n\
    \                return \"Yes\";\n            }\n        }\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3s6az4h6.java:59)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpch54yhr2.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 != 0) {\n            return \"No\";\n\
    \        }\n        if (c1 != 0 && c2 == 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n      \
    \  }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n        }\n\
    \        if (c1 < 0 && c2 > 0) {\n            if (c1 + c2 == 0) {\n          \
    \      return \"Yes\";\n            } else {\n                return \"No\";\n\
    \            }\n        }\n        if (c1 > 0 && c2 < 0) {\n            if (c1\
    \ + c2 == 0) {\n                return \"Yes\";\n            } else {\n      \
    \          return \"No\";\n            }\n        }\n        return \"No\";\n\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpx86g76co.java:81)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 < 0 || count2 < 0) {\n\
    \            return \"No\";\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        }\n        if (count1 == 0 && count2\
    \ > 0) {\n            return \"Yes\";\n        }\n        if (count1 > 0 && count2\
    \ == 0) {\n            return \"Yes\";\n        }\n        if (count1 > 0 && count2\
    \ > 0) {\n            return \"Yes\";\n        }\n        return \"No\";\n\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpjjmdjowg.java:58)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppg2bqi3f.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Your code here\n        return \"\";\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6qmk8kac.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprkzsvld3.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // TODO: Implement this function\n        return \"No\";\n\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmps7flg5sm.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Write your code here\n        return \"\";\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8yww6p2y.java:26)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < s1.length(); i++)\
    \ {\n            if (s1.charAt(i) == '(') {\n                c1++;\n         \
    \   } else {\n                c1--;\n            }\n        }\n        for (int\
    \ i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n   \
    \             c2++;\n            } else {\n                c2--;\n           \
    \ }\n        }\n        if (c1 == 0 && c2 == 0) {\n            return \"Yes\"\
    ;\n        }\n        if (c1 == 0 && c2 != 0) {\n            return \"No\";\n\
    \        }\n        if (c1 != 0 && c2 == 0) {\n            return \"No\";\n  \
    \      }\n        if (c1 < 0 && c2 < 0) {\n            return \"No\";\n      \
    \  }\n        if (c1 > 0 && c2 > 0) {\n            return \"No\";\n        }\n\
    \        return \"Yes\";\n\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpec1fgilf.java:60)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ s1_open = 0;\n        int s1_close = 0;\n        int s2_open = 0;\n        int\
    \ s2_close = 0;\n        for (int i = 0; i < s1.length(); i++) {\n           \
    \ if (s1.charAt(i) == '(') {\n                s1_open++;\n            } else {\n\
    \                s1_close++;\n            }\n        }\n        for (int i = 0;\
    \ i < s2.length(); i++) {\n            if (s2.charAt(i) == '(') {\n          \
    \      s2_open++;\n            } else {\n                s2_close++;\n       \
    \     }\n        }\n        if (s1_open == s1_close && s2_open == s2_close) {\n\
    \            return \"Yes\";\n        }\n        if (s1_open == s1_close && s2_open\
    \ != s2_close) {\n            return \"No\";\n        }\n        if (s1_open !=\
    \ s1_close && s2_open == s2_close) {\n            return \"No\";\n        }\n\
    \        if (s1_open > s1_close) {\n            if (s2_open > s2_close) {\n  \
    \              return \"No\";\n            } else {\n                if (s1_open\
    \ - s1_close == s2_close - s2_open) {\n                    return \"Yes\";\n \
    \               } else {\n                    return \"No\";\n               \
    \ }\n            }\n        } else {\n            if (s2_open > s2_close) {\n\
    \                if (s1_close - s1_open == s2_open - s2_close) {\n           \
    \         return \"Yes\";\n                } else {\n                    return\
    \ \"No\";\n                }\n            } else {\n                return \"\
    No\";\n            }\n        }\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp8lvwzij4.java:83)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int n = s.length();\n        int cnt = 0;\n        for\
    \ (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '(') {\n         \
    \       cnt++;\n            } else {\n                cnt--;\n            }\n\
    \            if (cnt < 0) {\n                return \"No\";\n            }\n \
    \       }\n        if (cnt == 0) {\n            return \"Yes\";\n        }\n \
    \       cnt = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i)\
    \ == ')') {\n                cnt++;\n            } else {\n                cnt--;\n\
    \            }\n            if (cnt < 0) {\n                return \"No\";\n \
    \           }\n        }\n        return \"Yes\";\n\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpai2zpyv1.java:57)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int n = s.length();\n        int balance = 0;\n      \
    \  for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '(') {\n    \
    \            balance++;\n            } else {\n                balance--;\n  \
    \          }\n            if (balance < 0) {\n                return \"No\";\n\
    \            }\n        }\n        if (balance == 0) {\n            return \"\
    Yes\";\n        }\n        s = s2 + s1;\n        balance = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            if (s.charAt(i) == '(') {\n              \
    \  balance++;\n            } else {\n                balance--;\n            }\n\
    \            if (balance < 0) {\n                return \"No\";\n            }\n\
    \        }\n        return \"Yes\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpj955bghr.java:58)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppvomlcmo.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplf1eb7j2.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s3 = s1 + s2;\n        String s4 = s2 + s1;\n        if (isGood(s3) || isGood(s4))\
    \ {\n            return \"Yes\";\n        }\n        return \"No\";\n\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqpsmika_.java:25: error: cannot find symbol\n        if (isGood(s3)\
    \ || isGood(s4)) {\n            ^\n  symbol:   method isGood(String)\n  location:\
    \ class Problem\n/tmp/tmpqpsmika_.java:25: error: cannot find symbol\n       \
    \ if (isGood(s3) || isGood(s4)) {\n                          ^\n  symbol:   method\
    \ isGood(String)\n  location: class Problem\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        if (lst.size() != 2) {\n            return \"No\";\n        }\n     \
    \   String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int n1 =\
    \ s1.length();\n        int n2 = s2.length();\n        if (n1 == 0 && n2 == 0)\
    \ {\n            return \"Yes\";\n        }\n        if (n1 == 0) {\n        \
    \    return s2.charAt(0) == '(' ? \"Yes\" : \"No\";\n        }\n        if (n2\
    \ == 0) {\n            return s1.charAt(0) == ')' ? \"Yes\" : \"No\";\n      \
    \  }\n        if (s1.charAt(0) == ')' && s2.charAt(0) == ')') {\n            return\
    \ \"No\";\n        }\n        if (s1.charAt(0) == '(' && s2.charAt(0) == '(')\
    \ {\n            return \"Yes\";\n        }\n        if (s1.charAt(0) == '(')\
    \ {\n            return matchParens(new ArrayList<String>(Arrays.asList(s1.substring(1),\
    \ s2)));\n        }\n        if (s2.charAt(0) == '(') {\n            return matchParens(new\
    \ ArrayList<String>(Arrays.asList(s1, s2.substring(1))));\n        }\n       \
    \ return \"No\";\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpp9wnc9f6.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        Stack<Character> st = new Stack<Character>();\n      \
    \  for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\
    \            if (c == '(') {\n                st.push(c);\n            } else\
    \ {\n                if (st.empty()) {\n                    return \"No\";\n \
    \               } else {\n                    st.pop();\n                }\n \
    \           }\n        }\n        if (st.empty()) {\n            return \"Yes\"\
    ;\n        } else {\n            return \"No\";\n        }\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5c9bnqt4.java:48)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 >\
    \ 0 && count2 > 0) {\n                return \"No\";\n            } else if (count1\
    \ < 0 && count2 < 0) {\n                return \"No\";\n            } else {\n\
    \                return \"Yes\";\n            }\n        }\n\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpsrc1ssuf.java:59)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 < 0 && count2 < 0)\
    \ {\n            return \"No\";\n        } else if (count1 > 0 && count2 > 0)\
    \ {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqbkscxqs.java:53)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpt3v2gvg8.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        String\
    \ s = s1 + s2;\n        int count = 0;\n        for (int i = 0; i < s.length();\
    \ i++) {\n            if (s.charAt(i) == '(') {\n                count++;\n  \
    \          } else {\n                count--;\n            }\n            if (count\
    \ < 0) {\n                return \"No\";\n            }\n        }\n        if\
    \ (count == 0) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp33hf9upq.java:46)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 == 0 && count2 !=\
    \ 0) {\n            return \"No\";\n        } else if (count1 != 0 && count2 ==\
    \ 0) {\n            return \"No\";\n        } else {\n            if (count1 ==\
    \ count2) {\n                return \"Yes\";\n            } else {\n         \
    \       return \"No\";\n            }\n        }\n\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp36xmcnx6.java:55)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        int\
    \ count1 = 0;\n        int count2 = 0;\n        for (int i = 0; i < s1.length();\
    \ i++) {\n            if (s1.charAt(i) == '(') {\n                count1++;\n\
    \            } else {\n                count1--;\n            }\n        }\n \
    \       for (int i = 0; i < s2.length(); i++) {\n            if (s2.charAt(i)\
    \ == '(') {\n                count2++;\n            } else {\n               \
    \ count2--;\n            }\n        }\n        if (count1 == 0 && count2 == 0)\
    \ {\n            return \"Yes\";\n        } else if (count1 > 0 && count2 < 0)\
    \ {\n            if (count1 == -count2) {\n                return \"Yes\";\n \
    \           } else {\n                return \"No\";\n            }\n        }\
    \ else if (count1 < 0 && count2 > 0) {\n            if (count2 == -count1) {\n\
    \                return \"Yes\";\n            } else {\n                return\
    \ \"No\";\n            }\n        } else {\n            return \"No\";\n     \
    \   }\n\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpsbxpi07n.java:68)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    public static String matchParens(ArrayList<String> lst) {\n\
    \        // Write your code here\n        // To print results to the standard\
    \ output you can use System.out.println()\n        // Example: System.out.println(\"\
    Hello world!\");\n        return \"\";\n\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpppp1x0_i.java:28)\n"
  exit_code: 1
  status: Exception
