name: HumanEval_120_maximum
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers\
  \ and a positive integer k, return a sorted vector \n// of length k with the maximum\
  \ k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3,\
  \ (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n\
  // Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})),\
  \ (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3,\
  \ (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n\
  // Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n//\
  \ 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0\
  \ <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n"
tests: "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3,\
  \ (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n\
  \    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) ==\
  \ (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3,\
  \ (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n\
  \    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0,\
  \ (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20,\
  \ (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20,\
  \ (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1,\
  \ (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15,\
  \ (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13,\
  \ (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1,\
  \ (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3,\
  \ (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5,\
  \ (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4,\
  \ (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10,\
  \ (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n\
  }\n"
completions: ["    std::vector<long> res;\n    if (k == 0) return res;\n    for (long\
    \ idx = 0; idx < k; idx++) {\n        long maxIdx = idx;\n        for (long jdx\
    \ = idx + 1; jdx < arr.size(); jdx++) {\n            if (arr[jdx] > arr[maxIdx])\
    \ maxIdx = jdx;\n        }\n        if (idx != maxIdx) std::swap(arr[idx], arr[maxIdx]);\n\
    \        res.push_back(arr[idx]);\n    }\n    return res;", "\tstd::vector<long>\
    \ result;\n\tif (k == 0) return result;\n\tstd::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> q;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tq.push(arr[i]);\n\
    \t\tif (q.size() > k) q.pop();\n\t}\n\twhile (!q.empty()) {\n\t\tresult.push_back(q.top());\n\
    \t\tq.pop();\n\t}\n\tstd::reverse(result.begin(), result.end());\n\treturn result;",
  "    std::vector<long> res;\n    priority_queue<long, std::vector<long>, std::greater<long>>\
    \ pq;\n    for (int i = 0; i < arr.size(); i++) {\n        if (pq.size() < k)\
    \ pq.push(arr[i]);\n        else {\n            if (arr[i] > pq.top()) {\n   \
    \             pq.pop();\n                pq.push(arr[i]);\n            }\n   \
    \     }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "    std::vector<long> answer;\n\
    \    std::priority_queue<long> pq;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        pq.push(arr[i]);\n    }\n    while (!pq.empty() && k--) {\n     \
    \   answer.push_back(pq.top());\n        pq.pop();\n    }\n    return answer;",
  "    // An initial, naive implementation.\n    if(k==0) return {};\n    std::vector<long>\
    \ result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ min_heap;\n    int i=0;\n    for(int i=0; i<arr.size(); i++){\n        if(min_heap.size()<k){\n\
    \            min_heap.push(arr[i]);\n        }\n        else{\n            if(arr[i]>min_heap.top()){\n\
    \                min_heap.pop();\n                min_heap.push(arr[i]);\n   \
    \         }\n        }\n    }\n    while(!min_heap.empty()){\n        result.push_back(min_heap.top());\n\
    \        min_heap.pop();\n    }\n    return result;", "    assert(arr.size() >\
    \ 0);\n    std::vector<long> result;\n    int length = arr.size();\n    std::vector<long>\
    \ left(length, 0);\n    std::vector<long> right(length, 0);\n    // left[i] =\
    \ max(arr[0] .. arr[i])\n    left[0] = arr[0];\n    for (int i = 1; i < length;\
    \ i++) {\n        left[i] = std::max(left[i - 1], arr[i]);\n    }\n    // right[i]\
    \ = max(arr[i] .. arr[n - 1])\n    right[length - 1] = arr[length - 1];\n    for\
    \ (int i = length - 2; i >= 0; i--) {\n        right[i] = std::max(right[i + 1],\
    \ arr[i]);\n    }\n    for (int i = 0; i < k; i++) {\n        if (i == 0) {\n\
    \            result.push_back(right[i]);\n        } else if (i == length - 1)\
    \ {\n            result.push_back(left[i]);\n        } else {\n            result.push_back(std::max(left[i],\
    \ right[i]));\n        }\n    }\n    return result;", "    // assert(((arr.size())\
    \ >= (k)));\n    if (arr.size() < k) {\n        k = arr.size();\n    }\n    std::sort(arr.begin(),\
    \ arr.end());\n    auto arr_sorted = arr;\n    std::reverse(arr_sorted.begin(),\
    \ arr_sorted.end());\n    std::vector<long> k_max;\n    for (size_t i = 0; i <\
    \ k; i++) {\n        k_max.push_back(arr_sorted[i]);\n    }\n    return k_max;",
  "  std::priority_queue<long> q;\n  for (auto el : arr) {\n    q.push(el);\n    if\
    \ (q.size() > k) {\n      q.pop();\n    }\n  }\n  std::vector<long> result;\n\
    \  while (q.size() > 0) {\n    result.push_back(q.top());\n    q.pop();\n  }\n\
    \  return result;", "    priority_queue<long, vector<long>, greater<long>> pq;\n\
    \    vector<long> res;\n    for(auto i : arr) {\n        pq.push(i);\n       \
    \ if(pq.size() > k) {\n            pq.pop();\n        }\n    }\n    while(!pq.empty())\
    \ {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
  "    std::vector<long> res;\n    std::sort(arr.begin(), arr.end());\n    res.assign(arr.end()\
    \ - k, arr.end());\n    return res;", "\tif (k > arr.size()) return arr;\n\tstd::priority_queue<long>\
    \ q;\n\tfor (auto x : arr) {\n\t\tq.push(x);\n\t\tif (q.size() > k) q.pop();\n\
    \t}\n\tstd::vector<long> res;\n\twhile (!q.empty()) {\n\t\tres.push_back(q.top());\n\
    \t\tq.pop();\n\t}\n\treturn res;", "    long n = arr.size();\n    std::vector<long>\
    \ res(k);\n    for (long i = 0; i < k; i++) {\n        res[i] = arr[i];\n    }\n\
    \    std::make_heap(res.begin(), res.end());\n    for (long i = k; i < n; i++)\
    \ {\n        if (arr[i] > res[0]) {\n            res[0] = arr[i];\n          \
    \  std::make_heap(res.begin(), res.end());\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end());\n    return res;", "    std::vector<long> output;\n    // sorting\
    \ array\n    std::sort(arr.begin(), arr.end());\n    // returning maximum k numbers\n\
    \    return std::vector<long>(arr.end() - k, arr.end());", "    // your code goes\
    \ here\n    std::priority_queue<long> max_heap;\n    std::vector<long> res;\n\
    \    for(long i=0;i<arr.size();i++){\n        max_heap.push(arr[i]);\n    }\n\
    \    while(k--){\n        res.push_back(max_heap.top());\n        max_heap.pop();\n\
    \    }\n    std::sort(res.begin(),res.end());\n    return res;", "  std::vector<long>\
    \ temp;\n  std::priority_queue<long> pq;\n  for(int i = 0; i < arr.size(); i++)\n\
    \  {\n    pq.push(arr[i]);\n  }\n  for(int i = 0; i < k; i++)\n  {\n    temp.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  std::reverse(temp.begin(), temp.end());\n  return temp;",
  "  // Your code here...\n  std::vector<long> max_arr;\n  int size = arr.size();\n\
    \  if(size == k)\n    return arr;\n  long max;\n  int i = 0;\n  while(max_arr.size()\
    \ != k)\n  {\n    max = arr[0];\n    i = 0;\n    for(int j = 0; j < arr.size();\
    \ j++)\n    {\n      if(arr[j] > max)\n      {\n        max = arr[j];\n      \
    \  i = j;\n      }\n    }\n    max_arr.push_back(max);\n    arr.erase(arr.begin()\
    \ + i);\n  }\n  return max_arr;", "  std::vector<long> result;\n  if (k > arr.size())\
    \ {\n    return result;\n  }\n  // sort the vector in descending order\n  std::sort(arr.begin(),\
    \ arr.end(), std::greater<long>());\n  for (long i = 0; i < k; i++) {\n    result.push_back(arr[i]);\n\
    \  }\n  return result;", "    assert(k <= arr.size());\n    std::vector<long>\
    \ result(k);\n    std::priority_queue<long> pq;\n    for (const auto& elem : arr)\
    \ {\n        pq.push(elem);\n        if (pq.size() > k)\n            pq.pop();\n\
    \    }\n    for (int i = k - 1; i >= 0; --i) {\n        result[i] = pq.top();\n\
    \        pq.pop();\n    }\n    return result;", "    // initialize a vector\n\
    \    std::vector<long> ret_val;\n    // initialize an empty priority queue\n \
    \   std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n   \
    \ // iterate the array\n    for (int i = 0; i < arr.size(); i++) {\n        //\
    \ if the size of the priority queue is less than k,\n        // push the element\
    \ into the priority queue\n        if (pq.size() < k) {\n            pq.push(arr[i]);\n\
    \        } else {\n            // pop the smallest element in the priority queue\n\
    \            pq.pop();\n            // push the new element into the priority\
    \ queue\n            pq.push(arr[i]);\n        }\n    }\n    // iterate the priority\
    \ queue and add the element into the \n    // ret_val vector\n    while (!pq.empty())\
    \ {\n        ret_val.push_back(pq.top());\n        pq.pop();\n    }\n    // reverse\
    \ the ret_val vector, since the element in the priority\n    // queue is in the\
    \ non-increasing order\n    std::reverse(ret_val.begin(), ret_val.end());\n  \
    \  // return the ret_val vector\n    return ret_val;", "    std::priority_queue<long>\
    \ pq;\n    for (long num : arr) {\n        pq.push(num);\n        if (pq.size()\
    \ > k) pq.pop();\n    }\n    std::vector<long> ans;\n    while (!pq.empty()) {\n\
    \        ans.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(ans.begin(),\
    \ ans.end());\n    return ans;", "\tint len = arr.size();\n\tpriority_queue<long>\
    \ pq;\n\tfor (int i = 0; i < len; i++) {\n\t\tpq.push(arr[i]);\n\t}\n\tstd::vector<long>\
    \ res;\n\twhile (k > 0) {\n\t\tres.push_back(pq.top());\n\t\tpq.pop();\n\t\tk--;\n\
    \t}\n\treturn res;", "    std::priority_queue<long> pq;\n    std::vector<long>\
    \ result;\n    int i;\n    for(i=0;i<k;i++) {\n        pq.push(arr[i]);\n    }\n\
    \    for(i=k;i<arr.size();i++) {\n        if(arr[i]>pq.top()) {\n            pq.pop();\n\
    \            pq.push(arr[i]);\n        }\n    }\n    for(i=0;i<k;i++) {\n    \
    \    result.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(result.begin(),\
    \ result.end());\n    return result;", "    int n = arr.size();\n    std::priority_queue<long>\
    \ pq;\n    for(auto &x: arr) {\n        pq.push(x);\n        if(pq.size() > k)\
    \ pq.pop();\n    }\n    std::vector<long> ans;\n    while(!pq.empty()) {\n   \
    \     ans.push_back(pq.top());\n        pq.pop();\n    }\n    return ans;", " \
    \   // Input and output vectors\n    std::vector<long> out, in;\n    // Loop variable\n\
    \    long i, j;\n    // Loop through the input array\n    for(i = 0; i < arr.size();\
    \ i++) {\n        // Add element to input vector\n        in.push_back(arr[i]);\n\
    \        // If the size of input vector is greater than k,\n        // remove\
    \ the minimum element of the vector\n        if(in.size() > k) {\n           \
    \ // Initialize minimum element\n            long min = in[0];\n            //\
    \ Set loop variable\n            j = 0;\n            // Loop through the input\
    \ vector\n            for(long l = 0; l < in.size(); l++) {\n                //\
    \ If current element is less than the minimum element,\n                // update\
    \ minimum element and loop variable\n                if(in[l] < min) {\n     \
    \               min = in[l];\n                    j = l;\n                }\n\
    \            }\n            // Remove minimum element from input vector\n    \
    \        in.erase(in.begin() + j);\n        }\n    }\n    // Sort the input vector\n\
    \    std::sort(in.begin(), in.end());\n    // Loop through the input vector\n\
    \    for(i = in.size() - 1; i >= 0; i--) {\n        // Add elements to output\
    \ vector\n        out.push_back(in[i]);\n    }\n    // Return the output vector\n\
    \    return out;", "    std::vector<long> v;\n    int n = arr.size();\n    int\
    \ mid = n/2;\n    //we will do a quickselect like in quicksort\n    //we will\
    \ recursively partition the array and pick the largest k elements\n    //quickselect(arr,l,r,k)\n\
    \    //if(r-l+1<=k) return arr[l..r]\n    //pivot = arr[r]\n    //partition arrount\
    \ pivot\n    //if(r-left+1>k) return quickselect(arr,l,left-1,k)\n    //else return\
    \ quickselect(arr,left,r,k-(r-left+1))\n    //O(n) expected time\n    for(int\
    \ i=0;i<k;i++){\n        int l = 0;\n        int r = n-1;\n        //mid = (l+r)/2;\n\
    \        //we want to partition the array around mid\n        int pivot = arr[mid];\n\
    \        std::swap(arr[mid],arr[r]);\n        int left = l;\n        for(int j=l;j<r;j++){\n\
    \            if(arr[j]>pivot){\n                std::swap(arr[j],arr[left]);\n\
    \                left++;\n            }\n        }\n        std::swap(arr[left],arr[r]);\n\
    \        //now at left pivot is present\n        if(r-left+1>k){\n           \
    \ mid = left;\n        }\n        else{\n            n = left;\n        }\n  \
    \  }\n    return arr;", "    // Find the max value in arr and then\n    // find\
    \ the first index of max value.\n    // If (k == 1) return {max(arr)}.\n    //\
    \ Next, find the second max value in arr.\n    // Then, find the second index\
    \ of max value.\n    // We use a map to store the index of each number.\n    //\
    \ For example, if\n    // [arr[i] = -100, arr[j] = -100]\n    // We want to save\
    \ the position of arr[i]\n    // and arr[j] in a map.\n    // In this case, we\
    \ should push back\n    // arr[i] and arr[j] into our answer.\n    // In this\
    \ way, we can use (k) number of times.\n    std::map<long, std::vector<int>> m;\n\
    \    // Init maxval, maxval_idx\n    long maxval = arr[0];\n    int maxval_idx\
    \ = 0;\n    // Loop every element in arr.\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        // Find the max element in arr.\n        if (arr[i] > maxval)\
    \ {\n            maxval = arr[i];\n            maxval_idx = i;\n        }\n  \
    \      // Save the index of each element in arr.\n        m[arr[i]].push_back(i);\n\
    \    }\n    // Case (k == 1).\n    if (k == 1) return {maxval};\n    // Erase\
    \ the max element in arr.\n    m[maxval].erase(m[maxval].begin());\n    // Init\
    \ vector<long> answer.\n    std::vector<long> answer;\n    // Push back the max\
    \ element in arr.\n    answer.push_back(maxval);\n    // Loop (k - 1) times.\n\
    \    for (int i = 0; i < k - 1; i++) {\n        // Init maxval_idx, maxval.\n\
    \        maxval_idx = 0;\n        maxval = arr[0];\n        // Find the second\
    \ max element in arr.\n        for (auto x : m) {\n            if (x.first > maxval)",
  "    std::vector<long> result;\n    std::multiset<long> ms;\n    for (int i = 0;\
    \ i < arr.size(); i++) {\n        ms.insert(arr[i]);\n    }\n    for (int i =\
    \ 0; i < k; i++) {\n        result.push_back(*ms.rbegin());\n        ms.erase(ms.find(*ms.rbegin()));\n\
    \    }\n    return result;", "    std::vector<long> res;\n    for (int i = 0;\
    \ i < k; i++) {\n        int currIdx = i;\n        for (int j = i + 1; j < arr.size();\
    \ j++) {\n            if (arr[j] > arr[currIdx]) {\n                currIdx =\
    \ j;\n            }\n        }\n        res.push_back(arr[currIdx]);\n       \
    \ std::swap(arr[i], arr[currIdx]);\n    }\n    return res;", "  long size = arr.size();\n\
    \  if (k > size) {\n    k = size;\n  }\n  if (k <= 0) {\n    return {};\n  }\n\
    \  std::vector<long> result(k);\n  std::priority_queue<long> pq;\n  for (long\
    \ i = 0; i < size; i++) {\n    pq.push(arr[i]);\n  }\n  for (long i = k - 1; i\
    \ >= 0; i--) {\n    result[i] = pq.top();\n    pq.pop();\n  }\n  return result;",
  "  std::priority_queue<long> pq;\n  for (auto num : arr) {\n    pq.push(num);\n\
    \    if (pq.size() > k) {\n      pq.pop();\n    }\n  }\n  std::vector<long> ans;\n\
    \  while (pq.size()) {\n    ans.push_back(pq.top());\n    pq.pop();\n  }\n  return\
    \ ans;", "    // Initialize\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> pq;\n    // Push array elements into heap\n    for (auto\
    \ it = arr.begin(); it != arr.end(); ++it) {\n        pq.push(*it);\n    }\n \
    \   // Remove all elements but k from heap\n    for (int i = 0; i < arr.size()\
    \ - k; ++i) {\n        pq.pop();\n    }\n    // Pop all elements in heap into\
    \ result\n    std::vector<long> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    // Reverse results\n    std::reverse(result.begin(),\
    \ result.end());\n    return result;", "    if (k == 0) {\n        return {};\n\
    \    }\n    if (k >= arr.size()) {\n        std::sort(arr.begin(), arr.end());\n\
    \        return arr;\n    }\n    std::vector<long> r;\n    for (size_t i = 0;\
    \ i < k; i++) {\n        r.push_back(arr[i]);\n    }\n    std::sort(r.begin(),\
    \ r.end());\n    for (size_t i = k; i < arr.size(); i++) {\n        if (arr[i]\
    \ > r[0]) {\n            r[0] = arr[i];\n            std::sort(r.begin(), r.end());\n\
    \        }\n    }\n    return r;", "    int i, j;\n    std::vector<long> res;\n\
    \    if (k == 0)\n        return res;\n    if (k == arr.size())\n        return\
    \ arr;\n    // k-1 first elements are from arr\n    for (i = 0; i < k - 1; i++)\n\
    \        res.push_back(arr[i]);\n    for (i = k - 1; i < arr.size(); i++) {\n\
    \        // if next element is larger than max of k-1 elements\n        // then\
    \ add it to res and remove the max element\n        // then sort the array\n \
    \       if (arr[i] > *max_element(res.begin(), res.end())) {\n            res.push_back(arr[i]);\n\
    \            sort(res.begin(), res.end());\n            res.erase(res.begin());\n\
    \        }\n    }\n    return res;", "    int n = arr.size();\n    if (k == n)\
    \ {\n        return arr;\n    }\n    assert(k > 0);\n    std::vector<long> result(k);\n\
    \    int i = 0;\n    for (int j = 0; j < k; j++) {\n        result[j] = std::numeric_limits<long>::min();\n\
    \    }\n    while (i < n) {\n        if (arr[i] > result[0]) {\n            result[0]\
    \ = arr[i];\n            int j = 0;\n            while (j < k - 1 && result[j]\
    \ > result[j + 1]) {\n                std::swap(result[j], result[j + 1]);\n \
    \               j++;\n            }\n        }\n        i++;\n    }\n    return\
    \ result;", "\tstd::vector<long> res;\n\tstd::sort(arr.begin(), arr.end());\n\t\
    for (long j = arr.size() - 1; j >= 0; j--) {\n\t\tres.push_back(arr[j]);\n\t\t\
    if (res.size() == k) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;", "    vector<long>\
    \ ans;\n    priority_queue<long> pq;\n    for(auto a: arr){\n        pq.push(a);\n\
    \    }\n    while(k--){\n        long top = pq.top();\n        ans.push_back(top);\n\
    \        pq.pop();\n    }\n    return ans;", "  // Implement your solution here\n\
    \  if(k==0) return {};\n  std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ pq;\n  std::vector<long> res;\n  for(int i=0;i<arr.size();i++){\n    if(pq.size()<k)\n\
    \      pq.push(arr[i]);\n    else{\n      long m=pq.top();\n      if(arr[i]>m){\n\
    \        pq.pop();\n        pq.push(arr[i]);\n      }\n    }\n  }\n  while(!pq.empty()){\n\
    \    res.push_back(pq.top());\n    pq.pop();\n  }\n  return res;", "  std::priority_queue<long>\
    \ queue;\n  for (long i = 0; i < k; i++) {\n    queue.push(arr[i]);\n  }\n  for\
    \ (long i = k; i < arr.size(); i++) {\n    queue.push(arr[i]);\n    queue.pop();\n\
    \  }\n  std::vector<long> result;\n  while (!queue.empty()) {\n    result.push_back(queue.top());\n\
    \    queue.pop();\n  }\n  return result;", "    if (k == 0) {\n        return\
    \ {};\n    }\n    if (k >= arr.size()) {\n        return arr;\n    }\n    std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> pq;\n    for (long n : arr) {\n     \
    \   if (pq.size() < k) {\n            pq.push(n);\n        } else {\n        \
    \    if (n > pq.top()) {\n                pq.pop();\n                pq.push(n);\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    while (!pq.empty())\
    \ {\n        ans.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(ans.begin(),\
    \ ans.end());\n    return ans;", "    std::priority_queue<long> pq;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n    std::vector<long>\
    \ ret;\n    while (k--) {\n        ret.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(ret.begin(), ret.end());\n    return ret;", "    std::vector<long>\
    \ k_max(k);\n    std::make_heap(k_max.begin(), k_max.end());\n    for (long el\
    \ : arr) {\n        if (el > k_max.front()) {\n            std::pop_heap(k_max.begin(),\
    \ k_max.end());\n            k_max.back() = el;\n            std::push_heap(k_max.begin(),\
    \ k_max.end());\n        }\n    }\n    std::sort_heap(k_max.begin(), k_max.end());\n\
    \    return k_max;", "    // Initialize the vector.\n    std::vector<long> max_arr;\n\
    \    // Check for empty vector.\n    if (arr.size() == 0) {\n        return max_arr;\n\
    \    }\n    // Check for longer requested than vector.\n    if (k > arr.size())\
    \ {\n        k = arr.size();\n    }\n    // Create a partial sort with the length\
    \ of k.\n    std::nth_element(arr.begin(), arr.begin() + k, arr.end(), std::greater<int>());\n\
    \    // Create a reverse iterator.\n    std::vector<long>::reverse_iterator rit\
    \ = arr.rbegin();\n    // Create the maximum array.\n    for (long idx = 0; idx\
    \ < k; idx++) {\n        max_arr.push_back(*rit);\n        rit++;\n    }\n   \
    \ return max_arr;", "    if (k == 0) {\n        return {};\n    }\n    if (k >=\
    \ arr.size()) {\n        return arr;\n    }\n    auto cmp = [](long num1, long\
    \ num2) { return num1 > num2; };\n    std::priority_queue<long, std::vector<long>,\
    \ decltype(cmp)> pq(cmp);\n    for (auto num : arr) {\n        pq.push(num);\n\
    \    }\n    std::vector<long> ans;\n    while (k--) {\n        ans.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return ans;", "    // Implement your solution here.\n\
    \    std::vector<long> res;\n    std::vector<long>::iterator itr;\n    int index\
    \ = 0;\n    while(k > 0) {\n        long max = arr[0];\n        for(int i = 0;\
    \ i < arr.size(); i++) {\n            if(arr[i] > max) {\n                max\
    \ = arr[i];\n                index = i;\n            }\n        }\n        res.push_back(max);\n\
    \        arr.erase(arr.begin() + index);\n        k--;\n    }\n    return res;",
  "    int n = arr.size();\n    if (n < k) return arr;\n    for (int i = 0; i < k;\
    \ i++) {\n        int max_ = i;\n        for (int j = i+1; j < n; j++) {\n   \
    \         if (arr[j] > arr[max_]) {\n                max_ = j;\n            }\n\
    \        }\n        std::swap(arr[i], arr[max_]);\n    }\n    return arr;", "\t\
    // assert(arr.size() >= k);\n\t// assert(k >= 0);\n\tif (arr.size() < k)\n\t\t\
    return std::vector<long>();\n\tif (k == 0)\n\t\treturn std::vector<long>();\n\t\
    if (k == arr.size())\n\t\treturn arr;\n\tstd::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> max_pq;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\t\
    max_pq.push(arr[i]);\n\t\tif (max_pq.size() > k)\n\t\t\tmax_pq.pop();\n\t}\n\t\
    std::vector<long> ans;\n\twhile (!max_pq.empty()) {\n\t\tans.push_back(max_pq.top());\n\
    \t\tmax_pq.pop();\n\t}\n\treturn ans;", "  std::priority_queue<long> queue;\n\
    \  for (long i = 0; i < k; i++) {\n    queue.push(arr[i]);\n  }\n  for (long i\
    \ = k; i < arr.size(); i++) {\n    if (arr[i] > queue.top()) {\n      queue.pop();\n\
    \      queue.push(arr[i]);\n    }\n  }\n  std::vector<long> result;\n  while (!queue.empty())\
    \ {\n    result.push_back(queue.top());\n    queue.pop();\n  }\n  std::reverse(result.begin(),\
    \ result.end());\n  return result;", "    std::priority_queue<long> pq;\n    for\
    \ (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n    std::vector<long>\
    \ ans;\n    for (long i = 0; i < k; i++) {\n        ans.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return ans;", "    std::priority_queue<long> pq;\n\
    \    for (long el : arr) {\n        pq.push(el);\n        if (pq.size() > k) {\n\
    \            pq.pop();\n        }\n    }\n    std::vector<long> result;\n    while\
    \ (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n  \
    \  }\n    std::reverse(result.begin(), result.end());\n    return result;", " \
    \   assert(0 <= k && k <= arr.size());\n    std::vector<long> res;\n    int n\
    \ = arr.size();\n    for (int i = 0; i < n; i++) {\n        while (!res.empty()\
    \ && n - i + res.size() > k && res.back() < arr[i]) {\n            res.pop_back();\n\
    \        }\n        if (res.size() < k) res.push_back(arr[i]);\n    }\n    return\
    \ res;", "\tstd::vector<long> result;\n\tstd::priority_queue<long> heap;\n\tfor\
    \ (long long i : arr) {\n\t\theap.push(i);\n\t}\n\tfor (long long i = 0; i < k;\
    \ i++) {\n\t\tresult.push_back(heap.top());\n\t\theap.pop();\n\t}\n\treturn result;",
  "    int n = arr.size();\n    for(int i = n/2 - 1; i >= 0; i--) {\n        heapify(arr,\
    \ n, i);\n    }\n    while(k > 0) {\n        arr.pop_back();\n        k--;\n \
    \   }\n    return arr;", "    std::sort(arr.begin(), arr.end());\n    std::vector<long>\
    \ res;\n    for (int i = arr.size() - 1; i >= arr.size() - k; i--)\n        res.push_back(arr[i]);\n\
    \    return res;", "    if (k == 0) return {};\n    if (k == arr.size()) return\
    \ arr;\n    std::vector<long> result;\n    for (int i = 0; i < k; i++) {\n   \
    \     auto it = std::max_element(arr.begin(), arr.end());\n        result.push_back(*it);\n\
    \        arr.erase(it);\n    }\n    return result;", "  // your code here\n  std::vector<long>\
    \ ret;\n  for(auto i : arr) {\n    if(ret.size() < k) {\n      ret.push_back(i);\n\
    \      std::sort(ret.begin(), ret.end(), std::greater<long>());\n    } else {\n\
    \      for(auto& j : ret) {\n        if(i > j) {\n          j = i;\n         \
    \ std::sort(ret.begin(), ret.end(), std::greater<long>());\n          break;\n\
    \        }\n      }\n    }\n  }\n  return ret;", "    std::vector<long> res;\n\
    \    if (k > arr.size()) {\n        std::cout << \"K is larger than size of array\"\
    \ << std::endl;\n        return res;\n    }\n    if (k == 0) {\n        return\
    \ res;\n    }\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ pq;\n    for (int i = 0; i < arr.size(); i++) {\n        if (pq.size() < k)\
    \ {\n            pq.push(arr[i]);\n        } else {\n            if (pq.top()\
    \ < arr[i]) {\n                pq.pop();\n                pq.push(arr[i]);\n \
    \           }\n        }\n    }\n    for (int i = 0; i < k; i++) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "    std::priority_queue<long> pq;\n\
    \    for (long elt : arr) {\n        pq.push(elt);\n        if (pq.size() > k)\
    \ {\n            pq.pop();\n        }\n    }\n    std::vector<long> res;\n   \
    \ while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(res.begin(), res.end());\n    return res;", "    std::vector<long>\
    \ result;\n    std::priority_queue<long> max_heap;\n    for (long el : arr) {\n\
    \        max_heap.push(el);\n    }\n    for (long i = 0; i < k; i++) {\n     \
    \   result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return\
    \ result;", "    std::priority_queue<long> queue;\n    for (long num : arr) {\n\
    \        queue.push(num);\n        if (queue.size() > k) {\n            queue.pop();\n\
    \        }\n    }\n    std::vector<long> result;\n    while (!queue.empty()) {\n\
    \        result.push_back(queue.top());\n        queue.pop();\n    }\n    std::reverse(result.begin(),\
    \ result.end());\n    return result;", "    std::vector<long> r;\n    if (k ==\
    \ 0) return r;\n    if (k >= arr.size()) return arr;\n    std::sort(arr.begin(),\
    \ arr.end());\n    for (long i = arr.size() - 1; i >= arr.size() - k; i--)\n \
    \       r.push_back(arr[i]);\n    return r;", "    std::vector<long> res;\n  \
    \  while(k>0){\n        long temp = INT_MIN;\n        int index = -1;\n      \
    \  for(int i=0;i<arr.size();i++){\n            if(arr[i]>temp){\n            \
    \    temp = arr[i];\n                index = i;\n            }\n        }\n  \
    \      res.push_back(temp);\n        arr.erase(arr.begin()+index);\n        k--;\n\
    \    }\n    return res;", "  if (k == 0) return std::vector<long>();\n  std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> q;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    if (q.size() < k) q.push(arr[i]);\n    else {\n      if (arr[i]\
    \ > q.top()) {\n        q.pop();\n        q.push(arr[i]);\n      }\n    }\n  }\n\
    \  std::vector<long> result;\n  while (!q.empty()) {\n    result.push_back(q.top());\n\
    \    q.pop();\n  }\n  std::reverse(result.begin(), result.end());\n  return result;",
  "    priority_queue<long, vector<long>, greater<long>> Q;\n    for (int i = 0; i\
    \ < arr.size(); i++) {\n        if (Q.size() < k)\n            Q.push(arr[i]);\n\
    \        else {\n            if (Q.top() < arr[i]) {\n                Q.pop();\n\
    \                Q.push(arr[i]);\n            }\n        }\n    }\n    // dequeue\
    \ an element from queue and print it\n    // while (!Q.empty()) {\n    //    \
    \ cout << Q.top() << \" \";\n    //     Q.pop();\n    // }\n    vector<long> v;\n\
    \    for (int i = 0; i < k; i++) {\n        v.push_back(Q.top());\n        Q.pop();\n\
    \    }\n    reverse(v.begin(), v.end());\n    return v;", "\tstd::vector<long>\
    \ res;\n\tstd::sort(arr.begin(), arr.end());\n\tint length = arr.size();\n\tfor\
    \ (int i = 0; i < k; i++) {\n\t\tres.push_back(arr[length - 1 - i]);\n\t}\n\t\
    return res;", "    std::priority_queue<long> pq;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        pq.push(arr[i]);\n    }\n    std::vector<long> ans;\n    while\
    \ (k > 0) {\n        ans.push_back(pq.top());\n        pq.pop();\n        k--;\n\
    \    }\n    return ans;", "    std::vector<long> rt;\n    std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> heap;\n    int i;\n    for (i = 0; i\
    \ < k; i++) {\n        heap.push(arr[i]);\n    }\n    for (; i < arr.size(); i++)\
    \ {\n        if (arr[i] > heap.top()) {\n            heap.pop();\n           \
    \ heap.push(arr[i]);\n        }\n    }\n    for (i = 0; i < k; i++) {\n      \
    \  rt.push_back(heap.top());\n        heap.pop();\n    }\n    return rt;", " \
    \   std::vector<long> result;\n    for (long i = 0; i < k; i++) {\n        result.push_back(0);\n\
    \    }\n    long top = -1;\n    for (long i = 0; i < arr.size(); i++) {\n    \
    \    long e = arr[i];\n        if (top < k - 1) {\n            top++;\n      \
    \      result[top] = e;\n        } else {\n            long index = top;\n   \
    \         for (long j = top; j >= 0; j--) {\n                if (result[j] < e)\
    \ {\n                    index = j;\n                }\n            }\n      \
    \      for (long j = index; j < top; j++) {\n                result[j] = result[j\
    \ + 1];\n            }\n            result[top] = e;\n        }\n    }\n    return\
    \ result;", "  // Initialization:\n  std::vector<long> ans = arr;\n  // Edge case:\n\
    \  if (arr.size() <= k) {\n    return ans;\n  }\n  // Selection sort:\n  for (long\
    \ i = 0; i < k; i++) {\n    long max_index = i;\n    for (long j = i + 1; j <\
    \ arr.size(); j++) {\n      if (arr[j] > arr[max_index]) {\n        max_index\
    \ = j;\n      }\n    }\n    // Swap:\n    long temp = arr[i];\n    arr[i] = arr[max_index];\n\
    \    arr[max_index] = temp;\n  }\n  // Get:\n  ans.assign(arr.begin(), arr.begin()\
    \ + k);\n  // Return:\n  return ans;", "    if (k == arr.size()) {\n        std::sort(arr.begin(),\
    \ arr.end());\n        return arr;\n    }\n    std::sort(arr.begin(), arr.end());\n\
    \    std::vector<long> res(k);\n    auto it = arr.end() - 1;\n    int index =\
    \ 0;\n    while (k > 0) {\n        res[index] = *it;\n        index++;\n     \
    \   it--;\n        k--;\n    }\n    return res;", "    std::priority_queue<long>\
    \ heap;\n    for (int i = 0; i < arr.size(); i++) {\n        heap.push(arr[i]);\n\
    \    }\n    std::vector<long> res;\n    while (k--) {\n        res.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    return res;", "    int n = arr.size();\n    std::vector<long>\
    \ heap(arr.begin(), arr.begin() + k);\n    std::make_heap(heap.begin(), heap.end());\n\
    \    for (int i = k; i < n; i++) {\n        if (arr[i] > heap[0]) {\n        \
    \    std::pop_heap(heap.begin(), heap.end());\n            heap.pop_back();\n\
    \            heap.push_back(arr[i]);\n            std::push_heap(heap.begin(),\
    \ heap.end());\n        }\n    }\n    std::sort_heap(heap.begin(), heap.end());\n\
    \    return heap;", "\t// Your code here\n\tassert(k<=arr.size());\n\tsort(arr.begin(),arr.end());\n\
    \tstd::vector<long> res;\n\tfor(long i=0;i<k;i++)\n\t{\n\t\tres.push_back(arr[arr.size()-1-i]);\n\
    \t}\n\treturn res;", "    // Since set is by default a sorted container.\n   \
    \ std::set<long> maximum;\n    // If k is equal to the vector size.\n    if (k\
    \ == arr.size()) {\n        // Return the sorted vector.\n        std::sort(arr.begin(),\
    \ arr.end());\n        return arr;\n    }\n    // For each element in the vector.\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        // Insert the element into\
    \ the set.\n        maximum.insert(arr[i]);\n        // If the set size is greater\
    \ than k.\n        if (maximum.size() > k) {\n            // Delete the minimum\
    \ element from the set.\n            maximum.erase(maximum.begin());\n       \
    \ }\n    }\n    // Return the set converted to vector.\n    return std::vector<long>(maximum.begin(),\
    \ maximum.end());", "    assert(arr.size() >= 1 && arr.size() <= 1000);\n    for\
    \ (long& i : arr) {\n        assert(i >= -1000 && i <= 1000);\n    }\n    assert(k\
    \ >= 0 && k <= arr.size());\n    // O(arr.size())\n    std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> q;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        q.push(arr[i]);\n        if (q.size() > k) {\n            q.pop();\n\
    \        }\n    }\n    // O(k log k)\n    std::vector<long> res;\n    while (!q.empty())\
    \ {\n        res.push_back(q.top());\n        q.pop();\n    }\n    // reverse\n\
    \    std::reverse(res.begin(), res.end());\n    return res;", "  std::vector<long>\
    \ maxarr;\n  std::priority_queue<long> mypq;\n  for(auto it=arr.begin();it!=arr.end();it++){\n\
    \    mypq.push(*it);\n  }\n  for(long i=0;i<k;i++){\n    maxarr.push_back(mypq.top());\n\
    \    mypq.pop();\n  }\n  return maxarr;", "  /*\n   * Write your code here.\n\
    \   */\n   std::vector<long> tmp(arr.begin(), arr.end());\n   std::sort(tmp.begin(),\
    \ tmp.end());\n   tmp.erase(tmp.begin(), tmp.end() - k);\n   std::reverse(tmp.begin(),\
    \ tmp.end());\n   return tmp;", "    // Write your code here\n    std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> minHeap;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (minHeap.size() < k) {\n            minHeap.push(arr[i]);\n\
    \        } else {\n            if (minHeap.top() < arr[i]) {\n               \
    \ minHeap.pop();\n                minHeap.push(arr[i]);\n            }\n     \
    \   }\n    }\n    std::vector<long> res;\n    while (!minHeap.empty()) {\n   \
    \     res.push_back(minHeap.top());\n        minHeap.pop();\n    }\n    return\
    \ res;", "    vector<long> res;\n    for(int i = 0; i < k; i++) {\n        int\
    \ maxVal = INT_MIN;\n        int maxIndex = -1;\n        for(int j = 0; j < arr.size();\
    \ j++) {\n            if(arr[j] > maxVal) {\n                maxVal = arr[j];\n\
    \                maxIndex = j;\n            }\n        }\n        res.push_back(maxVal);\n\
    \        arr.erase(arr.begin() + maxIndex);\n    }\n    return res;", "  std::priority_queue<long>\
    \ max_heap;\n  std::vector<long> res;\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    max_heap.push(arr[i]);\n  }\n  while (k--) {\n    res.push_back(max_heap.top());\n\
    \    max_heap.pop();\n  }\n  return res;", "    // create a priority queue that\
    \ keeps only the largest k elements\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> kElements;\n    for (auto num : arr) {\n        if (kElements.size()\
    \ < k) {\n            kElements.push(num);\n        } else {\n            if (num\
    \ > kElements.top()) {\n                kElements.pop();\n                kElements.push(num);\n\
    \            }\n        }\n    }\n    // check if k is greater than the length\
    \ of arr\n    if (k > arr.size()) {\n        k = arr.size();\n    }\n    // create\
    \ the result vector\n    std::vector<long> result(k);\n    for (int i = k - 1;\
    \ i >= 0; i--) {\n        result[i] = kElements.top();\n        kElements.pop();\n\
    \    }\n    return result;", "  if (k == arr.size()) return arr;\n  std::priority_queue<long>\
    \ q;\n  for (auto i : arr) {\n    q.push(i);\n    if (q.size() > k) q.pop();\n\
    \  }\n  std::vector<long> res;\n  while (!q.empty()) {\n    res.push_back(q.top());\n\
    \    q.pop();\n  }\n  return res;", "  // TODO: Implement the solution\n    std::vector<long>\
    \ v;\n    int a;\n    for(int i=0;i<k;i++)\n    {\n        a=*max_element(arr.begin(),arr.end());\n\
    \        arr.erase(std::remove(arr.begin(), arr.end(), a), arr.end());\n     \
    \   v.push_back(a);\n    }\n    return v;", "    // remove everything else\n \
    \   // the rightmost elements will be the k largest\n    // std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> pq;\n    // for (auto it = arr.begin();\
    \ it != arr.end(); ++it) {\n    //     pq.push(*it);\n    //     if (pq.size()\
    \ > k) {\n    //         pq.pop();\n    //     }\n    // }\n    // std::vector<long>\
    \ v;\n    // for (int i = 0; i < k; ++i) {\n    //     v.push_back(pq.top());\n\
    \    //     pq.pop();\n    // }\n    // std::reverse(v.begin(), v.end());\n  \
    \  // return v;\n    std::vector<long> v;\n    int i = 0;\n    while (i < k) {\n\
    \        long max = INT_MIN;\n        int maxIdx = 0;\n        for (int j = i;\
    \ j < arr.size(); ++j) {\n            if (arr[j] > max) {\n                max\
    \ = arr[j];\n                maxIdx = j;\n            }\n        }\n        v.push_back(max);\n\
    \        arr.erase(arr.begin() + maxIdx);\n        ++i;\n    }\n    return v;",
  "    std::vector<long> res;\n    for (long i = 0; i < k; i++)\n    {\n        res.push_back(arr[i]);\n\
    \    }\n    std::sort(res.begin(), res.end());\n    for (long i = k; i < arr.size();\
    \ i++)\n    {\n        if (arr[i] > res[0])\n        {\n            res[0] = arr[i];\n\
    \            std::sort(res.begin(), res.end());\n        }\n    }\n    return\
    \ res;", "    long n = arr.size();\n    if (k == n) return arr;\n    std::vector<long>\
    \ res;\n    for (long i = 0; i < n; i++) {\n        while (!res.empty() && res.back()\
    \ < arr[i] && res.size()+n-i > k) res.pop_back();\n        if (res.size() < k)\
    \ res.push_back(arr[i]);\n    }\n    return res;", "\tstd::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> q;\n\tfor (auto& x : arr) {\n\t\tif (q.size()\
    \ < k) {\n\t\t\tq.push(x);\n\t\t}\n\t\telse {\n\t\t\tlong top = q.top();\n\t\t\
    \tif (x > top) {\n\t\t\t\tq.pop();\n\t\t\t\tq.push(x);\n\t\t\t}\n\t\t}\n\t}\n\t\
    std::vector<long> ans;\n\twhile (!q.empty()) {\n\t\tans.push_back(q.top());\n\t\
    \tq.pop();\n\t}\n\tstd::reverse(ans.begin(), ans.end());\n\treturn ans;", "  \
    \  std::priority_queue<long> pq;\n    for (auto i: arr) {\n        pq.push(i);\n\
    \        if (pq.size() > k) pq.pop();\n    }\n    std::vector<long> result;\n\
    \    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(result.begin(), result.end());\n    return result;",
  "    std::sort(arr.begin(), arr.end());\n    std::vector<long>::iterator it;\n \
    \   it = arr.begin();\n    arr.erase(it, it + arr.size() - k);\n    return arr;",
  "    using namespace std;\n    vector<long> res;\n    int len = arr.size();\n  \
    \  int gap = len - k;\n    sort(arr.begin(), arr.end());\n    if (gap == 0) {\n\
    \        return arr;\n    }\n    while (gap > 0) {\n        res.push_back(arr[0]);\n\
    \        arr.erase(arr.begin());\n        gap--;\n    }\n    return res;", " \
    \   assert(0 <= k && k <= arr.size());\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> pq;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (pq.size() < k) {\n            pq.push(arr[i]);\n        } else {\n   \
    \         if (arr[i] > pq.top()) {\n                pq.pop();\n              \
    \  pq.push(arr[i]);\n            }\n        }\n    }\n    std::vector<long> ans;\n\
    \    while (!pq.empty()) {\n        ans.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(ans.begin(), ans.end());\n    return ans;", "    std::priority_queue<long>\
    \ pq;\n    for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n\
    \    }\n    std::vector<long> res;\n    while (k--) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "    std::vector<long> res;\n   \
    \ std::priority_queue<long> q;\n    int i = 0;\n    while(i < arr.size()){\n \
    \       q.push(arr[i]);\n        i++;\n    }\n    while(k--){\n        res.push_back(q.top());\n\
    \        q.pop();\n    }\n    return res;", "\tusing namespace std;\n\tpriority_queue<long,\
    \ vector<long>, greater<long>> pq;\n\tfor (auto i : arr) {\n\t\tif (pq.size()\
    \ < k) {\n\t\t\tpq.push(i);\n\t\t} else {\n\t\t\tlong min = pq.top();\n\t\t\t\
    if (i > min) {\n\t\t\t\tpq.pop();\n\t\t\t\tpq.push(i);\n\t\t\t}\n\t\t}\n\t}\n\t\
    vector<long> result;\n\twhile (!pq.empty()) {\n\t\tresult.push_back(pq.top());\n\
    \t\tpq.pop();\n\t}\n\treturn result;", "  std::vector<long> ans;\n  int i = 0;\n\
    \  while (i < k) {\n    long max = arr[0];\n    int max_idx = 0;\n    for (int\
    \ j = 0; j < arr.size(); j++) {\n      if (arr[j] > max) {\n        max = arr[j];\n\
    \        max_idx = j;\n      }\n    }\n    ans.push_back(max);\n    arr.erase(arr.begin()\
    \ + max_idx);\n    i++;\n  }\n  return ans;", "    // Solutions:\n    // + Sort\
    \ the array and return the first k elements.\n    // + Or:\n    // + Maintain\
    \ a map in sorted order. Add each element to the map, and remove the smallest\n\
    \    // + element of the map if the map has more than k elements.\n    // + Or:\n\
    \    // + Use a heap to keep track of the k largest elements.\n    std::sort(arr.begin(),\
    \ arr.end());\n    std::vector<long> result;\n    for (int i = arr.size() - 1;\
    \ i >= arr.size() - k; i--) {\n        result.push_back(arr[i]);\n    }\n    return\
    \ result;", "    // your code goes here\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> pq;\n    for(int i = 0; i < arr.size(); i++){\n        if(pq.size()\
    \ < k) pq.push(arr[i]);\n        else{\n            if(arr[i] > pq.top()){\n \
    \               pq.pop();\n                pq.push(arr[i]);\n            }\n \
    \       }\n    }\n    std::vector<long> ret;\n    while(!pq.empty()){\n      \
    \  ret.push_back(pq.top());\n        pq.pop();\n    }\n    return ret;", "   \
    \ std::priority_queue<long> pq;\n    for (int i = 0; i < arr.size(); i++) {\n\
    \        pq.push(arr[i]);\n    }\n    std::vector<long> res;\n    while (k--)\
    \ {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
  "    std::vector<long> result(k);\n    auto n = arr.size();\n    std::priority_queue<std::pair<long,\
    \ long>> pq;\n    for (int i = 0; i < n; i++) {\n        pq.push({arr[i], i});\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    for\
    \ (int i = k - 1; i >= 0; i--) {\n        result[i] = pq.top().first;\n      \
    \  pq.pop();\n    }\n    return result;", "  std::vector<long> result;\n  int\
    \ n = arr.size();\n  if (n == 0) return result;\n  if (k == 0) return result;\n\
    \  long min = arr[0];\n  for (int i = 0; i < n; i++) {\n    if (arr[i] < min)\
    \ min = arr[i];\n  }\n  if (min < 0) {\n    for (int i = 0; i < n; i++) {\n  \
    \    arr[i] -= min;\n    }\n  }\n  int len = arr.size();\n  if (k >= len) return\
    \ arr;\n  std::vector<long> result2;\n  for (int i = 0; i < k; i++) {\n    result2.push_back(arr[i]);\n\
    \  }\n  int minIndex = 0;\n  for (int i = k; i < len; i++) {\n    minIndex = getMinIndex(result2);\n\
    \    if (arr[i] > result2[minIndex]) {\n      result2[minIndex] = arr[i];\n  \
    \  }\n  }\n  if (min < 0) {\n    for (int i = 0; i < k; i++) {\n      result2[i]\
    \ += min;\n    }\n  }\n  return result2;", "    std::vector<long> res;\n    if\
    \ (k == 0) {\n        return res;\n    }\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> pq;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (pq.size() < k) {\n            pq.push(arr[i]);\n        } else {\n   \
    \         if (arr[i] > pq.top()) {\n                pq.pop();\n              \
    \  pq.push(arr[i]);\n            }\n        }\n    }\n    while (!pq.empty())\
    \ {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
  "  // initialize a result vector\n  std::vector<long> result;\n  // if k is 0, return\
    \ result\n  if (k == 0) {\n    return result;\n  }\n  // iterate through arr,\
    \ starting from the first number\n  for (int i = 0; i < arr.size(); i++) {\n \
    \   // if result is empty, append the number to result and continue to the next\
    \ number\n    if (result.empty()) {\n      result.push_back(arr[i]);\n      continue;\n\
    \    }\n    // if the number is larger than the first number in result, insert\
    \ the number in front of result\n    // and pop the last element of result\n \
    \   if (arr[i] > result[0]) {\n      result.insert(result.begin(), arr[i]);\n\
    \      result.pop_back();\n    }\n    // if the number is smaller than the last\
    \ number in result, append the number to result\n    else if (arr[i] < result[result.size()\
    \ - 1]) {\n      result.push_back(arr[i]);\n    }\n    // if the number is between\
    \ the first and last number in result, \n    // then compare the number with the\
    \ numbers in result from the end and insert\n    // the number at the first index\
    \ where the number is larger than the index's number\n    else {\n      for (int\
    \ j = result.size() - 1; j >= 0; j--) {\n        if (arr[i] > result[j]) {\n \
    \         result.insert(result.begin() + j + 1, arr[i]);\n          break;\n \
    \       }\n      }\n    }\n  }\n  // return result\n  return result;", "\tif (k\
    \ == 0) {\n\t\treturn {};\n\t}\n\tstd::vector<long> ans;\n\tfor (long i = 0; i\
    \ < arr.size(); i++) {\n\t\tif (ans.size() < k) {\n\t\t\tans.push_back(arr[i]);\n\
    \t\t}\n\t\telse {\n\t\t\tstd::sort(ans.begin(), ans.end());\n\t\t\tif (arr[i]\
    \ > ans[0]) {\n\t\t\t\tans[0] = arr[i];\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(ans.begin(),\
    \ ans.end());\n\treturn ans;", "    std::priority_queue<long> heap;\n    for (auto\
    \ it = arr.begin(); it != arr.end(); ++it) {\n        heap.push(*it);\n    }\n\
    \    std::vector<long> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    std::vector<long> ret;\n    std::multiset<long> st;\n\
    \    for (auto ele : arr) {\n        st.insert(ele);\n        if (st.size() >\
    \ k) {\n            st.erase(st.begin());\n        }\n    }\n    for (auto ele\
    \ : st) {\n        ret.push_back(ele);\n    }\n    std::reverse(ret.begin(), ret.end());\n\
    \    return ret;", "  vector<long> result;\n  if (arr.size() <= k) {\n    return\
    \ arr;\n  }\n  priority_queue<long, vector<long>, greater<long>> min_heap;\n \
    \ for (int i = 0; i < arr.size(); i++) {\n    if (min_heap.size() < k) {\n   \
    \   min_heap.push(arr[i]);\n    } else {\n      if (min_heap.top() < arr[i]) {\n\
    \        min_heap.pop();\n        min_heap.push(arr[i]);\n      }\n    }\n  }\n\
    \  while (!min_heap.empty()) {\n    result.push_back(min_heap.top());\n    min_heap.pop();\n\
    \  }\n  reverse(result.begin(), result.end());\n  return result;", "    std::vector<long>\
    \ res(k);\n    std::sort(arr.begin(), arr.end());\n    std::copy(arr.end() - k,\
    \ arr.end(), res.begin());\n    return res;", "\tstd::vector<long> res;\n\tstd::priority_queue<long>\
    \ pq;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tpq.push(arr[i]);\n\t}\n\t\
    while (!pq.empty() && k > 0) {\n\t\tres.push_back(pq.top());\n\t\tpq.pop();\n\t\
    \tk--;\n\t}\n\treturn res;", "    std::priority_queue<long> pq;\n    for (auto\
    \ x : arr) {\n        pq.push(x);\n        if (pq.size() > k) pq.pop();\n    }\n\
    \    std::vector<long> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    std::reverse(res.begin(), res.end());\n    return\
    \ res;", "    priority_queue<long, vector<long>, greater<long>> pq;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (pq.size() < k)\n            pq.push(arr[i]);\n\
    \        else {\n            if (arr[i] > pq.top()) {\n                pq.pop();\n\
    \                pq.push(arr[i]);\n            }\n        }\n    }\n    vector<long>\
    \ res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return res;", "    std::vector<long> result;\n    // Complete this\
    \ function\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ min_heap;\n    for (auto& num : arr) {\n        min_heap.push(num);\n      \
    \  if (min_heap.size() > k) {\n            min_heap.pop();\n        }\n    }\n\
    \    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n\
    \        min_heap.pop();\n    }\n    return result;", "    std::priority_queue<long>\
    \ arrMin(arr.begin(), arr.end());\n    std::vector<long> res;\n    for (int i\
    \ = 0; i < k; i++) {\n        res.push_back(arrMin.top());\n        arrMin.pop();\n\
    \    }\n    std::sort(res.begin(), res.end());\n    return res;", "  std::vector<long>\
    \ max_list;\n  if (k == 0) {\n    return max_list;\n  }\n  std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> max_heap;\n  for (auto num : arr) {\n\
    \    max_heap.push(num);\n    if (max_heap.size() > k) {\n      max_heap.pop();\n\
    \    }\n  }\n  while (!max_heap.empty()) {\n    max_list.push_back(max_heap.top());\n\
    \    max_heap.pop();\n  }\n  std::reverse(max_list.begin(), max_list.end());\n\
    \  return max_list;", "\tstd::multiset<long> st;\n\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\tif (st.size() < k) {\n\t\t\tst.insert(arr[i]);\n\t\t}\n\t\telse\
    \ {\n\t\t\tauto it = st.begin();\n\t\t\tif (arr[i] > *it) {\n\t\t\t\tst.erase(it);\n\
    \t\t\t\tst.insert(arr[i]);\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<long> res;\n\t\
    for (auto it = st.rbegin(); it != st.rend(); it++) {\n\t\tres.push_back(*it);\n\
    \t}\n\treturn res;", "    std::vector<long> result;\n    std::priority_queue<long>\
    \ pq;\n    for (long i : arr) {\n        pq.push(i);\n    }\n    for (long i =\
    \ 0; i < k; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n \
    \   }\n    return result;", "    std::priority_queue<long> pq;\n    for (long\
    \ v : arr) {\n        pq.push(v);\n        if (pq.size() > k) {\n            pq.pop();\n\
    \        }\n    }\n    std::vector<long> ans;\n    while (!pq.empty()) {\n   \
    \     ans.push_back(pq.top());\n        pq.pop();\n    }\n    return ans;", " \
    \   std::sort(arr.begin(), arr.end());\n    reverse(arr.begin(), arr.end());\n\
    \    std::vector<long> ans;\n    for(int i = 0; i < k; i++) {\n        ans.push_back(arr[i]);\n\
    \    }\n    return ans;", "    std::vector<long> ans;\n    int size = arr.size();\n\
    \    sort(arr.begin(), arr.end());\n    for(int i = size - 1; i >= size - k; i--)\
    \ {\n        ans.push_back(arr[i]);\n    }\n    return ans;", "  std::vector<long>\
    \ res;\n  int l = 0, r = arr.size() - 1;\n  while (l <= r) {\n    int i = l;\n\
    \    for (int j = l + 1; j <= r; j++) {\n      if (arr[j] > arr[i]) {\n      \
    \  i = j;\n      }\n    }\n    res.push_back(arr[i]);\n    if (res.size() == k)\
    \ {\n      break;\n    }\n    if (i == l) {\n      l++;\n    } else if (i == r)\
    \ {\n      r--;\n    } else {\n      l++;\n      r--;\n    }\n  }\n  return res;",
  "    std::vector<long> s;\n    long i,j;\n    for(i=0;i<k;i++)\n    {\n        s.push_back(arr[i]);\n\
    \    }\n    std::sort(s.begin(),s.end());\n    j=k;\n    while(j<arr.size())\n\
    \    {\n        if(arr[j]>s[0])\n        {\n            s.erase(s.begin());\n\
    \            s.push_back(arr[j]);\n            std::sort(s.begin(),s.end());\n\
    \        }\n        j++;\n    }\n    return s;", "    std::priority_queue<long>\
    \ pq;\n    std::vector<long> results;\n    int arrSize = arr.size();\n    if (arrSize\
    \ < k) {\n        for (int i = 0; i < arrSize; i++) {\n            pq.push(arr[i]);\n\
    \        }\n    } else {\n        for (int i = 0; i < k; i++) {\n            pq.push(arr[i]);\n\
    \        }\n        for (int i = k; i < arrSize; i++) {\n            if (arr[i]\
    \ > pq.top()) {\n                pq.pop();\n                pq.push(arr[i]);\n\
    \            }\n        }\n    }\n    while (!pq.empty()) {\n        results.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    std::reverse(results.begin(), results.end());\n\
    \    return results;", "    // std::cout << \"arr: \";\n    // for (auto v : arr)\
    \ {\n    //     std::cout << v << \" \";\n    // }\n    // std::cout << \"\\n\"\
    ;\n    // std::cout << \"k: \" << k << \"\\n\";\n    if (k == arr.size()) {\n\
    \        std::sort(arr.begin(), arr.end());\n        return arr;\n    }\n    std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> min_heap;\n    std::vector<long> result;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (min_heap.size() < k)\
    \ {\n            min_heap.push(arr[i]);\n        } else {\n            if (arr[i]\
    \ > min_heap.top()) {\n                min_heap.pop();\n                min_heap.push(arr[i]);\n\
    \            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n\
    \        min_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    std::vector<long> res;\n    int len = arr.size();\n\
    \    for (int i = 0; i < len; i++) {\n        // If there are enough items in\
    \ the vector and the current element\n        // is greater than the last item\
    \ in the vector then insert the\n        // current element at the right position\
    \ to keep the vector\n        // sorted.\n        while (res.size() > 0 && res.size()\
    \ + len - i > k && res.back() < arr[i])\n            res.pop_back();\n       \
    \ if (res.size() < k)\n            res.push_back(arr[i]);\n    }\n    return res;",
  "    std::priority_queue<long> pq;\n    for (auto &item : arr) {\n        pq.push(item);\n\
    \    }\n    std::vector<long> res;\n    while (k--) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "    // your code here\n    // priority_queue<long,\
    \ vector<long>, greater<long>> queue;\n    // priority_queue<long, vector<long>,\
    \ greater<long>> new_queue;\n    // for(long i = 0; i < arr.size(); i++){\n  \
    \  //     if(queue.size() < k){\n    //         queue.push(arr[i]);\n    //  \
    \   }else{\n    //         if(arr[i] > queue.top()){\n    //             queue.pop();\n\
    \    //             queue.push(arr[i]);\n    //         }\n    //     }\n    //\
    \ }\n    // for(long i = 0; i < k; i++){\n    //     new_queue.push(queue.top());\n\
    \    //     queue.pop();\n    // }\n    // vector<long> vector_result;\n    //\
    \ for(long i = 0; i < k; i++){\n    //     vector_result.push_back(new_queue.top());\n\
    \    //     new_queue.pop();\n    // }\n    // return vector_result;\n    priority_queue<long,\
    \ vector<long>, greater<long>> queue;\n    priority_queue<long, vector<long>,\
    \ greater<long>> new_queue;\n    for(long i = 0; i < arr.size(); i++){\n     \
    \   if(queue.size() < k){\n            queue.push(arr[i]);\n        }else{\n \
    \           if(arr[i] > queue.top()){\n                queue.pop();\n        \
    \        queue.push(arr[i]);\n            }\n        }\n    }\n    for(long i\
    \ = 0; i < k; i++){\n        new_queue.push(queue.top());\n        queue.pop();\n\
    \    }\n    vector<long> vector_result;\n    for(long i = 0; i < k; i++){\n  \
    \      vector_result.push_back(new_queue.top());\n        new_queue.pop();\n \
    \   }\n    return vector_result;", "\tpriority_queue<long, vector<long>, greater<long>>\
    \ min_heap;\n\tvector<long> ans;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\
    \tif (min_heap.size() < k) {\n\t\t\tmin_heap.push(arr[i]);\n\t\t}\n\t\telse {\n\
    \t\t\tif (arr[i] > min_heap.top()) {\n\t\t\t\tmin_heap.pop();\n\t\t\t\tmin_heap.push(arr[i]);\n\
    \t\t\t}\n\t\t}\n\t}\n\twhile (!min_heap.empty()) {\n\t\tans.push_back(min_heap.top());\n\
    \t\tmin_heap.pop();\n\t}\n\treverse(ans.begin(), ans.end());\n\treturn ans;",
  "    std::vector<long> ans;\n    std::priority_queue<long> pq;\n    for(auto x:\
    \ arr) {\n        pq.push(x);\n        if(pq.size() > k) {\n            pq.pop();\n\
    \        }\n    }\n    while(!pq.empty()) {\n        ans.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    std::reverse(ans.begin(), ans.end());\n    return\
    \ ans;", "  assert(arr.size() >= k);\n  std::vector<long> max;\n  std::make_heap(arr.begin(),\
    \ arr.end());\n  for (long i = 0; i < k; i++) {\n    max.push_back(arr.front());\n\
    \    std::pop_heap(arr.begin(), arr.end());\n    arr.pop_back();\n  }\n  return\
    \ max;", "  // I thought it might be faster to use min-heap than sort.\n  // It\
    \ is not.\n  std::vector<long> res;\n  if (k > arr.size()) {\n    res = arr;\n\
    \    return res;\n  }\n  res.reserve(k);\n  std::make_heap(arr.begin(), arr.end());\n\
    \  std::pop_heap(arr.begin(), arr.end());\n  arr.pop_back();\n  while (arr.size()\
    \ > k - 1) {\n    std::pop_heap(arr.begin(), arr.end());\n    arr.pop_back();\n\
    \  }\n  std::make_heap(arr.begin(), arr.end());\n  for (long i = k - 1; i >= 0;\
    \ i--) {\n    res.push_back(arr.front());\n    std::pop_heap(arr.begin(), arr.end());\n\
    \    arr.pop_back();\n  }\n  return res;", "    std::vector<long> max_k;\n   \
    \ std::vector<long>::iterator it;\n    while(k--){\n        it = std::max_element(arr.begin(),\
    \ arr.end());\n        max_k.push_back(*it);\n        arr.erase(it);\n    }\n\
    \    return max_k;", "\tstd::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ pq;\n\tfor (long i = 0; i < k; i++) {\n\t\tpq.push(arr[i]);\n\t}\n\tfor (long\
    \ i = k; i < arr.size(); i++) {\n\t\tif (arr[i] > pq.top()) {\n\t\t\tpq.pop();\n\
    \t\t\tpq.push(arr[i]);\n\t\t}\n\t}\n\tstd::vector<long> result;\n\twhile (!pq.empty())\
    \ {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\tstd::reverse(result.begin(),\
    \ result.end());\n\treturn result;", "    int len = arr.size();\n    if (k >=\
    \ len) {\n        sort(arr.begin(), arr.end());\n        return arr;\n    }\n\
    \    std::vector<long> res;\n    priority_queue<long, vector<long>, greater<long>>\
    \ pq;\n    for (int i = 0; i < len; i++) {\n        if (pq.size() < k) {\n   \
    \         pq.push(arr[i]);\n        } else {\n            if (arr[i] > pq.top())\
    \ {\n                pq.pop();\n                pq.push(arr[i]);\n           \
    \ }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    sort(res.begin(), res.end());\n    return res;",
  "    std::vector<long> res;\n    res.reserve(k);\n    // Using std::priority_queue\
    \ to sort elements in descending order.\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> pq;\n    for (auto num : arr) {\n        pq.push(num);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    while\
    \ (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n\
    \    return res;", "  if(k == 0) return {};\n  std::priority_queue<long> pq;\n\
    \  for(auto& i : arr) {\n    pq.push(i);\n    if(pq.size() > k) {\n      pq.pop();\n\
    \    }\n  }\n  std::vector<long> res;\n  while(pq.size()) {\n    res.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  std::reverse(res.begin(), res.end());\n  return res;",
  "    priority_queue<long, vector<long>, greater<long>> pq;\n    vector<long> result;\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n       \
    \ if(pq.size() > k) {\n            pq.pop();\n        }\n    }\n    while(!pq.empty())\
    \ {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    reverse(result.begin(),\
    \ result.end());\n    return result;", "\tstd::vector<long> result;\n\tstd::sort(arr.begin(),\
    \ arr.end());\n\tfor (int i = arr.size() - 1; i >= arr.size() - k; i--) {\n\t\t\
    result.push_back(arr[i]);\n\t}\n\treturn result;", "\tif (k > arr.size())\n\t\t\
    throw std::invalid_argument(\"K should be less than or equal to the length of\
    \ the array\");\n\tstd::vector<long> maxK(k);\n\tstd::make_heap(maxK.begin(),\
    \ maxK.end());\n\tstd::vector<long>::iterator it;\n\tfor (it = arr.begin(); it\
    \ != arr.end(); ++it) {\n\t\tif (*it > maxK.front()) {\n\t\t\tstd::pop_heap(maxK.begin(),\
    \ maxK.end());\n\t\t\tmaxK.pop_back();\n\t\t\tmaxK.push_back(*it);\n\t\t\tstd::push_heap(maxK.begin(),\
    \ maxK.end());\n\t\t}\n\t}\n\tstd::sort_heap(maxK.begin(), maxK.end());\n\treturn\
    \ maxK;", "  std::vector<long> res;\n  // your code here\n  // std::cout << \"\
    arr: \";\n  // for (auto e : arr) {\n  //   std::cout << e << \" \";\n  // }\n\
    \  // std::cout << std::endl;\n  // std::cout << \"k: \" << k << std::endl;\n\
    \  if (k == 0) {\n    return res;\n  }\n  std::vector<long> buffer;\n  for (auto\
    \ e : arr) {\n    if (buffer.size() < k) {\n      buffer.push_back(e);\n     \
    \ std::push_heap(buffer.begin(), buffer.end());\n    } else {\n      if (e > buffer[0])\
    \ {\n        std::pop_heap(buffer.begin(), buffer.end());\n        buffer.pop_back();\n\
    \        buffer.push_back(e);\n        std::push_heap(buffer.begin(), buffer.end());\n\
    \      }\n    }\n  }\n  // std::cout << \"buffer: \";\n  // for (auto e : buffer)\
    \ {\n  //   std::cout << e << \" \";\n  // }\n  // std::cout << std::endl;\n \
    \ std::sort_heap(buffer.begin(), buffer.end());\n  res = buffer;\n  return res;",
  "\tstd::vector<long> maxes;\n\tstd::priority_queue<long> pq;\n\tfor (long i = 0;\
    \ i < arr.size(); i++) {\n\t\tpq.push(arr[i]);\n\t}\n\tfor (long i = 0; i < k;\
    \ i++) {\n\t\tmaxes.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn maxes;",
  "    std::priority_queue<long> pq;\n    for (auto a : arr) {\n        pq.push(a);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    std::vector<long>\
    \ ret;\n    while (!pq.empty()) {\n        ret.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(ret.begin(), ret.end());\n    return ret;", "  // Your\
    \ code here\n  return {};", "    // int n = arr.size();\n    // int n = 1;\n \
    \   // std::vector<long> res;\n    // std::sort(arr.begin(), arr.end());\n   \
    \ // for (int i = n - 1; i >= n - k; i--) {\n    //     res.push_back(arr[i]);\n\
    \    // }\n    // return res;\n    std::priority_queue<long> pq;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n    std::vector<long>\
    \ res;\n    while (k > 0) {\n        res.push_back(pq.top());\n        pq.pop();\n\
    \        k--;\n    }\n    return res;", "    std::priority_queue<long> pq;\n \
    \   for (long l : arr) {\n        pq.push(l);\n        if (pq.size() > k) pq.pop();\n\
    \    }\n    std::vector<long> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    std::reverse(res.begin(), res.end());\n    return\
    \ res;", "    std::priority_queue<long> q;\n    for (auto &e : arr) {\n      \
    \  q.push(e);\n        if (q.size() > k) {\n            q.pop();\n        }\n\
    \    }\n    std::vector<long> result;\n    while (q.size()) {\n        result.push_back(q.top());\n\
    \        q.pop();\n    }\n    std::reverse(result.begin(), result.end());\n  \
    \  return result;", "    std::vector<long> result;\n    for (long i = 0; i < k;\
    \ i++) {\n        result.push_back(0);\n    }\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        long index = k - 1;\n        for (long j = k - 1; j >= 0; j--)\
    \ {\n            if (result[j] > arr[i]) {\n                index = j - 1;\n \
    \           }\n        }\n        if (index >= 0) {\n            for (long j =\
    \ 0; j < index; j++) {\n                result[j] = result[j + 1];\n         \
    \   }\n            result[index] = arr[i];\n        }\n    }\n    return result;",
  "    // your code here\n    std::sort(arr.begin(), arr.end());\n    std::vector<long>\
    \ res;\n    int j = arr.size() - 1;\n    for(int i = 0; i < k; i++){\n       \
    \ res.push_back(arr[j]);\n        j--;\n    }\n    return res;", "  std::vector<long>\
    \ max_arr;\n  if (k <= 0) {\n    return max_arr;\n  }\n\n  std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> pq;\n  for (auto e : arr) {\n    if (pq.size()\
    \ < k) {\n      pq.push(e);\n    } else {\n      if (e > pq.top()) {\n       \
    \ pq.pop();\n        pq.push(e);\n      }\n    }\n  }\n\n  max_arr.assign(pq.top(),\
    \ pq.top() + pq.size());\n  std::reverse(max_arr.begin(), max_arr.end());\n  return\
    \ max_arr;", "    std::vector<long> maxes;\n    for (auto i : arr) {\n       \
    \ while (maxes.size() && i > maxes.back() && maxes.size() + arr.size() - (int)\
    \ (&i - &arr[0]) > k)\n            maxes.pop_back();\n        if (maxes.size()\
    \ < k)\n            maxes.push_back(i);\n    }\n    return maxes;", "    std::vector<long>\
    \ result;\n    if (k == 0) return result;\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> pq;\n    for (auto i: arr) {\n        if (pq.size() < k)\
    \ {\n            pq.push(i);\n        } else {\n            if (i > pq.top())\
    \ {\n                pq.pop();\n                pq.push(i);\n            }\n \
    \       }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return result;", "    if (k == 0) return std::vector<long>();\n\
    \    if (k == arr.size()) return arr;\n    std::priority_queue<long> pq;\n   \
    \ for (int i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n        if\
    \ (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    std::vector<long>\
    \ res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(res.begin(), res.end());\n    return res;", "\tif (k\
    \ == 0) return {};\n\tif (k >= arr.size()) return arr;\n\tstd::vector<long> ans;\n\
    \tstd::sort(arr.begin(), arr.end());\n\twhile (k > 0) {\n\t\tans.push_back(arr[arr.size()\
    \ - 1]);\n\t\tarr.pop_back();\n\t\tk--;\n\t}\n\treturn ans;", "    std::priority_queue<long>\
    \ pq;\n    for (auto it = arr.begin(); it != arr.end(); ++it) {\n        pq.push(*it);\n\
    \    }\n    std::vector<long> res;\n    while (k--) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    std::reverse(res.begin(), res.end());\n    return\
    \ res;", '  // your code here', "  std::priority_queue<long> maxHeap;\n  int i;\n\
    \  for (i = 0; i < k; i++) {\n    maxHeap.push(arr[i]);\n  }\n  for (; i < arr.size();\
    \ i++) {\n    if (arr[i] > maxHeap.top()) {\n      maxHeap.pop();\n      maxHeap.push(arr[i]);\n\
    \    }\n  }\n  std::vector<long> ans;\n  while (!maxHeap.empty()) {\n    ans.push_back(maxHeap.top());\n\
    \    maxHeap.pop();\n  }\n  std::reverse(ans.begin(), ans.end());\n  return ans;",
  "    assert(arr.size() >= 1);\n    assert(arr.size() <= 1000);\n    for (auto el\
    \ : arr) {\n        assert(el >= -1000);\n        assert(el <= 1000);\n    }\n\
    \    assert(k >= 0);\n    assert(k <= arr.size());\n    std::vector<long> result;\n\
    \    std::vector<long> candidates;\n    for (auto el : arr) {\n        while (candidates.size()\
    \ > 0 && candidates.back() < el) {\n            candidates.pop_back();\n     \
    \   }\n        candidates.push_back(el);\n        if (candidates.size() > k) {\n\
    \            candidates.erase(candidates.begin());\n        }\n    }\n    for\
    \ (long i = 0; i < k; i++) {\n        result.push_back(candidates[i]);\n    }\n\
    \    return result;", "    priority_queue<long, std::vector<long>, std::greater<long>>\
    \ max_heap;\n    for (long i = 0; i < arr.size(); i++) {\n        if (max_heap.size()\
    \ == k) {\n            if (arr[i] > max_heap.top()) {\n                max_heap.pop();\n\
    \                max_heap.push(arr[i]);\n            }\n        } else {\n   \
    \         max_heap.push(arr[i]);\n        }\n    }\n    std::vector<long> result;\n\
    \    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n\
    \        max_heap.pop();\n    }\n    return result;", "  // Write your code here\n\
    \  std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n  for\
    \ (auto n : arr) {\n    pq.push(n);\n    if (pq.size() > k) {\n      pq.pop();\n\
    \    }\n  }\n  std::vector<long> res;\n  while (!pq.empty()) {\n    res.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  std::reverse(res.begin(), res.end());\n  return res;",
  "\tif (k < 0) return std::vector<long>{};\n\tif (k == 0) return std::vector<long>{};\n\
    \tif (k == 1) {\n\t\tauto it = std::max_element(arr.begin(), arr.end());\n\t\t\
    return std::vector<long>{ *it };\n\t}\n\tstd::multiset<long> ms(arr.begin(), arr.end());\n\
    \t// std::cout << \"after init ms = \";\n\t// for (const auto & e : ms) {\n\t\
    // \tstd::cout << e << \" \";\n\t// }\n\t// std::cout << std::endl;\n\tfor (int\
    \ i = 0; i < arr.size() - k; ++i) {\n\t\tauto it = ms.end();\n\t\t--it;\n\t\t\
    ms.erase(it);\n\t}\n\t// std::cout << \"after erase ms = \";\n\t// for (const\
    \ auto & e : ms) {\n\t// \tstd::cout << e << \" \";\n\t// }\n\t// std::cout <<\
    \ std::endl;\n\tstd::vector<long> ans(ms.begin(), ms.end());\n\tstd::reverse(ans.begin(),\
    \ ans.end());\n\treturn ans;", "  std::priority_queue<long> pq;\n  for (auto x\
    \ : arr) {\n    pq.push(x);\n    if (pq.size() > k) {\n      pq.pop();\n    }\n\
    \  }\n  std::vector<long> result;\n  while (!pq.empty()) {\n    result.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  std::reverse(result.begin(), result.end());\n  return result;",
  "  std::vector<long> result;\n  std::priority_queue<long> pq;\n  if (k == 0) return\
    \ result;\n  for (auto elm : arr) {\n    pq.push(elm);\n    if (pq.size() > k)\
    \ pq.pop();\n  }\n  while (!pq.empty()) {\n    result.push_back(pq.top());\n \
    \   pq.pop();\n  }\n  return result;", "    int n = arr.size();\n    // The maxheap\
    \ is a vector of the first k elements.\n    std::vector<long> maxheap(arr.begin(),\
    \ arr.begin() + k);\n    // Push_heap takes the elements in a range, and pushes\
    \ the first one\n    // to the correct position to make the rest of the elements\
    \ satisfy the maxheap property.\n    std::push_heap(maxheap.begin(), maxheap.end());\n\
    \    // All the remaining elements in arr will be used to update the maxheap,\n\
    \    // the maxheap will be updated until there is no more elements in arr.\n\
    \    for (int i = k; i < n; i++) {\n        // If the value of arr[i] is larger\
    \ than the top of the maxheap,\n        // it replaces the top element with arr[i],\
    \ and update the maxheap.\n        if (arr[i] > maxheap[0]) {\n            maxheap[0]\
    \ = arr[i];\n            std::push_heap(maxheap.begin(), maxheap.end());\n   \
    \     }\n    }\n    // A maxheap has been made, sort it to get the max k elements\
    \ in arr.\n    std::sort_heap(maxheap.begin(), maxheap.end());\n    return maxheap;",
  '  return std::vector<long>();', "    std::vector<long> res;\n    priority_queue<long,\
    \ vector<long>, greater<long>> q;\n\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        q.push(arr[i]);\n        if (q.size() > k) {\n            q.pop();\n\
    \        }\n    }\n\n    while (!q.empty()) {\n        res.push_back(q.top());\n\
    \        q.pop();\n    }\n\n    return res;", "  std::priority_queue<long> pq;\n\
    \  for (long e : arr) {\n    pq.push(e);\n    if (pq.size() > k) {\n      pq.pop();\n\
    \    }\n  }\n  std::vector<long> res;\n  while (!pq.empty()) {\n    res.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  return res;", "    std::vector<long> r(arr.begin(), arr.begin()\
    \ + k);\n    // TODO(improve)\n    std::sort(r.begin(), r.end());\n    return\
    \ r;", "\tstd::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (pq.size() < k) {\n\t\t\tpq.push(arr[i]);\n\
    \t\t} else {\n\t\t\tif (pq.top() < arr[i]) {\n\t\t\t\tpq.pop();\n\t\t\t\tpq.push(arr[i]);\n\
    \t\t\t}\n\t\t}\n\t}\n\tstd::vector<long> ans;\n\twhile (!pq.empty()) {\n\t\tans.push_back(pq.top());\n\
    \t\tpq.pop();\n\t}\n\tstd::reverse(ans.begin(), ans.end());\n\treturn ans;", " \
    \   std::priority_queue<long> pq;\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        pq.push(arr[i]);\n    }\n    std::vector<long> res;\n    while (k > 0)\
    \ {\n        long tmp = pq.top();\n        pq.pop();\n        res.push_back(tmp);\n\
    \        k--;\n    }\n    return res;", "    std::priority_queue<long> pq;\n \
    \   for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n\
    \    std::vector<long> ans;\n    for (long i = 0; i < k; i++) {\n        ans.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return ans;", "  std::vector<long> result;\n  for\
    \ (int i = 0; i < k; i++) {\n    int index = 0;\n    for (int j = 0; j < arr.size();\
    \ j++) {\n      if (arr[j] > arr[index]) index = j;\n    }\n    result.push_back(arr[index]);\n\
    \    arr.erase(arr.begin() + index);\n  }\n  return result;", "  // your code\
    \ goes here\n  std::vector<long> l(k);\n  if(k == 0)\n    return l;\n  std::partial_sort(arr.begin(),\
    \ arr.begin() + k, arr.end(), std::greater<int>());\n  return std::vector<long>(arr.begin(),\
    \ arr.begin() + k);", "    vector<long> sortedArray;\n    for(int i=0;i<k;i++){\n\
    \        sortedArray.push_back(arr[i]);\n    }\n    sort(sortedArray.begin(),sortedArray.end());\n\
    \    for(int i=k;i<arr.size();i++){\n        if(arr[i]>sortedArray[0]){\n    \
    \        sortedArray[0]=arr[i];\n            sort(sortedArray.begin(),sortedArray.end());\n\
    \        }\n    }\n    return sortedArray;", "\tassert(arr.size() == k);\n\tsort(arr.begin(),\
    \ arr.end());\n\treturn arr;", "  std::vector<long> result;\n  if (k <= 0) {\n\
    \    return result;\n  }\n  if (k >= arr.size()) {\n    return arr;\n  }\n  std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> pq;\n  for (long n : arr) {\n    if (pq.size()\
    \ < k) {\n      pq.push(n);\n    } else {\n      if (n > pq.top()) {\n       \
    \ pq.pop();\n        pq.push(n);\n      }\n    }\n  }\n  while (!pq.empty()) {\n\
    \    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;", "  std::priority_queue<long>\
    \ pq;\n  for (long i = 0; i < arr.size(); i++) {\n    pq.push(arr[i]);\n  }\n\
    \  std::vector<long> result;\n  while (k > 0) {\n    result.push_back(pq.top());\n\
    \    pq.pop();\n    k--;\n  }\n  return result;", "    std::vector<long> result;\n\
    \    if (k == 0) {\n        return result;\n    }\n    if (k >= arr.size()) {\n\
    \        return arr;\n    }\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> heap;\n    for (auto &i : arr) {\n        if (heap.size()\
    \ < k) {\n            heap.push(i);\n        } else {\n            if (i > heap.top())\
    \ {\n                heap.pop();\n                heap.push(i);\n            }\n\
    \        }\n    }\n    while (!heap.empty()) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    std::priority_queue<long> maxQueue;\n    for (const\
    \ auto& i : arr) {\n        maxQueue.push(i);\n    }\n    std::vector<long> res;\n\
    \    while (k-- > 0) {\n        res.push_back(maxQueue.top());\n        maxQueue.pop();\n\
    \    }\n    return res;", "  std::priority_queue<long> pq;\n  for (auto i = 0;\
    \ i < arr.size(); i++) {\n    pq.push(arr[i]);\n  }\n  std::vector<long> max;\n\
    \  for (int i = 0; i < k; i++) {\n    max.push_back(pq.top());\n    pq.pop();\n\
    \  }\n  return max;", "\tint l = arr.size();\n\tint *arr2 = new int[l];\n\tfor\
    \ (int i = 0; i < l; i++)\n\t\tarr2[i] = arr[i];\n\tstd::make_heap(arr2, arr2\
    \ + l);\n\tstd::vector<long> res;\n\tfor (int i = 0; i < k; i++) {\n\t\tres.push_back(arr2[0]);\n\
    \t\tstd::pop_heap(arr2, arr2 + l - i);\n\t}\n\treturn res;", "    // Implement\
    \ the solution here.\n    std::vector<long> res(k);\n    for(int i=0;i<k;i++){\n\
    \        res[i] = LONG_MIN;\n    }\n    std::priority_queue<long> pq;\n    for(auto\
    \ x:arr){\n        pq.push(x);\n    }\n    for(int i=0;i<k;i++){\n        res[i]\
    \ = pq.top();\n        pq.pop();\n    }\n    std::sort(res.begin(),res.end());\n\
    \    return res;", "    if (k == 0) {\n        return {};\n    }\n    if (k >=\
    \ arr.size()) {\n        std::sort(arr.begin(), arr.end());\n        return arr;\n\
    \    }\n    std::priority_queue<long> pq;\n    for (long l : arr) {\n        pq.push(l);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    std::vector<long>\
    \ ans;\n    while (!pq.empty()) {\n        ans.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(ans.begin(), ans.end());\n    return ans;", "    std::vector<long>\
    \ res;\n    std::priority_queue<long> q;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        q.push(arr[i]);\n    }\n    while (k--) {\n        res.push_back(q.top());\n\
    \        q.pop();\n    }\n    return res;", "    std::vector<long> result;\n \
    \   int n = arr.size();\n    // we need to find maximum k elements in arr\n  \
    \  // for which we will use maxheap\n    std::priority_queue<long> pq;\n    for(int\
    \ i = 0; i < k; i++) {\n        pq.push(arr[i]);\n    }\n    for(int i = k; i\
    \ < n; i++) {\n        if(arr[i] > pq.top()) {\n            pq.pop();\n      \
    \      pq.push(arr[i]);\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return result;", "\tstd::vector<long> result;\n\
    \tstd::priority_queue<long> pq;\n\tfor (long x : arr) {\n\t\tpq.push(x);\n\t\t\
    if (pq.size() > k)\n\t\t\tpq.pop();\n\t}\n\twhile (!pq.empty()) {\n\t\tresult.push_back(pq.top());\n\
    \t\tpq.pop();\n\t}\n\tstd::reverse(result.begin(), result.end());\n\treturn result;",
  "    std::vector<long> temp;\n    int i;\n    for(i=0;i<k;i++)\n    {\n        temp.push_back(arr[i]);\n\
    \    }\n    std::sort(temp.begin(),temp.end());\n    for(i=k;i<arr.size();i++)\n\
    \    {\n        if(arr[i]>temp[0])\n        {\n            temp[0]=arr[i];\n \
    \           std::sort(temp.begin(),temp.end());\n        }\n    }\n    return\
    \ temp;", "  std::vector<long> res;\n  std::priority_queue<long> pq;\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    pq.push(arr[i]);\n  }\n  for (int i = 0;\
    \ i < k; i++) {\n    res.push_back(pq.top());\n    pq.pop();\n  }\n  return res;",
  "    int size = arr.size();\n    // Add your code here.\n    sort(arr.begin(), arr.end());\n\
    \    std::vector<long> ans;\n    for(int i = size - 1; i >= size - k; i--)\n \
    \       ans.push_back(arr[i]);\n    return ans;", "    std::vector<long> max_k(k);\n\
    \    std::priority_queue<long> max_heap;\n    for (long n : arr) {\n        max_heap.push(n);\n\
    \        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n\
    \    }\n    for (long i = k - 1; i >= 0; i--) {\n        max_k[i] = max_heap.top();\n\
    \        max_heap.pop();\n    }\n    return max_k;", "    std::vector<long> res;\n\
    \    if (k == 0) return res;\n    std::multiset<long> s;\n    for (long i = 0;\
    \ i < k; i++) {\n        s.insert(arr[i]);\n    }\n    for (long i = k; i < arr.size();\
    \ i++) {\n        if (arr[i] > *s.begin()) {\n            s.erase(s.begin());\n\
    \            s.insert(arr[i]);\n        }\n    }\n    for (auto x : s) {\n   \
    \     res.push_back(x);\n    }\n    return res;", "    std::vector<long> result;\n\
    \    if (k < 1) {\n        return result;\n    }\n    if (k == 1) {\n        long\
    \ max = arr[0];\n        for (long i = 1; i < arr.size(); i++) {\n           \
    \ if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n\
    \        result.push_back(max);\n        return result;\n    }\n    std::sort(arr.begin(),\
    \ arr.end());\n    long pos = arr.size() - 1;\n    long counter = 0;\n    while\
    \ (counter < k) {\n        result.push_back(arr[pos]);\n        pos--;\n     \
    \   counter++;\n    }\n    return result;", "  std::vector<long> ans(k);\n  for\
    \ (int i = 0; i < k; i++) {\n    ans[i] = INT_MIN;\n  }\n  for (int i = 0; i <\
    \ arr.size(); i++) {\n    if (arr[i] > ans[0]) {\n      ans[0] = arr[i];\n   \
    \   std::sort(ans.begin(), ans.end());\n    }\n  }\n  return ans;", "  std::priority_queue<long>\
    \ heap;\n  for (auto i : arr) {\n    heap.push(i);\n  }\n  std::vector<long> res;\n\
    \  for (auto i = 0; i < k; i++) {\n    res.push_back(heap.top());\n    heap.pop();\n\
    \  }\n  return res;", "    int n = arr.size();\n    if (n == k) return arr;\n\
    \    std::vector<long> k_max;\n    for (int i = 0; i < k; i++) {\n        int\
    \ max_ind = 0;\n        for (int j = 0; j < n; j++) {\n            if (arr[j]\
    \ > arr[max_ind]) max_ind = j;\n        }\n        k_max.push_back(arr[max_ind]);\n\
    \        arr[max_ind] = -99999999999999;\n    }\n    return k_max;", "    assert(k\
    \ >= 0);\n    std::vector<long> stack;\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        int size = stack.size();\n        while (size > 0 && arr[i] > stack[size\
    \ - 1] && k - size <= arr.size() - i) {\n            stack.pop_back();\n     \
    \       size--;\n        }\n        if (size < k) {\n            stack.push_back(arr[i]);\n\
    \        }\n    }\n    return stack;", "    std::vector<long> result;\n    if\
    \ (k == 0) {\n        return result;\n    }\n    if (k >= arr.size()) {\n    \
    \    sort(arr.begin(), arr.end());\n        return arr;\n    }\n    std::priority_queue<long>\
    \ PQ;\n    for (int i = 0; i < arr.size(); i++) {\n        PQ.push(arr[i]);\n\
    \    }\n    for (int i = 0; i < k; i++) {\n        result.push_back(PQ.top());\n\
    \        PQ.pop();\n    }\n    return result;", "\t// Write your code here\n \
    \   std::vector<long> res;\n    int n = arr.size();\n    assert(k >= 0 && k <=\
    \ n);\n    if(k == 0)\n        return res;\n    for(int i = 0; i < k; i++){\n\
    \        int maxIdx = i;\n        for(int j = i + 1; j < n; j++){\n          \
    \  if(arr[j] > arr[maxIdx])\n                maxIdx = j;\n        }\n        res.push_back(arr[maxIdx]);\n\
    \        std::swap(arr[i], arr[maxIdx]);\n    }\n    return res;", "  assert(k\
    \ <= arr.size());\n  priority_queue<long, vector<long>, greater<long>> pq;\n \
    \ for (long i = 0; i < arr.size(); i++) {\n    if (pq.size() < k) {\n      pq.push(arr[i]);\n\
    \    } else {\n      if (arr[i] > pq.top()) {\n        pq.pop();\n        pq.push(arr[i]);\n\
    \      }\n    }\n  }\n  vector<long> ans;\n  while (!pq.empty()) {\n    ans.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  reverse(ans.begin(), ans.end());\n  return ans;", "  std::priority_queue<long>\
    \ heap;\n  for (auto v : arr) {\n    heap.push(v);\n    if (heap.size() > k) heap.pop();\n\
    \  }\n  std::vector<long> ans;\n  while (heap.size()) {\n    ans.push_back(heap.top());\n\
    \    heap.pop();\n  }\n  return ans;", "    std::priority_queue<long> pq;\n  \
    \  for (auto item : arr)\n        pq.push(item);\n    std::vector<long> results;\n\
    \    while (k--) {\n        results.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return results;", "    std::vector<long> ans(k);\n    std::priority_queue<long>\
    \ max_heap;\n    for (auto x : arr) {\n        max_heap.push(x);\n        if (max_heap.size()\
    \ > k) {\n            max_heap.pop();\n        }\n    }\n    int count = 0;\n\
    \    while (!max_heap.empty()) {\n        ans[count++] = max_heap.top();\n   \
    \     max_heap.pop();\n    }\n    return ans;", "\tint i = 0;\n\twhile (i < k)\
    \ {\n\t\tint m = i;\n\t\tfor (int j = i + 1; j < arr.size(); j++) {\n\t\t\tif\
    \ (arr[j] > arr[m]) {\n\t\t\t\tm = j;\n\t\t\t}\n\t\t}\n\t\tstd::swap(arr[i], arr[m]);\n\
    \t\ti++;\n\t}\n\tarr.resize(k);\n\treturn arr;", "  std::vector<long> result;\n\
    \  for (auto n : arr) {\n    while (!result.empty() && result.back() < n && result.size()\
    \ + arr.size() - std::distance(arr.begin(), std::find(arr.begin(), arr.end(),\
    \ n)) > k) {\n      result.pop_back();\n    }\n    if (result.size() < k) {\n\
    \      result.push_back(n);\n    }\n  }\n  return result;"]
stop_tokens:
- "\n}"
