language: cpp
name: HumanEval_148_bf
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> d;\n    if (planet1 ==\
    \ \"Mercury\"){\n        if (planet2 == \"Venus\"){\n            d.push_back(\"\
    Venus\");\n        }\n        else if (planet2 == \"Earth\"){\n            d.push_back(\"\
    Venus\");\n            d.push_back(\"Earth\");\n        }\n        else if (planet2\
    \ == \"Mars\"){\n            d.push_back(\"Venus\");\n            d.push_back(\"\
    Earth\");\n            d.push_back(\"Mars\");\n        }\n        else if (planet2\
    \ == \"Jupiter\"){\n            d.push_back(\"Venus\");\n            d.push_back(\"\
    Earth\");\n            d.push_back(\"Mars\");\n            d.push_back(\"Jupiter\"\
    );\n        }\n        else if (planet2 == \"Saturn\"){\n            d.push_back(\"\
    Venus\");\n            d.push_back(\"Earth\");\n            d.push_back(\"Mars\"\
    );\n            d.push_back(\"Jupiter\");\n            d.push_back(\"Saturn\"\
    );\n        }\n        else if (planet2 == \"Uranus\"){\n            d.push_back(\"\
    Venus\");\n            d.push_back(\"Earth\");\n            d.push_back(\"Mars\"\
    );\n            d.push_back(\"Jupiter\");\n            d.push_back(\"Saturn\"\
    );\n            d.push_back(\"Uranus\");\n        }\n        else if (planet2\
    \ == \"Neptune\"){\n            d.push_back(\"Venus\");\n            d.push_back(\"\
    Earth\");\n            d.push_back(\"Mars\");\n            d.push_back(\"Jupiter\"\
    );\n            d.push_back(\"Saturn\");\n            d.push_back(\"Uranus\");\n\
    \            d.push_back(\"Neptune\");\n        }\n    }\n    else if (planet1\
    \ == \"Venus\"){\n        if (planet2 == \"Earth\"){\n            d.push_back(\"\
    Earth\");\n        }\n        else if (planet2 == \"Mars\"){\n            d.push_back(\"\
    Earth\");\n            d.push_back(\"Mars\");\n        }\n       \n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpki_cym92.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpki_cym92.cpp:75:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   75 |\
    \ int main() {\n      |            ^\n/tmp/tmpki_cym92.cpp:84:1: error: expected\
    \ \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmpki_cym92.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmpki_cym92.cpp:84:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   84 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660114013
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> solarsystem = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> res;\n  if (std::find(solarsystem.begin(), solarsystem.end(),\
    \ planet1) == solarsystem.end() || std::find(solarsystem.begin(), solarsystem.end(),\
    \ planet2) == solarsystem.end()) {\n    return res;\n  }\n  int planet1Idx = std::find(solarsystem.begin(),\
    \ solarsystem.end(), planet1) - solarsystem.begin();\n  int planet2Idx = std::find(solarsystem.begin(),\
    \ solarsystem.end(), planet2) - solarsystem.begin();\n  if (planet1Idx > planet2Idx)\
    \ {\n    std::swap(planet1Idx, planet2Idx);\n  }\n  for (int i = planet1Idx +\
    \ 1; i < planet2Idx; i++) {\n    res.push_back(solarsystem[i]);\n  }\n  return\
    \ res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> s={\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\t\
    std::vector<std::string> res;\n\tint min=-1, max=-1;\n\tfor(int i=0; i<s.size();\
    \ i++){\n\t\tif(planet1==s[i]) min=i;\n\t\tif(planet2==s[i]) max=i;\n\t}\n\tif(min==-1||max==-1)\
    \ return res;\n\tif(min>max) std::swap(min, max);\n\tfor(int i=min+1; i<max; i++)\
    \ res.push_back(s[i]);\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\",\n        \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"\n    };\n    std::map<std::string, int> i;\n    for (int\
    \ j = 0; j < planets.size(); j++) {\n        i[planets[j]] = j;\n    }\n    int\
    \ p1, p2;\n    auto f1 = i.find(planet1);\n    auto f2 = i.find(planet2);\n  \
    \  if (f1 == i.end() || f2 == i.end()) {\n        return {};\n    }\n    p1 =\
    \ f1->second;\n    p2 = f2->second;\n    if (p1 > p2) {\n        std::swap(p1,\
    \ p2);\n    }\n    std::vector<std::string> res;\n    for (int j = p1 + 1; j <\
    \ p2; j++) {\n        res.push_back(planets[j]);\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    static const std::vector<std::string> planets =\
    \ {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n\
    \    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n    if (it1\
    \ == planets.end() || it2 == planets.end())\n        return {};\n    std::vector<std::string>\
    \ sol;\n    if (it1 < it2) {\n        while (it1 != it2) {\n            sol.push_back(*it1);\n\
    \            it1++;\n        }\n    } else {\n        while (it1 != it2) {\n \
    \           sol.push_back(*it1);\n            it1--;\n        }\n    }\n    return\
    \ sol;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpwsjye_5d: /tmp/tmpwsjye_5d.cpp:41: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n      \
    \  \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\
    \n    };\n    std::vector<std::string> res;\n    std::vector<std::string>::iterator\
    \ p1 = std::find(planets.begin(), planets.end(), planet1);\n    std::vector<std::string>::iterator\
    \ p2 = std::find(planets.begin(), planets.end(), planet2);\n    if (p1 == planets.end()\
    \ || p2 == planets.end())\n        return res;\n    if (p1 > p2) {\n        auto\
    \ tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n    }\n    for (auto it = p1;\
    \ it <= p2; it++) {\n        res.push_back(*it);\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp73hu_x0f: /tmp/tmp73hu_x0f.cpp:47: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> planet1_after;\n  std::vector<std::string> result;\n\
    \  int k = 0;\n  for (int i = 0; i < planets.size(); i++) {\n    if (planets[i]\
    \ == planet1) {\n      k = i;\n    }\n  }\n  for (int i = k; i < planets.size();\
    \ i++) {\n    planet1_after.push_back(planets[i]);\n  }\n  for (int i = 0; i <\
    \ planet1_after.size(); i++) {\n    if (planet1_after[i] == planet2) {\n     \
    \ break;\n    }\n    result.push_back(planet1_after[i]);\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp0pnwz36c: /tmp/tmp0pnwz36c.cpp:42: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> res;\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::map<std::string, int> planet2index;\n  \
    \  for (int i = 0; i < planets.size(); i++)\n        planet2index[planets[i]]\
    \ = i;\n    if (planet2index.find(planet1) == planet2index.end() || planet2index.find(planet2)\
    \ == planet2index.end())\n        return res;\n    int left = std::min(planet2index[planet1],\
    \ planet2index[planet2]);\n    int right = std::max(planet2index[planet1], planet2index[planet2]);\n\
    \    for (int i = left + 1; i < right; i++)\n        res.push_back(planets[i]);\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> solar_system{\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> planets_between;\n    int idx1 = -1, idx2 = -1;\n\
    \    for (int i = 0; i < solar_system.size(); i++) {\n        if (solar_system[i]\
    \ == planet1) {\n            idx1 = i;\n        }\n        if (solar_system[i]\
    \ == planet2) {\n            idx2 = i;\n        }\n    }\n    if (idx1 == -1 ||\
    \ idx2 == -1) {\n        return planets_between;\n    }\n    if (idx1 < idx2)\
    \ {\n        for (int i = idx1 + 1; i < idx2; i++) {\n            planets_between.push_back(solar_system[i]);\n\
    \        }\n    } else {\n        for (int i = idx2 + 1; i < idx1; i++) {\n  \
    \          planets_between.push_back(solar_system[i]);\n        }\n    }\n   \
    \ return planets_between;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    static const std::vector<std::string> planets =\
    \ { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\" };\n    std::vector<std::string> result;\n    for (int i = 0; i\
    \ < planets.size(); i++) {\n        if (planets[i] == planet1) {\n           \
    \ int j = i + 1;\n            while (planets[j] != planet2) {\n              \
    \  result.push_back(planets[j]);\n                j++;\n            }\n      \
    \      break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::logic_error'\n  what():\
    \  basic_string::_M_construct null not valid\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::string names[] = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string>\
    \ namesVec(names, names + 8);\n\tint first = -1, second = -1;\n\tfor (int i =\
    \ 0; i < 8; i++) {\n\t\tif (names[i] == planet1) {\n\t\t\tfirst = i;\n\t\t}\n\t\
    \tif (names[i] == planet2) {\n\t\t\tsecond = i;\n\t\t}\n\t}\n\tstd::vector<std::string>\
    \ result;\n\tif (first == -1 || second == -1) {\n\t\treturn result;\n\t}\n\tint\
    \ start = first < second ? first : second;\n\tint end = first < second ? second\
    \ : first;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tresult.push_back(names[i]);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> result = {};\n\tstd::vector<std::string>\
    \ planets = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\" };\n\tint p1 = 0;\n\tint p2 = 0;\n\tfor (int i = 0;\
    \ i < planets.size(); i++) {\n\t\tif (planets[i] == planet1)\n\t\t\tp1 = i;\n\t\
    \tif (planets[i] == planet2)\n\t\t\tp2 = i;\n\t}\n\tif (p1 == 0 || p2 == 0)\n\t\
    \treturn result;\n\tif (p1 > p2) {\n\t\tint temp = p1;\n\t\tp1 = p2;\n\t\tp2 =\
    \ temp;\n\t}\n\tfor (int i = p1 + 1; i < p2; i++) {\n\t\tresult.push_back(planets[i]);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpynig1v4b: /tmp/tmpynig1v4b.cpp:45: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Mercury\") {\n        if (planet2\
    \ == \"Mercury\") {\n            return {};\n        } else if (planet2 == \"\
    Venus\") {\n            return {\"Venus\"};\n        } else if (planet2 == \"\
    Earth\") {\n            return {\"Venus\", \"Earth\"};\n        } else if (planet2\
    \ == \"Mars\") {\n            return {\"Venus\", \"Earth\", \"Mars\"};\n     \
    \   } else if (planet2 == \"Jupiter\") {\n            return {\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\"};\n        } else if (planet2 == \"Saturn\") {\n     \
    \       return {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n  \
    \      } else if (planet2 == \"Uranus\") {\n            return {\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n        } else if (planet2\
    \ == \"Neptune\") {\n            return {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n        } else {\n            return\
    \ {};\n        }\n    } else if (planet1 == \"Venus\") {\n        if (planet2\
    \ == \"Mercury\") {\n            return {};\n        } else if (planet2 == \"\
    Venus\") {\n            return {};\n        } else if (planet2 == \"Earth\") {\n\
    \            return {\"Earth\"};\n        } else if (planet2 == \"Mars\") {\n\
    \            return {\"Earth\", \"Mars\"};\n        } else if (planet2 == \"Jupiter\"\
    ) {\n            return {\"Earth\", \"Mars\", \"Jupiter\"};\n        } else if\
    \ (planet2 == \"Saturn\") {\n            return {\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"};\n        } else if (planet2 == \"Uranus\") {\n            return\
    \ {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n        } else\
    \ if (planet2 == \"Neptune\") {\n            return {\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n        } else {\n\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpxxo_m751.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpxxo_m751.cpp:60:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   60 |\
    \ int main() {\n      |            ^\n/tmp/tmpxxo_m751.cpp:69:1: error: expected\
    \ \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmpxxo_m751.cpp:40:36:\
    \ note: to match this \u2018{\u2019\n   40 |     } else if (planet1 == \"Venus\"\
    ) {\n      |                                    ^\n/tmp/tmpxxo_m751.cpp:69:1:\
    \ error: expected \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmpxxo_m751.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmpxxo_m751.cpp:69:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   69 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114013
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tconst std::map<std::string, int> planets = {\n\t\t\
    {\"Mercury\", 1},\n\t\t{\"Venus\", 2},\n\t\t{\"Earth\", 3},\n\t\t{\"Mars\", 4},\n\
    \t\t{\"Jupiter\", 5},\n\t\t{\"Saturn\", 6},\n\t\t{\"Uranus\", 7},\n\t\t{\"Neptune\"\
    , 8}\n\t};\n\tconst auto n1 = planets.find(planet1);\n\tconst auto n2 = planets.find(planet2);\n\
    \tif (n1 == planets.end() || n2 == planets.end()) {\n\t\treturn {};\n\t}\n\tconst\
    \ int idx1 = std::min(n1->second, n2->second);\n\tconst int idx2 = std::max(n1->second,\
    \ n2->second);\n\tstd::vector<std::string> res;\n\tfor (int i = idx1; i < idx2;\
    \ ++i) {\n\t\tfor (const auto& p : planets) {\n\t\t\tif (p.second == i) {\n\t\t\
    \t\tres.push_back(p.first);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmps2cpa0zn: /tmp/tmps2cpa0zn.cpp:49: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> result;\n\t//Planets from\
    \ the Sun (by Proximity)\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tint index_planet1 = -1;\n\tint index_planet2 = -1;\n\t// Search for the\
    \ index of planet1\n\tfor (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i]\
    \ == planet1) {\n\t\t\tindex_planet1 = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Search\
    \ for the index of planet2\n\tfor (int i = 0; i < planets.size(); i++) {\n\t\t\
    if (planets[i] == planet2) {\n\t\t\tindex_planet2 = i;\n\t\t\tbreak;\n\t\t}\n\t\
    }\n\t// If the names of planets are correct\n\tif (index_planet1 != -1 && index_planet2\
    \ != -1) {\n\t\t// If planet1 is closer to the Sun\n\t\tif (index_planet1 < index_planet2)\
    \ {\n\t\t\tfor (int i = index_planet1 + 1; i < index_planet2; i++) {\n\t\t\t\t\
    result.push_back(planets[i]);\n\t\t\t}\n\t\t}\n\t\t// If planet2 is closer to\
    \ the Sun\n\t\telse {\n\t\t\tfor (int i = index_planet2 + 1; i < index_planet1;\
    \ i++) {\n\t\t\t\tresult.push_back(planets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tauto solarSystem = std::vector<std::string> {\n\t\t\
    \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"\n\t};\n\tauto firstPlanet = std::find(solarSystem.begin(), solarSystem.end(),\
    \ planet1);\n\tauto secondPlanet = std::find(solarSystem.begin(), solarSystem.end(),\
    \ planet2);\n\tstd::vector<std::string> result;\n\tif (firstPlanet == solarSystem.end()\
    \ || secondPlanet == solarSystem.end()) {\n\t\treturn result;\n\t}\n\tresult.reserve(std::distance(firstPlanet,\
    \ secondPlanet) - 1);\n\tfor (auto it = firstPlanet + 1; it != secondPlanet; ++it)\
    \ {\n\t\tresult.push_back(*it);\n\t}\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  vector::reserve\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    //std::unordered_map<std::string, int> umap;\n \
    \   std::map<std::string, int> umap;\n    std::vector<std::string> planets = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \n                                \
    \        \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    for (int i =\
    \ 0; i < planets.size(); i++)\n        umap[planets[i]] = i;\n    int idx1 = umap[planet1];\n\
    \    int idx2 = umap[planet2];\n    if (idx1 == -1 || idx2 == -1)\n        return\
    \ {};\n    int a = std::min(idx1, idx2);\n    int b = std::max(idx1, idx2);\n\
    \    std::vector<std::string> v(planets.begin() + a + 1, planets.begin() + b);\n\
    \    return v;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets;\n    planets.push_back(\"\
    Mercury\");\n    planets.push_back(\"Venus\");\n    planets.push_back(\"Earth\"\
    );\n    planets.push_back(\"Mars\");\n    planets.push_back(\"Jupiter\");\n  \
    \  planets.push_back(\"Saturn\");\n    planets.push_back(\"Uranus\");\n    planets.push_back(\"\
    Neptune\");\n    std::vector<std::string> res;\n    int p1 = -1;\n    int p2 =\
    \ -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            p1 = i;\n        }\n        if (planets[i] == planet2)\
    \ {\n            p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n\
    \        return res;\n    }\n    int i = p1 + 1;\n    if (p1 > p2) {\n       \
    \ while (i != p2) {\n            res.push_back(planets[i]);\n            i = (i\
    \ + 1) % 8;\n        }\n    } else {\n        while (i != p2) {\n            res.push_back(planets[i]);\n\
    \            i = (i + 1) % 8;\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpigkjbhdt: /tmp/tmpigkjbhdt.cpp:60: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114015
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> res, planets = { \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tint start = -1, end = -1;\n\tfor (int i = 0; i < planets.size(); i++)\
    \ {\n\t\tif (planets[i] == planet1) start = i;\n\t\tif (planets[i] == planet2)\
    \ end = i;\n\t}\n\tif (start == -1 || end == -1) return res;\n\tfor (int i = std::min(start,\
    \ end) + 1; i < std::max(start, end); i++) {\n\t\tres.push_back(planets[i]);\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tint idx1 = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \tint idx2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \tif (idx1 >= planets.size() || idx2 >= planets.size())\n\t\treturn std::vector<std::string>();\n\
    \tstd::vector<std::string> res(planets.begin() + std::min(idx1, idx2) + 1, planets.begin()\
    \ + std::max(idx1, idx2));\n\treturn res;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    //converting string to lower case\
    \ to allow for mixed-case input\n    for (int i = 0; i < planet1.length(); i++)\
    \ {\n        planet1[i] = tolower(planet1[i]);\n    }\n    for (int i = 0; i <\
    \ planet2.length(); i++) {\n        planet2[i] = tolower(planet2[i]);\n    }\n\
    \    //if planets are the same, return empty list\n    if (planet1 == planet2)\
    \ {\n        return result;\n    }\n    bool planet1_found = false;\n    bool\
    \ planet2_found = false;\n    bool direction_forward = false;\n    //determine\
    \ if planets are found in the planet list,\n    //and determine if loop in list\
    \ will be forward or backward\n    for (int i = 0; i < planets.size(); i++) {\n\
    \        if (planets[i] == planet1) {\n            planet1_found = true;\n   \
    \     }\n        if (planets[i] == planet2) {\n            planet2_found = true;\n\
    \        }\n        if (planets[i] == planet1 && planets[i + 1] == planet2) {\n\
    \            direction_forward = true;\n        }\n        if (planets[i] == planet2\
    \ && planets[i + 1] == planet1) {\n            direction_forward = false;\n  \
    \      }\n    }\n    //if planets aren't found, return empty list\n    if (!planet1_found\
    \ || !planet2_found) {\n        return result;\n    }\n    //iterate through planet\
    \ list and add planets to result vector\n    if (direction_forward) {\n      \
    \  for (int i = 0; i < planets.size(); i++) {\n            if (planets[i] == planet1)\
    \ {\n                for (int j = i + 1; j < planets.size(); j++) {\n        \
    \            if (planets[j] == planet2) {\n                        break;\n  \
    \                 \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoobywlv1.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpoobywlv1.cpp:65:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   65 |\
    \ int main() {\n      |            ^\n/tmp/tmpoobywlv1.cpp:74:1: error: expected\
    \ \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpoobywlv1.cpp:60:62:\
    \ note: to match this \u2018{\u2019\n   60 |                 for (int j = i +\
    \ 1; j < planets.size(); j++) {\n      |                                     \
    \                         ^\n/tmp/tmpoobywlv1.cpp:74:1: error: expected \u2018\
    }\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpoobywlv1.cpp:59:40: note:\
    \ to match this \u2018{\u2019\n   59 |             if (planets[i] == planet1)\
    \ {\n      |                                        ^\n/tmp/tmpoobywlv1.cpp:74:1:\
    \ error: expected \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpoobywlv1.cpp:58:50:\
    \ note: to match this \u2018{\u2019\n   58 |         for (int i = 0; i < planets.size();\
    \ i++) {\n      |                                                  ^\n/tmp/tmpoobywlv1.cpp:74:1:\
    \ error: expected \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpoobywlv1.cpp:57:28:\
    \ note: to match this \u2018{\u2019\n   57 |     if (direction_forward) {\n  \
    \    |                            ^\n/tmp/tmpoobywlv1.cpp:74:1: error: expected\
    \ \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmpoobywlv1.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmpoobywlv1.cpp:74:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   74 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114013
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> res;\n\tbool flag1 = false, flag2 = false;\n\t\
    std::vector<std::string>::iterator it1, it2;\n\tfor (auto it = planets.begin();\
    \ it != planets.end(); it++) {\n\t\tif (*it == planet1) {\n\t\t\tflag1 = true;\n\
    \t\t\tit1 = it;\n\t\t}\n\t\tif (*it == planet2) {\n\t\t\tflag2 = true;\n\t\t\t\
    it2 = it;\n\t\t}\n\t}\n\tif (flag1 && flag2) {\n\t\tif (it1 < it2) {\n\t\t\tit1++;\n\
    \t\t\twhile (it1 != it2) {\n\t\t\t\tres.push_back(*it1);\n\t\t\t\tit1++;\n\t\t\
    \t}\n\t\t}\n\t\telse {\n\t\t\tit2++;\n\t\t\twhile (it2 != it1) {\n\t\t\t\tres.push_back(*it2);\n\
    \t\t\t\tit2++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::logic_error'\n  what():\
    \  basic_string::_M_construct null not valid\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // See these for some help with vector, find and\
    \ conditionals:\n    // https://en.cppreference.com/w/cpp/container/vector\n \
    \   // https://en.cppreference.com/w/cpp/algorithm/find\n    // https://en.cppreference.com/w/cpp/language/if\n\
    \    // https://en.cppreference.com/w/cpp/language/operator_logical\n    // https://en.cppreference.com/w/cpp/language/operator_relational\n\
    \    std::vector<std::string> planets{\n        \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    };\n    // Your\
    \ code goes here\n    if ((find(planets.begin(), planets.end(), planet1) == planets.end())\
    \ || (find(planets.begin(), planets.end(), planet2) == planets.end())) {\n   \
    \     std::vector<std::string> result;\n        return result;\n    }\n    else\
    \ {\n        int start = -1;\n        int finish = -1;\n        for (int i = 0;\
    \ i < planets.size(); i++) {\n            if (planets[i] == planet1) {\n     \
    \           start = i;\n            }\n            if (planets[i] == planet2)\
    \ {\n                finish = i;\n            }\n        }\n        std::vector<std::string>\
    \ result;\n        if (start < finish) {\n            for (int i = start + 1;\
    \ i < finish; i++) {\n                result.push_back(planets[i]);\n        \
    \    }\n        }\n        else {\n            for (int i = finish + 1; i < start;\
    \ i++) {\n                result.push_back(planets[i]);\n            }\n     \
    \   }\n        return result;\n    }\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> res;\n  if (planet1.compare(\"\
    Mercury\") == 0) {\n    if (planet2.compare(\"Venus\") == 0)\n      res.push_back(\"\
    Venus\");\n    else if (planet2.compare(\"Earth\") == 0) {\n      res.push_back(\"\
    Venus\");\n      res.push_back(\"Earth\");\n    }\n    else if (planet2.compare(\"\
    Mars\") == 0) {\n      res.push_back(\"Venus\");\n      res.push_back(\"Earth\"\
    );\n      res.push_back(\"Mars\");\n    }\n    else if (planet2.compare(\"Jupiter\"\
    ) == 0) {\n      res.push_back(\"Venus\");\n      res.push_back(\"Earth\");\n\
    \      res.push_back(\"Mars\");\n      res.push_back(\"Jupiter\");\n    }\n  \
    \  else if (planet2.compare(\"Saturn\") == 0) {\n      res.push_back(\"Venus\"\
    );\n      res.push_back(\"Earth\");\n      res.push_back(\"Mars\");\n      res.push_back(\"\
    Jupiter\");\n      res.push_back(\"Saturn\");\n    }\n    else if (planet2.compare(\"\
    Uranus\") == 0) {\n      res.push_back(\"Venus\");\n      res.push_back(\"Earth\"\
    );\n      res.push_back(\"Mars\");\n      res.push_back(\"Jupiter\");\n      res.push_back(\"\
    Saturn\");\n      res.push_back(\"Uranus\");\n    }\n    else if (planet2.compare(\"\
    Neptune\") == 0) {\n      res.push_back(\"Venus\");\n      res.push_back(\"Earth\"\
    );\n      res.push_back(\"Mars\");\n      res.push_back(\"Jupiter\");\n      res.push_back(\"\
    Saturn\");\n      res.push_back(\"Uranus\");\n      res.push_back(\"Neptune\"\
    );\n    }\n  }\n  else if (planet1.compare(\"Venus\") == 0) {\n    if (planet2.compare(\"\
    Earth\") == 0)\n      res.push\n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1p13h2e1.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmp1p13h2e1.cpp:66:11: error: \u2018\
    class std::vector<std::__cxx11::basic_string<char> >\u2019 has no member named\
    \ \u2018push\u2019\n   66 |       res.push\n      |           ^~~~\n/tmp/tmp1p13h2e1.cpp:68:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   68 | int main() {\n      |            ^\n/tmp/tmp1p13h2e1.cpp:77:1: error:\
    \ expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmp1p13h2e1.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmp1p13h2e1.cpp:77:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   77 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660114013
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> res;\n    std::vector<std::string>\
    \ planets{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1;\n    for (int i = 0;\
    \ i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n         \
    \   pos1 = i;\n        }\n        if (planets[i] == planet2) {\n            pos2\
    \ = i;\n        }\n    }\n    if (pos1 < 0 || pos2 < 0) {\n        return res;\n\
    \    }\n    if (pos1 < pos2) {\n        for (int i = pos1 + 1; i < pos2; i++)\
    \ {\n            res.push_back(planets[i]);\n        }\n    } else {\n       \
    \ for (int i = pos2 + 1; i < pos1; i++) {\n            res.push_back(planets[i]);\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    auto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if (it1 == planets.end() || it2 == planets.end()) {\n       \
    \ return res;\n    }\n    auto it = it1;\n    while(true) {\n        it++;\n \
    \       if (it == it2) {\n            break;\n        }\n        res.push_back(*it);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::logic_error'\n  what():\
    \  basic_string::_M_construct null not valid\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\n    \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \n  };\n  std::vector<std::string> res;\n  auto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n  auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n  if (it1 == planets.end() || it2 == planets.end()) {\n    return\
    \ res;\n  }\n  if (it1 > it2) {\n    std::swap(it1, it2);\n  }\n  res.assign(it1\
    \ + 1, it2);\n  return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> res;\n  std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n  int i = 0;\n  int j = planets.size() - 1;\n  for\
    \ (i = 0; i < planets.size(); i++) {\n    if (planets[i] == planet1) {\n     \
    \ break;\n    }\n  }\n  for (j = planets.size() - 1; j >= 0; j--) {\n    if (planets[j]\
    \ == planet2) {\n      break;\n    }\n  }\n  if (i == planets.size() || j == -1)\
    \ {\n    return res;\n  }\n  for (int t = i + 1; t < j; t++) {\n    res.push_back(planets[t]);\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpu83x0stw: /tmp/tmpu83x0stw.cpp:45: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114015
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    if (std::find(planets.begin(), planets.end(),\
    \ planet1) == planets.end() || std::find(planets.begin(), planets.end(), planet2)\
    \ == planets.end())\n        return res;\n    int fst = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int snd = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (fst > snd)\n        std::swap(fst,\
    \ snd);\n    for (int i = fst + 1; i < snd; i++)\n        res.push_back(planets[i]);\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // Use an unordered_map to make a quick lookup table\
    \ for the planets and their distance from the sun.\n    std::unordered_map<std::string,\
    \ int> planets = {\n        {\"Mercury\", 58}, {\"Venus\", 108}, {\"Earth\", 150},\
    \ {\"Mars\", 228},\n        {\"Jupiter\", 778}, {\"Saturn\", 1427}, {\"Uranus\"\
    , 2871}, {\"Neptune\", 4504}\n    };\n    // use the find function to look up\
    \ the planets and their distance.\n    auto it1 = planets.find(planet1);\n   \
    \ auto it2 = planets.find(planet2);\n    // If the planets cannot be found then\
    \ return an empty vector.\n    if(it1 == planets.end() || it2 == planets.end())\
    \ {\n        return {};\n    }\n    // Store the planets and their distances from\
    \ the sun in variables.\n    int d1 = it1->second;\n    int d2 = it2->second;\n\
    \    // Determine which planet has the shorter distance.\n    std::string first_planet\
    \ = (d1 < d2) ? planet1 : planet2;\n    std::string second_planet = (d1 < d2)\
    \ ? planet2 : planet1;\n    // Create a vector to store the planets that lie between\
    \ the two planets.\n    std::vector<std::string> planets_between;\n    // Loop\
    \ through all the planets.\n    for(auto planet: planets) {\n        // Check\
    \ if the current planet is between the two planets.\n        if(planet.second\
    \ > planets[first_planet] && planet.second < planets[second_planet]) {\n     \
    \       // If the planet is between the two planets then add it to the vector.\n\
    \            planets_between.push_back(planet.first);\n        }\n    }\n    //\
    \ Return the vector with all the planets between the two planets.\n    return\
    \ planets_between;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp4tul2n01: /tmp/tmp4tul2n01.cpp:53: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::map<std::string, std::string> planets_sun;\n\
    \    planets_sun[\"Mercury\"] = \"Sun\";\n    planets_sun[\"Venus\"] = \"Sun\"\
    ;\n    planets_sun[\"Earth\"] = \"Sun\";\n    planets_sun[\"Mars\"] = \"Sun\"\
    ;\n    planets_sun[\"Jupiter\"] = \"Sun\";\n    planets_sun[\"Saturn\"] = \"Sun\"\
    ;\n    planets_sun[\"Uranus\"] = \"Sun\";\n    planets_sun[\"Neptune\"] = \"Sun\"\
    ;\n    if (planets_sun.find(planet1) == planets_sun.end() || planets_sun.find(planet2)\
    \ == planets_sun.end()) {\n        return std::vector<std::string>();\n    }\n\
    \    std::map<std::string, int> planets_sun_position;\n    planets_sun_position[\"\
    Mercury\"] = 1;\n    planets_sun_position[\"Venus\"] = 2;\n    planets_sun_position[\"\
    Earth\"] = 3;\n    planets_sun_position[\"Mars\"] = 4;\n    planets_sun_position[\"\
    Jupiter\"] = 5;\n    planets_sun_position[\"Saturn\"] = 6;\n    planets_sun_position[\"\
    Uranus\"] = 7;\n    planets_sun_position[\"Neptune\"] = 8;\n    if (planets_sun_position[planet1]\
    \ > planets_sun_position[planet2]) {\n        std::string temp = planet1;\n  \
    \      planet1 = planet2;\n        planet2 = temp;\n    }\n    std::vector<std::string>\
    \ result;\n    for (auto it = planets_sun_position.begin(); it != planets_sun_position.end();\
    \ it++) {\n        if (it->second > planets_sun_position[planet1] && it->second\
    \ < planets_sun_position[planet2]) {\n            result.push_back(it->first);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp6z_39yky: /tmp/tmp6z_39yky.cpp:58: int main(): Assertion `candidate(("Mercury"),
    ("Uranus")) == (std::vector<std::string>({(std::string)"Venus", (std::string)"Earth",
    (std::string)"Mars", (std::string)"Jupiter", (std::string)"Saturn"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114015
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> solar_system = {\n\t\t\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n\tstd::vector<std::string> result;\n\tint index_planete1 = std::find(solar_system.begin(),\
    \ solar_system.end(), planet1) - solar_system.begin();\n\tint index_planete2 =\
    \ std::find(solar_system.begin(), solar_system.end(), planet2) - solar_system.begin();\n\
    \tif (index_planete1 >= solar_system.size() || index_planete2 >= solar_system.size())\
    \ {\n\t\treturn result;\n\t}\n\tstd::sort(solar_system.begin(), solar_system.end());\n\
    \tif (index_planete1 < index_planete2) {\n\t\tfor (int i = index_planete1 + 1;\
    \ i < index_planete2; i++) {\n\t\t\tresult.push_back(solar_system[i]);\n\t\t}\n\
    \t}\n\telse {\n\t\tfor (int i = index_planete2 + 1; i < index_planete1; i++) {\n\
    \t\t\tresult.push_back(solar_system[i]);\n\t\t}\n\t}\n\treturn result;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmph7d3je6_: /tmp/tmph7d3je6_.cpp:44: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = { \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n    std::vector<std::string> res;\n    int pos1 = 0, pos2 = 0;\n    for\
    \ (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) pos1\
    \ = i;\n        if (planets[i] == planet2) pos2 = i;\n    }\n    if (pos1 == 0\
    \ || pos2 == 0) return res;\n    if (pos1 == pos2) return res;\n    if (pos1 >\
    \ pos2) {\n        std::swap(pos1, pos2);\n    }\n    for (int i = pos1 + 1; i\
    \ < pos2; i++) {\n        res.push_back(planets[i]);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmprqhj0n0n: /tmp/tmprqhj0n0n.cpp:40: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::string planets[] = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tint start,\
    \ end;\n\tbool s, e;\n\ts = e = false;\n\tfor (int i = 0; i < 8; i++) {\n\t\t\
    if (planets[i] == planet1) {\n\t\t\tstart = i;\n\t\t\ts = true;\n\t\t}\n\t\tif\
    \ (planets[i] == planet2) {\n\t\t\tend = i;\n\t\t\te = true;\n\t\t}\n\t}\n\tif\
    \ (!s || !e) {\n\t\treturn std::vector<std::string>();\n\t}\n\tstd::vector<std::string>\
    \ result;\n\tfor (int i = start; i <= end; i++) {\n\t\tresult.push_back(planets[i]);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmprg22i6vy: /tmp/tmprg22i6vy.cpp:45: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i, j;\n    for (i = 0; i < planets.size();\
    \ i++) {\n        if (planets[i] == planet1) {\n            break;\n        }\n\
    \    }\n    for (j = 0; j < planets.size(); j++) {\n        if (planets[j] ==\
    \ planet2) {\n            break;\n        }\n    }\n    int k = j;\n    while\
    \ (k != i) {\n        result.push_back(planets[k]);\n        k = (k + 1) % planets.size();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp4ce_hn6q: /tmp/tmp4ce_hn6q.cpp:42: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::string planets[8] = {\"Mercury\", \"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string>\
    \ res;\n  int i1 = -1, i2 = -1;\n  for (int i = 0; i < 8; i++) {\n    if (planets[i]\
    \ == planet1) i1 = i;\n    if (planets[i] == planet2) i2 = i;\n  }\n  if (i1 <\
    \ 0 || i2 < 0) return res;\n  if (i1 > i2) return res;\n  for (int i = i1 + 1;\
    \ i < i2; i++) res.push_back(planets[i]);\n  return res;\n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpghp5wu0g: /tmp/tmpghp5wu0g.cpp:35: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114013
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planetList = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> answer;\n\tbool isPlanet1Found = false;\n\tbool\
    \ isPlanet2Found = false;\n\tint planet1Index;\n\tint planet2Index;\n\t// check\
    \ if planet 1 or planet 2 are planets\n\tfor (int i = 0; i < planetList.size();\
    \ i++) {\n\t\tif (planetList[i] == planet1) {\n\t\t\tisPlanet1Found = true;\n\t\
    \t\tplanet1Index = i;\n\t\t}\n\t\tif (planetList[i] == planet2) {\n\t\t\tisPlanet2Found\
    \ = true;\n\t\t\tplanet2Index = i;\n\t\t}\n\t}\n\t// if planet 1 and planet 2\
    \ are planets, then go into loop and store answer\n\tif (isPlanet1Found == true\
    \ && isPlanet2Found == true) {\n\t\tif (planet1Index < planet2Index) {\n\t\t\t\
    for (int i = planet1Index; i < planet2Index; i++) {\n\t\t\t\tanswer.push_back(planetList[i]);\n\
    \t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = planet2Index; i < planet1Index;\
    \ i++) {\n\t\t\t\tanswer.push_back(planetList[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ answer;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpikrpsq8u: /tmp/tmpikrpsq8u.cpp:54: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114015
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tint i = 0;\n\tint p1, p2;\n\tfor (i = 0; i < planets.size(); i++) {\n\t\t\
    if (planets[i] == planet1) {\n\t\t\tp1 = i;\n\t\t}\n\t\tif (planets[i] == planet2)\
    \ {\n\t\t\tp2 = i;\n\t\t}\n\t}\n\tif (p1 > p2) {\n\t\tint t = p1;\n\t\tp1 = p2;\n\
    \t\tp2 = t;\n\t}\n\tstd::vector<std::string> res;\n\tfor (i = p1 + 1; i < p2;\
    \ i++) {\n\t\tres.push_back(planets[i]);\n\t}\n\treturn res;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"\n    };\n    std::vector<std::string> result;\n    auto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if(it1 == planets.end() || it2 == planets.end()) {\n        return\
    \ result;\n    }\n    auto start = it1 > it2 ? it2 : it1;\n    auto end = it1\
    \ > it2 ? it1 : it2;\n    while(start != end) {\n        result.push_back(*start);\n\
    \        start++;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpzp3bb3hl: /tmp/tmpzp3bb3hl.cpp:39: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    for (int i = std::min(p1, p2) + 1; i < std::max(p1, p2);\
    \ i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planets[] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::vector<std::string> output;\n    if ((planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    ) &&\n    (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\")) {\n        int p1 = 0;\n \
    \       int p2 = 0;\n        for (int i = 0; i < 8; i++) {\n            if (planets[i]\
    \ == planet1) {\n                p1 = i;\n            }\n            if (planets[i]\
    \ == planet2) {\n                p2 = i;\n            }\n        }\n        if\
    \ (p1 < p2) {\n            for (int i = p1 + 1; i < p2; i++) {\n             \
    \   output.push_back(planets[i]);\n            }\n        }\n        else {\n\
    \            for (int i = p2 + 1; i < p1; i++) {\n                output.push_back(planets[i]);\n\
    \            }\n        }\n    }\n    return output;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> solar_system = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    if (planet1 == \"Mercury\" && planet2\
    \ == \"Uranus\") {\n        result = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"};\n    } else if (planet1 == \"Earth\" && planet2 == \"Mercury\"\
    ) {\n        result = {\"Venus\"};\n    } else if (planet1 == \"Jupiter\" && planet2\
    \ == \"Neptune\") {\n        result = {\"Saturn\", \"Uranus\"};\n    } else {\n\
    \        result = {};\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpuu53s66y: /tmp/tmpuu53s66y.cpp:38: int main(): Assertion `candidate(("Neptune"),
    ("Venus")) == (std::vector<std::string>({(std::string)"Earth", (std::string)"Mars",
    (std::string)"Jupiter", (std::string)"Saturn", (std::string)"Uranus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114015
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> res;\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int x = -1, y = -1;\n    for (int i = 0; i <\
    \ planets.size(); i++) {\n        if (planets[i] == planet1) {\n            x\
    \ = i;\n        }\n        if (planets[i] == planet2) {\n            y = i;\n\
    \        }\n    }\n    if (x == -1 || y == -1) {\n        return res;\n    }\n\
    \    if (x > y) {\n        std::swap(x, y);\n    }\n    while (x < y) {\n    \
    \    res.push_back(planets[x++]);\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp74dswx_q: /tmp/tmp74dswx_q.cpp:44: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  // your code here\n  int p1 = find(planets.begin(), planets.end(), planet1)\
    \ - planets.begin();\n  int p2 = find(planets.begin(), planets.end(), planet2)\
    \ - planets.begin();\n  std::vector<std::string> res;\n  if (p1 == 8 || p2 ==\
    \ 8) return res;\n  if (p1 > p2) {\n    int temp = p1;\n    p1 = p2;\n    p2 =\
    \ temp;\n  }\n  return std::vector<std::string>(planets.begin() + p1 + 1, planets.begin()\
    \ + p2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114014
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\t// Please write the function body\n\tstd::string p[]\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n\tstd::vector<std::string> v;\n\tint a, b;\n\tfor(int\
    \ i = 0; i < 8; i++) {\n\t\tif(p[i] == planet1) a = i;\n\t\tif(p[i] == planet2)\
    \ b = i;\n\t}\n\tfor(int i = a + 1; i < b; i++) v.push_back(p[i]);\n\treturn v;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpdf69g7uf: /tmp/tmpdf69g7uf.cpp:34: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114013
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> answer;\n    int pos1, pos2;\n    for (size_t\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) pos1 =\
    \ i;\n        if (planets[i] == planet2) pos2 = i;\n    }\n    if (pos1 > pos2)\
    \ {\n        std::swap(pos1, pos2);\n    }\n    for (size_t i = pos1 + 1; i <\
    \ pos2; i++) {\n        answer.push_back(planets[i]);\n    }\n    return answer;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114014
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> res;\n  std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n  std::unordered_map<std::string,int> planets_to_idx;\n\
    \  for(int i = 0; i < planets.size(); i++) {\n    planets_to_idx[planets[i]] =\
    \ i;\n  }\n  if(planets_to_idx.find(planet1) == planets_to_idx.end() || planets_to_idx.find(planet2)\
    \ == planets_to_idx.end()) {\n    return res;\n  }\n  int low = std::min(planets_to_idx[planet1],\
    \ planets_to_idx[planet2]);\n  int high = std::max(planets_to_idx[planet1], planets_to_idx[planet2]);\n\
    \  for(int i = low+1; i < high; i++) {\n    res.push_back(planets[i]);\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114016
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // Write your code here\n    std::vector<std::string>\
    \ str;\n    std::string planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::map<std::string,\
    \ int> mp;\n    for(int i = 0; i < 8; i++)\n        mp[planets[i]] = i;\n    int\
    \ f = mp[planet1], l = mp[planet2];\n    for(int i = f; i < l; i++)\n        str.push_back(planets[i]);\n\
    \    return str;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp_nww9r99: /tmp/tmp_nww9r99.cpp:33: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114016
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    auto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if(it1 != planets.end() && it2 != planets.end()){\n        std::reverse(planets.begin(),\
    \ planets.end());\n        std::reverse(it1, planets.end());\n        std::reverse(it2,\
    \ planets.end());\n        std::copy(it1, it2, std::back_inserter(result));\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp0eiuesr5: /tmp/tmp0eiuesr5.cpp:34: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // your code here\n    std::vector<std::string>\
    \ res;\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1,\
    \ pos2;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) pos1 = i;\n        if (planets[i] == planet2) pos2 = i;\n    }\n\
    \    int min = std::min(pos1, pos2);\n    int max = std::max(pos1, pos2);\n  \
    \  for (int i = min + 1; i < max; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpnaoyon_o: /tmp/tmpnaoyon_o.cpp:43: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"\n    };\n    std::vector<std::string> closest;\n    int p1 = -1,\
    \ p2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) p1 = i;\n        if (planets[i] == planet2) p2 = i;\n    }\n   \
    \ if (p1 > p2) {\n        p1 ^= p2;\n        p2 ^= p1;\n        p1 ^= p2;\n  \
    \  }\n    for (int i = p1 + 1; i < p2; i++) closest.push_back(planets[i]);\n \
    \   return closest;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmptf0hzemm: /tmp/tmptf0hzemm.cpp:45: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\t\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmph8g19viq: /tmp/tmph8g19viq.cpp:24: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114016
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> list_of_planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    bool planet1_exist = false;\n  \
    \  bool planet2_exist = false;\n    int planet1_index = 0;\n    int planet2_index\
    \ = 0;\n    for (int i = 0; i < list_of_planets.size(); i++) {\n        if (list_of_planets[i]\
    \ == planet1) {\n            planet1_exist = true;\n            planet1_index\
    \ = i;\n        }\n        if (list_of_planets[i] == planet2) {\n            planet2_exist\
    \ = true;\n            planet2_index = i;\n        }\n    }\n    if (planet1_exist\
    \ && planet2_exist) {\n        if (planet1_index < planet2_index) {\n        \
    \    for (int i = planet1_index + 1; i < planet2_index; i++) {\n             \
    \   result.push_back(list_of_planets[i]);\n            }\n        } else {\n \
    \           for (int i = planet2_index + 1; i < planet1_index; i++) {\n      \
    \          result.push_back(list_of_planets[i]);\n            }\n        }\n \
    \   } else {\n        return result;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114016
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  if (planet1 == \"Mercury\") {\n    if (planet2 ==\
    \ \"Venus\")\n      return {};\n    if (planet2 == \"Earth\")\n      return {\"\
    Venus\"};\n    if (planet2 == \"Mars\")\n      return {\"Venus\", \"Earth\"};\n\
    \    if (planet2 == \"Jupiter\")\n      return {\"Venus\", \"Earth\", \"Mars\"\
    };\n    if (planet2 == \"Saturn\")\n      return {\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\"};\n    if (planet2 == \"Uranus\")\n      return {\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"};\n    if (planet2 == \"Neptune\")\n     \
    \ return {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    };\n  }\n  if (planet1 == \"Venus\") {\n    if (planet2 == \"Earth\")\n      return\
    \ {};\n    if (planet2 == \"Mars\")\n      return {\"Earth\"};\n    if (planet2\
    \ == \"Jupiter\")\n      return {\"Earth\", \"Mars\"};\n    if (planet2 == \"\
    Saturn\")\n      return {\"Earth\", \"Mars\", \"Jupiter\"};\n    if (planet2 ==\
    \ \"Uranus\")\n      return {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n\
    \    if (planet2 == \"Neptune\")\n      return {\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"};\n  }\n  if (planet1 == \"Earth\") {\n    if (planet2\
    \ == \"Mars\")\n      return {};\n    if (planet2 == \"Jupiter\")\n      return\
    \ {\"Mars\"};\n    if (planet2 == \"Saturn\")\n      return {\"Mars\", \"Jupiter\"\
    };\n    if (planet2 == \"Uranus\")\n      return {\"Mars\", \"Jupiter\", \"Saturn\"\
    };\n    if (planet2 == \"Neptune\")\n      return {\"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"};\n  }\n  if (planet1 == \"Mars\") {\n    if (planet2 == \"Jupiter\"\
    )\n      return {};\n   \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp76hf8n95.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmp76hf8n95.cpp:67:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   67 |\
    \ int main() {\n      |            ^\n/tmp/tmp76hf8n95.cpp:76:1: error: expected\
    \ \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmp76hf8n95.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmp76hf8n95.cpp:76:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   76 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114016
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> plan_list{\"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> ans;\n    int low = 1, high = 8;\n    for(int\
    \ i = 0; i < 8; i++) {\n        if(planet1 == plan_list[i]) low = i;\n       \
    \ if(planet2 == plan_list[i]) high = i;\n    }\n    if(low > high) return ans;\n\
    \    for(int i = low + 1; i < high; i++) {\n        ans.push_back(plan_list[i]);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp4x3x90sk: /tmp/tmp4x3x90sk.cpp:36: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // Write your code here\n    return {};\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp6u87jo_y: /tmp/tmp6u87jo_y.cpp:25: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets{\n        \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \n    };\n    // returns the index of the given planet name\n    auto get_index\
    \ = [&planets](std::string planet) {\n        auto it = std::find(planets.begin(),\
    \ planets.end(), planet);\n        if (it == planets.end()) {\n            //\
    \ not found\n            return planets.size();\n        }\n        return std::distance(planets.begin(),\
    \ it);\n    };\n    auto planet1_index = get_index(planet1);\n    auto planet2_index\
    \ = get_index(planet2);\n    if (planet1_index == planets.size() || planet2_index\
    \ == planets.size()) {\n        // both planets don't exist\n        return {};\n\
    \    }\n    if (planet1_index > planet2_index) {\n        // swap\n        auto\
    \ tmp = planet1_index;\n        planet1_index = planet2_index;\n        planet2_index\
    \ = tmp;\n    }\n    return std::vector<std::string>(planets.begin() + planet1_index\
    \ + 1, planets.begin() + planet2_index);\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeymp9gp6.cpp: In lambda function:\n/tmp/tmpeymp9gp6.cpp:30:49:\
    \ error: inconsistent types \u2018long unsigned int\u2019 and \u2018long int\u2019\
    \ deduced for lambda return type\n   30 |         return std::distance(planets.begin(),\
    \ it);\n      |                                                 ^\n"
  stdout: ''
  timestamp: 1660114016
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    const char* planets[] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  const int begin = [&]() {\n        for (int i = 0; i < 8; ++i) {\n        \
    \    if (planets[i] == planet1) return i;\n        }\n        return 0;\n    }();\n\
    \    const int end = [&]() {\n        for (int i = 0; i < 8; ++i) {\n        \
    \    if (planets[i] == planet2) return i;\n        }\n        return 8;\n    }();\n\
    \    const int size = end - begin;\n    std::vector<std::string> res(size);\n\
    \    std::copy(planets + begin, planets + end, res.begin());\n    return res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp6pfgtwej: /tmp/tmp6pfgtwej.cpp:40: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> solar_system = { \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tint pos1 = 0, pos2 = 0;\n\tstd::vector<std::string> v;\n\tfor (int i =\
    \ 0; i < solar_system.size(); i++) {\n\t\tif (solar_system[i] == planet1)\n\t\t\
    \tpos1 = i;\n\t\tif (solar_system[i] == planet2)\n\t\t\tpos2 = i;\n\t}\n\tif (pos1\
    \ == 0 || pos2 == 0)\n\t\treturn v;\n\telse if (pos1 < pos2) {\n\t\tfor (int i\
    \ = pos1 + 1; i < pos2; i++)\n\t\t\tv.push_back(solar_system[i]);\n\t}\n\telse\
    \ {\n\t\tfor (int i = pos2 + 1; i < pos1; i++)\n\t\t\tv.push_back(solar_system[i]);\n\
    \t}\n\treturn v;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmplqa9rr5u: /tmp/tmplqa9rr5u.cpp:44: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> res;\n    if (planet1 ==\
    \ \"Mercury\") {\n        if (planet2 == \"Venus\") {\n            res.push_back(\"\
    Venus\");\n        } else if (planet2 == \"Earth\") {\n            res.push_back(\"\
    Venus\");\n            res.push_back(\"Earth\");\n        } else if (planet2 ==\
    \ \"Mars\") {\n            res.push_back(\"Venus\");\n            res.push_back(\"\
    Earth\");\n            res.push_back(\"Mars\");\n        } else if (planet2 ==\
    \ \"Jupiter\") {\n            res.push_back(\"Venus\");\n            res.push_back(\"\
    Earth\");\n            res.push_back(\"Mars\");\n            res.push_back(\"\
    Jupiter\");\n        } else if (planet2 == \"Saturn\") {\n            res.push_back(\"\
    Venus\");\n            res.push_back(\"Earth\");\n            res.push_back(\"\
    Mars\");\n            res.push_back(\"Jupiter\");\n            res.push_back(\"\
    Saturn\");\n        } else if (planet2 == \"Uranus\") {\n            res.push_back(\"\
    Venus\");\n            res.push_back(\"Earth\");\n            res.push_back(\"\
    Mars\");\n            res.push_back(\"Jupiter\");\n            res.push_back(\"\
    Saturn\");\n            res.push_back(\"Uranus\");\n        } else if (planet2\
    \ == \"Neptune\") {\n            res.push_back(\"Venus\");\n            res.push_back(\"\
    Earth\");\n            res.push_back(\"Mars\");\n            res.push_back(\"\
    Jupiter\");\n            res.push_back(\"Saturn\");\n            res.push_back(\"\
    Uranus\");\n            res.push_back(\"Neptune\");\n        } else {\n      \
    \      return res;\n        }\n    } else if (planet1 == \"Venus\") {\n      \
    \  if (planet2 == \"Earth\") {\n            res.push_back(\"Earth\");\n      \
    \  } else if (planet2 == \"Mars\") {\n            res.push_back(\"Earth\");\n\
    \            res.push_back(\"Mars\");\n        } else if (planet2 == \"J\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpkk590n8m.cpp:66:31: warning: missing terminating \" character\n\
    \   66 |         } else if (planet2 == \"J\n      |                          \
    \     ^\n/tmp/tmpkk590n8m.cpp:66:31: error: missing terminating \" character\n\
    \   66 |         } else if (planet2 == \"J\n      |                          \
    \     ^~\n/tmp/tmpkk590n8m.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpkk590n8m.cpp:67:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmpkk590n8m.cpp:66:30:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   66 |         }\
    \ else if (planet2 == \"J\n      |                   ~          ^\n      |   \
    \                           )\n   67 | }\n      | ~                          \
    \   \n/tmp/tmpkk590n8m.cpp:67:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   67 | }\n      | ^\n/tmp/tmpkk590n8m.cpp:68:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   68 | int main() {\n     \
    \ |            ^\n/tmp/tmpkk590n8m.cpp:77:1: error: expected \u2018}\u2019 at\
    \ end of input\n   77 | }\n      | ^\n/tmp/tmpkk590n8m.cpp:19:71: note: to match\
    \ this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n      |                                            \
    \                           ^\n/tmp/tmpkk590n8m.cpp:77:1: warning: control reaches\
    \ end of non-void function [-Wreturn-type]\n   77 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114016
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planets[8] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::map<std::string,int> mp;\n    std::vector<std::string> res;\n    for(int\
    \ i = 0; i < 8; i++) {\n        mp[planets[i]] = i;\n    }\n    int r1 = mp[planet1];\n\
    \    int r2 = mp[planet2];\n    if(r1 > r2) {\n        std::swap(r1,r2);\n   \
    \ }\n    for(int i = r1+1; i < r2; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpzyqnr0ro: /tmp/tmpzyqnr0ro.cpp:44: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    const std::vector<std::string> planets{\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    auto begin_it = std::find(planets.begin(), planets.end(), planet1);\n\
    \    auto end_it = std::find(planets.begin(), planets.end(), planet2);\n    if\
    \ (begin_it == planets.end() || end_it == planets.end()) {\n        return {};\n\
    \    }\n    if (begin_it > end_it) {\n        std::swap(begin_it, end_it);\n \
    \   }\n    std::vector<std::string> res;\n    for (auto it = begin_it; it != end_it;\
    \ ++it) {\n        res.push_back(*it);\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpv4ycri5v: /tmp/tmpv4ycri5v.cpp:37: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto\
    \ it2 = std::find(planets.begin(), planets.end(), planet2);\n    if (it1 == planets.end()\
    \ || it2 == planets.end()) {\n        return {};\n    }\n    auto [min, max] =\
    \ std::minmax(it1, it2);\n    return std::vector<std::string>(min + 1, max);\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> result;\n  std::vector<std::string>\
    \ planet_list = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"};\n  int len = planet_list.size();\n  int p1\
    \ = 0, p2 = 0;\n  for (int i = 0; i < len; i++) {\n    if (planet_list[i] == planet1)\
    \ p1 = i;\n    if (planet_list[i] == planet2) p2 = i;\n  }\n  if (p1 > p2) std::swap(p1,\
    \ p2);\n  for (int i = p1 + 1; i < p2; i++) result.push_back(planet_list[i]);\n\
    \  return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpwaqzik16: /tmp/tmpwaqzik16.cpp:40: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // your code here\n    std::vector<std::string>\
    \ ans;\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int f = -1,\
    \ s = -1;\n    for(int i = 0; i < planets.size(); i++) {\n        if(planets[i]\
    \ == planet1) {\n            f = i;\n        }\n        if(planets[i] == planet2)\
    \ {\n            s = i;\n        }\n    }\n    if(f == -1 || s == -1) return ans;\n\
    \    if(f > s) {\n        std::swap(f, s);\n    }\n    for(int i = f + 1; i <\
    \ s; i++) {\n        ans.push_back(planets[i]);\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> result;\n  int left, right;\n  for (int i = 0;\
    \ i < planets.size(); i++) {\n    if (planets[i] == planet1) {\n      left = i;\n\
    \    }\n    if (planets[i] == planet2) {\n      right = i;\n    }\n  }\n  if (left\
    \ > right) {\n    std::swap(left, right);\n  }\n  for (int i = left + 1; i < right;\
    \ i++) {\n    result.push_back(planets[i]);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets;\n    if (planet1\
    \ == \"Mercury\") {\n        planets.push_back(\"Mercury\");\n    }\n    if (planet1\
    \ == \"Venus\") {\n        planets.push_back(\"Mercury\");\n        planets.push_back(\"\
    Venus\");\n    }\n    if (planet1 == \"Earth\") {\n        planets.push_back(\"\
    Mercury\");\n        planets.push_back(\"Venus\");\n        planets.push_back(\"\
    Earth\");\n    }\n    if (planet1 == \"Mars\") {\n        planets.push_back(\"\
    Mercury\");\n        planets.push_back(\"Venus\");\n        planets.push_back(\"\
    Earth\");\n        planets.push_back(\"Mars\");\n    }\n    if (planet1 == \"\
    Jupiter\") {\n        planets.push_back(\"Mercury\");\n        planets.push_back(\"\
    Venus\");\n        planets.push_back(\"Earth\");\n        planets.push_back(\"\
    Mars\");\n        planets.push_back(\"Jupiter\");\n    }\n    if (planet1 == \"\
    Saturn\") {\n        planets.push_back(\"Mercury\");\n        planets.push_back(\"\
    Venus\");\n        planets.push_back(\"Earth\");\n        planets.push_back(\"\
    Mars\");\n        planets.push_back(\"Jupiter\");\n        planets.push_back(\"\
    Saturn\");\n    }\n    if (planet1 == \"Uranus\") {\n        planets.push_back(\"\
    Mercury\");\n        planets.push_back(\"Venus\");\n        planets.push_back(\"\
    Earth\");\n        planets.push_back(\"Mars\");\n        planets.push_back(\"\
    Jupiter\");\n        planets.push_back(\"Saturn\");\n        planets.push_back(\"\
    Uranus\");\n    }\n    if (planet1 == \"Neptune\") {\n        planets.push_back(\"\
    Mercury\");\n        planets.push_back(\"Venus\");\n        planets.push_back(\"\
    Earth\");\n        planets.push_back(\"Mars\");\n        planets.push_back(\"\
    Jupiter\");\n        planets.push_back(\"Saturn\");\n        planets.push_back(\"\
    Uranus\");\n        planets.push_back\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq7l7b88m.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpq7l7b88m.cpp:71:26: error: expected\
    \ \u2018;\u2019 before \u2018}\u2019 token\n   71 |         planets.push_back\n\
    \      |                          ^\n      |                          ;\n   72\
    \ | }\n      | ~                         \n/tmp/tmpq7l7b88m.cpp:71:17: error:\
    \ statement cannot resolve address of overloaded function\n   71 |         planets.push_back\n\
    \      |         ~~~~~~~~^~~~~~~~~\n/tmp/tmpq7l7b88m.cpp:73:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   73 | int main() {\n     \
    \ |            ^\n/tmp/tmpq7l7b88m.cpp:82:1: error: expected \u2018}\u2019 at\
    \ end of input\n   82 | }\n      | ^\n/tmp/tmpq7l7b88m.cpp:19:71: note: to match\
    \ this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n      |                                            \
    \                           ^\n/tmp/tmpq7l7b88m.cpp:82:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   82 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114016
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> plan_vec = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int it;\n    for (int i = 0; i <\
    \ plan_vec.size(); i++) {\n        if (plan_vec[i] == planet1) {\n           \
    \ it = i;\n            break;\n        }\n    }\n    for (int i = it; i < plan_vec.size();\
    \ i++) {\n        if (plan_vec[i] == planet2) {\n            break;\n        }\n\
    \        result.push_back(plan_vec[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpvv9km38a: /tmp/tmpvv9km38a.cpp:39: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::map<std::string, int> all_planets;\n\tall_planets[\"\
    Mercury\"] = 1;\n\tall_planets[\"Venus\"] = 2;\n\tall_planets[\"Earth\"] = 3;\n\
    \tall_planets[\"Mars\"] = 4;\n\tall_planets[\"Jupiter\"] = 5;\n\tall_planets[\"\
    Saturn\"] = 6;\n\tall_planets[\"Uranus\"] = 7;\n\tall_planets[\"Neptune\"] = 8;\n\
    \tif (all_planets.find(planet1) == all_planets.end() || all_planets.find(planet2)\
    \ == all_planets.end())\n\t\treturn std::vector<std::string>();\n\tstd::vector<std::string>\
    \ res;\n\tif (all_planets[planet1] < all_planets[planet2]) {\n\t\tfor (auto iter\
    \ = all_planets.begin(); iter != all_planets.end(); iter++) {\n\t\t\tif (iter->second\
    \ > all_planets[planet1] && iter->second < all_planets[planet2])\n\t\t\t\tres.push_back(iter->first);\n\
    \t\t}\n\t}\n\telse {\n\t\tfor (auto iter = all_planets.begin(); iter != all_planets.end();\
    \ iter++) {\n\t\t\tif (iter->second > all_planets[planet2] && iter->second < all_planets[planet1])\n\
    \t\t\t\tres.push_back(iter->first);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmphmqxaryr: /tmp/tmphmqxaryr.cpp:50: int main(): Assertion `candidate(("Mercury"),
    ("Uranus")) == (std::vector<std::string>({(std::string)"Venus", (std::string)"Earth",
    (std::string)"Mars", (std::string)"Jupiter", (std::string)"Saturn"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    bool start = false;\n    bool end =\
    \ false;\n    for (auto &&p : planets) {\n        if (p == planet1) {\n      \
    \      start = true;\n        }\n        if (p == planet2) {\n            end\
    \ = true;\n        }\n        if (start && !end) {\n            res.push_back(p);\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpaykdrq6k: /tmp/tmpaykdrq6k.cpp:39: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // YOUR CODE HERE\n    throw std::logic_error(\"\
    Waiting to be implemented\");\n}\nint main() {\n    auto candidate = bf;\n   \
    \ assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::logic_error'\n  what():\
    \  Waiting to be implemented\n"
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::string planets[] = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string>\
    \ result;\n\tint index1 = -1, index2 = -1;\n\tfor (int i = 0; i < 8; i++) {\n\t\
    \tif (planets[i] == planet1) {\n\t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i] ==\
    \ planet2) {\n\t\t\tindex2 = i;\n\t\t}\n\t}\n\tif (index1 == -1 || index2 == -1)\
    \ {\n\t\treturn result;\n\t}\n\tif (index1 > index2) {\n\t\tint temp = index1;\n\
    \t\tindex1 = index2;\n\t\tindex2 = temp;\n\t}\n\tfor (int i = index1 + 1; i <\
    \ index2; i++) {\n\t\tresult.push_back(planets[i]);\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> solar_system = { \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n    std::vector<std::string> ret;\n    auto first = std::find(solar_system.begin(),\
    \ solar_system.end(), planet1);\n    auto second = std::find(solar_system.begin(),\
    \ solar_system.end(), planet2);\n    if (first == solar_system.end() || second\
    \ == solar_system.end()) {\n        return ret;\n    } else {\n        ret.insert(ret.end(),\
    \ first + 1, second);\n        return ret;\n    }\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  vector::_M_range_insert\n"
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> ret;\n\tint i1, i2;\n\tfor (int i = 0; i < planets.size();\
    \ i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\ti1 = i;\n\t\t}\n\t\tif (planets[i]\
    \ == planet2) {\n\t\t\ti2 = i;\n\t\t}\n\t}\n\tif (i1 == i2) {\n\t\treturn ret;\n\
    \t}\n\tif (i1 > i2) {\n\t\tstd::swap(i1, i2);\n\t}\n\tfor (int i = i1 + 1; i <\
    \ i2; i++) {\n\t\tret.push_back(planets[i]);\n\t}\n\treturn ret;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n   std::string planetNames[8] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \ int i1 = -1, i2 = -1;\n   std::vector<std::string> t;\n   for (int i = 0; i\
    \ < 8; i++) {\n      if (planetNames[i] == planet1) i1 = i;\n      if (planetNames[i]\
    \ == planet2) i2 = i;\n   }\n   if (i1 == -1 || i2 == -1) return t;\n   if (i1\
    \ > i2) std::swap(i1, i2);\n   for (int i = i1 + 1; i < i2; i++) t.push_back(planetNames[i]);\n\
    \   return t;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // your code\n    std::vector<std::string> planets\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n    std::vector<std::string> vec;\n    int p1, p2;\n\
    \    for(int i = 0; i < planets.size(); i++) {\n        if(planets[i] == planet1)\
    \ p1 = i;\n        if(planets[i] == planet2) p2 = i;\n    }\n    if(p1 == p2)\
    \ return vec;\n    else if(p1 > p2) {\n        for(int i = p2; i < p1; i++) vec.push_back(planets[i]);\n\
    \    }\n    else {\n        for(int i = p1; i < p2; i++) vec.push_back(planets[i]);\n\
    \    }\n    return vec;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpq2bg6icz: /tmp/tmpq2bg6icz.cpp:39: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // input check\n    std::vector<std::string> res;\n\
    \    if (planet1 == planet2){\n        return res;\n    }\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    // Get planets between the two planets\n    std::vector<std::string>::iterator\
    \ it1 = std::find(planets.begin(), planets.end(), planet1);\n    std::vector<std::string>::iterator\
    \ it2 = std::find(planets.begin(), planets.end(), planet2);\n    if (it1 == planets.end()\
    \ || it2 == planets.end()){\n        return res;\n    }\n    std::vector<std::string>::iterator\
    \ it_start = std::min(it1, it2);\n    std::vector<std::string>::iterator it_end\
    \ = std::max(it1, it2);\n    for (auto it = it_start; it != it_end; it++){\n \
    \       res.push_back(*it);\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp8jzighfx: /tmp/tmp8jzighfx.cpp:41: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> res;\n\tint a = std::find(planets.begin(), planets.end(),\
    \ planet1) - planets.begin();\n\tint b = std::find(planets.begin(), planets.end(),\
    \ planet2) - planets.begin();\n\tif (a == 8 || b == 8) return res;\n\tif (a >\
    \ b) std::swap(a, b);\n\tfor (int i = a+1; i < b; i++) {\n\t\tres.push_back(planets[i]);\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planetNames{\"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\",\n                                          \
    \  \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string>\
    \ planets;\n\tint firstPlanetPos = -1;\n\tint secondPlanetPos = -1;\n\t\n\tfor(int\
    \ i = 0; i < planetNames.size(); i++) {\n\t\tif(planetNames[i] == planet1) {\n\
    \t\t\tfirstPlanetPos = i;\n\t\t} else if(planetNames[i] == planet2) {\n\t\t\t\
    secondPlanetPos = i;\n\t\t}\n\t}\n\t\n\tfor(int i = firstPlanetPos + 1; i < secondPlanetPos;\
    \ i++) {\n\t\tplanets.push_back(planetNames[i]);\n\t}\n\t\n\treturn planets;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp2ttzbyty: /tmp/tmp2ttzbyty.cpp:43: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> all_planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string>::iterator it1 = std::find(all_planets.begin(),\
    \ all_planets.end(), planet1);\n    std::vector<std::string>::iterator it2 = std::find(all_planets.begin(),\
    \ all_planets.end(), planet2);\n    if (it1 == all_planets.end() || it2 == all_planets.end())\
    \ {\n        return {};\n    }\n    int p1 = it1 - all_planets.begin();\n    int\
    \ p2 = it2 - all_planets.begin();\n    std::vector<std::string> between_planets;\n\
    \    if (p1 < p2) {\n        between_planets = std::vector<std::string>(all_planets.begin()\
    \ + p1 + 1, all_planets.begin() + p2);\n    } else {\n        between_planets\
    \ = std::vector<std::string>(all_planets.begin() + p2 + 1, all_planets.begin()\
    \ + p1);\n    }\n    return between_planets;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> result;\n\tstd::vector<std::string>\
    \ planets;\n\tplanets.push_back(\"Mercury\");\n\tplanets.push_back(\"Venus\");\n\
    \tplanets.push_back(\"Earth\");\n\tplanets.push_back(\"Mars\");\n\tplanets.push_back(\"\
    Jupiter\");\n\tplanets.push_back(\"Saturn\");\n\tplanets.push_back(\"Uranus\"\
    );\n\tplanets.push_back(\"Neptune\");\n\tstd::vector<std::string>::iterator it1,\
    \ it2;\n\tit1 = std::find(planets.begin(), planets.end(), planet1);\n\tit2 = std::find(planets.begin(),\
    \ planets.end(), planet2);\n\tif(it1 != planets.end() && it2 != planets.end())\
    \ {\n\t\tint ind1 = std::distance(planets.begin(), it1);\n\t\tint ind2 = std::distance(planets.begin(),\
    \ it2);\n\t\tint start = std::min(ind1, ind2);\n\t\tint end = std::max(ind1, ind2);\n\
    \t\tfor(int i = start + 1; i < end; i++) {\n\t\t\tresult.push_back(planets[i]);\n\
    \t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> s;\n\tstd::vector<std::string>\
    \ v;\n\tv.push_back(\"Mercury\");\n\tv.push_back(\"Venus\");\n\tv.push_back(\"\
    Earth\");\n\tv.push_back(\"Mars\");\n\tv.push_back(\"Jupiter\");\n\tv.push_back(\"\
    Saturn\");\n\tv.push_back(\"Uranus\");\n\tv.push_back(\"Neptune\");\n\tbool check1\
    \ = false;\n\tbool check2 = false;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\
    \tif (v[i] == planet1) {\n\t\t\tcheck1 = true;\n\t\t}\n\t\tif (v[i] == planet2)\
    \ {\n\t\t\tcheck2 = true;\n\t\t}\n\t}\n\tif (check1 == false || check2 == false)\
    \ {\n\t\treturn s;\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i]\
    \ == planet1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v[i] == planet2) {\n\t\t\tbreak;\n\
    \t\t}\n\t\ts.push_back(v[i]);\n\t}\n\treturn s;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmphuuhcfr6: /tmp/tmphuuhcfr6.cpp:56: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> ans;\n\tstd::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n\tint pos1 = -1, pos2 = -1;\n\tfor (int i = 0; i\
    \ < planets.size(); i++) {\n\t\tif (planets[i] == planet1) pos1 = i;\n\t\tif (planets[i]\
    \ == planet2) pos2 = i;\n\t}\n\tif (pos1 == -1 || pos2 == -1) return ans;\n\t\
    if (pos1 > pos2) {\n\t\tfor (int i = pos2 + 1; i < pos1; i++) {\n\t\t\tans.push_back(planets[i]);\n\
    \t\t}\n\t} else {\n\t\tfor (int i = pos1 + 1; i < pos2; i++) {\n\t\t\tans.push_back(planets[i]);\n\
    \t\t}\n\t}\n\treturn ans;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // your code goes here \n    return {};\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpprua9w97: /tmp/tmpprua9w97.cpp:25: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114018
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> temp = { (std::string)\"\
    Mercury\", (std::string)\"Venus\", \n\t\t(std::string)\"Earth\", (std::string)\"\
    Mars\", (std::string)\"Jupiter\", \n\t\t(std::string)\"Saturn\", (std::string)\"\
    Uranus\", (std::string)\"Neptune\" };\n\tif (std::find(temp.begin(), temp.end(),\
    \ planet1) == temp.end() || \n\t\tstd::find(temp.begin(), temp.end(), planet2)\
    \ == temp.end())\n\t\treturn {};\n\tif (planet1 == planet2)\n\t\treturn {};\n\t\
    std::vector<std::string> res;\n\tfor (auto it = temp.begin(); it != temp.end();\
    \ it++) {\n\t\tif ((std::find(temp.begin(), temp.end(), planet1) - temp.begin())\
    \ <\n\t\t\t(std::find(temp.begin(), temp.end(), planet2) - temp.begin())) {\n\t\
    \t\tif ((std::find(temp.begin(), temp.end(), planet1) - temp.begin()) <\n\t\t\t\
    \t(std::find(temp.begin(), temp.end(), *it) - temp.begin()) &&\n\t\t\t\t(std::find(temp.begin(),\
    \ temp.end(), planet2) - temp.begin()) >\n\t\t\t\t(std::find(temp.begin(), temp.end(),\
    \ *it) - temp.begin()))\n\t\t\t\tres.push_back(*it);\n\t\t}\n\t\telse {\n\t\t\t\
    if ((std::find(temp.begin(), temp.end(), planet1) - temp.begin()) >\n\t\t\t\t\
    (std::find(temp.begin(), temp.end(), *it) - temp.begin()) &&\n\t\t\t\t(std::find(temp.begin(),\
    \ temp.end(), planet2) - temp.begin()) <\n\t\t\t\t(std::find(temp.begin(), temp.end(),\
    \ *it) - temp.begin()))\n\t\t\t\tres.push_back(*it);\n\t\t}\n\t}\n\treturn res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tint p1 = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \tint p2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \tif (p1 >= planets.size() || p2 >= planets.size())\n\t\treturn std::vector<std::string>();\n\
    \tif (p1 > p2) {\n\t\tint t = p1;\n\t\tp1 = p2;\n\t\tp2 = t;\n\t}\n\tstd::vector<std::string>\
    \  res(planets.begin() + p1 + 1, planets.begin() + p2);\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint size = planets.size();\n\tint start\
    \ = 0;\n\tint end = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tif (planets[i]\
    \ == planet1) {\n\t\t\tstart = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\
    \t\tend = i;\n\t\t}\n\t}\n\tif (start == 0 || end == 0) {\n\t\treturn result;\n\
    \t}\n\tif (start < end) {\n\t\tfor (int i = start + 1; i < end; i++) {\n\t\t\t\
    result.push_back(planets[i]);\n\t\t}\n\t} else {\n\t\tfor (int i = end + 1; i\
    \ < start; i++) {\n\t\t\tresult.push_back(planets[i]);\n\t\t}\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpmk61otxo: /tmp/tmpmk61otxo.cpp:50: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114018
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tfor (int i = 0; i < planets.size();\
    \ i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tfor (int j = i+1; j < planets.size();\
    \ j++) {\n\t\t\t\tif (planets[j] == planet2) {\n\t\t\t\t\treturn result;\n\t\t\
    \t\t}\n\t\t\t\tresult.push_back(planets[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp40i21nae: /tmp/tmp40i21nae.cpp:37: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114018
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> res;\n\tstd::vector<std::string>\
    \ names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n\tif(!count(names.begin(), names.end(), planet1)\
    \ || !count(names.begin(), names.end(), planet2)) {\n\t\treturn res;\n\t}\n\t\
    std::map<std::string, int> m;\n\tfor(int i = 0; i < names.size(); i++) {\n\t\t\
    m[names[i]] = i;\n\t}\n\tif(m[planet1] > m[planet2]) {\n\t\tstd::swap(planet1,\
    \ planet2);\n\t}\n\tfor(int i = m[planet1] + 1; i < m[planet2]; i++) {\n\t\tres.push_back(names[i]);\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> temp = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\t\
    std::vector<std::string>::iterator first = temp.begin();\n\tstd::vector<std::string>::iterator\
    \ last = temp.end();\n\tint pos1 = find(first, last, planet1) - first;\n\tint\
    \ pos2 = find(first, last, planet2) - first;\n\tstd::vector<std::string> ret;\n\
    \tif(pos1 > pos2)\n\t\tstd::swap(pos1, pos2);\n\tif(pos1 == temp.size() || pos2\
    \ == temp.size())\n\t\treturn ret;\n\tfor(int i = pos1+1; i < pos2; i++)\n\t\t\
    ret.push_back(temp[i]);\n\treturn ret;\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> orbit = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> sol;\n    int p1, p2;\n    auto it1 = std::find(orbit.begin(),\
    \ orbit.end(), planet1);\n    auto it2 = std::find(orbit.begin(), orbit.end(),\
    \ planet2);\n    p1 = std::distance(orbit.begin(), it1);\n    p2 = std::distance(orbit.begin(),\
    \ it2);\n    if(p1 == -1 || p2 == -1)\n        return sol;\n    if(p1 <= p2)\n\
    \        return std::vector<std::string>(orbit.begin() + p1 + 1, orbit.begin()\
    \ + p2);\n    return std::vector<std::string>(orbit.begin() + p2 + 1, orbit.begin()\
    \ + p1);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114018
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> names = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> ans;\n    int i1 = std::find(names.begin(), names.end(),\
    \ planet1) - names.begin();\n    int i2 = std::find(names.begin(), names.end(),\
    \ planet2) - names.begin();\n    if (i1 == names.size() || i2 == names.size())\
    \ {\n        return ans;\n    }\n    if (i1 > i2) {\n        std::swap(i1, i2);\n\
    \    }\n    for (int i = i1 + 1; i < i2; i++) {\n        ans.push_back(names[i]);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114017
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Mercury\") {\n        if (planet2\
    \ == \"Venus\") {\n            return {};\n        } else if (planet2 == \"Earth\"\
    ) {\n            return {\"Venus\"};\n        } else if (planet2 == \"Mars\")\
    \ {\n            return {\"Venus\", \"Earth\"};\n        } else if (planet2 ==\
    \ \"Jupiter\") {\n            return {\"Venus\", \"Earth\", \"Mars\"};\n     \
    \   } else if (planet2 == \"Saturn\") {\n            return {\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\"};\n        } else if (planet2 == \"Uranus\") {\n     \
    \       return {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n  \
    \      } else if (planet2 == \"Neptune\") {\n            return {\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n        } else {\n \
    \           return {};\n        }\n    } else if (planet1 == \"Venus\") {\n  \
    \      if (planet2 == \"Earth\") {\n            return {};\n        } else if\
    \ (planet2 == \"Mars\") {\n            return {\"Earth\"};\n        } else if\
    \ (planet2 == \"Jupiter\") {\n            return {\"Earth\", \"Mars\"};\n    \
    \    } else if (planet2 == \"Saturn\") {\n            return {\"Earth\", \"Mars\"\
    , \"Jupiter\"};\n        } else if (planet2 == \"Uranus\") {\n            return\
    \ {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n        } else if (planet2\
    \ == \"Neptune\") {\n            return {\"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\"};\n        } else {\n            return {};\n        }\n\
    \    } else if (planet1 == \"Earth\") {\n        if (planet2 == \"Mars\") {\n\
    \            return {};\n        } else if (planet2 == \"Jupiter\") {\n      \
    \      return {\"Mars\"};\n        } else if (planet2 == \"Saturn\") {\n     \
    \       return {\"Mars\", \"Jupiter\"};\n        } else if (planet2 == \"Uranus\"\
    ) {\n            return {\"Mars\", \"Jupiter\",\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpap_tfyit.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpap_tfyit.cpp:63:2: error: expected\
    \ \u2018;\u2019 before \u2018int\u2019\n   63 | }\n      |  ^\n      |  ;\n  \
    \ 64 | int main() {\n      | ~~~\n/tmp/tmpap_tfyit.cpp:64:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   64 | int main() {\n     \
    \ |            ^\n/tmp/tmpap_tfyit.cpp:73:1: error: expected \u2018}\u2019 at\
    \ end of input\n   73 | }\n      | ^\n/tmp/tmpap_tfyit.cpp:61:41: note: to match\
    \ this \u2018{\u2019\n   61 |         } else if (planet2 == \"Uranus\") {\n  \
    \    |                                         ^\n/tmp/tmpap_tfyit.cpp:73:1: error:\
    \ expected \u2018}\u2019 at end of input\n   73 | }\n      | ^\n/tmp/tmpap_tfyit.cpp:54:36:\
    \ note: to match this \u2018{\u2019\n   54 |     } else if (planet1 == \"Earth\"\
    ) {\n      |                                    ^\n/tmp/tmpap_tfyit.cpp:73:1:\
    \ error: expected \u2018}\u2019 at end of input\n   73 | }\n      | ^\n/tmp/tmpap_tfyit.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmpap_tfyit.cpp:73:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   73 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114018
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> planetsInOrder;\n    for (int i = 0; i < planets.size();\
    \ i++) {\n        if (planets[i] == planet1) {\n            for (int j = i; j\
    \ < planets.size(); j++) {\n                if (planets[j] == planet2) {\n   \
    \                 for (int k = i; k <= j; k++) {\n                        planetsInOrder.push_back(planets[k]);\n\
    \                    }\n                    return planetsInOrder;\n         \
    \       }\n            }\n        }\n    }\n    return planetsInOrder;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpzxhgu8ck: /tmp/tmpzxhgu8ck.cpp:38: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114019
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> solar_system = { \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> result;\n\tint index1 = -1, index2 = -1;\n\t\
    for (int i = 0; i < solar_system.size(); i++) {\n\t\tif (solar_system[i] == planet1)\
    \ {\n\t\t\tindex1 = i;\n\t\t}\n\t\tif (solar_system[i] == planet2) {\n\t\t\tindex2\
    \ = i;\n\t\t}\n\t}\n\tif (index1 == -1 || index2 == -1) {\n\t\treturn result;\n\
    \t}\n\tif (index1 > index2) {\n\t\tstd::swap(index1, index2);\n\t}\n\tfor (int\
    \ i = index1 + 1; i < index2; i++) {\n\t\tresult.push_back(solar_system[i]);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114019
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> res;\n    int p1 = 0, p2\
    \ = 0;\n    if (planet1 == \"Mercury\") p1 = 1;\n    if (planet1 == \"Venus\"\
    ) p1 = 2;\n    if (planet1 == \"Earth\") p1 = 3;\n    if (planet1 == \"Mars\"\
    ) p1 = 4;\n    if (planet1 == \"Jupiter\") p1 = 5;\n    if (planet1 == \"Saturn\"\
    ) p1 = 6;\n    if (planet1 == \"Uranus\") p1 = 7;\n    if (planet1 == \"Neptune\"\
    ) p1 = 8;\n    if (planet2 == \"Mercury\") p2 = 1;\n    if (planet2 == \"Venus\"\
    ) p2 = 2;\n    if (planet2 == \"Earth\") p2 = 3;\n    if (planet2 == \"Mars\"\
    ) p2 = 4;\n    if (planet2 == \"Jupiter\") p2 = 5;\n    if (planet2 == \"Saturn\"\
    ) p2 = 6;\n    if (planet2 == \"Uranus\") p2 = 7;\n    if (planet2 == \"Neptune\"\
    ) p2 = 8;\n    if (p1 == 0 || p2 == 0) return res;\n    if (p1 > p2) {\n     \
    \   p1 ^= p2;\n        p2 ^= p1;\n        p1 ^= p2;\n    }\n    for (int i = p1\
    \ + 1; i < p2; i++) {\n        if (i == 2) res.push_back(\"Venus\");\n       \
    \ if (i == 3) res.push_back(\"Earth\");\n        if (i == 4) res.push_back(\"\
    Mars\");\n        if (i == 5) res.push_back(\"Jupiter\");\n        if (i == 6)\
    \ res.push_back(\"Saturn\");\n        if (i == 7) res.push_back(\"Uranus\");\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> r = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  int i = std::find(r.begin(), r.end(), planet1) - r.begin();\n    int j = std::find(r.begin(),\
    \ r.end(), planet2) - r.begin();\n    if (i >= 0 && j >= 0 && i < j) {\n     \
    \   return std::vector<std::string>(r.begin() + i + 1, r.begin() + j);\n    }\n\
    \    return std::vector<std::string>();\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp12f0r7t3: /tmp/tmp12f0r7t3.cpp:31: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> ret;\n    const std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    for (auto i = planets.begin(); i != planets.end();\
    \ ++i) {\n        if (*i == planet1) {\n            for (auto j = i; j != planets.end();\
    \ ++j) {\n                if (*j == planet2) {\n                    ret.push_back(*j);\n\
    \                    return ret;\n                }\n                ret.push_back(*j);\n\
    \            }\n        }\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp0j5u04qd: /tmp/tmp0j5u04qd.cpp:37: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114019
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Mercury\") {\n        if (planet2\
    \ == \"Mercury\") {\n            return std::vector<std::string>();\n        }\n\
    \        else if (planet2 == \"Venus\") {\n            return std::vector<std::string>{\"\
    Venus\"};\n        }\n        else if (planet2 == \"Earth\") {\n            return\
    \ std::vector<std::string>{\"Venus\", \"Earth\"};\n        }\n        else if\
    \ (planet2 == \"Mars\") {\n            return std::vector<std::string>{\"Venus\"\
    , \"Earth\", \"Mars\"};\n        }\n        else if (planet2 == \"Jupiter\") {\n\
    \            return std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\"};\n        }\n        else if (planet2 == \"Saturn\") {\n          \
    \  return std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"};\n        }\n        else if (planet2 == \"Uranus\") {\n       \
    \     return std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"};\n        }\n        else if (planet2 == \"Neptune\"\
    ) {\n            return std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n        }\n        else\
    \ {\n            return std::vector<std::string>();\n        }\n    }\n    else\
    \ if (planet1 == \"Venus\") {\n        if (planet2 == \"Mercury\") {\n       \
    \     return std::vector<std::string>();\n        }\n        else if (planet2\
    \ == \"Venus\") {\n            return std::vector<std::string>();\n        }\n\
    \        else if (planet2 == \"Earth\") {\n            return std::vector<std::string>{\"\
    Earth\"};\n        }\n        else if (planet2 == \"Mars\") {\n            return\
    \ std::vector<std::string>{\"Earth\", \"Mars\"};\n        }\n        else if (planet2\
    \ == \"Jupiter\") {\n            return std::vector<\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9ums3emh.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmp9ums3emh.cpp:63:31: error: template\
    \ argument 1 is invalid\n   63 |             return std::vector<\n      |    \
    \                           ^\n/tmp/tmp9ums3emh.cpp:63:31: error: template argument\
    \ 2 is invalid\n/tmp/tmp9ums3emh.cpp:63:32: error: expected \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   63 |             return std::vector<\n      |      \
    \                          ^\n      |                                ;\n   64\
    \ | }\n      | ~                               \n/tmp/tmp9ums3emh.cpp:65:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   65\
    \ | int main() {\n      |            ^\n/tmp/tmp9ums3emh.cpp:74:1: error: expected\
    \ \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmp9ums3emh.cpp:49:34:\
    \ note: to match this \u2018{\u2019\n   49 |     else if (planet1 == \"Venus\"\
    ) {\n      |                                  ^\n/tmp/tmp9ums3emh.cpp:74:1: error:\
    \ expected \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmp9ums3emh.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n"
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tusing namespace std;\n\tstring planets[8] = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> vec;\n\tint p1, p2;\n\tfor (int i = 0; i < 8; i++)\
    \ {\n\t\tif (planets[i] == planet1) {\n\t\t\tp1 = i;\n\t\t}\n\t\tif (planets[i]\
    \ == planet2) {\n\t\t\tp2 = i;\n\t\t}\n\t}\n\tif (p1 == p2) {\n\t\treturn vec;\n\
    \t}\n\tfor (int i = min(p1, p2) + 1; i < max(p1, p2); i++) {\n\t\tvec.push_back(planets[i]);\n\
    \t}\n\treturn vec;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmppwy493db: /tmp/tmppwy493db.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> res;\n    std::map<std::string,\
    \ int> mp;\n    mp[\"Mercury\"] = 1;\n    mp[\"Venus\"] = 2;\n    mp[\"Earth\"\
    ] = 3;\n    mp[\"Mars\"] = 4;\n    mp[\"Jupiter\"] = 5;\n    mp[\"Saturn\"] =\
    \ 6;\n    mp[\"Uranus\"] = 7;\n    mp[\"Neptune\"] = 8;\n    if(mp.find(planet1)\
    \ == mp.end() || mp.find(planet2) == mp.end()) return res;\n    int min_val =\
    \ std::min(mp[planet1], mp[planet2]);\n    int max_val = std::max(mp[planet1],\
    \ mp[planet2]);\n    for(auto x : mp) {\n        if(x.second >= min_val && x.second\
    \ <= max_val) {\n            res.push_back(x.first);\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpq3vdktwj: /tmp/tmpq3vdktwj.cpp:42: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    int p1 = -1, p2 = -1;\n    for (int i = 0; i < 8; i++) {\n        if (planets[i]\
    \ == planet1) {\n            p1 = i;\n        }\n        if (planets[i] == planet2)\
    \ {\n            p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n\
    \        return {};\n    }\n    std::vector<std::string> result;\n    if (p1 >\
    \ p2) {\n        for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = p1 + 1; i < p2; i++) {\n      \
    \      result.push_back(planets[i]);\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> result;\n\tauto planet1_it = std::find(planets.begin(),\
    \ planets.end(), planet1);\n\tauto planet2_it = std::find(planets.begin(), planets.end(),\
    \ planet2);\n\tif (planet1_it == planets.end() || planet2_it == planets.end())\
    \ {\n\t\treturn result;\n\t}\n\tif (planet1_it < planet2_it) {\n\t\tresult.assign(planet1_it,\
    \ planet2_it + 1);\n\t}\n\telse {\n\t\tresult.assign(planet2_it, planet1_it +\
    \ 1);\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp3r5i6v1w: /tmp/tmp3r5i6v1w.cpp:37: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> res;\n    std::vector<std::string>\
    \ planets{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int first = -1;\n    int second = -1;\n    for\
    \ (size_t i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            first = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            second = i;\n        }\n    }\n    if (first == -1 || second == -1)\
    \ {\n        return res;\n    }\n    int min = std::min(first, second);\n    int\
    \ max = std::max(first, second);\n    for (int i = min + 1; i < max; i++) {\n\
    \        res.push_back(planets[i]);\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    const std::string solar_system[] = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1_position = -1;\n    int p2_position\
    \ = -1;\n    for (int i = 0; i < 8; i++) {\n        if (solar_system[i] == planet1)\n\
    \            p1_position = i;\n        if (solar_system[i] == planet2)\n     \
    \       p2_position = i;\n    }\n    if (p1_position == -1 || p2_position == -1)\n\
    \        return result;\n    if (p1_position > p2_position) {\n        int temp\
    \ = p1_position;\n        p1_position = p2_position;\n        p2_position = temp;\n\
    \    }\n    for (int i = p1_position + 1; i < p2_position; i++) {\n        result.push_back(solar_system[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planets[] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::vector<std::string> result;\n    int i1, i2;\n    for (int i = 0; i <\
    \ 8; i++) {\n        if (planets[i] == planet1) i1 = i;\n        if (planets[i]\
    \ == planet2) i2 = i;\n    }\n    if (i1 < i2) {\n        for (int i = i1 + 1;\
    \ i < i2; i++) {\n            result.push_back(planets[i]);\n        }\n    }\
    \ else {\n        for (int i = i2 + 1; i < i1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpmhy0f_mr: /tmp/tmpmhy0f_mr.cpp:46: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\t\tstd::vector<std::string> planet_names = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\t\tstd::vector<std::string> ans;\n\t\tif (std::find(planet_names.begin(),\
    \ planet_names.end(), planet1) == planet_names.end() || std::find(planet_names.begin(),\
    \ planet_names.end(), planet2) == planet_names.end()) {\n\t\t\treturn ans;\n\t\
    \t}\n\t\tint idx1 = std::find(planet_names.begin(), planet_names.end(), planet1)\
    \ - planet_names.begin();\n\t\tint idx2 = std::find(planet_names.begin(), planet_names.end(),\
    \ planet2) - planet_names.begin();\n\t\tif (idx1 > idx2) {\n\t\t\tstd::reverse(planet_names.begin(),\
    \ planet_names.end());\n\t\t\tidx1 = std::find(planet_names.begin(), planet_names.end(),\
    \ planet1) - planet_names.begin();\n\t\t\tidx2 = std::find(planet_names.begin(),\
    \ planet_names.end(), planet2) - planet_names.begin();\n\t\t}\n\t\tans.assign(planet_names.begin()\
    \ + idx1 + 1, planet_names.begin() + idx2);\n\t\treturn ans;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp2r6f4v00: /tmp/tmp2r6f4v00.cpp:40: int main(): Assertion `candidate(("Neptune"),
    ("Venus")) == (std::vector<std::string>({(std::string)"Earth", (std::string)"Mars",
    (std::string)"Jupiter", (std::string)"Saturn", (std::string)"Uranus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> answer;\n    std::vector<std::string>\
    \ names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int index1 = -1;\n    int index2 = -1;\n    for\
    \ (int i = 0; i < names.size(); i++) {\n        if (names[i] == planet1) {\n \
    \           index1 = i;\n        }\n        if (names[i] == planet2) {\n     \
    \       index2 = i;\n        }\n    }\n    if (index1 == -1 || index2 == -1) {\n\
    \        return answer;\n    }\n    for (int i = 0; i < names.size(); i++) {\n\
    \        if (index1 < index2) {\n            if (i > index1 && i < index2) {\n\
    \                answer.push_back(names[i]);\n            }\n        } else {\n\
    \            if (i > index2 && i < index1) {\n                answer.push_back(names[i]);\n\
    \            }\n        }\n    }\n    return answer;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets({\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    });\n\tint start = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \tint end = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \tif (start >= 8 || end >= 8) return {};\n\treturn {planets.begin() + std::min(start,\
    \ end) + 1, planets.begin() + std::max(start, end)};\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::map<std::string, int> planet_map = { {\"Mercury\"\
    , 0}, {\"Venus\", 1}, {\"Earth\", 2}, {\"Mars\", 3}, {\"Jupiter\", 4}, {\"Saturn\"\
    , 5}, {\"Uranus\", 6}, {\"Neptune\", 7} };\n\tstd::vector<std::string> planets\
    \ = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\" };\n\tstd::vector<std::string> result;\n\tint from = -1,\
    \ to = -1;\n\tfor (auto planet : planet_map) {\n\t\tif (planet.first == planet1)\
    \ from = planet.second;\n\t\tif (planet.first == planet2) to = planet.second;\n\
    \t}\n\tif (from == -1 || to == -1) return result;\n\tif (from > to) std::swap(from,\
    \ to);\n\tfor (int i = from; i <= to; i++) {\n\t\tresult.push_back(planets[i]);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpvx4w70gw: /tmp/tmpvx4w70gw.cpp:37: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\treturn {};\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp1v9t8pm0: /tmp/tmp1v9t8pm0.cpp:24: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> ret;\n    bool left = false;\n    bool right\
    \ = false;\n    for (auto p : planets) {\n        if (p == planet1) left = true;\n\
    \        if (p == planet2) right = true;\n        if (left && p != planet2) ret.push_back(p);\n\
    \        if (right) break;\n    }\n    return ret;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp6b0kpp77: /tmp/tmp6b0kpp77.cpp:34: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> v;\n\treturn v;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpdjz555x8: /tmp/tmpdjz555x8.cpp:25: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> between_planet = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    bool flag1 = false;\n    bool flag2\
    \ = false;\n    int pos1, pos2;\n    int count = 0;\n    for (auto elem : between_planet)\
    \ {\n        if (elem == planet1) {\n            flag1 = true;\n            pos1\
    \ = count;\n        } else if (elem == planet2) {\n            flag2 = true;\n\
    \            pos2 = count;\n        }\n        count += 1;\n    }\n    if (flag1\
    \ && flag2) {\n        int i;\n        if (pos1 > pos2) {\n            for (i\
    \ = pos2 + 1; i < pos1; i++) {\n                result.push_back(between_planet[i]);\n\
    \            }\n        } else {\n            for (i = pos1 + 1; i < pos2; i++)\
    \ {\n                result.push_back(between_planet[i]);\n            }\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planets[] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int i\
    \ = 0; i < 8; i++) {\n        if (planets[i] == planet1) {\n            p1 = i;\n\
    \        }\n        if (planets[i] == planet2) {\n            p2 = i;\n      \
    \  }\n    }\n    if (p1 == -1 || p2 == -1) return result;\n    if (p1 > p2) {\n\
    \        p1 = p1 + p2;\n        p2 = p1 - p2;\n        p1 = p1 - p2;\n    }\n\
    \    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> v1;\n    int flag1 = 0,\
    \ flag2 = 0;\n    std::vector<std::string> v2{\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int a1, a2;\n\
    \    for(int i = 0; i < v2.size(); i++) {\n        if(v2[i] == planet1) {\n  \
    \          a1 = i;\n            flag1 = 1;\n        }\n        if(v2[i] == planet2)\
    \ {\n            a2 = i;\n            flag2 = 1;\n        }\n    }\n    if(flag1\
    \ == 0 || flag2 == 0) {\n        return v1;\n    }\n    for(int i = a1 + 1; i\
    \ < a2; i++) {\n        v1.push_back(v2[i]);\n    }\n    return v1;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp340cio6b: /tmp/tmp340cio6b.cpp:45: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets;\n    if(planet1\
    \ == \"Mercury\"){\n        planets.push_back(\"Mercury\");\n    }else if(planet1\
    \ == \"Venus\"){\n        planets.push_back(\"Mercury\");\n        planets.push_back(\"\
    Venus\");\n    }else if(planet1 == \"Earth\"){\n        planets.push_back(\"Mercury\"\
    );\n        planets.push_back(\"Venus\");\n        planets.push_back(\"Earth\"\
    );\n    }else if(planet1 == \"Mars\"){\n        planets.push_back(\"Mercury\"\
    );\n        planets.push_back(\"Venus\");\n        planets.push_back(\"Earth\"\
    );\n        planets.push_back(\"Mars\");\n    }else if(planet1 == \"Jupiter\"\
    ){\n        planets.push_back(\"Mercury\");\n        planets.push_back(\"Venus\"\
    );\n        planets.push_back(\"Earth\");\n        planets.push_back(\"Mars\"\
    );\n        planets.push_back(\"Jupiter\");\n    }else if(planet1 == \"Saturn\"\
    ){\n        planets.push_back(\"Mercury\");\n        planets.push_back(\"Venus\"\
    );\n        planets.push_back(\"Earth\");\n        planets.push_back(\"Mars\"\
    );\n        planets.push_back(\"Jupiter\");\n        planets.push_back(\"Saturn\"\
    );\n    }else if(planet1 == \"Uranus\"){\n        planets.push_back(\"Mercury\"\
    );\n        planets.push_back(\"Venus\");\n        planets.push_back(\"Earth\"\
    );\n        planets.push_back(\"Mars\");\n        planets.push_back(\"Jupiter\"\
    );\n        planets.push_back(\"Saturn\");\n        planets.push_back(\"Uranus\"\
    );\n    }else if(planet1 == \"Neptune\"){\n        planets.push_back(\"Mercury\"\
    );\n        planets.push_back(\"Venus\");\n        planets.push_back(\"Earth\"\
    );\n        planets.push_back(\"Mars\");\n        planets.push_back(\"Jupiter\"\
    );\n        planets.push_back(\"Saturn\");\n        planets.push_back(\"Uranus\"\
    );\n        planets.push_back(\"Neptune\");\n   \n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp__228o4k.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmp__228o4k.cpp:67:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   67 |\
    \ int main() {\n      |            ^\n/tmp/tmp__228o4k.cpp:76:1: error: expected\
    \ \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmp__228o4k.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmp__228o4k.cpp:76:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   76 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660114019
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {(std::string)\"\
    Mercury\", \n                                      (std::string)\"Venus\",\n \
    \                                     (std::string)\"Earth\",\n              \
    \                        (std::string)\"Mars\",\n                            \
    \          (std::string)\"Jupiter\",\n                                      (std::string)\"\
    Saturn\",\n                                      (std::string)\"Uranus\",\n  \
    \                                    (std::string)\"Neptune\"};\n  bool planet_one_is_first\
    \ = false;\n  int i;\n  int j;\n  std::vector<std::string> result;\n  for (i =\
    \ 0; i < planets.size(); i++) {\n    if (planets[i] == planet1) {\n      planet_one_is_first\
    \ = true;\n      break;\n    }\n  }\n  if (i == planets.size()) {\n    return\
    \ result;\n  }\n  for (j = 0; j < planets.size(); j++) {\n    if (planets[j] ==\
    \ planet2) {\n      break;\n    }\n  }\n  if (j == planets.size()) {\n    return\
    \ result;\n  }\n  if (planet_one_is_first && i < j) {\n    for (int k = i + 1;\
    \ k < j; k++) {\n      result.push_back(planets[k]);\n    }\n  } else if (!planet_one_is_first\
    \ && i > j) {\n    for (int k = j + 1; k < i; k++) {\n      result.push_back(planets[k]);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = bf;\n   \
    \ assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpzzcn6_es: /tmp/tmpzzcn6_es.cpp:63: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> list = { \"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tint pos1 = std::find(list.begin(), list.end(), planet1) - list.begin();\n\
    \tint pos2 = std::find(list.begin(), list.end(), planet2) - list.begin();\n\t\
    if (pos1 == list.size() || pos2 == list.size())\n\t\treturn {};\n\tstd::vector<std::string>\
    \ output;\n\tif (pos1 > pos2) {\n\t\tfor (int i = pos2 + 1; i < pos1; i++)\n\t\
    \t\toutput.push_back(list[i]);\n\t}\n\telse {\n\t\tfor (int i = pos1 + 1; i <\
    \ pos2; i++)\n\t\t\toutput.push_back(list[i]);\n\t}\n\treturn output;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    const std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> my_vector;\n    auto it = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if (it != planets.end() && it2 != planets.end()) {\n        if\
    \ (it > it2) {\n            auto it3 = it2;\n            it2 = it;\n         \
    \   it = it3;\n        }\n        for (auto it4 = it; it4 <= it2; it4++) {\n \
    \           my_vector.push_back(*it4);\n        }\n    }\n    return my_vector;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp5qh9w6v1: /tmp/tmp5qh9w6v1.cpp:38: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n      \
    \  \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\
    \n    };\n    std::vector<std::string> result;\n    auto pos1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto pos2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if (pos1 == planets.end() || pos2 == planets.end()) {\n     \
    \   return result;\n    }\n    auto start = pos1 < pos2 ? pos1 : pos2;\n    auto\
    \ end = pos1 < pos2 ? pos2 : pos1;\n    for (auto i = start + 1; i < end; ++i)\
    \ {\n        result.push_back(*i);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> list;\n\tconst std::string\
    \ planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n\tint i = -1,j = -1;\n\tfor(i = 0; i < 8; i++) {\n\
    \t\tif(planets[i] == planet1)\n\t\t\tbreak;\n\t}\n\tfor(j = 0; j < 8; j++) {\n\
    \t\tif(planets[j] == planet2)\n\t\t\tbreak;\n\t}\n\tif(i == -1 || j == -1)\n\t\
    \treturn list;\n\tif(i == j)\n\t\treturn list;\n\tif(i < j) {\n\t\tfor(int k =\
    \ i + 1; k < j; k++) {\n\t\t\tlist.push_back(planets[k]);\n\t\t}\n\t}\n\telse\
    \ {\n\t\tfor(int k = j + 1; k < i; k++) {\n\t\t\tlist.push_back(planets[k]);\n\
    \t\t}\n\t}\n\treturn list;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpo8gxtd62: /tmp/tmpo8gxtd62.cpp:55: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n      \
    \  \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\
    \n    };\n    std::vector<std::string> result;\n    std::vector<std::string>::iterator\
    \ it1 = find(planets.begin(), planets.end(), planet1);\n    std::vector<std::string>::iterator\
    \ it2 = find(planets.begin(), planets.end(), planet2);\n    if (it1 == planets.end()\
    \ || it2 == planets.end()) {\n        return result;\n    }\n    if (it1 <= it2)\
    \ {\n        result.insert(result.end(), it1 + 1, it2);\n    } else {\n      \
    \  result.insert(result.end(), it2 + 1, it1);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  vector::_M_range_insert\n"
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    int index1 = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \    int index2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \    std::vector<std::string> result = {};\n    if (index1 == 8 || index2 == 8)\
    \ {\n        return result;\n    }\n    if (index1 > index2) {\n        int tmp\
    \ = index1;\n        index1 = index2;\n        index2 = tmp;\n    }\n    while\
    \ (index1 < index2) {\n        result.push_back(planets[index1]);\n        index1++;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmprq4f8jxl: /tmp/tmprq4f8jxl.cpp:40: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets{ \"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> res;\n\tint pos1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n\tint pos2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n\tif (pos1 == 8 || pos2 == 8)\n\t\
    \treturn res;\n\tif (pos1 < pos2) {\n\t\tfor (int i = pos1 + 1; i < pos2; i++)\n\
    \t\t\tres.push_back(planets[i]);\n\t}\n\telse {\n\t\tfor (int i = pos2 + 1; i\
    \ < pos1; i++)\n\t\t\tres.push_back(planets[i]);\n\t}\n\treturn res;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // TODO: Write your code here\n    std::vector<std::string>planets={\"\
    Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"\
    };\n    std::vector<std::string>ans;\n    int index1=-1,index2=-1;\n    for(int\
    \ i=0;i<planets.size();i++){\n        if(planets[i]==planet1){\n            index1=i;\n\
    \        }\n        if(planets[i]==planet2){\n            index2=i;\n        }\n\
    \    }\n    if(index1==-1||index2==-1){\n        return ans;\n    }\n    if(index1>index2){\n\
    \        int temp=index1;\n        index1=index2;\n        index2=temp;\n    }\n\
    \    for(int i=index1+1;i<index2;i++){\n        ans.push_back(planets[i]);\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> solar_system = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> planet_between_1_and_2;\n  int i = 0;\n  while\
    \ (solar_system[i] != planet1) {\n    i++;\n  }\n  while (solar_system[i] != planet2)\
    \ {\n    planet_between_1_and_2.push_back(solar_system[i]);\n    i++;\n  }\n \
    \ return planet_between_1_and_2;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpsxfo2ddm: /tmp/tmpsxfo2ddm.cpp:34: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> v;\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    bool found_planet1 = false;\n    bool found_planet2\
    \ = false;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            found_planet1 = true;\n        }\n        if (planets[i]\
    \ == planet2) {\n            found_planet2 = true;\n        }\n    }\n    if (!found_planet1\
    \ || !found_planet2) {\n        return v;\n    }\n    int planet1_pos = -1;\n\
    \    int planet2_pos = -1;\n    for (int i = 0; i < planets.size(); i++) {\n \
    \       if (planets[i] == planet1) {\n            planet1_pos = i;\n        }\n\
    \        if (planets[i] == planet2) {\n            planet2_pos = i;\n        }\n\
    \    }\n    if (planet1_pos > planet2_pos) {\n        std::swap(planet1_pos, planet2_pos);\n\
    \    }\n    for (int i = planet1_pos + 1; i < planet2_pos; i++) {\n        v.push_back(planets[i]);\n\
    \    }\n    return v;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // your code\n    std::vector<std::string> planets;\n\
    \    planets.push_back(\"Mercury\");\n    planets.push_back(\"Venus\");\n    planets.push_back(\"\
    Earth\");\n    planets.push_back(\"Mars\");\n    planets.push_back(\"Jupiter\"\
    );\n    planets.push_back(\"Saturn\");\n    planets.push_back(\"Uranus\");\n \
    \   planets.push_back(\"Neptune\");\n    std::vector<std::string> ret;\n    if(std::find(planets.begin(),\
    \ planets.end(), planet1) == planets.end() || std::find(planets.begin(), planets.end(),\
    \ planet2) == planets.end())\n        return ret;\n    for(int i = 0; i < planets.size();\
    \ i++)\n    {\n        if(planets[i] == planet1)\n        {\n            for(int\
    \ j = i + 1; j < planets.size(); j++)\n            {\n                if(planets[j]\
    \ == planet2)\n                    return ret;\n                ret.push_back(planets[j]);\n\
    \            }\n        }\n    }\n    for(int i = 0; i < planets.size(); i++)\n\
    \    {\n        if(planets[i] == planet2)\n        {\n            for(int j =\
    \ i + 1; j < planets.size(); j++)\n            {\n                if(planets[j]\
    \ == planet1)\n                    return ret;\n                ret.push_back(planets[j]);\n\
    \            }\n        }\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpfcxxx63h: /tmp/tmpfcxxx63h.cpp:62: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\t\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmph8g19viq: /tmp/tmph8g19viq.cpp:24: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114016
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> result;\n    std::map<std::string,\
    \ int> planetsMap = {\n        {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3},\
    \ {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\"\
    , 8}\n    };\n    int planet1Index = planetsMap[planet1];\n    int planet2Index\
    \ = planetsMap[planet2];\n    for (auto& [planet, index] : planetsMap) {\n   \
    \     if (planet1Index < planet2Index) {\n            if (planet1Index < index\
    \ && index < planet2Index) {\n                result.push_back(planet);\n    \
    \        }\n        } else {\n            if (planet2Index < index && index <\
    \ planet1Index) {\n                result.push_back(planet);\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmppejbbxns: /tmp/tmppejbbxns.cpp:43: int main(): Assertion `candidate(("Mercury"),
    ("Uranus")) == (std::vector<std::string>({(std::string)"Venus", (std::string)"Earth",
    (std::string)"Mars", (std::string)"Jupiter", (std::string)"Saturn"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114021
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> res;\n\tstd::map<std::string,\
    \ int> planets = {{\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\"\
    , 4}, {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\", 8}};\n\
    \tif (planets.find(planet1) == planets.end() || planets.find(planet2) == planets.end())\
    \ {\n\t\treturn res;\n\t}\n\tint l = planets[planet1], r = planets[planet2];\n\
    \tstd::cout << l << \" \" << r << std::endl;\n\tif (l > r) std::swap(l, r);\n\t\
    for (int i = l; i <= r; i++) {\n\t\tif (i == l || i == r) continue;\n\t\tfor (auto\
    \ it = planets.begin(); it != planets.end(); it++) {\n\t\t\tif (it->second ==\
    \ i) {\n\t\t\t\tres.push_back(it->first);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: '5 8

    3 1

    1 7

    8 2

    3 3

    4 3

    '
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> sol = {};\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    bool flag = false;\n    int index1 = 0, index2\
    \ = 0;\n    for(int i = 0; i < planets.size(); i++) {\n        if(planets[i] ==\
    \ planet1) {\n            index1 = i;\n            flag = true;\n        } else\
    \ if(planets[i] == planet2) {\n            index2 = i;\n            flag = true;\n\
    \        }\n    }\n    if(!flag) {\n        return sol;\n    }\n    if(index1\
    \ > index2) {\n        std::swap(index1, index2);\n    }\n    for(int i = index1\
    \ + 1; i < index2; i++) {\n        sol.push_back(planets[i]);\n    }\n    return\
    \ sol;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpcpht1dau: /tmp/tmpcpht1dau.cpp:50: int main(): Assertion `candidate(("Earth"),
    ("Earth")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114021
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> res;\n\tstd::vector<std::string>\
    \ planets = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\" };\n\tstd::vector<std::string>::iterator it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n\tstd::vector<std::string>::iterator it2 = std::find(planets.begin(),\
    \ planets.end(), planet2);\n\tif (it1 == planets.end() || it2 == planets.end())\n\
    \t\treturn res;\n\tint index1 = std::distance(planets.begin(), it1);\n\tint index2\
    \ = std::distance(planets.begin(), it2);\n\tint l = std::min(index1, index2);\n\
    \tint r = std::max(index1, index2);\n\twhile (l <= r) {\n\t\tres.push_back(planets[l]);\n\
    \t\tl++;\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpx2oz6_u7: /tmp/tmpx2oz6_u7.cpp:38: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114021
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // your code here\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    auto it1\
    \ = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(),\
    \ planets.end(), planet2);\n    if (it1 == planets.end() || it2 == planets.end())\
    \ {\n        return result;\n    }\n    else {\n        if (it1 < it2) {\n   \
    \         for (auto it = it1 + 1; it != it2; it++) {\n                result.push_back(*it);\n\
    \            }\n        }\n        else {\n            for (auto it = it2 + 1;\
    \ it != it1; it++) {\n                result.push_back(*it);\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::logic_error'\n  what():\
    \  basic_string::_M_construct null not valid\n"
  stdout: ''
  timestamp: 1660114021
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> arr = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\t\
    std::vector<std::string> res;\n\tint ind1 = -1, ind2 = -1;\n\tfor (int i = 0;\
    \ i < arr.size(); i++) {\n\t\tif (arr[i] == planet1) ind1 = i;\n\t\tif (arr[i]\
    \ == planet2) ind2 = i;\n\t}\n\tif (ind1 == -1 || ind2 == -1) return res;\n\t\
    if (ind1 < ind2) {\n\t\tfor (int i = ind1 + 1; i < ind2; i++) res.push_back(arr[i]);\n\
    \t} else {\n\t\tfor (int i = ind2 + 1; i < ind1; i++) res.push_back(arr[i]);\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114020
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> result;\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int start_index = -1;\n    int end_index = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start_index = i;\n        }\n        if (planets[i] == planet2)\
    \ {\n            end_index = i;\n        }\n    }\n    if (start_index == -1 ||\
    \ end_index == -1) {\n        return result;\n    }\n    std::cout << start_index\
    \ << std::endl;\n    std::cout << end_index << std::endl;\n    if (start_index\
    \ < end_index) {\n        for (int i = start_index + 1; i < end_index; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    } else {\n        for\
    \ (int i = end_index + 1; i < start_index; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: '4

    7

    2

    0

    0

    6

    7

    1

    2

    2

    3

    2

    '
  timestamp: 1660114020
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planet_list = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    for (int i = 0; i < planet_list.size();\
    \ i++) {\n        if (planet_list[i] == planet1) {\n            for (int j = i+1;\
    \ j < planet_list.size(); j++) {\n                if (planet_list[j] == planet2)\
    \ {\n                    break;\n                }\n                result.push_back(planet_list[j]);\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmplj9bp1pr: /tmp/tmplj9bp1pr.cpp:37: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114021
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    auto iter1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto iter2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if(iter1 == planets.end() || iter2 == planets.end()) {\n    \
    \    return result;\n    }\n    int distance = std::distance(iter1, iter2);\n\
    \    if(distance >= 0) {\n        result.insert(result.end(), iter1, iter2);\n\
    \    } else {\n        result.insert(result.end(), iter2, iter1);\n    }\n   \
    \ return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpqmsgs8v2: /tmp/tmpqmsgs8v2.cpp:37: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114021
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = { \n    \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ \n  };\n  std::vector<std::string> res;\n  int f1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n  int f2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n  if (f1 > f2)\n    std::swap(f1,\
    \ f2);\n  if (f1 == 8 || f2 == 8)\n    return res;\n  for (int i = f1 + 1; i <\
    \ f2; ++i)\n    res.push_back(planets[i]);\n  return res;\n}\nint main() {\n \
    \   auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114021
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> result;\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(),\
    \ planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\
    \    if(it1 == planets.end() || it2 == planets.end())\n        return result;\n\
    \    std::sort(it1, it2);\n    auto it = it1;\n    while(it != it2) {\n      \
    \  result.push_back(*it);\n        it++;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpwht95_tr: /tmp/tmpwht95_tr.cpp:36: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114022
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets;\n\tplanets.push_back(\"\
    Mercury\");\n\tplanets.push_back(\"Venus\");\n\tplanets.push_back(\"Earth\");\n\
    \tplanets.push_back(\"Mars\");\n\tplanets.push_back(\"Jupiter\");\n\tplanets.push_back(\"\
    Saturn\");\n\tplanets.push_back(\"Uranus\");\n\tplanets.push_back(\"Neptune\"\
    );\n\t// find the index of the planet1\n\tint p1 = -1;\n\tfor (int i = 0; i <\
    \ planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tp1 = i;\n\t\t\
    \tbreak;\n\t\t}\n\t}\n\t// find the index of the planet2\n\tint p2 = -1;\n\tfor\
    \ (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet2) {\n\t\
    \t\tp2 = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if the planets are incorrect names\n\
    \tif (p1 == -1 || p2 == -1) {\n\t\treturn std::vector<std::string>();\n\t}\n\t\
    // create a new vector to contain the result\n\tstd::vector<std::string> result;\n\
    \t// add the planets between p1 and p2\n\tfor (int i = p1; i < p2; i++) {\n\t\t\
    result.push_back(planets[i]);\n\t}\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpkhd7m1ej: /tmp/tmpkhd7m1ej.cpp:59: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114022
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Mercury\") {\n        if (planet2\
    \ == \"Mercury\") {\n            return {};\n        } else if (planet2 == \"\
    Venus\") {\n            return {\"Venus\"};\n        } else if (planet2 == \"\
    Earth\") {\n            return {\"Venus\", \"Earth\"};\n        } else if (planet2\
    \ == \"Mars\") {\n            return {\"Venus\", \"Earth\", \"Mars\"};\n     \
    \   } else if (planet2 == \"Jupiter\") {\n            return {\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\"};\n        } else if (planet2 == \"Saturn\") {\n     \
    \       return {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n  \
    \      } else if (planet2 == \"Uranus\") {\n            return {\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n        } else if (planet2\
    \ == \"Neptune\") {\n            return {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n        } else {\n            return\
    \ {};\n        }\n    } else if (planet1 == \"Venus\") {\n        if (planet2\
    \ == \"Mercury\") {\n            return {};\n        } else if (planet2 == \"\
    Venus\") {\n            return {};\n        } else if (planet2 == \"Earth\") {\n\
    \            return {\"Earth\"};\n        } else if (planet2 == \"Mars\") {\n\
    \            return {\"Earth\", \"Mars\"};\n        } else if (planet2 == \"Jupiter\"\
    ) {\n            return {\"Earth\", \"Mars\", \"Jupiter\"};\n        } else if\
    \ (planet2 == \"Saturn\") {\n            return {\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"};\n        } else if (planet2 == \"Uranus\") {\n            return\
    \ {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n        } else\
    \ if (planet2 == \"Neptune\") {\n            return {\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n        } else {\n\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpxxo_m751.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpxxo_m751.cpp:60:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   60 |\
    \ int main() {\n      |            ^\n/tmp/tmpxxo_m751.cpp:69:1: error: expected\
    \ \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmpxxo_m751.cpp:40:36:\
    \ note: to match this \u2018{\u2019\n   40 |     } else if (planet1 == \"Venus\"\
    ) {\n      |                                    ^\n/tmp/tmpxxo_m751.cpp:69:1:\
    \ error: expected \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmpxxo_m751.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmpxxo_m751.cpp:69:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   69 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114013
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> ret;\n\tif(find(planets.begin(), planets.end(),\
    \ planet1) != planets.end() && find(planets.begin(), planets.end(), planet2) !=\
    \ planets.end()) {\n\t\tint first = find(planets.begin(), planets.end(), planet1)\
    \ - planets.begin();\n\t\tint second = find(planets.begin(), planets.end(), planet2)\
    \ - planets.begin();\n\t\tif(first > second) {\n\t\t\tint tmp = first;\n\t\t\t\
    first = second;\n\t\t\tsecond = tmp;\n\t\t}\n\t\tfor(int i = first + 1; i < second;\
    \ i++) {\n\t\t\tret.push_back(planets[i]);\n\t\t}\n\t}\n\treturn ret;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string>res;\n\tstd::vector<std::string>all\
    \ = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\" };\n\tint pos1 = -1, pos2 = -1;\n\tfor (int i = 0; i < 8;\
    \ i++) {\n\t\tif (all[i] == planet1) pos1 = i;\n\t\tif (all[i] == planet2) pos2\
    \ = i;\n\t}\n\tif (pos1 == -1 || pos2 == -1) return res;\n\tint l = pos1 < pos2\
    \ ? pos1 : pos2;\n\tint r = pos1 < pos2 ? pos2 : pos1;\n\tfor (int i = l + 1;\
    \ i < r; i++) {\n\t\tres.push_back(all[i]);\n\t}\n\treturn res;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n      \
    \  \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\
    \n    };\n    std::vector<std::string> result;\n    auto index1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto index2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if(index1 == planets.end() || index2 == planets.end()) {\n  \
    \      return result;\n    } else {\n        int start = std::distance(planets.begin(),\
    \ index1);\n        int end = std::distance(planets.begin(), index2);\n      \
    \  if(start > end) {\n            std::swap(start, end);\n        }\n        for(int\
    \ i = start + 1; i < end; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n        return result;\n    }\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> res;\n  std::string planets[8]\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n  int first_index = -1;\n  int second_index = -1;\n \
    \ for (int i = 0; i < 8; i++) {\n    if (planets[i] == planet1) {\n      first_index\
    \ = i;\n    }\n    if (planets[i] == planet2) {\n      second_index = i;\n   \
    \ }\n  }\n  if (first_index == -1 || second_index == -1) {\n    return res;\n\
    \  }\n  if (first_index < second_index) {\n    for (int i = first_index + 1; i\
    \ < second_index; i++) {\n      res.push_back(planets[i]);\n    }\n  } else {\n\
    \    for (int i = second_index + 1; i < first_index; i++) {\n      res.push_back(planets[i]);\n\
    \    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::map<std::string, int> m;\n\tm[\"Mercury\"] =\
    \ 1;\n\tm[\"Venus\"] = 2;\n\tm[\"Earth\"] = 3;\n\tm[\"Mars\"] = 4;\n\tm[\"Jupiter\"\
    ] = 5;\n\tm[\"Saturn\"] = 6;\n\tm[\"Uranus\"] = 7;\n\tm[\"Neptune\"] = 8;\n\t\
    std::string planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n\tif(m.find(planet1) == m.end() || m.find(planet2)\
    \ == m.end())\n\t\treturn {};\n\tif(m[planet1] > m[planet2])\n\t\tstd::swap(planet1,\
    \ planet2);\n\tstd::vector<std::string> v;\n\tfor(int i = m[planet1]; i <= m[planet2];\
    \ i++)\n\t\tv.push_back(planets[i - 1]);\n\treturn v;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpujl96k7v: /tmp/tmpujl96k7v.cpp:41: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> solar = { \"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n  auto foundPlanet1 = std::find(solar.begin(), solar.end(), planet1);\n\
    \  auto foundPlanet2 = std::find(solar.begin(), solar.end(), planet2);\n  std::vector<std::string>\
    \ result;\n  if (foundPlanet1 == solar.end() || foundPlanet2 == solar.end())\n\
    \    return result;\n  if (foundPlanet1 == foundPlanet2) {\n    result.push_back(*foundPlanet1);\n\
    \    return result;\n  }\n  if (foundPlanet1 > foundPlanet2) {\n    result.assign(foundPlanet2\
    \ + 1, foundPlanet1);\n    return result;\n  }\n  else {\n    result.assign(foundPlanet1\
    \ + 1, foundPlanet2);\n    return result;\n  }\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp5lqphi74: /tmp/tmp5lqphi74.cpp:45: int main(): Assertion `candidate(("Earth"),
    ("Earth")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114022
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets;\n    planets.push_back(\"\
    Mercury\");\n    planets.push_back(\"Venus\");\n    planets.push_back(\"Earth\"\
    );\n    planets.push_back(\"Mars\");\n    planets.push_back(\"Jupiter\");\n  \
    \  planets.push_back(\"Saturn\");\n    planets.push_back(\"Uranus\");\n    planets.push_back(\"\
    Neptune\");\n    // find the two planets\n    auto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if(it1 == planets.end() || it2 == planets.end())\n        return\
    \ std::vector<std::string>();\n    if(it1 > it2)\n        std::swap(it1, it2);\n\
    \    std::vector<std::string> result;\n    std::copy(it1, it2, std::back_inserter(result));\n\
    \    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpx4k8saja: /tmp/tmpx4k8saja.cpp:42: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int first_planet = -1;\n    int\
    \ second_planet = -1;\n    for (int i = 0; i < planets.size(); i++) {\n      \
    \  if (planets[i] == planet1) {\n            first_planet = i;\n        }\n  \
    \      if (planets[i] == planet2) {\n            second_planet = i;\n        }\n\
    \    }\n    if (first_planet == -1 || second_planet == -1) {\n        return result;\n\
    \    }\n    if (first_planet > second_planet) {\n        for (int i = second_planet\
    \ + 1; i < first_planet; i++) {\n            result.push_back(planets[i]);\n \
    \       }\n    } else {\n        for (int i = first_planet + 1; i < second_planet;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // write your code here\n    std::string planets[]\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n    std::map<std::string, int> planet_map;\n    for (int\
    \ i = 0; i < 8; i++) {\n        planet_map[planets[i]] = i;\n    }\n    auto p1\
    \ = planet_map.find(planet1);\n    auto p2 = planet_map.find(planet2);\n    if\
    \ (p1 == planet_map.end() || p2 == planet_map.end()) {\n        return {};\n \
    \   }\n    std::vector<std::string> res;\n    if (p1->second > p2->second) {\n\
    \        p1 = planet_map.find(planet2);\n        p2 = planet_map.find(planet1);\n\
    \    }\n    for (int i = p1->second + 1; i < p2->second; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets {\n\t\t\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> answer;\n\tint found1 = 0;\n\tint found2 = 0;\n\
    \tstd::vector<std::string>::iterator it1 = planets.begin();\n\tstd::vector<std::string>::iterator\
    \ it2 = planets.begin();\n\tstd::vector<std::string>::iterator it = planets.begin();\n\
    \tfor (it = planets.begin(); it != planets.end(); it++) {\n\t\tif (*it == planet1)\
    \ {\n\t\t\tfound1 = 1;\n\t\t\tit1 = it;\n\t\t}\n\t\tif (*it == planet2) {\n\t\t\
    \tfound2 = 1;\n\t\t\tit2 = it;\n\t\t}\n\t}\n\tif (found1 == 0 || found2 == 0)\
    \ {\n\t\treturn answer;\n\t}\n\tif (it1 < it2) {\n\t\tfor (it = it1 + 1; it !=\
    \ it2; it++) {\n\t\t\tanswer.push_back(*it);\n\t\t}\n\t}\n\telse {\n\t\tfor (it\
    \ = it2 + 1; it != it1; it++) {\n\t\t\tanswer.push_back(*it);\n\t\t}\n\t}\n\t\
    return answer;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::logic_error'\n  what():\
    \  basic_string::_M_construct null not valid\n"
  stdout: ''
  timestamp: 1660114023
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1 == \"Mercury\") {\n        if(planet2\
    \ == \"Venus\") {\n            return std::vector<std::string>{\"Venus\"};\n \
    \       }\n        else if(planet2 == \"Earth\") {\n            return std::vector<std::string>{\"\
    Venus\", \"Earth\"};\n        }\n        else if(planet2 == \"Mars\") {\n    \
    \        return std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\"};\n  \
    \      }\n        else if(planet2 == \"Jupiter\") {\n            return std::vector<std::string>{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\"};\n        }\n        else if(planet2\
    \ == \"Saturn\") {\n            return std::vector<std::string>{\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n        }\n        else if(planet2\
    \ == \"Uranus\") {\n            return std::vector<std::string>{\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n        }\n        else\
    \ if(planet2 == \"Neptune\") {\n            return std::vector<std::string>{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n        }\n        else {\n            return std::vector<std::string>{};\n\
    \        }\n    }\n    else if(planet1 == \"Venus\") {\n        if(planet2 ==\
    \ \"Earth\") {\n            return std::vector<std::string>{\"Earth\"};\n    \
    \    }\n        else if(planet2 == \"Mars\") {\n            return std::vector<std::string>{\"\
    Earth\", \"Mars\"};\n        }\n        else if(planet2 == \"Jupiter\") {\n  \
    \          return std::vector<std::string>{\"Earth\", \"Mars\", \"Jupiter\"};\n\
    \        }\n        else if(planet2 == \"Saturn\") {\n            return std::vector<std::string>{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n        }\n        else if(planet2\
    \ == \"Uranus\") {\n            return std::vector<std::\n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpzmrvfzpd.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpzmrvfzpd.cpp:60:32: error: template\
    \ argument 1 is invalid\n   60 |             return std::vector<std::\n      |\
    \                                ^~~\n/tmp/tmpzmrvfzpd.cpp:60:32: error: template\
    \ argument 2 is invalid\n/tmp/tmpzmrvfzpd.cpp:60:35: error: expected \u2018;\u2019\
    \ before \u2018}\u2019 token\n   60 |             return std::vector<std::\n \
    \     |                                   ^\n      |                         \
    \          ;\n   61 | }\n      | ~                                  \n/tmp/tmpzmrvfzpd.cpp:62:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   62 | int main() {\n      |            ^\n/tmp/tmpzmrvfzpd.cpp:71:1: error:\
    \ expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpzmrvfzpd.cpp:46:33:\
    \ note: to match this \u2018{\u2019\n   46 |     else if(planet1 == \"Venus\"\
    ) {\n      |                                 ^\n/tmp/tmpzmrvfzpd.cpp:71:1: error:\
    \ expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpzmrvfzpd.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n"
  stdout: ''
  timestamp: 1660114022
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> p = { \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n \
    \   std::vector<std::string> ans;\n    auto it1 = std::find(p.begin(), p.end(),\
    \ planet1);\n    auto it2 = std::find(p.begin(), p.end(), planet2);\n    if(it1\
    \ == p.end() || it2 == p.end())\n        return ans;\n    if(it1 > it2)\n    \
    \    std::swap(it1, it2);\n    for(auto it = it1 + 1; it != it2; it++)\n     \
    \   ans.push_back(*it);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::logic_error'\n  what():\
    \  basic_string::_M_construct null not valid\n"
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n  \
    \  }\n    if (index1 != -1 && index2 != -1) {\n        if (index1 > index2) {\n\
    \            for (int i = index2 + 1; i < index1; i++) {\n                result.push_back(planets[i]);\n\
    \            }\n        } else {\n            for (int i = index1 + 1; i < index2;\
    \ i++) {\n                result.push_back(planets[i]);\n            }\n     \
    \   }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::map<std::string, int> planets;\n\tplanets[\"\
    Mercury\"] = 1;\n\tplanets[\"Venus\"] = 2;\n\tplanets[\"Earth\"] = 3;\n\tplanets[\"\
    Mars\"] = 4;\n\tplanets[\"Jupiter\"] = 5;\n\tplanets[\"Saturn\"] = 6;\n\tplanets[\"\
    Uranus\"] = 7;\n\tplanets[\"Neptune\"] = 8;\n\tstd::vector<std::string> result;\n\
    \tif (planets.find(planet1) == planets.end() or\n\t\tplanets.find(planet2) ==\
    \ planets.end())\n\t\treturn result;\n\tint start = std::min(planets[planet1],\
    \ planets[planet2]);\n\tint end = std::max(planets[planet1], planets[planet2]);\n\
    \tfor (int i = start + 1; i < end; i++) {\n\t\tif (i == 2)\n\t\t\tresult.push_back(\"\
    Venus\");\n\t\tif (i == 3)\n\t\t\tresult.push_back(\"Earth\");\n\t\tif (i == 4)\n\
    \t\t\tresult.push_back(\"Mars\");\n\t\tif (i == 5)\n\t\t\tresult.push_back(\"\
    Jupiter\");\n\t\tif (i == 6)\n\t\t\tresult.push_back(\"Saturn\");\n\t\tif (i ==\
    \ 7)\n\t\t\tresult.push_back(\"Uranus\");\n\t}\n\treturn result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> r;\n  std::vector<std::string>\
    \ p = {\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n   \
    \ \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\"\n  };\n  int\
    \ i1 = std::find(p.begin(), p.end(), planet1) - p.begin();\n  int i2 = std::find(p.begin(),\
    \ p.end(), planet2) - p.begin();\n  if (i1 < 0 || i2 < 0) return r;\n  if (i1\
    \ < i2) {\n    for (int i = i1 + 1; i < i2; i++) r.push_back(p[i]);\n  } else\
    \ {\n    for (int i = i2 + 1; i < i1; i++) r.push_back(p[i]);\n  }\n  return r;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpotf2ldin: /tmp/tmpotf2ldin.cpp:49: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> sol = {};\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int p1 = -1, p2 = -1;\n    for (int i = 0; i\
    \ < 8; i++) {\n        if (planets[i] == planet1) {\n            p1 = i;\n   \
    \     }\n        if (planets[i] == planet2) {\n            p2 = i;\n        }\n\
    \    }\n    if (p1 == -1 || p2 == -1) {\n        return sol;\n    }\n    for (int\
    \ i = p1; i <= p2; i++) {\n        sol.push_back(planets[i]);\n    }\n    return\
    \ sol;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmppjxiuem9: /tmp/tmppjxiuem9.cpp:41: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int planet_1_pos = -1;\n    int\
    \ planet_2_pos = -1;\n    for (int i = 0; i < planets.size(); i++) {\n       \
    \ if (planets[i] == planet1) {\n            planet_1_pos = i;\n        } else\
    \ if (planets[i] == planet2) {\n            planet_2_pos = i;\n        }\n   \
    \ }\n    if (planet_1_pos == -1 || planet_2_pos == -1) {\n        return result;\n\
    \    }\n    for (int i = planet_1_pos + 1; i < planet_2_pos; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmphcngwkug: /tmp/tmphcngwkug.cpp:42: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> result;\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int idx1 = -1, idx2 = -1;\n    for (int i = 0;\
    \ i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n         \
    \   idx1 = i;\n        }\n        if (planets[i] == planet2) {\n            idx2\
    \ = i;\n        }\n    }\n    if (idx1 == -1 || idx2 == -1) {\n        return\
    \ result;\n    }\n    for (int i = std::min(idx1, idx2) + 1; i < std::max(idx1,\
    \ idx2); i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    if (planet1 == \"Mercury\") {\n        if (planet2 == \"Venus\") return\
    \ std::vector<std::string>{\"Venus\"};\n        if (planet2 == \"Earth\") return\
    \ std::vector<std::string>{\"Venus\", \"Earth\"};\n        if (planet2 == \"Mars\"\
    ) return std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\"};\n        if\
    \ (planet2 == \"Jupiter\") return std::vector<std::string>{\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\"};\n        if (planet2 == \"Saturn\") return std::vector<std::string>{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n        if (planet2 ==\
    \ \"Uranus\") return std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\"};\n        if (planet2 == \"Neptune\") return\
    \ std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    }\n    if (planet1 == \"Venus\") {\n        if\
    \ (planet2 == \"Earth\") return std::vector<std::string>{\"Earth\"};\n       \
    \ if (planet2 == \"Mars\") return std::vector<std::string>{\"Earth\", \"Mars\"\
    };\n        if (planet2 == \"Jupiter\") return std::vector<std::string>{\"Earth\"\
    , \"Mars\", \"Jupiter\"};\n        if (planet2 == \"Saturn\") return std::vector<std::string>{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n        if (planet2 == \"Uranus\"\
    ) return std::vector<std::string>{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"};\n        if (planet2 == \"Neptune\") return std::vector<std::string>{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Sat\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwvppx8ec.cpp:36:95: warning: missing terminating \" character\n\
    \   36 |         if (planet2 == \"Neptune\") return std::vector<std::string>{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Sat\n      |                               \
    \                                                                ^\n/tmp/tmpwvppx8ec.cpp:36:95:\
    \ error: missing terminating \" character\n   36 |         if (planet2 == \"Neptune\"\
    ) return std::vector<std::string>{\"Earth\", \"Mars\", \"Jupiter\", \"Sat\n  \
    \    |                                                                       \
    \                        ^~~~\n/tmp/tmpwvppx8ec.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpwvppx8ec.cpp:37:2: error: expected\
    \ \u2018;\u2019 before \u2018int\u2019\n   37 | }\n      |  ^\n      |  ;\n  \
    \ 38 | int main() {\n      | ~~~\n/tmp/tmpwvppx8ec.cpp:38:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   38 | int main() {\n     \
    \ |            ^\n/tmp/tmpwvppx8ec.cpp:47:1: error: expected \u2018}\u2019 at\
    \ end of input\n   47 | }\n      | ^\n/tmp/tmpwvppx8ec.cpp:30:29: note: to match\
    \ this \u2018{\u2019\n   30 |     if (planet1 == \"Venus\") {\n      |       \
    \                      ^\n/tmp/tmpwvppx8ec.cpp:47:1: error: expected \u2018}\u2019\
    \ at end of input\n   47 | }\n      | ^\n/tmp/tmpwvppx8ec.cpp:19:71: note: to\
    \ match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n      |                                            \
    \                           ^\n/tmp/tmpwvppx8ec.cpp:47:1: warning: control reaches\
    \ end of non-void function [-Wreturn-type]\n   47 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114022
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = { \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n    std::vector<std::string> res;\n    if (std::find(planets.begin(), planets.end(),\
    \ planet1) == planets.end() ||\n        std::find(planets.begin(), planets.end(),\
    \ planet2) == planets.end())\n        return res;\n    if (std::find(planets.begin(),\
    \ planets.end(), planet1) < std::find(planets.begin(), planets.end(), planet2))\n\
    \        std::copy(std::find(planets.begin(), planets.end(), planet1) + 1, std::find(planets.begin(),\
    \ planets.end(), planet2), std::back_inserter(res));\n    else\n        std::copy(std::find(planets.begin(),\
    \ planets.end(), planet2) + 1, std::find(planets.begin(), planets.end(), planet1),\
    \ std::back_inserter(res));\n    return res;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> between_planets;\n    int first_index = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int second_index = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (first_index > 7 || second_index\
    \ > 7) {\n        return between_planets;\n    }\n    if (first_index > second_index)\
    \ {\n        for (int i = second_index + 1; i < first_index; i++) {\n        \
    \    between_planets.push_back(planets[i]);\n        }\n    } else {\n       \
    \ for (int i = first_index + 1; i < second_index; i++) {\n            between_planets.push_back(planets[i]);\n\
    \        }\n    }\n    return between_planets;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114022
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> ans;\n  std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n  int pos_planet1 = std::find(planets.begin(), planets.end(),\
    \ planet1) - planets.begin();\n  int pos_planet2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n  if (pos_planet1 > pos_planet2)\
    \ std::swap(pos_planet1, pos_planet2);\n  for (int i = pos_planet1 + 1; i < pos_planet2;\
    \ i++) ans.push_back(planets[i]);\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpfi27arwi: /tmp/tmpfi27arwi.cpp:36: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> res;\n\tif (std::find(planets.begin(), planets.end(),\
    \ planet1) == planets.end() || std::find(planets.begin(), planets.end(), planet2)\
    \ == planets.end()) {\n\t\treturn res;\n\t}\n\tauto start = std::find(planets.begin(),\
    \ planets.end(), planet1);\n\tauto end = std::find(planets.begin(), planets.end(),\
    \ planet2);\n\tif (start < end) {\n\t\tres.assign(start + 1, end);\n\t} else {\n\
    \t\tres.assign(end + 1, start);\n\t}\n\treturn res;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    int first_idx = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \    int second_idx = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \    std::vector<std::string> res;\n    if(first_idx >= planets.size() || second_idx\
    \ >= planets.size())\n        return res;\n    else if(first_idx > second_idx)\n\
    \        return res;\n    else\n        for(int i = first_idx + 1; i < second_idx;\
    \ i++)\n            res.push_back(planets[i]);\n    return res;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpttk063vq: /tmp/tmpttk063vq.cpp:36: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets{(std::string)\"\
    Mercury\", (std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\",\
    \ (std::string)\"Neptune\"};\n    std::vector<std::string> sol;\n    int p1 =\
    \ std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int\
    \ p2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \    if(p1 == 8 || p2 == 8){\n        return sol;\n    }\n    if(p1 < p2){\n \
    \       for(int i = p1 + 1; i < p2; i++){\n            sol.push_back(planets[i]);\n\
    \        }\n    }else{\n        for(int i = p2 + 1; i < p1; i++){\n          \
    \  sol.push_back(planets[i]);\n        }\n    }\n    return sol;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tconst static std::vector<std::string> solar_system\
    \ = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\" };\n\tconst auto planet1_index = std::find(solar_system.begin(),\
    \ solar_system.end(), planet1);\n\tconst auto planet2_index = std::find(solar_system.begin(),\
    \ solar_system.end(), planet2);\n\tif (planet1_index == solar_system.end() ||\
    \ planet2_index == solar_system.end()) {\n\t\treturn {};\n\t}\n\tif (planet1_index\
    \ < planet2_index) {\n\t\treturn { planet1_index + 1, planet2_index };\n\t}\n\t\
    else {\n\t\treturn { planet2_index + 1, planet1_index };\n\t}\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::map<std::string, int> m;\n  m[\"Mercury\"] =\
    \ 1;\n  m[\"Venus\"] = 2;\n  m[\"Earth\"] = 3;\n  m[\"Mars\"] = 4;\n  m[\"Jupiter\"\
    ] = 5;\n  m[\"Saturn\"] = 6;\n  m[\"Uranus\"] = 7;\n  m[\"Neptune\"] = 8;\n  std::vector<std::string>\
    \ p({\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"});\n  std::vector<std::string> res;\n  if(m.find(planet1)\
    \ == m.end() || m.find(planet2) == m.end())\n    return res;\n  if(m[planet1]\
    \ < m[planet2])\n    for(int i = m[planet1]; i < m[planet2]; i++)\n      res.push_back(p[i]);\n\
    \  else\n    for(int i = m[planet1]; i > m[planet2]; i--)\n      res.push_back(p[i]);\n\
    \  return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpmfcr50ut: /tmp/tmpmfcr50ut.cpp:43: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::map<std::string,int> Planets;\n    Planets[\"\
    Mercury\"] = 1;\n    Planets[\"Venus\"] = 2;\n    Planets[\"Earth\"] = 3;\n  \
    \  Planets[\"Mars\"] = 4;\n    Planets[\"Jupiter\"] = 5;\n    Planets[\"Saturn\"\
    ] = 6;\n    Planets[\"Uranus\"] = 7;\n    Planets[\"Neptune\"] = 8;\n    if(Planets.find(planet1)==Planets.end()||Planets.find(planet2)==Planets.end())\
    \ return {};\n    int a = Planets[planet1];\n    int b = Planets[planet2];\n \
    \   if(a>b)\n        std::swap(a,b);\n    std::vector<std::string> ans;\n    for(auto\
    \ p:Planets)\n        if(p.second>a&&p.second<b)\n            ans.push_back(p.first);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpvjwb_y4q: /tmp/tmpvjwb_y4q.cpp:44: int main(): Assertion `candidate(("Mercury"),
    ("Uranus")) == (std::vector<std::string>({(std::string)"Venus", (std::string)"Earth",
    (std::string)"Mars", (std::string)"Jupiter", (std::string)"Saturn"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code goes here\n    std::vector<std::string>\
    \ result;\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int\
    \ first = 0;\n    int second = 0;\n    for (int i = 0; i < planets.size(); i++)\
    \ {\n        if (planets[i] == planet1) {\n            first = i;\n        }\n\
    \        if (planets[i] == planet2) {\n            second = i;\n        }\n  \
    \  }\n    if (first == 0 || second == 0) {\n        return result;\n    }\n  \
    \  if (first > second) {\n        int temp = first;\n        first = second;\n\
    \        second = temp;\n    }\n    for (int i = first + 1; i < second; i++) {\n\
    \        result.push_back(planets[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpxsfeynx5: /tmp/tmpxsfeynx5.cpp:49: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets;\n    planets.push_back(\"\
    Mercury\");\n    planets.push_back(\"Venus\");\n    planets.push_back(\"Earth\"\
    );\n    planets.push_back(\"Mars\");\n    planets.push_back(\"Jupiter\");\n  \
    \  planets.push_back(\"Saturn\");\n    planets.push_back(\"Uranus\");\n    planets.push_back(\"\
    Neptune\");\n    bool flag = false;\n    std::vector<std::string> result;\n  \
    \  for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            flag = true;\n        }\n        if (flag == true) {\n      \
    \      result.push_back(planets[i]);\n        }\n        if (planets[i] == planet2)\
    \ {\n            flag = false;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpl8oog349: /tmp/tmpl8oog349.cpp:46: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> ret;\n    std::string str[]\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n    std::map<std::string, int> mp;\n    for (int i =\
    \ 0; i < 8; i++) {\n        mp[str[i]] = i;\n    }\n    if (mp.find(planet1) ==\
    \ mp.end() || mp.find(planet2) == mp.end()) {\n        return ret;\n    }\n  \
    \  if (mp[planet1] < mp[planet2]) {\n        for (int i = mp[planet1] + 1; i <\
    \ mp[planet2]; i++) {\n            ret.push_back(str[i]);\n        }\n    } else\
    \ {\n        for (int i = mp[planet2] + 1; i < mp[planet1]; i++) {\n         \
    \   ret.push_back(str[i]);\n        }\n    }\n    return ret;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets;\n    std::vector<std::string>\
    \ result;\n    planets.push_back(\"Mercury\");\n    planets.push_back(\"Venus\"\
    );\n    planets.push_back(\"Earth\");\n    planets.push_back(\"Mars\");\n    planets.push_back(\"\
    Jupiter\");\n    planets.push_back(\"Saturn\");\n    planets.push_back(\"Uranus\"\
    );\n    planets.push_back(\"Neptune\");\n    bool check = false;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          check = true;\n        }\n        if (check == true) {\n          \
    \  if (planets[i] == planet2) {\n                break;\n            }\n     \
    \       result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpv7j60vpo: /tmp/tmpv7j60vpo.cpp:46: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planetList = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint start = 0;\n\tint end = 0;\n\tfor\
    \ (int i = 0; i < planetList.size(); i++) {\n\t\tif (planetList[i] == planet1)\
    \ {\n\t\t\tstart = i;\n\t\t}\n\t\tif (planetList[i] == planet2) {\n\t\t\tend =\
    \ i;\n\t\t}\n\t}\n\tif (start == 0 || end == 0) {\n\t\treturn result;\n\t}\n\t\
    if (start > end) {\n\t\tfor (int i = end; i < start; i++) {\n\t\t\tresult.push_back(planetList[i]);\n\
    \t\t}\n\t} else {\n\t\tfor (int i = start; i < end; i++) {\n\t\t\tresult.push_back(planetList[i]);\n\
    \t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp_sj_fw_p: /tmp/tmp_sj_fw_p.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  int p1 = -1, p2 = -1;\n  std::string planets[] = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n  for (int i = 0; i < 8; i++) {\n    if (planets[i] == planet1)\
    \ {\n      p1 = i;\n    }\n    if (planets[i] == planet2) {\n      p2 = i;\n \
    \   }\n  }\n  std::vector<std::string> res;\n  if (p1 == -1 || p2 == -1) {\n \
    \   return res;\n  }\n  if (p1 > p2) {\n    std::swap(p1, p2);\n  }\n  for (int\
    \ i = p1 + 1; i < p2; i++) {\n    res.push_back(planets[i]);\n  }\n  return res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::map<std::string, int> planets = {{\"Mercury\"\
    , 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\"\
    , 6}, {\"Uranus\", 7}, {\"Neptune\", 8}};\n    std::vector<std::string> res;\n\
    \    if (planets.find(planet1) == planets.end() || planets.find(planet2) == planets.end())\
    \ {\n        return res;\n    }\n    if (planets[planet1] < planets[planet2])\
    \ {\n        for (int i = planets[planet1] + 1; i < planets[planet2]; i++) {\n\
    \            res.push_back(planets.begin()->first);\n        }\n    } else {\n\
    \        for (int i = planets[planet2] + 1; i < planets[planet1]; i++) {\n   \
    \         res.push_back(planets.begin()->first);\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp4_6jvh9l: /tmp/tmp4_6jvh9l.cpp:38: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // If planet1 and planet2 are not valid planet names,\
    \ return an empty vector.\n    if (planet1 != \"Mercury\" && planet1 != \"Venus\"\
    \ && planet1 != \"Earth\" &&\n        planet1 != \"Mars\" && planet1 != \"Jupiter\"\
    \ && planet1 != \"Saturn\" &&\n        planet1 != \"Uranus\" && planet1 != \"\
    Neptune\") {\n        return std::vector<std::string>();\n    }\n    if (planet2\
    \ != \"Mercury\" && planet2 != \"Venus\" && planet2 != \"Earth\" &&\n        planet2\
    \ != \"Mars\" && planet2 != \"Jupiter\" && planet2 != \"Saturn\" &&\n        planet2\
    \ != \"Uranus\" && planet2 != \"Neptune\") {\n        return std::vector<std::string>();\n\
    \    }\n    // Planet is each planet's name.\n    // planetPos is each planet's\
    \ distance from the sun.\n    // planetPosRange is the vector where we will store\
    \ the names of the planets.\n    std::string planet;\n    int planetPos;\n   \
    \ std::vector<std::string> planetPosRange;\n    for (int i = 1; i <= 8; i++) {\n\
    \        switch (i) {\n            case 1:\n                planet = \"Mercury\"\
    ;\n                planetPos = 1;\n                break;\n            case 2:\n\
    \                planet = \"Venus\";\n                planetPos = 2;\n       \
    \         break;\n            case 3:\n                planet = \"Earth\";\n \
    \               planetPos = 3;\n                break;\n            case 4:\n\
    \                planet = \"Mars\";\n                planetPos = 4;\n        \
    \        break;\n            case 5:\n                planet = \"Jupiter\";\n\
    \                planetPos = 5;\n                break;\n            case 6:\n\
    \                planet = \"Saturn\";\n                planetPos = 6;\n      \
    \          break;\n            case 7:\n                planet = \"Uranus\";\n\
    \                planetPos = 7;\n                break;\n            case 8:\n\
    \                planet = \"Neptune\";\n                planetPos = 8;\n     \
    \           break;\n        }\n        // If planet1 and planet2 are not reversed\
    \ and planet is between planet1 and planet2,\n        // add planet to planetPos\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpg5ip_fmb.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpg5ip_fmb.cpp:75:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   75 |\
    \ int main() {\n      |            ^\n/tmp/tmpg5ip_fmb.cpp:84:1: error: expected\
    \ \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmpg5ip_fmb.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmpg5ip_fmb.cpp:84:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   84 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  int p1 = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \  int p2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \  std::vector<std::string> v;\n  if (p1 > p2) {\n    for (int i = p2; i < p1;\
    \ i++) {\n      v.push_back(planets[i]);\n    }\n  } else {\n    for (int i =\
    \ p1; i < p2; i++) {\n      v.push_back(planets[i]);\n    }\n  }\n  return v;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpq6bea1kq: /tmp/tmpq6bea1kq.cpp:37: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114023
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> res;\n\tstd::map<std::string,\
    \ int> m = {\n\t\t{\"Mercury\", 1},\n\t\t{\"Venus\", 2},\n\t\t{\"Earth\", 3},\n\
    \t\t{\"Mars\", 4},\n\t\t{\"Jupiter\", 5},\n\t\t{\"Saturn\", 6},\n\t\t{\"Uranus\"\
    , 7},\n\t\t{\"Neptune\", 8}\n\t};\n\tint p1 = m[planet1];\n\tint p2 = m[planet2];\n\
    \tif (p1 == 0 || p2 == 0) return res;\n\tif (p1 < p2) {\n\t\tfor (int i = p1;\
    \ i < p2; i++) {\n\t\t\tres.push_back(m.find(i)->first);\n\t\t}\n\t} else {\n\t\
    \tfor (int i = p1; i > p2; i--) {\n\t\t\tres.push_back(m.find(i)->first);\n\t\t\
    }\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyx7nxhwh.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmpyx7nxhwh.cpp:36:26: error: no\
    \ matching function for call to \u2018std::map<std::__cxx11::basic_string<char>,\
    \ int>::find(int&)\u2019\n   36 |    res.push_back(m.find(i)->first);\n      |\
    \                          ^\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpyx7nxhwh.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1168:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::iterator std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::find(const key_type&) [with _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc =\
    \ std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const std::__cxx11::basic_string<char>,\
    \ int> >; std::map<_Key, _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1168 |       find(const key_type& __x)\n      |       ^~~~\n/usr/include/c++/9/bits/stl_map.h:1168:28:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1168 |       find(const key_type& __x)\n      |            ~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_map.h:1174:2: note: candidate: \u2018template<class\
    \ _Kt> decltype (((std::map<_Key, _Tp, _Compare, _Alloc>*)this)->std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::_M_t._M_find_tr(__x)) std::map<_Key, _Tp, _Compare,\
    \ _Alloc>::find(const _Kt&) [with _Kt = _Kt; _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc =\
    \ std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]\u2019\
    \n 1174 |  find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n      |  ^~~~\n\
    /usr/include/c++/9/bits/stl_map.h:1174:2: note:   template argument deduction/substitution\
    \ failed:\n"
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    int p1, p2;\n    if (planet1 == \"Mercury\") p1\
    \ = 0;\n    else if (planet1 == \"Venus\") p1 = 1;\n    else if (planet1 == \"\
    Earth\") p1 = 2;\n    else if (planet1 == \"Mars\") p1 = 3;\n    else if (planet1\
    \ == \"Jupiter\") p1 = 4;\n    else if (planet1 == \"Saturn\") p1 = 5;\n    else\
    \ if (planet1 == \"Uranus\") p1 = 6;\n    else if (planet1 == \"Neptune\") p1\
    \ = 7;\n    else return {};\n    if (planet2 == \"Mercury\") p2 = 0;\n    else\
    \ if (planet2 == \"Venus\") p2 = 1;\n    else if (planet2 == \"Earth\") p2 = 2;\n\
    \    else if (planet2 == \"Mars\") p2 = 3;\n    else if (planet2 == \"Jupiter\"\
    ) p2 = 4;\n    else if (planet2 == \"Saturn\") p2 = 5;\n    else if (planet2 ==\
    \ \"Uranus\") p2 = 6;\n    else if (planet2 == \"Neptune\") p2 = 7;\n    else\
    \ return {};\n    if (p1 > p2) std::swap(p1, p2);\n    std::vector<std::string>\
    \ result;\n    for (int i = p1 + 1; i < p2; i++) {\n        if (i == 0) result.push_back(\"\
    Mercury\");\n        else if (i == 1) result.push_back(\"Venus\");\n        else\
    \ if (i == 2) result.push_back(\"Earth\");\n        else if (i == 3) result.push_back(\"\
    Mars\");\n        else if (i == 4) result.push_back(\"Jupiter\");\n        else\
    \ if (i == 5) result.push_back(\"Saturn\");\n        else if (i == 6) result.push_back(\"\
    Uranus\");\n        else if (i == 7) result.push_back(\"Neptune\");\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> result = {};\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::unordered_map<std::string, int> planet_map\
    \ = {\n        {\"Mercury\", 0},\n        {\"Venus\", 1},\n        {\"Earth\"\
    , 2},\n        {\"Mars\", 3},\n        {\"Jupiter\", 4},\n        {\"Saturn\"\
    , 5},\n        {\"Uranus\", 6},\n        {\"Neptune\", 7}\n    };\n    if (planet_map.find(planet1)\
    \ == planet_map.end() || planet_map.find(planet2) == planet_map.end()) {\n   \
    \     return result;\n    }\n    int start_index = planet_map[planet1];\n    int\
    \ end_index = planet_map[planet2];\n    if (start_index > end_index) {\n     \
    \   std::swap(start_index, end_index);\n    }\n    for (int i = start_index +\
    \ 1; i < end_index; i++) {\n        result.push_back(planets[i]);\n    }\n   \
    \ return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114024
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> v = { \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n\t\
    int a, b;\n\tbool p1, p2;\n\tp1 = p2 = false;\n\tfor (int i = 0; i < v.size();\
    \ i++) {\n\t\tif (v[i] == planet1) {\n\t\t\ta = i;\n\t\t\tp1 = true;\n\t\t}\n\t\
    \tif (v[i] == planet2) {\n\t\t\tb = i;\n\t\t\tp2 = true;\n\t\t}\n\t}\n\tstd::vector<std::string>\
    \ vr;\n\tif (p1 && p2) {\n\t\tif (a > b) {\n\t\t\tfor (int i = b + 1; i < a; i++)\
    \ {\n\t\t\t\tvr.push_back(v[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i\
    \ = a + 1; i < b; i++) {\n\t\t\t\tvr.push_back(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\
    return vr;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    //planets is a sorted array of strings with planet\
    \ names\n    //copy_of_planets is a copy of planets\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::vector<std::string> copy_of_planets = planets;\n\
    \    // result is empty vector\n    std::vector<std::string> result;\n    //remove\
    \ planets from the vector if they do not exist \n    //(here we check if planet\
    \ name exists)\n    if(std::find(planets.begin(), planets.end(), planet1) == planets.end())\n\
    \    {\n        planets.erase(std::remove(planets.begin(), planets.end(), planet1),\
    \ planets.end());\n    }\n    if(std::find(planets.begin(), planets.end(), planet2)\
    \ == planets.end())\n    {\n        planets.erase(std::remove(planets.begin(),\
    \ planets.end(), planet2), planets.end());\n    }\n    //if planets vector is\
    \ empty -> planet1 or planet2 do not exist\n    if(planets.empty())\n    {\n \
    \       return result;\n    }\n    //if planets vector is not empty -> planet1\
    \ and planet2 exist\n    //get an iterator to the first element in the planets\
    \ array\n    std::vector<std::string>::iterator it = planets.begin();\n    //and\
    \ increment the iterator until we reach planet1\n    while(*it != planet1)\n \
    \   {\n        it++;\n    }\n    //when we reach planet1 we get the iterator and\
    \ increment it until we reach planet2\n    //push_back all elements on the way\n\
    \    while(*it != planet2)\n    {\n        it++;\n        result.push_back(*it);\n\
    \    }\n    //if the planet1 is after planet2 in the array, we invert the result\
    \ vector\n    if(std::find(copy_of_planets.begin(), copy_of_planets.end(), planet1)\
    \ > \n    std::find(copy_of_planets.begin(), copy_of_planets.end(), planet2))\n\
    \    {\n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps83g0hi7.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmps83g0hi7.cpp:62:12: error: a\
    \ function-definition is not allowed here before \u2018{\u2019 token\n   62 |\
    \ int main() {\n      |            ^\n/tmp/tmps83g0hi7.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmps83g0hi7.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmps83g0hi7.cpp:71:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   71 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660114023
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\t// Write your code here\n\tstd::vector<std::string>\
    \ myvec;\n\tmyvec.push_back(\"Mercury\");\n\tmyvec.push_back(\"Venus\");\n\tmyvec.push_back(\"\
    Earth\");\n\tmyvec.push_back(\"Mars\");\n\tmyvec.push_back(\"Jupiter\");\n\tmyvec.push_back(\"\
    Saturn\");\n\tmyvec.push_back(\"Uranus\");\n\tmyvec.push_back(\"Neptune\");\n\t\
    std::vector<std::string> ans;\n\tint idx1 = -1, idx2 = -1;\n\tfor (int i = 0;\
    \ i < myvec.size(); i++) {\n\t\tif (myvec[i] == planet1) {\n\t\t\tidx1 = i;\n\t\
    \t}\n\t\tif (myvec[i] == planet2) {\n\t\t\tidx2 = i;\n\t\t}\n\t}\n\tif (idx1 ==\
    \ -1 || idx2 == -1) {\n\t\treturn ans;\n\t}\n\tif (idx1 > idx2) {\n\t\tstd::swap(idx1,\
    \ idx2);\n\t}\n\tfor (int i = idx1 + 1; i < idx2; i++) {\n\t\tans.push_back(myvec[i]);\n\
    \t}\n\treturn ans;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114023
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> result;\n    std::string\
    \ planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int index1, index2;\n    for (int i = 0; i <\
    \ 8; i++) {\n        if (planets[i] == planet1) {\n            index1 = i;\n \
    \       }\n        if (planets[i] == planet2) {\n            index2 = i;\n   \
    \     }\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp8k9st8c3: /tmp/tmp8k9st8c3.cpp:39: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> our_planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> planets_between;\n    std::vector<std::string>::iterator\
    \ it1 = std::find(our_planets.begin(), our_planets.end(), planet1);\n    std::vector<std::string>::iterator\
    \ it2 = std::find(our_planets.begin(), our_planets.end(), planet2);\n    if (it1\
    \ != our_planets.end() && it2 != our_planets.end()) {\n        if (it1 > it2)\
    \ {\n            std::reverse(it1, it2);\n        }\n        planets_between.insert(planets_between.end(),\
    \ ++it1, it2);\n    }\n    return planets_between;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  vector::_M_range_insert\n"
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets({\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    });\n\tstd::vector<std::string> ans;\n\tif (std::find(planets.begin(), planets.end(),\
    \ planet1) == planets.end()\n\t\t|| std::find(planets.begin(), planets.end(),\
    \ planet2) == planets.end())\n\t\treturn ans;\n\tif (planet1 == planet2) {\n\t\
    \tans.push_back(planet1);\n\t\treturn ans;\n\t}\n\tint i1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n\tint i2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n\tif (i1 < i2)\n\t\tfor (int i =\
    \ i1 + 1; i < i2; i++)\n\t\t\tans.push_back(planets[i]);\n\telse\n\t\tfor (int\
    \ i = i2 + 1; i < i1; i++)\n\t\t\tans.push_back(planets[i]);\n\treturn ans;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpd048jnmj: /tmp/tmpd048jnmj.cpp:45: int main(): Assertion `candidate(("Earth"),
    ("Earth")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets{\n    \"Mercury\"\
    ,\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\"\
    ,\n    \"Uranus\",\n    \"Neptune\"\n  };\n  std::vector<std::string> ans;\n \
    \ int planet1_idx = -1;\n  int planet2_idx = -1;\n  for (int i = 0; i < 8; i++)\
    \ {\n    if (planets[i] == planet1) {\n      planet1_idx = i;\n    }\n    if (planets[i]\
    \ == planet2) {\n      planet2_idx = i;\n    }\n  }\n  if (planet1_idx == -1 ||\
    \ planet2_idx == -1) {\n    return ans;\n  }\n  std::sort(planets.begin(), planets.end());\n\
    \  int lower_bound = planet1_idx;\n  int upper_bound = planet2_idx;\n  if (lower_bound\
    \ > upper_bound) {\n    lower_bound = planet2_idx;\n    upper_bound = planet1_idx;\n\
    \  }\n  for (int i = lower_bound; i <= upper_bound; i++) {\n    ans.push_back(planets[i]);\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp8vznh3pg: /tmp/tmp8vznh3pg.cpp:58: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\",\n                                        \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int start = 0;\n    int\
    \ end = 0;\n    bool valid_planet1 = false;\n    bool valid_planet2 = false;\n\
    \    for (size_t i = 0; i < planets.size(); i++) {\n        if (planets[i] ==\
    \ planet1) {\n            start = i;\n            valid_planet1 = true;\n    \
    \    }\n        if (planets[i] == planet2) {\n            end = i;\n         \
    \   valid_planet2 = true;\n        }\n    }\n    if (!valid_planet1 || !valid_planet2)\
    \ {\n        return {};\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    std::vector<std::string> planets_between;\n    for (int i\
    \ = start + 1; i < end; i++) {\n        planets_between.push_back(planets[i]);\n\
    \    }\n    return planets_between;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> res;\n\tint index1 = 0, index2\
    \ = 0;\n\tstd::vector<std::string> planets = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n\tfor (int i\
    \ = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tindex1\
    \ = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tindex2 = i;\n\t\t}\n\t\
    }\n\tif (index1 == 0 || index2 == 0) return res;\n\tfor (int i = index1 + 1; i\
    \ < index2; i++) {\n\t\tres.push_back(planets[i]);\n\t}\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpu9_fceuo: /tmp/tmpu9_fceuo.cpp:40: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tbool match1 = false;\n\tbool match2\
    \ = false;\n\tfor (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] ==\
    \ planet1) {\n\t\t\tmatch1 = true;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\
    \t\tmatch2 = true;\n\t\t}\n\t}\n\tif (match1 && match2) {\n\t\tif (planets.find(planet1)\
    \ < planets.find(planet2)) {\n\t\t\tfor (int i = planets.find(planet1) + 1; i\
    \ < planets.find(planet2); i++) {\n\t\t\t\tresult.push_back(planets[i]);\n\t\t\
    \t}\n\t\t} else {\n\t\t\tfor (int i = planets.find(planet2) + 1; i < planets.find(planet1);\
    \ i++) {\n\t\t\t\tresult.push_back(planets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptuqurwi6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmptuqurwi6.cpp:33:15: error: \u2018\
    class std::vector<std::__cxx11::basic_string<char> >\u2019 has no member named\
    \ \u2018find\u2019\n   33 |   if (planets.find(planet1) < planets.find(planet2))\
    \ {\n      |               ^~~~\n/tmp/tmptuqurwi6.cpp:33:39: error: \u2018class\
    \ std::vector<std::__cxx11::basic_string<char> >\u2019 has no member named \u2018\
    find\u2019\n   33 |   if (planets.find(planet1) < planets.find(planet2)) {\n \
    \     |                                       ^~~~\n/tmp/tmptuqurwi6.cpp:34:25:\
    \ error: \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has\
    \ no member named \u2018find\u2019\n   34 |    for (int i = planets.find(planet1)\
    \ + 1; i < planets.find(planet2); i++) {\n      |                         ^~~~\n\
    /tmp/tmptuqurwi6.cpp:34:56: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018find\u2019\n   34 |    for (int i = planets.find(planet1)\
    \ + 1; i < planets.find(planet2); i++) {\n      |                            \
    \                            ^~~~\n/tmp/tmptuqurwi6.cpp:38:25: error: \u2018class\
    \ std::vector<std::__cxx11::basic_string<char> >\u2019 has no member named \u2018\
    find\u2019\n   38 |    for (int i = planets.find(planet2) + 1; i < planets.find(planet1);\
    \ i++) {\n      |                         ^~~~\n/tmp/tmptuqurwi6.cpp:38:56: error:\
    \ \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has no member\
    \ named \u2018find\u2019\n   38 |    for (int i = planets.find(planet2) + 1; i\
    \ < planets.find(planet1); i++) {\n      |                                   \
    \                     ^~~~\n"
  stdout: ''
  timestamp: 1660114024
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tint flag = 0;\n\tint p1 = -1, p2 = -1;\n\tfor (int i = 0; i < planets.size();\
    \ i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tp1 = i;\n\t\t\tflag++;\n\t\t\
    }\n\t\tif (planets[i] == planet2) {\n\t\t\tp2 = i;\n\t\t\tflag++;\n\t\t}\n\t}\n\
    \tif (flag != 2) return {};\n\tstd::vector<std::string> res;\n\tif (p1 < p2) {\n\
    \t\tfor (int i = p1+1; i < p2; i++) {\n\t\t\tres.push_back(planets[i]);\n\t\t\
    }\n\t} else {\n\t\tfor (int i = p2+1; i < p1; i++) {\n\t\t\tres.push_back(planets[i]);\n\
    \t\t}\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planets[] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::vector<std::string> result;\n    int index1 = -1, index2 = -1;\n    for\
    \ (int i = 0; i < 8; i++) {\n        if (planets[i] == planet1) {\n          \
    \  index1 = i;\n        }\n        if (planets[i] == planet2) {\n            index2\
    \ = i;\n        }\n    }\n    int start, end;\n    if (index1 < index2) {\n  \
    \      start = index1;\n        end = index2;\n    } else {\n        start = index2;\n\
    \        end = index1;\n    }\n    for (int i = start + 1; i < end; i++) {\n \
    \       result.push_back(planets[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpole30pl_: /tmp/tmpole30pl_.cpp:52: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    // Write your code here\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::vector<std::string> ans;\n    if (std::find(planets.begin(),\
    \ planets.end(), planet1) == planets.end() || std::find(planets.begin(), planets.end(),\
    \ planet2) == planets.end()) {\n        return ans;\n    }\n    std::vector<std::string>::iterator\
    \ it1 = std::find(planets.begin(), planets.end(), planet1);\n    std::vector<std::string>::iterator\
    \ it2 = std::find(planets.begin(), planets.end(), planet2);\n    while (it1 !=\
    \ it2) {\n        ans.push_back(*it1);\n        it1++;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp8ge2jg5q: /tmp/tmp8ge2jg5q.cpp:36: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> a;\n    if (planet1 ==\
    \ \"Mercury\") {\n        if (planet2 == \"Mercury\") a.push_back(\"Mercury\"\
    );\n        if (planet2 == \"Venus\") a.push_back(\"Venus\");\n        if (planet2\
    \ == \"Earth\") a.push_back(\"Venus\");\n        if (planet2 == \"Mars\") a.push_back(\"\
    Venus\");\n        if (planet2 == \"Jupiter\") a.push_back(\"Venus\");\n     \
    \   if (planet2 == \"Saturn\") a.push_back(\"Venus\");\n        if (planet2 ==\
    \ \"Uranus\") a.push_back(\"Venus\");\n        if (planet2 == \"Neptune\") a.push_back(\"\
    Venus\");\n    }\n    if (planet1 == \"Venus\") {\n        if (planet2 == \"Venus\"\
    ) a.push_back(\"Venus\");\n        if (planet2 == \"Earth\") a.push_back(\"Earth\"\
    );\n        if (planet2 == \"Mars\") a.push_back(\"Earth\");\n        if (planet2\
    \ == \"Jupiter\") a.push_back(\"Earth\");\n        if (planet2 == \"Saturn\")\
    \ a.push_back(\"Earth\");\n        if (planet2 == \"Uranus\") a.push_back(\"Earth\"\
    );\n        if (planet2 == \"Neptune\") a.push_back(\"Earth\");\n    }\n    if\
    \ (planet1 == \"Earth\") {\n        if (planet2 == \"Earth\") a.push_back(\"Earth\"\
    );\n        if (planet2 == \"Mars\") a.push_back(\"Mars\");\n        if (planet2\
    \ == \"Jupiter\") a.push_back(\"Mars\");\n        if (planet2 == \"Saturn\") a.push_back(\"\
    Mars\");\n        if (planet2 == \"Uranus\") a.push_back(\"Mars\");\n        if\
    \ (planet2 == \"Neptune\") a.push_back(\"Mars\");\n    }\n    if (planet1 == \"\
    Mars\") {\n        if (planet2 == \"Mars\") a.push_back(\"Mars\");\n        if\
    \ (planet2 == \"Jupiter\") a.push_back(\"Jupiter\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4q5l5w_o.cpp:50:47: warning: missing terminating \" character\n\
    \   50 |         if (planet2 == \"Jupiter\") a.push_back(\"Jupiter\n      |  \
    \                                             ^\n/tmp/tmp4q5l5w_o.cpp:50:47: error:\
    \ missing terminating \" character\n   50 |         if (planet2 == \"Jupiter\"\
    ) a.push_back(\"Jupiter\n      |                                             \
    \  ^~~~~~~~\n/tmp/tmp4q5l5w_o.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > bf(std::string, std::string)\u2019:\n/tmp/tmp4q5l5w_o.cpp:51:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   51 | }\n      | ^\n/tmp/tmp4q5l5w_o.cpp:52:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   52 | int main() {\n      |            ^\n/tmp/tmp4q5l5w_o.cpp:61:1: error:\
    \ expected \u2018}\u2019 at end of input\n   61 | }\n      | ^\n/tmp/tmp4q5l5w_o.cpp:19:71:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                    ^\n/tmp/tmp4q5l5w_o.cpp:61:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   61 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {(std::string)\"\
    Mercury\", (std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\",\
    \ (std::string)\"Neptune\"};\n    std::vector<std::string> result;\n    auto first\
    \ = std::find(planets.begin(), planets.end(), planet1);\n    auto second = std::find(planets.begin(),\
    \ planets.end(), planet2);\n    if (first==planets.end()||second==planets.end())\
    \ {\n        return result;\n    }\n    for (auto i = first; i != second; i++)\
    \ {\n        result.push_back(*i);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp4_58zokg: /tmp/tmp4_58zokg.cpp:34: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \n\t\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tauto start = std::find(planets.begin(),\
    \ planets.end(), planet1);\n\tauto end = std::find(planets.begin(), planets.end(),\
    \ planet2);\n\tif (start != planets.end() && end != planets.end()) {\n\t\tint\
    \ start_pos = start - planets.begin();\n\t\tint end_pos = end - planets.begin();\n\
    \t\tint tmp;\n\t\tif (start_pos > end_pos) {\n\t\t\ttmp = start_pos;\n\t\t\tstart_pos\
    \ = end_pos;\n\t\t\tend_pos = tmp;\n\t\t}\n\t\twhile (start_pos < end_pos) {\n\
    \t\t\tresult.push_back(planets[start_pos]);\n\t\t\tstart_pos++;\n\t\t}\n\t}\n\t\
    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp2_sezvd0: /tmp/tmp2_sezvd0.cpp:43: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660114024
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> p = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  int i = 0, j = 0;\n    while (p[i] != planet1) {\n        i++;\n    }\n   \
    \ while (p[j] != planet2) {\n        j++;\n    }\n    std::vector<std::string>\
    \ c;\n    if (i < j) {\n        for (int k = i + 1; k < j; k++) {\n          \
    \  c.push_back(p[k]);\n        }\n    } else {\n        for (int k = j + 1; k\
    \ < i; k++) {\n            c.push_back(p[k]);\n        }\n    }\n    return c;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660114024
