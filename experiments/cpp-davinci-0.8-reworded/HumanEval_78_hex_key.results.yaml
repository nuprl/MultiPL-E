language: cpp
name: HumanEval_78_hex_key
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::set<char> chars({'2', '3', '5', '7', 'B', 'D'});\n  long count = 0;\n \
    \ for (auto c : num) {\n    if (chars.find(c) != chars.end()) {\n      count++;\n\
    \    }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code\n    long sum = 0;\n    for(char x : num){\n        if(x == '2'\
    \ || x == '3' || x == '5' || x == '7' || x == 'B' || x == 'D'){\n            sum\
    \ += 1;\n        }\n    }\n    return sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::string primes = \"2357BD\";\n  int c = 0;\n  for (char& i : num) {\n  \
    \  if (primes.find(i) != std::string::npos) {\n      c++;\n    }\n  }\n  return\
    \ c;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ unsigned long length = num.length();\n  if(length == 0)\n    return 0;\n  int\
    \ result = 0;\n  for(int i = 0; i < length; i++){\n    if(num[i] == '2' || num[i]\
    \ == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D')\n\
    \      result++;\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // Write your code here\n    int digit = 0;\n    long count = 0;\n    for(int\
    \ i = 0; i < num.length(); i++){\n        if(isalpha(num[i])){\n            digit\
    \ = (int)num[i] - 55;\n        }else{\n            digit = (int)num[i] - 48;\n\
    \        }\n        if(digit == 2 || digit == 3 || digit == 5 || digit == 7 ||\
    \ digit == 11 || digit == 13){\n            count++;\n        }\n    }\n    return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122153
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int count = 0;\n    int hexVal = 0;\n    for(int i = 0; i < num.length();\
    \ i++){\n        if(num[i] >= '0' && num[i] <= '9'){\n            hexVal = num[i]\
    \ - '0';\n        }else if(num[i] >= 'A' && num[i] <= 'F'){\n            hexVal\
    \ = num[i] - 'A' + 10;\n        }else{\n            return -1;\n        }\n  \
    \      if(hexVal == 2 || hexVal == 3 || hexVal == 5 || hexVal == 7 || hexVal ==\
    \ 11 || hexVal == 13){\n            count++;\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ if(num.length() == 0)\n    return 0;\n  std::string h_str(\"0123456789ABCDEF\"\
    );\n  std::vector<bool> h_nums(16, false);\n  h_nums[2] = true;\n  h_nums[3] =\
    \ true;\n  h_nums[5] = true;\n  h_nums[7] = true;\n  h_nums[11] = true;\n  h_nums[13]\
    \ = true;\n  h_nums[17] = true;\n  int hex_num = 0;\n  int c = 0;\n  int total\
    \ = 0;\n  for(auto it = num.rbegin(); it != num.rend(); ++it){\n    hex_num +=\
    \ h_nums[*it - '0'] ? 1 << c : 0;\n    c += 4;\n    if(c == 16){\n      total\
    \ += hex_num;\n      hex_num = 0;\n      c = 0;\n    }\n  }\n  return total;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpkqdzfqp3: /tmp/tmpkqdzfqp3.cpp:52: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // your code here\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp0p_j4ekx: /tmp/tmp0p_j4ekx.cpp:29: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int sum = 0;\n    char a[] = {'A', 'B', 'D', 'E'};\n    std::vector<char>\
    \ vec(a, a + 4);\n    for (auto c : num) {\n        if (c == '2' || c == '3' ||\
    \ c == '5' || c == '7') {\n            sum++;\n        }\n        else if (std::find(vec.begin(),\
    \ vec.end(), c) != vec.end()) {\n            sum++;\n        }\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmptmb_6hpr: /tmp/tmptmb_6hpr.cpp:40: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::string hex_digits = \"2357BD\";\n    long count = 0;\n    for (int i\
    \ = 0; i < num.length(); i++) {\n        if (hex_digits.find(num[i]) != std::string::npos)\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ if(num.length() == 0)\n    return 0;\n  if(num.length() == 1){\n    if(num ==\
    \ \"2\" || num == \"3\" || num == \"5\" || num == \"7\" || num == \"B\" || num\
    \ == \"D\")\n      return 1;\n    else\n      return 0;\n  }\n  long count = 0;\n\
    \  for(int i = 0; i < num.length(); i++){\n    if(num[i] == '2' || num[i] == '3'\
    \ || num[i] == '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D')\n     \
    \ count++;\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ long ctr = 0;\n  for(long i = 0; i < num.length(); i++){\n    switch(num[i]){\n\
    \      case '2':\n      case '3':\n      case '5':\n      case '7':\n      case\
    \ 'B':\n      case 'D':\n        ctr++;\n    }\n  }\n  return ctr;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int prime_count = 0;\n  std::vector<int> nums;\n  for (int i = 0; i < num.length();\
    \ i++) {\n    char digit = num[i];\n    if (digit == '0' || digit == '1' || digit\
    \ == '4' || digit == '6' ||\n        digit == '8' || digit == '9' || digit ==\
    \ 'A' || digit == 'C' ||\n        digit == 'E') {\n      continue;\n    }\n  \
    \  if (digit == '2' || digit == '3' || digit == '5' || digit == '7' ||\n     \
    \   digit == 'B' || digit == 'D' || digit == 'F') {\n      prime_count++;\n  \
    \  }\n  }\n  return prime_count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpilsxpa0u: /tmp/tmpilsxpa0u.cpp:47: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    long count = 0;\n\tfor (char ch : num) {\n\t\tif (ch == '2' || ch == '3' || ch\
    \ == '5' || ch == '7' || ch == 'B' || ch == 'D') {\n\t\t\tcount++;\n\t\t}\n\t\
    }\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::unordered_set<char> hex_prime({'2', '3', '5', '7', 'B', 'D'});\n  return\
    \ std::count_if(num.begin(), num.end(), \n    [&hex_prime](char c) {return hex_prime.count(c);});\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long sum = 0;\n    std::unordered_set<char> p = {'2', '3', '5', '7', 'B',\
    \ 'D'};\n    for (char& c : num) {\n        if (p.find(c) != p.end()) {\n    \
    \        sum++;\n        }\n    }\n    return sum;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ \n  auto is_prime = [](int n) {\n    for (int i = 2; i < n; i++)\n      if (n\
    \ % i == 0)\n        return false;\n    return true;\n  };\n  \n  int hexprimes\
    \ = 0;\n  std::map<char, int> m{\n      {'0', 0}, {'1', 1}, {'2', 2}, {'3', 3},\
    \ {'4', 4}, {'5', 5}, {'6', 6},\n      {'7', 7}, {'8', 8}, {'9', 9}, {'A', 10},\
    \ {'B', 11}, {'C', 12}, {'D', 13},\n      {'E', 14}, {'F', 15}};\n  for (auto\
    \ i : num) {\n    if (is_prime(m[i])) {\n      hexprimes++;\n    }\n  }\n  return\
    \ hexprimes;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp2sl10mgc: /tmp/tmp2sl10mgc.cpp:48: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int c=0;\n    int l=num.length();\n    //assert(l>0 && l<8);\n    int s;\n\
    \    for(int i=0;i<l;i++)\n    {\n        s=num[i];\n        if(s>=65)\n     \
    \   {\n            s=s-55;\n        }\n        else\n        {\n            s=s-48;\n\
    \        }\n        if(s==2 || s==3 || s==5 || s==7 || s==11 || s==13)\n     \
    \   {\n            c++;\n        }\n    }\n    return c;\n}\nint main() {\n  \
    \  auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int n = num.length();\n\tstd::cout << num;\n\tstd::cout << \"n= \" << n << std::endl;\n\
    \tint i = 0;\n\tint count = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tstd::cout <<\
    \ num[i] << \" \";\n\t\tif (num[i] == '2' || num[i] == '3' || num[i] == '5' ||\
    \ num[i] == '7' || num[i] == 'B' || num[i] == 'D') {\n\t\t\tcount++;\n\t\t}\n\t\
    }\n\tstd::cout << \"count= \" << count << std::endl;\n\treturn count;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: 'ABn= 2

    A B count= 1

    1077En= 5

    1 0 7 7 E count= 2

    ABED1A33n= 8

    A B E D 1 A 3 3 count= 4

    2020n= 4

    2 0 2 0 count= 2

    123456789ABCDEF0n= 16

    1 2 3 4 5 6 7 8 9 A B C D E F 0 count= 6

    112233445566778899AABBCCDDEEFF00n= 32

    1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 A A B B C C D D E E F F 0 0 count= 12

    '
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int primes[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n\tint cnt\
    \ = 0;\n\tfor (char c : num) {\n\t\tassert(isupper(c));\n\t\tcnt += primes[c >=\
    \ 'A' ? c - 'A' + 10 : c - '0'];\n\t}\n\treturn cnt;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpbb19882q: /tmp/tmpbb19882q.cpp:28: long int hex_key(std::string): Assertion
    `isupper(c)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    std::vector<char> v = {'2','3','5','7','B','D'};\n\tint c = 0;\n\tfor(int i =\
    \ 0; i < num.size(); i++){\n\t\tfor(int j = 0; j < v.size(); j++){\n\t\t\tif(num[i]\
    \ == v[j]){\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::map<char, long> hexMap = {{'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4',\
    \ 4}, {'5', 5}, {'6', 6}, {'7', 7}, {'8', 8}, {'9', 9}, {'A', 10}, {'B', 11},\
    \ {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15}};\n  int primeCount = 0;\n  for (auto\
    \ c : num) {\n    if (hexMap[c] == 2 || hexMap[c] == 3 || hexMap[c] == 5 || hexMap[c]\
    \ == 7 || hexMap[c] == 11 || hexMap[c] == 13) {\n      primeCount++;\n    }\n\
    \  }\n  return primeCount;\n}\nint main() {\n    auto candidate = hex_key;\n \
    \   assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int count = 0;\n  std::set<int> s;\n  for(char i = '0'; i <= '9'; i++)\n   \
    \ s.insert(i - '0');\n  for(char i = 'A'; i <= 'F'; i++)\n    s.insert(i - 'A'\
    \ + 10);\n  for(auto i : num)\n    if(s.find(i) != s.end())\n      count++;\n\
    \  return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp82it9jm0: /tmp/tmp82it9jm0.cpp:38: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int count = 0;\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tif (num[i] ==\
    \ '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' || num[i]\
    \ == 'D')\n\t\t\tcount++;\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int primeNum = 0;\n\tint numVal = 0;\n\tfor (int i = 0; i < num.length(); i++)\
    \ {\n\t\tswitch (num[i]) {\n\t\tcase 'A':\n\t\t\tnumVal = 10;\n\t\t\tbreak;\n\t\
    \tcase 'B':\n\t\t\tnumVal = 11;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tnumVal = 12;\n\
    \t\t\tbreak;\n\t\tcase 'D':\n\t\t\tnumVal = 13;\n\t\t\tbreak;\n\t\tcase 'E':\n\
    \t\t\tnumVal = 14;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tnumVal = 15;\n\t\t\tbreak;\n\
    \t\tdefault:\n\t\t\tnumVal = num[i] - '0';\n\t\t\tbreak;\n\t\t}\n\t\tif (numVal\
    \ == 2 || numVal == 3 || numVal == 5 || numVal == 7 || numVal == 11 || numVal\
    \ == 13) {\n\t\t\tprimeNum++;\n\t\t}\n\t}\n\treturn primeNum;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    // your code here\n    for(int i = 0; i < num.length();\
    \ i++){\n        switch(num[i]){\n            case '2':\n            case '3':\n\
    \            case '5':\n            case '7':\n            case 'B':\n       \
    \     case 'D':\n                count++;\n                break;\n          \
    \  default:\n                break;\n        }\n    }\n    return count;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    long primeSum = 0;\n\tfor (auto &item : num) {\n\t\tswitch (item) {\n\t\t\tcase\
    \ '2':\n\t\t\tcase '3':\n\t\t\tcase '5':\n\t\t\tcase '7':\n\t\t\tcase 'B':\n\t\
    \t\tcase 'D':\n\t\t\t\tprimeSum++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn primeSum;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    std::unordered_set<char> s {'2','3','5','7','B','D'};\n\tlong cnt=0;\n\tfor(long\
    \ i=0;i<num.size();i++)\n\t\tif(s.find(num[i])!=s.end())\n\t\t\tcnt++;\n\treturn\
    \ cnt;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   if(num.length() == 0)\n        return 0;\n    std::map<char, int> hm;\n  \
    \  hm['2'] = 2;\n    hm['3'] = 3;\n    hm['5'] = 5;\n    hm['7'] = 7;\n    hm['B']\
    \ = 11;\n    hm['D'] = 13;\n    std::vector<int> nums;\n    for(int i = 0; i <\
    \ num.length(); i++)\n        nums.push_back(hm[num[i]]);\n    int count = 0;\n\
    \    for(int i = 0; i < nums.size(); i++)\n        count += nums[i];\n    return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpdg68xqe2: /tmp/tmpdg68xqe2.cpp:44: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long primes = 0;\n    assert(num.length() >= 0);\n    //check if each digit\
    \ is prime\n    for(int i = 0; i < num.length(); i++){\n      //convert to int\n\
    \      int a = num[i];\n      //check if it is a letter\n      if(a >= 65 && a\
    \ <= 70){\n        //convert to decimal\n        a -= 55;\n      }\n      //check\
    \ if number is prime\n      if(a == 2 || a == 3 || a == 5 || a == 7 || a == 11\
    \ || a == 13){\n        primes++;\n      }\n    }\n    return primes;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp_lq8kedf: /tmp/tmp_lq8kedf.cpp:46: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   string a=\"12347BDE\";\n    int count=0;\n    for(int i=0;i<num.length();i++){\n\
    \        for(int j=0;j<a.length();j++){\n            if(num[i]==a[j]){\n     \
    \           count++;\n            }\n        }\n    }\n    return count;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiptjiz0f.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpiptjiz0f.cpp:25:5: error: \u2018string\u2019 was not declared in this\
    \ scope\n   25 |     string a=\"12347BDE\";\n      |     ^~~~~~\n/tmp/tmpiptjiz0f.cpp:25:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpiptjiz0f.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpiptjiz0f.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpiptjiz0f.cpp:28:23: error: \u2018a\u2019 was not declared in this scope\n\
    \   28 |         for(int j=0;j<a.length();j++){\n      |                     \
    \  ^\n"
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   char arr[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \    int ans = 0;\n    for(int i = 0; i < num.length(); i++){\n        for(int\
    \ j = 2; j < 11; j += 2){\n            if(num[i] == arr[j]){\n               \
    \ ans++;\n            }\n        }\n        if(num[i] == arr[11] || num[i] ==\
    \ arr[13]){\n            ans++;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpppc0zf83: /tmp/tmpppc0zf83.cpp:41: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::unordered_set<char> s = {'2', '3', '5', '7', 'B', 'D'};\n  int count =\
    \ 0;\n  for (char c : num) {\n    if (s.find(c) != s.end()) {\n      count++;\n\
    \    }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code here\n    return std::count_if(num.begin(), num.end(),\n    \
    \                     [](auto& c) {\n                             return std::set<char>{'2',\
    \ '3', '5', '7', 'B', 'D'}.count(c);\n                         });\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   char chars[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',\
    \ 'C', 'D', 'E', 'F'};\n    int dig[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15};\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n\
    \    int cnt = 0;\n    for (int i = 0; i < num.length(); i++) {\n        for (int\
    \ j = 0; j < 16; j++) {\n            if (num[i] == chars[j]) {\n             \
    \   for (int k = 0; k < 10; k++) {\n                    if (dig[j] == primes[k])\
    \ {\n                        cnt++;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return cnt;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int count = 0;\n    if(num.length()==0) return 0;\n    for(int i=0;i<num.length();i++){\n\
    \        if(num[i]=='2' || num[i]=='3' || num[i]=='5' || num[i]=='7' || num[i]=='B'\
    \ || num[i]=='D')\n            count++;\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   char key[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \    int temp[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n    int count =\
    \ 0;\n    for(int i = 0; i < num.length(); i++){\n        for(int j = 0; j < 16;\
    \ j++){\n            if(num[i] == key[j]){\n                if(temp[j] == 1 ||\
    \ temp[j] == 0){\n                    continue;\n                }\n         \
    \       else if(temp[j] == 2 || temp[j] == 3 || temp[j] == 5 || temp[j] == 7 ||\
    \ temp[j] == 11 || temp[j] == 13){\n                    count++;\n           \
    \     }\n            }\n        }\n    }\n    return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::set<char> chars;\n    chars.insert('2');\n    chars.insert('3');\n  \
    \  chars.insert('5');\n    chars.insert('7');\n    chars.insert('B');\n    chars.insert('D');\n\
    \    long sum = 0;\n    for(char c : num)\n    {\n        if(chars.find(c) !=\
    \ chars.end())\n        {\n            sum += 1;\n        }\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   if(num.empty()) return 0;\n    char primes[] = {'2','3','5','7','B','D'};\n\
    \    int count = 0;\n    for(int i = 0; i < num.length(); i++){\n        for(int\
    \ j = 0; j < 6; j++){\n            if(num[i] == primes[j]){\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ return 0;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpi0h_qu_6: /tmp/tmpi0h_qu_6.cpp:29: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ \tlong int decnum = std::stoi(num, 0, 16);\n  \tstd::bitset<32> bin(decnum);\n\
    \  \tlong long int i,j,count=0;\n  \tlong long int n = bin.count();\n  \tfor(i=2;i<=n;i++)\n\
    \  \t{\n  \t\tif(bin[i]==1)\n  \t\t{\n  \t\t\tfor(j=2;j<=i/2;j++)\n  \t\t\t{\n\
    \  \t\t\t\tif(i%j==0)\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tif(j>i/2)\n  \t\t\
    \t\tcount++;\n  \t\t}\n  \t}\n  \treturn count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpej9ajzrb: /tmp/tmpej9ajzrb.cpp:46: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122155
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::string::iterator it;\n  int i,count=0;\n  int prime_number[]={2,3,5,7,11,13};\n\
    \  for(it=num.begin();it!=num.end();it++){\n    if((*it>=48 && *it<=57)||(*it>=65\
    \ && *it<=70)){\n      for(i=0;i<6;i++){\n        if(*it==prime_number[i] || (*it<=57\
    \ && *it==prime_number[i]+48) || (*it>=65 && *it==prime_number[i]+55)){\n    \
    \      count++;\n          break;\n        }\n      }\n    }\n  }\n  return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::map<char, bool> prime_dict;\n  prime_dict['0'] = false;\n  prime_dict['1']\
    \ = false;\n  prime_dict['2'] = true;\n  prime_dict['3'] = true;\n  prime_dict['4']\
    \ = false;\n  prime_dict['5'] = true;\n  prime_dict['6'] = false;\n  prime_dict['7']\
    \ = true;\n  prime_dict['8'] = false;\n  prime_dict['9'] = false;\n  prime_dict['A']\
    \ = false;\n  prime_dict['B'] = true;\n  prime_dict['C'] = false;\n  prime_dict['D']\
    \ = true;\n  prime_dict['E'] = false;\n  prime_dict['F'] = false;\n  long count\
    \ = 0;\n  for (int i = 0; i < num.length(); i++) {\n    if (prime_dict[num[i]])\
    \ {\n      count++;\n    }\n  }\n  return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122155
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // assert(false);\n    // return 0;\n    std::map<char, int> map_;\n    map_['2']\
    \ = 2;\n    map_['3'] = 3;\n    map_['5'] = 5;\n    map_['7'] = 7;\n    map_['B']\
    \ = 11;\n    map_['D'] = 13;\n    int count = 0;\n    for (auto c : num) {\n \
    \       if (map_.find(c) != map_.end()) {\n            count++;\n        }\n \
    \   }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n   \
    \ assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int sum = 0;\n  for(char c : num){\n    if( c == '2'|| c == '3'|| c == '5'||\
    \ c == '7'|| c == 'B'|| c == 'D') sum++;\n  }\n  return sum;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122154
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code goes here\n    long n = num.length();\n    std::string hex_digits\
    \ = \"0123456789ABCDEF\";\n    long hex_primes[] = {2, 3, 5, 7, 11, 13};\n   \
    \ long count = 0;\n    for(long i = 0; i < n; i++) {\n        for(long j = 0;\
    \ j < 6; j++) {\n            if(num[i] == hex_digits[hex_primes[j]]) {\n     \
    \           count++;\n                break;\n            }\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122153
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::unordered_set<char> primes;\n    primes.insert('2');\n    primes.insert('3');\n\
    \    primes.insert('5');\n    primes.insert('7');\n    primes.insert('B');\n \
    \   primes.insert('D');\n    int count = 0;\n    for(int i = 0; i < num.size();\
    \ i++) {\n        if(primes.find(num[i]) != primes.end()) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122156
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    char prime[10] = {'2','3','5','7','B','D','F'};\n\t// int hex[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n\
    \tstd::vector<char> myvector(prime, prime+7);\n\tstd::vector<char>::iterator it;\n\
    \tint count = 0;\n\tfor(int i = 0; i < num.length(); i++){\n\t\tit = std::find(myvector.begin(),\
    \ myvector.end(), num[i]);\n\t\tif(it != myvector.end()){\n\t\t\tcount++;\n\t\t\
    }\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpqb2m9k9m: /tmp/tmpqb2m9k9m.cpp:44: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long c = 0;\n    for(int i = 0; i < num.length(); i++){\n        if(num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' ||\
    \ num[i] == 'D'){\n            c++;\n        }\n    }\n    return c;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122156
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count=0;\n    int arr[16]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};\n\
    \    for(int i=0;i<num.length();i++){\n        if(num[i]>=65){\n            count+=arr[num[i]-55];\n\
    \        }\n        else{\n            count+=arr[num[i]-48];\n        }\n   \
    \ }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpbn1v0lnh: /tmp/tmpbn1v0lnh.cpp:39: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int count = 0;\n\tint x = num.length();\n\tchar * hex_num = new char[x];\n\tint\
    \ y = strlen(hex_num);\n\tint i = 0;\n\t// convert hexadecimal to decimal\n\t\
    while (num[i])\n\t{\n\t\thex_num[i] = num[i];\n\t\ti++;\n\t}\n\tfor (int i = 0;\
    \ i < y; i++)\n\t{\n\t\tif (hex_num[i] >= '0' && hex_num[i] <= '9')\n\t\t\thex_num[i]\
    \ = hex_num[i] - 48;\n\t\telse if (hex_num[i] >= 'A' && hex_num[i] <= 'F')\n\t\
    \t\thex_num[i] = hex_num[i] - 55;\n\t\telse if (hex_num[i] >= 'a' && hex_num[i]\
    \ <= 'f')\n\t\t\thex_num[i] = hex_num[i] - 87;\n\t}\n\tint dec_num = 0;\n\tint\
    \ base = 1;\n\tfor (int i = y - 1; i >= 0; i--)\n\t{\n\t\tif (hex_num[i] > 16)\n\
    \t\t{\n\t\t\tprintf(\"Invalid hexadecimal digit %c \", hex_num[i]);\n\t\t\treturn\
    \ 0;\n\t\t}\n\t\tdec_num += hex_num[i] * base;\n\t\tbase = base * 16;\n\t}\n\t\
    // define primes\n\tstd::vector<int> primes{ 2, 3, 5, 7, 11, 13 };\n\t// count\
    \ the number of primes\n\tfor (int i = 0; i < y; i++)\n\t{\n\t\tint j = 0;\n\t\
    \twhile (j<primes.size())\n\t\t{\n\t\t\tif (hex_num[i] == primes[j])\n\t\t\t{\n\
    \t\t\t\tcount++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\treturn count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp5z0rmz3m: /tmp/tmp5z0rmz3m.cpp:76: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int ans = 0;\n    std::map<char, int> num2digit = {\n        {'2', 2},\n \
    \       {'3', 3},\n        {'5', 5},\n        {'7', 7},\n        {'B', 11},\n\
    \        {'D', 13}\n    };\n    for (char c : num) {\n        if (num2digit.find(c)\
    \ != num2digit.end()) {\n            ans++;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int value = 0;\n    int result = 0;\n    for (int i = 0; i < num.length();\
    \ i++) {\n        switch (num[i]) {\n            case '0': value = 0;\n      \
    \                break;\n            case '1': value = 1;\n                  \
    \    break;\n            case '2': value = 2;\n                      break;\n\
    \            case '3': value = 3;\n                      break;\n            case\
    \ '4': value = 4;\n                      break;\n            case '5': value =\
    \ 5;\n                      break;\n            case '6': value = 6;\n       \
    \               break;\n            case '7': value = 7;\n                   \
    \   break;\n            case '8': value = 8;\n                      break;\n \
    \           case '9': value = 9;\n                      break;\n            case\
    \ 'A': value = 10;\n                      break;\n            case 'B': value\
    \ = 11;\n                      break;\n            case 'C': value = 12;\n   \
    \                   break;\n            case 'D': value = 13;\n              \
    \        break;\n            case 'E': value = 14;\n                      break;\n\
    \            case 'F': value = 15;\n                      break;\n        }\n\
    \        if (value == 2 || value == 3 || value == 5 || value == 7 || value ==\
    \ 11 || value == 13) {\n            result++;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int pos=0;\n  long sum=0;\n  bool is_prime(int x);\n  while(num[pos]!='\\0'){\n\
    \    if(num[pos]=='A'||num[pos]=='B'||num[pos]=='D') sum++;\n    else if(num[pos]>='2'&&num[pos]<='7')\
    \ sum++;\n    pos++;\n  }\n  return sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmp7bnpy644: /tmp/tmp7bnpy644.cpp:37: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code here\n    std::string alpha = \"ABCDEF\";\n    std::string alphaprime\
    \ = \"ABCDEF\";\n    std::string numstr = \"0123456789\";\n    std::string numprime\
    \ = \"2357\";\n    long len = num.length();\n    std::cout << len << std::endl;\n\
    \    long counter = 0;\n    for (long i = 0; i < len; i++) {\n        if (numstr.find(num[i])\
    \ != std::string::npos) {\n            if (numprime.find(num[i]) != std::string::npos)\
    \ {\n                counter++;\n            }\n        }\n        else if (alpha.find(num[i])\
    \ != std::string::npos) {\n            if (alphaprime.find(num[i]) != std::string::npos)\
    \ {\n                counter++;\n            }\n        }\n    }\n    return counter;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpuvxg3czq: /tmp/tmpuvxg3czq.cpp:49: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: '2

    '
  timestamp: 1660122157
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code here\n    long ans=0;\n    int len=num.length();\n    for(int\
    \ i=0;i<len;i++){\n      if(num[i]=='2'||num[i]=='3'||num[i]=='5'||num[i]=='7'||num[i]=='B'||num[i]=='D')\n\
    \      ans++;\n    }\n    return ans;\n  }\nint main()\n{\n    assert( hex_key((\"\
    AB\")) == 1);\n    assert( hex_key((\"1077E\")) == 2);\n    assert( hex_key((\"\
    ABED1A33\")) == 4);\n    assert( hex_key((\"123456789ABCDEF0\")) == 6);\n    assert(\
    \ hex_key((\"2020\")) == 2);\n    return 0;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa89pmyea.cpp:43:5: error: redefinition of \u2018int main()\u2019\
    \n   43 | int main() {\n      |     ^~~~\n/tmp/tmpa89pmyea.cpp:34:5: note: \u2018\
    int main()\u2019 previously defined here\n   34 | int main()\n      |     ^~~~\n"
  stdout: ''
  timestamp: 1660122156
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long result = 0;\n    std::unordered_set<char> prime_hex_digits = {'2', '3',\
    \ '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (prime_hex_digits.find(c)\
    \ != prime_hex_digits.end()) {\n            result++;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long sum = 0;\n    std::unordered_set<int> hexset = {2, 3, 5, 7, 11, 13};\n\
    \    for (auto c : num) {\n        if (hexset.find(std::stoi(std::string(1, c),\
    \ nullptr, 16)) != hexset.end()) sum++;\n    }\n    return sum;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::map<std::string, int> primetable = {\n    {\"2\", 1},\n    {\"3\", 1},\n\
    \    {\"5\", 1},\n    {\"7\", 1},\n    {\"B\", 1},\n    {\"D\", 1},\n  };\n  long\
    \ result = 0;\n  for (auto& c : num) {\n    if (primetable.find(std::string(1,\
    \ c)) != primetable.end()) {\n      result += 1;\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n  int count\
    \ = 0;\n  for (char i : num) {\n    if (primes.find(i) != primes.end()) {\n  \
    \    count++;\n    }\n  }\n  return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int digit,digit2;\n\tint i,j;\n\tint sum=0;\n\tfor(i=0;i<num.length();i++)\n\t\
    {\n\t\tdigit=num[i];\n\t\tfor(j=i+1;j<num.length();j++)\n\t\t{\n\t\t\tdigit2=num[j];\n\
    \t\t\tif(digit==digit2)\n\t\t\t{\n\t\t\t\tsum=sum+1;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpb44rjuh3: /tmp/tmpb44rjuh3.cpp:44: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122158
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // Make a hash table for the primes\n    std::unordered_set<char> s = {'2',\
    \ '3', '5', '7', 'B', 'D'};\n    int total = 0;\n    for (int i = 0; i < num.size();\
    \ i++) {\n        if (s.find(num[i]) != s.end()) {\n            total++;\n   \
    \     }\n    }\n    return total;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   //strtol(char *str, char **endptr, int base)\n    int base = 16;\n    char\
    \ *endptr = 0;\n    long conv = strtol(num.c_str(), &endptr, base);\n    long\
    \ ret = 0;\n    //std::cout << \"conv=\" << conv << std::endl;\n    if (conv ==\
    \ 0 || conv == 1) {\n        ret = 0;\n    } else if (conv == 2 || conv == 3 ||\
    \ conv == 5 || conv == 7\n        || conv == 11 || conv == 13) {\n        ret\
    \ = 1;\n    } else {\n        int sqr = sqrt(conv);\n        for (int i = 2; i\
    \ <= sqr; i++) {\n            if (conv % i == 0) {\n                ret = 0;\n\
    \                break;\n            } else {\n                ret = 1;\n    \
    \        }\n        }\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpxa2zoas6: /tmp/tmpxa2zoas6.cpp:51: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ // your code\n  if(num == \"\")\n    return 0;\n  std::map<char,int> hexa =\
    \ {{'0',0},{'1',1},{'2',2},{'3',3},{'4',4},{'5',5},{'6',6},{'7',7},{'8',8},{'9',9},{'A',10},{'B',11},{'C',12},{'D',13},{'E',14},{'F',15}};\n\
    \  std::map<int,bool> prime = {{2,true},{3,true},{5,true},{7,true},{11,true},{13,true}};\n\
    \  std::map<int,bool> decimal;\n  for(int i = 0; i < num.size(); i++){\n    decimal[hexa[num[i]]]\
    \ = true;\n  }\n  int result = 0;\n  for(auto val : decimal){\n    if(prime[val.first])\n\
    \      result++;\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmp_ibomm95: /tmp/tmp_ibomm95.cpp:44: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::set<char> hex_nums_set = {'0', '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n    std::map<char, int> hex_nums_to_int\
    \ = {{'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4}, {'5', 5}, {'6', 6}, {'7',\
    \ 7}, {'8', 8}, {'9', 9}, {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14},\
    \ {'F', 15}};\n    std::set<int> primes = {2, 3, 5, 7, 11, 13};\n    std::set<char>\
    \ primes_char = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    for (int\
    \ i = 0; i < num.size(); i++) {\n        // check if the current char is a part\
    \ of the hex\n        assert(hex_nums_set.find(num[i]) != hex_nums_set.end());\n\
    \        if (primes_char.find(num[i]) != primes_char.end()) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int key = 0;\n    for(int i = 0; i < num.length(); i++){\n        if(num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' ||\
    \ num[i] == 'D')\n            key++;\n    }\n    return key;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::vector<std::string> v={\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"\
    ,\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"};\n    std::vector<int> c={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0};\n\
    \    int k=0;\n    for(auto i:num)\n    {\n        k+=c[std::find(v.begin(),v.end(),std::string{i})-v.begin()];\n\
    \    }\n    return k;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    std::unordered_set<int> primes({2, 3, 5, 7, 11, 13});\n\
    \    for (auto c : num) {\n        if (c >= '0' && c <= '9') {\n            if\
    \ (primes.find(c - '0') != primes.end()) {\n                count++;\n       \
    \     }\n        } else {\n            if (primes.find(c - 'A' + 10) != primes.end())\
    \ {\n                count++;\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int count = 0;\n    for(int i = 0; i < num.length(); i++){\n        if(num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' ||\
    \ num[i] == 'D'){\n            count++;\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::string primes = \"2357BDF\";\n  int len = num.length();\n  long count =\
    \ 0;\n  for(int i = 0; i < len; i++) {\n    char ch = num[i];\n    if(primes.find(ch)\
    \ != std::string::npos) {\n      count++;\n    }\n  }\n  return count;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpbxu1iv7_: /tmp/tmpbxu1iv7_.cpp:42: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::vector<char> chars = {'2', '3', '5', '7', 'B', 'D'};\n    int count =\
    \ 0;\n    for (int i = 0; i < num.length(); i++) {\n        if (std::find(chars.begin(),\
    \ chars.end(), num[i]) != chars.end())\n            count++;\n    }\n    return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long pcount = 0;\n    long hexmap[15] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};\n\
    \    std::string hexstr = \"0123456789ABCDEF\";\n    // std::cout << \"num is:\
    \ \" << num << std::endl;\n    for (int i = 0; i < num.length(); i++) {\n    \
    \    if (std::find(hexstr.begin(), hexstr.end(), num[i]) != hexstr.end()) {\n\
    \            // std::cout << \"num[i] is: \" << num[i] << std::endl;\n       \
    \     if (num[i] >= 'A') {\n                // std::cout << \"num[i] is: \" <<\
    \ num[i] << std::endl;\n                if (hexmap[num[i] - 'A' + 10] <= 47) {\n\
    \                    pcount++;\n                }\n            } else {\n    \
    \            if (hexmap[num[i] - '0'] <= 47) {\n                    pcount++;\n\
    \                }\n            }\n        }\n    }\n    return pcount;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp4lrbzlgt: /tmp/tmp4lrbzlgt.cpp:48: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::map<char, int> dict;\n    dict['2'] = 2;\n    dict['3'] = 3;\n    dict['5']\
    \ = 5;\n    dict['7'] = 7;\n    dict['B'] = 11;\n    dict['D'] = 13;\n    int\
    \ result = 0;\n    for (int i = 0; i < num.size(); i++) {\n        if (dict.find(num[i])\
    \ != dict.end())\n            result++;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::map<char,int> myMap;\n  myMap['0'] = 0;\n  myMap['1'] = 1;\n  myMap['2']\
    \ = 2;\n  myMap['3'] = 3;\n  myMap['4'] = 4;\n  myMap['5'] = 5;\n  myMap['6']\
    \ = 6;\n  myMap['7'] = 7;\n  myMap['8'] = 8;\n  myMap['9'] = 9;\n  myMap['A']\
    \ = 10;\n  myMap['B'] = 11;\n  myMap['C'] = 12;\n  myMap['D'] = 13;\n  myMap['E']\
    \ = 14;\n  myMap['F'] = 15;\n  int total = 0;\n  for(auto it = num.begin(); it\
    \ != num.end(); it++){\n    if(myMap[*it] == 2 || myMap[*it] == 3 || myMap[*it]\
    \ == 5 || myMap[*it] == 7 || myMap[*it] == 11 || myMap[*it] == 13){\n      total++;\n\
    \    }\n  }\n  return total;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   static const std::set<char> hex_primes = {'2', '3', '5', '7', 'B', 'D'};\n\
    \    long res = 0;\n    for (const auto &ch : num) {\n        res += hex_primes.count(ch);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int l=num.length();\n    int cnt=0;\n    for(int i=0;i<l;i++){\n        if(num[i]=='2'\
    \ || num[i]=='3' || num[i]=='5' || num[i]=='7' || num[i]=='B' || num[i]=='D'){\n\
    \            cnt++;\n        }\n    }\n    return cnt;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   if(num.length() == 0)\n        return 0;\n    if(num.length() == 1)\n    \
    \    return ((num[0] >= '2' && num[0] <= '7') || num[0] == 'B' || num[0] == 'D')\
    \ ? 1 : 0;\n    long result = 0;\n    for(auto item : num)\n        result +=\
    \ (item >= '2' && item <= '7') || item == 'B' || item == 'D';\n    return result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpqz7ud67z: /tmp/tmpqz7ud67z.cpp:40: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // your code here\n\t// std::string size = num.size();\n\t// if (num.size == 0)\n\
    \t// \treturn 0;\n\t// return 1;\n\tlong counter = 0;\n\tlong size = num.size();\n\
    \tfor (int i = 0; i < size; i++)\n\t{\n\t\tif (num[i] == '2' || num[i] == '3'\
    \ || num[i] == '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D')\n\t\t\t\
    counter++;\n\t}\n\treturn counter;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int sum = 0;\n\tstd::map<char, int> a = { {'0', 0}, {'1', 1}, {'2', 2}, {'3',\
    \ 3}, {'4', 4}, {'5', 5}, {'6', 6}, {'7', 7}, {'8', 8}, {'9', 9}, {'A', 10}, {'B',\
    \ 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15} };\n\tfor (int i = 0; i < num.size();\
    \ i++) {\n\t\tsum += a[num[i]];\n\t}\n\tstd::vector<int> b = { 2, 3, 5, 7, 11,\
    \ 13 };\n\tint count = 0;\n\tfor (int i = 0; i < b.size(); i++) {\n\t\tif (sum\
    \ == b[i]) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpvi3164vy: /tmp/tmpvi3164vy.cpp:41: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122158
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::unordered_set<char> s({'2','3','5','7','B','D'});\n    int count = 0;\n\
    \    for(char c : num){\n        if(s.find(c) != s.end()){\n            count++;\n\
    \        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ // Your code here\n  int count = 0;\n  std::map<char, int> hexMap;\n  hexMap['2']\
    \ = 2;\n  hexMap['3'] = 3;\n  hexMap['5'] = 5;\n  hexMap['7'] = 7;\n  hexMap['B']\
    \ = 11;\n  hexMap['D'] = 13;\n  for(int i = 0; i < num.length(); i++){\n    if(hexMap.find(num[i])\
    \ != hexMap.end()){\n      count++;\n    }\n  }\n  return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122158
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    // I think the problem uses the hash table to save the\
    \ number\n    // of prime numbers in hexadecimal (digit 2, 3, 5, 7, 11, 13) \n\
    \    // and then count them. This is not an efficient way.\n    // Also, to be\
    \ honest I'm not familiar with the hash tables at all\n    // and I have to take\
    \ time to understand it.\n    // So I use the if-else statement to do the problem.\n\
    \    for (int i = 0; i < num.length(); i++) {\n        if (num[i] == '2' || num[i]\
    \ == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D')\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // 1. convert hex_string to digits\n\tstd::string hex_string = \"0123456789ABCDEF\"\
    ;\n\tstd::string digits = \"\";\n\tfor (int i = 0; i < num.length(); i++) {\n\t\
    \tchar c = num[i];\n\t\tint index = hex_string.find(c);\n\t\tint n = index;\n\t\
    \tstd::string temp = std::to_string(n);\n\t\tdigits += temp;\n\t}\n\t// 2. convert\
    \ digits string to int\n\tstd::stringstream s(digits);\n\tint x = 0;\n\ts >> x;\n\
    \t// 3. iterate through all prime numbers \n\t// and if they are present in the\
    \ digits string, \n\t// increment count\n\tstd::vector<int> prime_numbers = {2,\
    \ 3, 5, 7, 11, 13};\n\tint count = 0;\n\tfor (int i = 0; i < prime_numbers.size();\
    \ i++) {\n\t\tif (std::to_string(x).find(std::to_string(prime_numbers[i])) !=\
    \ std::string::npos) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp1wu21ttj: /tmp/tmp1wu21ttj.cpp:54: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122157
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count=0;\n    map<char,bool> mp;\n    mp['2']=true;\n    mp['3']=true;\n\
    \    mp['5']=true;\n    mp['7']=true;\n    mp['B']=true;\n    mp['D']=true;\n\
    \    for(auto ele:num){\n        if(mp[ele])\n            count++;\n    }\n  \
    \  return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqdsu2i9v.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpqdsu2i9v.cpp:26:5: error: \u2018map\u2019 was not declared in this\
    \ scope\n   26 |     map<char,bool> mp;\n      |     ^~~\n/tmp/tmpqdsu2i9v.cpp:26:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpqdsu2i9v.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:100:11:\
    \ note:   \u2018std::map\u2019\n  100 |     class map\n      |           ^~~\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpqdsu2i9v.cpp:2:\n/usr/include/c++/9/map:82:13:\
    \ note:   \u2018std::pmr::map\u2019\n   82 |       using map\n      |        \
    \     ^~~\n/tmp/tmpqdsu2i9v.cpp:26:9: error: expected primary-expression before\
    \ \u2018char\u2019\n   26 |     map<char,bool> mp;\n      |         ^~~~\n/tmp/tmpqdsu2i9v.cpp:27:5:\
    \ error: \u2018mp\u2019 was not declared in this scope\n   27 |     mp['2']=true;\n\
    \      |     ^~\n"
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    for(int i = 0; i < num.length(); i++){\n        if(num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' ||\
    \ num[i] == 'D'){\n            count++;\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // convert hex to decimal\n    long i = std::stol(num,nullptr,16);\n    long\
    \ t = 0;\n    // prime numbers\n    int num_prime[6] = {2,3,5,7,11,13};\n    for(int\
    \ x : num_prime){\n        // check if digit of the number is prime\n        if(i%x\
    \ == 0){\n            t++;\n        }\n    }\n    return t;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmp76e7zwj1: /tmp/tmp76e7zwj1.cpp:41: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122158
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    if (num.empty())\n\t\treturn 0;\n\tstd::set<char> hexdigits{ '0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n\tassert(std::all_of(num.begin(),\
    \ num.end(), [&hexdigits](const char& ch) {return hexdigits.find(ch) != hexdigits.end();\
    \ }));\n\tstd::set<char> primehexdigits{ '2', '3', '5', '7', 'B', 'D' };\n\tassert(std::all_of(num.begin(),\
    \ num.end(), [&primehexdigits](const char& ch) {return primehexdigits.find(ch)\
    \ != primehexdigits.end(); }));\n\tlong cnt = 0;\n\tfor (auto& ch : num)\n\t\t\
    if (primehexdigits.find(ch) != primehexdigits.end())\n\t\t\t++cnt;\n\treturn cnt;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpe0e8rxv1: /tmp/tmpe0e8rxv1.cpp:30: long int hex_key(std::string): Assertion
    `std::all_of(num.begin(), num.end(), [&primehexdigits](const char& ch) {return
    primehexdigits.find(ch) != primehexdigits.end(); })'' failed.

    '
  stdout: ''
  timestamp: 1660122158
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::string hex_string = \"0ABCDEF\";\n  int total_prime_hex_digits = 0;\n \
    \ for (int i = 0; i < num.length(); i++) {\n    int index = hex_string.find(num[i]);\n\
    \    if (index % 2 == 0) {\n      total_prime_hex_digits++;\n    }\n  }\n  return\
    \ total_prime_hex_digits;\n}\nint main() {\n    auto candidate = hex_key;\n  \
    \  assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpqp500nnj: /tmp/tmpqp500nnj.cpp:38: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122158
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // your code here\n\tstd::vector<char>primes = {'2','3','5','7','B','D'};\n\t\
    std::vector<char>numbers = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \tint counter = 0;\n\tint i = 0;\n\twhile(num[i] != '\\0'){\n\t\t// count the\
    \ number of digits\n\t\tcounter++;\n\t\ti++;\n\t}\n\tint sum = 0;\n\tfor(int i\
    \ = 0; i < counter; i++){\n\t\t// iterate over the string and check the character\n\
    \t\tfor(int j = 0; j < primes.size(); j++){\n\t\t\tif(num[i] == primes[j]){\n\t\
    \t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // Your code here\n    std::map<char,int> keys = {\n    \t{'0',0},\n    \t\
    {'1',1},\n    \t{'2',2},\n    \t{'3',3},\n    \t{'4',4},\n    \t{'5',5},\n   \
    \ \t{'6',6},\n    \t{'7',7},\n    \t{'8',8},\n    \t{'9',9},\n    \t{'A',10},\n\
    \    \t{'B',11},\n    \t{'C',12},\n    \t{'D',13},\n    \t{'E',14},\n    \t{'F',15}\n\
    \    };\n    std::vector<char> primeKeys = {'2','3','5','7','B','D'};\n    long\
    \ count = 0;\n    for(char i : num){\n    \tif(keys[i] > 1){\n    \t\tbool flag\
    \ = true;\n    \t\tfor(int j = 2; j <= keys[i]/2; j++){\n    \t\t\tif(keys[i]\
    \ % j == 0){\n    \t\t\t\tflag = false;\n    \t\t\t\tbreak;\n    \t\t\t}\n   \
    \ \t\t}\n    \t\tif(flag)\n    \t\t\tcount++;\n    \t}\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122158
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    long num_primes = 0;\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tswitch (num[i])\
    \ {\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '4':\n\t\t\tcase '6':\n\t\t\t\
    case '8':\n\t\t\tcase '9':\n\t\t\tcase 'A':\n\t\t\tcase 'C':\n\t\t\tcase 'E':\n\
    \t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '5':\n\t\t\tcase\
    \ '7':\n\t\t\tcase 'B':\n\t\t\tcase 'D':\n\t\t\t\tnum_primes++;\n\t\t\t\tbreak;\n\
    \t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn num_primes;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long cnt=0;\n    for(int i=0;i<num.length();i++){\n        switch(num[i]){\n\
    \            case '2':\n            case '3':\n            case '5':\n       \
    \     case '7':\n            case 'B':\n            case 'D':\n              \
    \  cnt++;\n                break;\n            default:\n                break;\n\
    \        }\n    }\n    return cnt;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122158
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    std::string hex{\"0123456789ABCDEF\"};\n    std::string\
    \ primes{\"2357BD\"};\n    for(int i = 0; i < num.length(); i++){\n        if(primes.find(num[i])\
    \ != std::string::npos){\n            count++;\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122159
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int n = num.length();\n    int hex_value[n];\n    for(int i=0;i<n;i++){\n\
    \        if(num[i]>='0' && num[i]<='9'){\n            hex_value[i] = num[i] -\
    \ '0';\n        }\n        else{\n            hex_value[i] = num[i] - 'A' + 10;\n\
    \        }\n    }\n    int count = 0;\n    for(int i=0;i<n;i++){\n        int\
    \ flag = 0;\n        if(hex_value[i]==2 || hex_value[i]==3 || hex_value[i]==5\
    \ || hex_value[i]==7 || hex_value[i]==11 || hex_value[i]==13){\n            flag\
    \ = 1;\n        }\n        if(flag==1){\n            count++;\n        }\n   \
    \ }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122159
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::unordered_set<char> hex_primes = {'2', '3', '5', '7', 'B', 'D'};\n  \
    \  long count = 0;\n    for (auto c : num) {\n        if (hex_primes.find(c) !=\
    \ hex_primes.end()) {\n            count++;\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122159
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::set<char> primes{'2', '3', '5', '7', 'B', 'D'};\n    return std::count_if(num.begin(),\
    \ num.end(), [&primes](char ch) {\n        return primes.find(ch) != primes.end();\n\
    \    });\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122159
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int arr[16]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};\n  long count=0;\n\
    \  if(num.length()==0) return 0;\n  for(int i=0;i<num.length();i++){\n    if(num[i]>='A'\
    \ && num[i]<='F'){\n      count+=arr[num[i]-'A'+10];\n    }\n    else if(num[i]>='0'\
    \ && num[i]<='9'){\n      count+=arr[num[i]-'0'];\n    }\n  }\n  return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp5za3mq6z: /tmp/tmp5za3mq6z.cpp:40: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122159
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::vector<int> num_map = {0,1,2,3,4,5,6,7,8,9,11,13};\n  long count = 0;\n\
    \  for(auto i: num){\n    count+= num_map[i];\n  }\n  return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpae4teqex: /tmp/tmpae4teqex.cpp:34: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ long count = 0;\n  std::map<char, int> conv;\n  for (long i = 0; i < 10; i++)\
    \ {\n    conv[i + '0'] = i;\n  }\n  for (long i = 10; i < 16; i++) {\n    conv[i\
    \ + 'A' - 10] = i;\n  }\n  std::vector<long> primes {2, 3, 5, 7, 11, 13};\n  std::vector<long>\
    \ result;\n  for (long i = 0; i < num.size(); i++) {\n    result.push_back(conv[num[i]]);\n\
    \  }\n  for (long i = 0; i < result.size(); i++) {\n    if (std::find(primes.begin(),\
    \ primes.end(), result[i]) != primes.end()) {\n      count++;\n    }\n  }\n  return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   map<char, int> m;\n    m['2'] = 2;\n    m['3'] = 3;\n    m['5'] = 5;\n   \
    \ m['7'] = 7;\n    m['B'] = 11;\n    m['D'] = 13;\n    int count = 0;\n    for(int\
    \ i = 0; i < num.length(); i++) {\n        if(m.find(num[i]) != m.end()) {\n \
    \           count++;\n        }\n    }\n    return count;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0dhb4zwq.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmp0dhb4zwq.cpp:25:5: error: \u2018map\u2019 was not declared in this\
    \ scope\n   25 |     map<char, int> m;\n      |     ^~~\n/tmp/tmp0dhb4zwq.cpp:25:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp0dhb4zwq.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:100:11:\
    \ note:   \u2018std::map\u2019\n  100 |     class map\n      |           ^~~\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp0dhb4zwq.cpp:2:\n/usr/include/c++/9/map:82:13:\
    \ note:   \u2018std::pmr::map\u2019\n   82 |       using map\n      |        \
    \     ^~~\n/tmp/tmp0dhb4zwq.cpp:25:9: error: expected primary-expression before\
    \ \u2018char\u2019\n   25 |     map<char, int> m;\n      |         ^~~~\n/tmp/tmp0dhb4zwq.cpp:26:5:\
    \ error: \u2018m\u2019 was not declared in this scope; did you mean \u2018tm\u2019\
    ?\n   26 |     m['2'] = 2;\n      |     ^\n      |     tm\n"
  stdout: ''
  timestamp: 1660122159
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   if(num == \"\") return 0;\n    int result = 0;\n    for(int i = 0; i < num.size();\
    \ i++){\n        switch(num[i]){\n            case '2':\n            case '3':\n\
    \            case '5':\n            case '7':\n            case 'B':\n       \
    \     case 'D':\n                result++;\n                break;\n         \
    \   default:\n                break;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // your code here\n\tlong numOfPrimes = 0;\n\tfor (int i = 0; i < num.length();\
    \ i++) {\n\t\tstd::string temp = num.substr(i, 1);\n\t\tif (temp == \"2\" || temp\
    \ == \"3\" || temp == \"5\" || temp == \"7\" || temp == \"B\" || temp == \"D\"\
    )\n\t\t\tnumOfPrimes++;\n\t}\n\treturn numOfPrimes;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122159
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code here\n    long result=0;\n    for(int i=0;i<num.length();i++){\n\
    \        if(num[i]=='2'||num[i]=='3'||num[i]=='5'||num[i]=='7'||num[i]=='B'||num[i]=='D'){\n\
    \            result++;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int hex_primes[] = {2, 3, 5, 7, 11, 13};\n    int count = 0;\n    for(int\
    \ i = 0; i < num.length(); i++) {\n        if(num[i] >= 'A' && num[i] <= 'F')\
    \ {\n            for(int j = 0; j < 6; j++) {\n                if(hex_primes[j]\
    \ == (num[i] - 'A' + 10)) {\n                    count++;\n                  \
    \  break;\n                }\n            }\n        } else {\n            for(int\
    \ j = 0; j < 6; j++) {\n                if(hex_primes[j] == (num[i] - '0')) {\n\
    \                    count++;\n                    break;\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122159
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int d=0;\n\tint n = num.length();\n\tlong p=0;\n\tfor(int i=0;i<n;i++){\n\t\t\
    if(num[i]=='0'||num[i]=='1'||num[i]=='2'||num[i]=='3'||num[i]=='4'||num[i]=='5'||num[i]=='6'||num[i]=='7'||num[i]=='8'||num[i]=='9'){\n\
    \t\t\td = num[i]-'0';\n\t\t}\n\t\telse if(num[i]=='A'){\n\t\t\td = 10;\n\t\t}\n\
    \t\telse if(num[i]=='B'){\n\t\t\td = 11;\n\t\t}\n\t\telse if(num[i]=='C'){\n\t\
    \t\td = 12;\n\t\t}\n\t\telse if(num[i]=='D'){\n\t\t\td = 13;\n\t\t}\n\t\telse\
    \ if(num[i]=='E'){\n\t\t\td = 14;\n\t\t}\n\t\telse if(num[i]=='F'){\n\t\t\td =\
    \ 15;\n\t\t}\n\t\tint c = 0;\n\t\tfor(int j=1;j<=d;j++){\n\t\t\tif(d%j==0){\n\t\
    \t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c==2){\n\t\t\tp++;\n\t\t}\n\t}\n\treturn p;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    std::map<char, int> primes = { {'2', 2}, {'3', 3}, {'5', 5}, {'7', 7}, {'B', 11},\
    \ {'D', 13} };\n\tint counter = 0;\n\tfor (int i = 0; i < num.length(); i++) {\n\
    \t\tif (primes.find(num[i]) != primes.end()) {\n\t\t\tcounter++;\n\t\t}\n\t}\n\
    \treturn counter;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::set<int> prime_numbers{2, 3, 5, 7, 11, 13};\n  int count = 0;\n  for (int\
    \ i = 0; i < num.size(); i++) {\n    if (num[i] >= '0' && num[i] <= '9') {\n \
    \     int digit = num[i] - '0';\n      if (prime_numbers.find(digit) != prime_numbers.end())\
    \ {\n        count++;\n      }\n    } else {\n      switch (num[i]) {\n      \
    \  case 'A':\n          count++;\n          break;\n        case 'B':\n      \
    \    count++;\n          break;\n        case 'D':\n          count++;\n     \
    \     break;\n        default:\n          break;\n      }\n    }\n  }\n  return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpm8igpb8e: /tmp/tmpm8igpb8e.cpp:53: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::map<char,int>m;\n    m['0']=0;\n    m['1']=1;\n    m['2']=2;\n    m['3']=3;\n\
    \    m['4']=4;\n    m['5']=5;\n    m['6']=6;\n    m['7']=7;\n    m['8']=8;\n \
    \   m['9']=9;\n    m['A']=10;\n    m['B']=11;\n    m['C']=12;\n    m['D']=13;\n\
    \    m['E']=14;\n    m['F']=15;\n    long long n=0;\n    long long i=0;\n    long\
    \ long k=num.size()-1;\n    long long count=0;\n    while(i<num.size())\n    {\n\
    \        if(m[num[i]]==2||m[num[i]]==3||m[num[i]]==5||m[num[i]]==7||m[num[i]]==11||m[num[i]]==13)\n\
    \        {\n            count++;\n        }\n        i++;\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // your code\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpg4gcmb9o: /tmp/tmpg4gcmb9o.cpp:29: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int count = 0;\n    std::map<char, int> prime;\n    prime['2'] = 2;\n    prime['3']\
    \ = 3;\n    prime['5'] = 5;\n    prime['7'] = 7;\n    prime['B'] = 11;\n    prime['D']\
    \ = 13;\n    for(char c : num) {\n        if(prime.find(c) != prime.end()) {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int count = 0;\n\tfor (char c : num) {\n\t\tstd::string hex = \"0123456789ABCDEF\"\
    ;\n\t\tif (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D')\n\
    \t\t\tcount++;\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::string prime = \"2357BD\";\n  long count = 0;\n  for(char ch : num) {\n\
    \    for(char x : prime) {\n      if(ch == x) {\n        count++;\n      }\n \
    \   }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int count = 0;\n  std::unordered_set<char> s{'2','3','5','7','B','D'};\n  for(char\
    \ c : num){\n    if(s.find(c) != s.end()){\n      count++;\n    }\n  }\n  return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int map[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97, 101};\n  int sum = 0;\n  for(int i = 0; i <\
    \ num.length(); i++) {\n    sum += map[num[i] - 'A'];\n  }\n  std::cout << sum\
    \ << std::endl;\n  return sum;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpmbyc88ci: /tmp/tmpmbyc88ci.cpp:35: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: '5

    '
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int count = 0;\n\tchar prime_arr[] = {'2', '3', '5', '7', 'B', 'D'};\n\tfor(int\
    \ i = 0; i < num.length(); i++) {\n\t\tfor(int j = 0; j < 6; j++) {\n\t\t\tif(num[i]\
    \ == prime_arr[j]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int index = 0;\n\tchar * str = new char[num.length()+1];\n\tstrcpy(str, num.c_str());\n\
    \twhile(str[index] != '\\0'){\n\t\tswitch(str[index]){\n\t\t\tcase 'A':\n\t\t\t\
    case 'B':\n\t\t\tcase 'D':\n\t\t\tcase 'E':\n\t\t\t\tstr[index] = '1';\n\t\t\t\
    \tbreak;\n\t\t\tcase 'C':\n\t\t\tcase 'F':\n\t\t\t\tstr[index] = '0';\n\t\t\t\t\
    break;\n\t\t}\n\t\tindex++;\n\t}\n\tint n = atoi(str);\n\tint count = 0;\n\tif(n\
    \ == 0){\n\t\treturn 0;\n\t}\n\tfor(int i = 2; i <= n; i++){\n\t\tif(n % i ==\
    \ 0){\n\t\t\tn /= i;\n\t\t\tcount++;\n\t\t\ti--;\n\t\t}\n\t}\n\treturn count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpp2vv5mg1: /tmp/tmpp2vv5mg1.cpp:60: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int hash[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    long\
    \ count = 0;\n    for (char c : num) {\n        int num = c > '9' ? c - 'A' +\
    \ 10 : c - '0';\n        count += hash[num];\n    }\n    return count;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code here\n    unordered_set<char> s{'2','3','5','7','B','D'};\n \
    \   int result = 0;\n    for(auto e:num){\n        if(s.find(e)!=s.end())\n  \
    \          result++;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx8mb5dwz.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpx8mb5dwz.cpp:26:5: error: \u2018unordered_set\u2019 was not declared\
    \ in this scope\n   26 |     unordered_set<char> s{'2','3','5','7','B','D'};\n\
    \      |     ^~~~~~~~~~~~~\n/tmp/tmpx8mb5dwz.cpp:26:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/unordered_set:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n                 from\
    \ /tmp/tmpx8mb5dwz.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:97:11: note:\
    \   \u2018std::unordered_set\u2019\n   97 |     class unordered_set\n      | \
    \          ^~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpx8mb5dwz.cpp:2:\n/usr/include/c++/9/unordered_set:68:13:\
    \ note:   \u2018std::pmr::unordered_set\u2019\n   68 |       using unordered_set\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmpx8mb5dwz.cpp:26:19: error: expected\
    \ primary-expression before \u2018char\u2019\n   26 |     unordered_set<char>\
    \ s{'2','3','5','7','B','D'};\n      |                   ^~~~\n/tmp/tmpx8mb5dwz.cpp:29:12:\
    \ error: \u2018s\u2019 was not declared in this scope\n   29 |         if(s.find(e)!=s.end())\n\
    \      |            ^\n"
  stdout: ''
  timestamp: 1660122159
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // Write your code here\n\tlong sum = 0;\n\tstd::unordered_map<char, bool> m =\
    \ {\n\t\t{'2', true},\n\t\t{'3', true},\n\t\t{'5', true},\n\t\t{'7', true},\n\t\
    \t{'B', true},\n\t\t{'D', true}\n\t};\n\tfor (int i = 0; i < num.size(); i++)\
    \ {\n\t\tif (m.find(num[i]) != m.end()) {\n\t\t\tsum++;\n\t\t}\n\t}\n\treturn\
    \ sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    if (num.empty())\n\t\treturn 0;\n\tstd::stringstream ss;\n\tss << std::hex <<\
    \ num;\n\tunsigned long n;\n\tss >> n;\n\tlong count = 0;\n\tfor (long i = 0;\
    \ i < num.length(); i++) {\n\t\tif (num[i] == 'B' || num[i] == 'D')\n\t\t\tcount++;\n\
    \t}\n\tif (n % 2 == 0)\n\t\tcount--;\n\tif (n % 3 == 0)\n\t\tcount--;\n\tif (n\
    \ % 5 == 0)\n\t\tcount--;\n\tif (n % 7 == 0)\n\t\tcount--;\n\tif (n % 11 == 0)\n\
    \t\tcount--;\n\tif (n % 13 == 0)\n\t\tcount--;\n\treturn count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpez6qg8ty: /tmp/tmpez6qg8ty.cpp:52: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122160
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ vector<int> vec = {2,3,5,7,11,13};\n  int count = 0;\n  int nums = 0;\n  for(int\
    \ i = 0; i < num.size(); i++){\n    if(num[i] >= '0' && num[i] <= '9')\n     \
    \ nums = num[i] - '0';\n    else if(num[i] >= 'A' && num[i] <= 'F')\n      nums\
    \ = num[i] - 'A' + 10;\n    for(int j = 0; j < vec.size(); j++){\n      if(nums\
    \ == vec[j])\n        count++;\n    }\n  }\n  return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf8687fmu.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpf8687fmu.cpp:25:3: error: \u2018vector\u2019 was not declared in this\
    \ scope\n   25 |   vector<int> vec = {2,3,5,7,11,13};\n      |   ^~~~~~\n/tmp/tmpf8687fmu.cpp:25:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf8687fmu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf8687fmu.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpf8687fmu.cpp:25:10:\
    \ error: expected primary-expression before \u2018int\u2019\n   25 |   vector<int>\
    \ vec = {2,3,5,7,11,13};\n      |          ^~~\n/tmp/tmpf8687fmu.cpp:33:24: error:\
    \ \u2018vec\u2019 was not declared in this scope\n   33 |     for(int j = 0; j\
    \ < vec.size(); j++){\n      |                        ^~~\n"
  stdout: ''
  timestamp: 1660122159
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::vector<int> map;\n  map.push_back(0);\n  map.push_back(0);\n  map.push_back(1);\n\
    \  map.push_back(1);\n  map.push_back(0);\n  map.push_back(1);\n  map.push_back(0);\n\
    \  map.push_back(1);\n  map.push_back(0);\n  map.push_back(0);\n  map.push_back(0);\n\
    \  map.push_back(1);\n  map.push_back(1);\n  map.push_back(0);\n  map.push_back(1);\n\
    \  map.push_back(0);\n  map.push_back(0);\n  long count = 0;\n  for(int i = 0;\
    \ i < num.length(); i++) {\n    if(num[i] >= '0' && num[i] <= '9') {\n      count\
    \ += map[num[i] - '0'];\n    } else {\n      count += map[num[i] - 'A' + 10];\n\
    \    }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpsjc6c1vb: /tmp/tmpsjc6c1vb.cpp:56: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122161
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int char_count = 0;\n  int hex_num = 0;\n  int hex_ascii_val[16] = {48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70};\n  char hex_char[16]\
    \ = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',\
    \ 'F'};\n  // char_count = num.length();\n  // std::cout << \"string length: \"\
    \ << char_count << \"\\n\";\n  for (int i = 0; i < num.length(); i++) {\n    for\
    \ (int j = 0; j < 16; j++) {\n      if (num[i] == hex_char[j]) {\n        // std::cout\
    \ << \"found a hex char: \" << hex_char[j] << \" \" << \"at position: \" << i\
    \ << \"\\n\";\n        hex_num = hex_ascii_val[j];\n        // std::cout << \"\
    corresponding hex value: \" << hex_num << \"\\n\";\n        if (hex_num == 66\
    \ || hex_num == 68) {\n          char_count++;\n        }\n      }\n    }\n  }\n\
    \  return char_count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpf0w98gaz: /tmp/tmpf0w98gaz.cpp:48: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // Your code here\n\tstd::vector<char> vec = {'2','3','5','7','B','D'};\n\tstd::set<char>\
    \ s(vec.begin(),vec.end());\n\tlong count = 0;\n\tfor(int i = 0; i < num.length();\
    \ i++){\n\t\tif(s.find(num[i]) != s.end()){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ // your code here\n  long int count = 0;\n  std::map<char, int> mymap = {{'2',\
    \ 2}, {'3', 3}, {'5', 5}, {'7', 7}, {'B', 11}, {'D', 13}};\n  for(int i = 0; i\
    \ < num.length(); i++){\n      if(mymap.find(num[i]) != mymap.end()){\n      \
    \    count++;\n      }\n  }\n  return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::vector<int> hexaPrime = {2, 3, 5, 7, 11, 13};\n  std::string::iterator\
    \ itr;\n  std::vector<int>::iterator itr1;\n  int count = 0;\n  for(itr = num.begin();\
    \ itr!=num.end(); itr++){\n    for(itr1 = hexaPrime.begin(); itr1!=hexaPrime.end();\
    \ itr1++){\n      if(*itr==*itr1+'0'){\n        count++;\n      }\n    }\n  }\n\
    \  return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpoixhv1a_: /tmp/tmpoixhv1a_.cpp:40: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::vector<char> p = { '2', '3', '5', '7', 'B', 'D' };\n  long cnt = 0;\n \
    \ for (auto it: num) {\n    for (auto p_it: p) {\n      if (it == p_it) {\n  \
    \      cnt++;\n      }\n    }\n  }\n  return cnt;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int count = 0;\n\tstd::map<char, int> map;\n\tmap['2'] = 2;\n\tmap['3'] = 3;\n\
    \tmap['5'] = 5;\n\tmap['7'] = 7;\n\tmap['B'] = 11;\n\tmap['D'] = 13;\n\tfor (int\
    \ i = 0; i < num.length(); i++) {\n\t\tif (map.find(num[i]) != map.end())\n\t\t\
    \tcount++;\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::unordered_set<char> primes {'2', '3', '5', '7', 'B', 'D'};\n  long result\
    \ = 0;\n  for (int i = 0; i < num.size(); i++) {\n    if (primes.find(num[i])\
    \ != primes.end()) {\n      result++;\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ \n  std::map<char, int> hex_map;\n  hex_map['0'] = 0;\n  hex_map['1'] = 1;\n\
    \  hex_map['2'] = 2;\n  hex_map['3'] = 3;\n  hex_map['4'] = 4;\n  hex_map['5']\
    \ = 5;\n  hex_map['6'] = 6;\n  hex_map['7'] = 7;\n  hex_map['8'] = 8;\n  hex_map['9']\
    \ = 9;\n  hex_map['A'] = 10;\n  hex_map['B'] = 11;\n  hex_map['C'] = 12;\n  hex_map['D']\
    \ = 13;\n  hex_map['E'] = 14;\n  hex_map['F'] = 15;\n  \n  long result = 0;\n\
    \  for (int i = 0; i < num.size(); i++) {\n    int n = hex_map[num[i]];\n    if\
    \ (n == 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13) {\n      result++;\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    //std::string num = \"ABED1A33\";\n\tlong size = num.size();\n\tstd::string values\
    \ = \"2357BD\";\n\tlong count = 0;\n\tfor(int i = 0; i < size; i++){\n\t\tfor(int\
    \ j = 0; j < 6; j++){\n\t\t\tif(num[i] == values[j])\n\t\t\t\tcount++;\n\t\t}\n\
    \t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::string hex_str {\"ABED1A33\"};\n  std::map<char,int> hex_prime_map;\n \
    \ hex_prime_map['2'] = 2;\n  hex_prime_map['3'] = 3;\n  hex_prime_map['5'] = 5;\n\
    \  hex_prime_map['7'] = 7;\n  hex_prime_map['B'] = 11;\n  hex_prime_map['D'] =\
    \ 13;\n  int count = 0;\n  for(auto i:num){\n    if(hex_prime_map.find(i) != hex_prime_map.end()){\n\
    \      count++;\n    }\n  }\n  return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::string arr = \"2357BDF\";\n  long count = 0;\n  for(int i = 0; i < num.length();\
    \ i++){\n    for(int j = 0; j < arr.length(); j++){\n      if(num[i] == arr[j]){\n\
    \        count += 1;\n      }\n    }\n  }\n  return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpsipx_qb7: /tmp/tmpsipx_qb7.cpp:42: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122161
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long ans=0;\n    for(auto i:num){\n        if(i=='2' || i=='3' || i=='5' ||\
    \ i=='7' || i=='B' || i=='D'){\n            ans++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    long\
    \ ans = 0;\n    for (int i = 0; i < num.size(); i++) {\n        if (primes.find(num[i])\
    \ != primes.end()) {\n            ans++;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   char arr[] = {'2','3','5','7','B','D'};\n    long count = 0;\n    for(int\
    \ i = 0; i < num.length(); i++){\n        for(int j = 0; j < 6; j++){\n      \
    \      if(num[i] == arr[j]){\n                count++;\n            }\n      \
    \  }\n    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // Your code here\n\t// If the string is empty, return 0, otherwise go on.\n\t\
    if (num.empty()) {\n\t\treturn 0;\n\t}\n\t// Precondition: the string must be\
    \ a hexadecimal string. So we have to\n\t// check if all characters are valid\
    \ hexadecimal characters.\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tif\
    \ (!(isdigit(num[i]) || (num[i] >= 'A' && num[i] <= 'F'))) {\n\t\t\t// If the\
    \ character is not a hexadecimal character, return 0.\n\t\t\treturn 0;\n\t\t}\n\
    \t}\n\t// A counter to count the number of prime numbers.\n\tint count = 0;\n\t\
    // Loop through the string.\n\tfor (int i = 0; i < num.length(); i++) {\n\t\t\
    // Convert the character to digit.\n\t\tint digit = 0;\n\t\tif (isdigit(num[i]))\
    \ {\n\t\t\tdigit = num[i] - '0';\n\t\t}\n\t\telse {\n\t\t\tdigit = num[i] - 'A'\
    \ + 10;\n\t\t}\n\t\t// If the digit is less than 2, it is not a prime number.\n\
    \t\tif (digit < 2) {\n\t\t\tcontinue;\n\t\t}\n\t\t// If the digit is 2, it is\
    \ a prime number, increase the counter.\n\t\tif (digit == 2) {\n\t\t\tcount++;\n\
    \t\t\tcontinue;\n\t\t}\n\t\t// Since we have considered 2, we can start to test\
    \ the number\n\t\t// with the number 2.\n\t\tint isPrime = true;\n\t\tfor (int\
    \ j = 2; j < digit; j++) {\n\t\t\tif (digit % j == 0) {\n\t\t\t\tisPrime = false;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isPrime) {\n\t\t\tcount++;\n\t\t}\n\t\
    }\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int count=0;\n    for(int i=0;i<num.length();i++){\n        if(num[i]=='2'||num[i]=='3'||num[i]=='5'||num[i]=='7'||num[i]=='B'||num[i]=='D')\n\
    \            count++;\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122160
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \  std::set<char> primes{'2', '3', '5', '7', 'B', 'D'};\n   long count = 0;\n\
    \   for (const auto & c : num) {\n      if (primes.find(c) != primes.end()) {\n\
    \         count++;\n      }\n   }\n   return count;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122161
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count=0;\n    for(auto i=num.begin();i!=num.end();i++){\n        switch(*i){\n\
    \            case '0':\n            case '1':\n            case '8':\n       \
    \     case '9': break;\n            case '2':\n            case '3':\n       \
    \     case '5':\n            case '7': count++;break;\n            case 'A':\n\
    \            case 'B':\n            case 'D':\n            case 'E': count++;break;\n\
    \            default: assert(0);\n        }\n    }\n    return count;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp57h6nxk_: /tmp/tmp57h6nxk_.cpp:47: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // only digits are allowed\n\tstatic const char *const lookup = \"0123456789abcdefABCDEF\"\
    ;\n\tstatic const long primes [] = {2,3,5,7,11,13};\n\tlong count = 0;\n\t\n\t\
    if(num.length()==0)\n\t\treturn 0;\n\tfor(auto c:num){\n\t\t// string must contain\
    \ only hexadecimal characters\t\n\t\tassert(std::strchr(lookup, c));\t\n\t\t//\
    \ count number of prime numbers in the string \n\t\tfor(auto p:primes){\n\t\t\t\
    if(c == std::to_string(p)[0]){\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpww02wvxk: /tmp/tmpww02wvxk.cpp:47: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    //int i;\n\t//int ar[16]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n\tint bin[16]={0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0};\n\
    \tint count=0;\n\tint j;\n\tfor(int i=0;i<num.length();i++)\n\t{\n\t\tif(num[i]>=48\
    \ && num[i]<=57)\n\t\t{\n\t\t\tj=num[i]-48;\n\t\t\tcount+=bin[j];\n\t\t}\n\t\t\
    else if(num[i]>=65 && num[i]<=70)\n\t\t{\n\t\t\tj=num[i]-55;\n\t\t\tcount+=bin[j];\n\
    \t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpyoxzuz1x: /tmp/tmpyoxzuz1x.cpp:49: int main(): Assertion `candidate(("ABED1A33"))
    == (4)'' failed.

    '
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::string alpha = \"ABCDEF\";\n    unsigned long long int counter = 0;\n\
    \    bool is_prime;\n    std::string hex_num = \"\";\n    std::vector<int> digits;\n\
    \    std::vector<int> primes = {2, 3, 5, 7, 11, 13};\n    for (int i = 0; i <\
    \ num.length(); i++) {\n        if (std::isdigit(num[i])) {\n            hex_num\
    \ += num[i];\n        } else {\n            int pos = alpha.find(num[i]);\n  \
    \          int digit = 10 + pos;\n            hex_num += std::to_string(digit);\n\
    \        }\n    }\n    for (int i = 0; i < hex_num.length(); i++) {\n        int\
    \ digit = hex_num[i] - '0';\n        digits.push_back(digit);\n    }\n    for\
    \ (int i = 0; i < digits.size(); i++) {\n        for (int j = 0; j < primes.size();\
    \ j++) {\n            if (digits[i] == primes[j]) {\n                counter++;\n\
    \            }\n        }\n    }\n    return counter;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpj39u3sau: /tmp/tmpj39u3sau.cpp:55: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    std::string primeHexValues = \"2357bd\";\n\tint count = 0;\n\tfor (int i = 0;\
    \ i < num.length(); i++) {\n\t\tfor (int j = 0; j < primeHexValues.length(); j++)\
    \ {\n\t\t\tif (num[i] == primeHexValues[j]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp74oafgsf: /tmp/tmp74oafgsf.cpp:38: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::vector<char> v{'2','3','5','7','B','D'};\n    long count=0;\n    for(int\
    \ i=0;i<num.size();i++){\n        if(std::find(v.begin(),v.end(),num[i])!=v.end()){\n\
    \            count++;\n        }\n    }\n    return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::string p = \"2357BDF\";\n    long c = 0;\n    for(auto i:num){\n    \
    \    if(p.find(i) != std::string::npos)\n            c++;\n    }\n    return c;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpnp4ysh13: /tmp/tmpnp4ysh13.cpp:39: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   const char* num2=num.c_str();\n    int count=0;\n    int c1=0;\n    for(int\
    \ i=0;i<num.length();i++)\n    {\n        if(num2[i]=='0'||num2[i]=='1'||num2[i]=='4'||num2[i]=='6'||num2[i]=='8'||num2[i]=='9'||num2[i]=='A'||num2[i]=='C'||num2[i]=='E'||num2[i]=='F')\n\
    \        {\n            count++;\n        }\n        else if(num2[i]=='2'||num2[i]=='3'||num2[i]=='5'||num2[i]=='7'||num2[i]=='B'||num2[i]=='D')\n\
    \        {\n            c1++;\n        }\n    }\n    return c1;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::vector<int> hex_keys = {\n    0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,\
    \ 0, 0\n  };\n  long hex_num = std::stol(num, nullptr, 16);\n  long ans = 0;\n\
    \  for (long i = 0; i < num.size(); i++) {\n    int digit = hex_num % 16;\n  \
    \  hex_num /= 16;\n    ans += hex_keys[digit];\n  }\n  return ans;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpnf_ejfv7: /tmp/tmpnf_ejfv7.cpp:40: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::set<char> s;\n  s.insert('2');\n  s.insert('3');\n  s.insert('5');\n  s.insert('7');\n\
    \  s.insert('B');\n  s.insert('D');\n  long ans = 0;\n  for(auto &c : num) {\n\
    \    if(s.find(c) != s.end()) {\n      ans++;\n    }\n  }\n  return ans;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // your code here\n\tstd::map<char,int> hex;\n\thex['2'] = 1;\n\thex['3'] = 1;\n\
    \thex['5'] = 1;\n\thex['7'] = 1;\n\thex['B'] = 1;\n\thex['D'] = 1;\n\tint count\
    \ = 0;\n\tfor(int i = 0; i < num.length(); i++){\n\t\tif(hex.find(num[i]) != hex.end()){\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n  int count = 0;\n\
    \  for (auto i : num) {\n    if (primes.find(i) != primes.end()) count++;\n  }\n\
    \  return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    if (num.length() == 0) return 0;\n\tif (num.length() == 1) return (num == \"2\"\
    \ || num == \"3\" || num == \"5\" || num == \"7\" || num == \"B\" || num == \"\
    D\") ? 1 : 0;\n\tint result = 0;\n\tfor (char n : num)\n\t\tresult += (n == '2'\
    \ || n == '3' || n == '5' || n == '7' || n == 'B' || n == 'D') ? 1 : 0;\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::set<char> primes{'2', '3', '5', '7', 'B', 'D'};\n    long count = 0;\n\
    \    for (auto c : num) {\n        if (primes.find(c) != primes.end()) count++;\n\
    \    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n  \
    \  assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code here\n    std::string s = \"2,3,5,7,11,13\";\n    std::vector<char>\
    \ vc;\n    std::stringstream ss(s);\n    char c;\n    while(ss >> c)\n       \
    \ vc.push_back(c);\n    unsigned int count = 0;\n    for(int i = 0; i < num.size();\
    \ i++)\n    {\n        for(int j = 0; j < vc.size(); j++)\n        {\n       \
    \     if(num[i] == vc[j])\n                count++;\n        }\n    }\n    return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpoys84qv1: /tmp/tmpoys84qv1.cpp:45: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    unsigned long count = 0;\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tif (num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' ||\n\t\t\tnum[i] == '7' || num[i] ==\
    \ 'B' || num[i] == 'D') {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int cnt = 0;\n  std::vector<int> primes = {2, 3, 5, 7, 11, 13};\n  for (int\
    \ i = 0; i < num.size(); i++) {\n    if (std::find(primes.begin(), primes.end(),\
    \ num[i] - '0') != primes.end()) {\n      cnt++;\n    }\n    if (num[i] == 'A')\
    \ {\n      cnt++;\n    }\n    if (num[i] == 'B') {\n      cnt++;\n    }\n    if\
    \ (num[i] == 'D') {\n      cnt++;\n    }\n  }\n  return cnt;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpl9klm4pg: /tmp/tmpl9klm4pg.cpp:45: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    static const std::string primes = \"2357BDF\";\n\tstd::set<char> s(primes.begin(),\
    \ primes.end());\n\treturn std::count_if(num.begin(), num.end(), [&s](char ch)\
    \ {\n\t\treturn s.count(ch);\n\t});\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpduhr59o8: /tmp/tmpduhr59o8.cpp:37: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ long long count = 0;\n  std::unordered_map<char, int> chars = {\n    {'0', 0},\
    \ {'1', 1}, {'2', 2}, {'3', 3},\n    {'4', 4}, {'5', 5}, {'6', 6}, {'7', 7},\n\
    \    {'8', 8}, {'9', 9}, {'A', 10}, {'B', 11},\n    {'C', 12}, {'D', 13}, {'E',\
    \ 14}, {'F', 15}\n  };\n  for (int i = 0; i < num.length(); i++) {\n    if (chars[num[i]]\
    \ == 2 || chars[num[i]] == 3 ||\n        chars[num[i]] == 5 || chars[num[i]] ==\
    \ 7 ||\n        chars[num[i]] == 11 || chars[num[i]] == 13) {\n      count++;\n\
    \    }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int n = num.length();\n  int count = 0;\n  // Your code here...\n  std::map<char,\
    \ int> mp = {{'0',0}, {'1',1}, {'2',2}, {'3',3}, {'4',4}, {'5',5}, {'6',6}, {'7',7},\
    \ {'8',8}, {'9',9}, {'A',10}, {'B',11}, {'C',12}, {'D',13}, {'E',14}, {'F',15}};\n\
    \  for(int i = 0; i < n; i++) {\n    if(mp[num[i]] == 2 || mp[num[i]] == 3 ||\
    \ mp[num[i]] == 5 || mp[num[i]] == 7 || mp[num[i]] == 11 || mp[num[i]] == 13)\n\
    \      count++;\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    for(int i = 0; i < num.length(); i++){\n        int hexChar\
    \ = num[i];\n        if(hexChar == '2' || hexChar == '3' || hexChar == '5' ||\
    \ hexChar == '7'\n         || hexChar == 'B' || hexChar == 'D'){\n           \
    \ count++;\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ std::unordered_set<char> primes;\n  std::unordered_set<char> nonPrimes;\n  primes.insert('2');\n\
    \  primes.insert('3');\n  primes.insert('5');\n  primes.insert('7');\n  primes.insert('B');\n\
    \  primes.insert('D');\n  nonPrimes.insert('0');\n  nonPrimes.insert('1');\n \
    \ nonPrimes.insert('4');\n  nonPrimes.insert('6');\n  nonPrimes.insert('8');\n\
    \  nonPrimes.insert('9');\n  nonPrimes.insert('A');\n  nonPrimes.insert('C');\n\
    \  nonPrimes.insert('E');\n  nonPrimes.insert('F');\n  int sum = 0;\n  for(unsigned\
    \ int i = 0; i < num.length(); i++){\n    if(primes.find(num[i]) != primes.end()){\n\
    \      sum++;\n    }\n  }\n  return sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    for(int i = 0; i < num.length(); i++){\n        if(num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' ||\
    \ num[i] == 'D'){\n            count++;\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122157
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long sum = 0;\n    long len = num.length();\n    for(long i = 0; i < len;\
    \ i++){\n        if(num[i] == '0' || num[i] == '1' || num[i] == '4' || num[i]\
    \ == '6' || num[i] == '8' || num[i] == '9' || num[i] == 'A' || num[i] == 'C' ||\
    \ num[i] == 'E' || num[i] == 'F') continue;\n        sum++;\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // Your code goes here\n    long len = num.length();\n    long sum = 0;\n\
    \    for(int i = 0; i < len; i++){\n        if((num[i] == '2') || (num[i] == '3')\
    \ || (num[i] == '5') || (num[i] == '7') || (num[i] == 'B') || (num[i] == 'D'))\n\
    \            sum++;\n    }\n    return sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::set<int> primes = {2, 3, 5, 7, 11, 13};\n    int result = 0;\n    for\
    \ (int i = 0; i < num.size(); i++) {\n        int num_i = 0;\n        if (num[i]\
    \ >= '0' && num[i] <= '9') {\n            num_i = num[i] - '0';\n        } else\
    \ {\n            num_i = num[i] - 'A' + 10;\n        }\n        if (primes.find(num_i)\
    \ != primes.end()) {\n            result++;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long length = 0;\n    if(num.length() == 0)\n        return length;\n    else\
    \ if(num.length() == 1)\n        length = 1;\n    else if(num.length() == 2)\n\
    \        length = 2;\n    else if(num.length() == 3)\n        length = 3;\n  \
    \  else if(num.length() == 4)\n        length = 4;\n    else if(num.length() ==\
    \ 5)\n        length = 5;\n    else if(num.length() == 6)\n        length = 6;\n\
    \    else if(num.length() == 7)\n        length = 7;\n    else if(num.length()\
    \ == 8)\n        length = 8;\n    else if(num.length() == 9)\n        length =\
    \ 9;\n    else if(num.length() == 10)\n        length = 10;\n    else if(num.length()\
    \ == 11)\n        length = 11;\n    else if(num.length() == 12)\n        length\
    \ = 12;\n    else if(num.length() == 13)\n        length = 13;\n    else if(num.length()\
    \ == 14)\n        length = 14;\n    else if(num.length() == 15)\n        length\
    \ = 15;\n    else if(num.length() == 16)\n        length = 16;\n    else if(num.length()\
    \ == 17)\n        length = 17;\n    else if(num.length() == 18)\n        length\
    \ = 18;\n    else if(num.length() == 19)\n        length = 19;\n    else if(num.length()\
    \ == 20)\n        length = 20;\n    else if(num.length() == 21)\n        length\
    \ = 21;\n    else if(num.length() == 22)\n        length = 22;\n    else if(num.length()\
    \ == 23)\n        length = 23;\n    else if(num.length() == 24)\n        length\
    \ = 24;\n    else if(num.length() == 25)\n        length = 25;\n    else if(num.length()\
    \ == 26)\n        length = 26;\n    else if(num.length() == 27)\n        length\
    \ = 27;\n    else\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr_riw0xb.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpr_riw0xb.cpp:83:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   83 | }\n      | ^\n/tmp/tmpr_riw0xb.cpp:83:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   83 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660122162
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    //assert(num == \"\" || num.length() == 0);\n\tchar hex_prime[] = { '2', '3',\
    \ '5', '7', 'B', 'D' };\n\tint count = 0;\n\t// if (num.length() == 0)\n\t// {\n\
    \t// \treturn 0;\n\t// }\n\tfor (int i = 0; i < num.length(); i++)\n\t{\n\t\t\
    for (int j = 0; j < 6; j++)\n\t\t{\n\t\t\tif (num[i] == hex_prime[j])\n\t\t\t\
    {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    assert(num.length() != 0);\n\t// your code here\n\tint c = 0;\n\tstd::string hex\
    \ = \"2357BDF\";\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tfor (int j =\
    \ 0; j < hex.length(); j++) {\n\t\t\tif (num[i] == hex[j])\n\t\t\t\tc++;\n\t\t\
    }\n\t}\n\treturn c;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp00bwq9gg: /tmp/tmp00bwq9gg.cpp:43: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   if(num.length() == 0) return 0;\n    int key = 0;\n    for(int i = 0; i <\
    \ num.length(); i++){\n        if(num[i] == '2' || num[i] == '3' || num[i] ==\
    \ '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D'){\n            key++;\n\
    \        }\n    }\n    return key;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ return std::count_if(num.begin(), num.end(), [](auto e) {\n    return e == '2'\
    \ || e == '3' || e == '5' || e == '7' || e == 'B' || e == 'D';\n  });\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::map<char, int> primes = {\n        {'2', 2},\n        {'3', 3},\n   \
    \     {'5', 5},\n        {'7', 7},\n        {'B', 11},\n        {'D', 13}\n  \
    \  };\n    long sum = 0;\n    for (auto i : num) {\n        if (primes.find(i)\
    \ != primes.end())\n            sum += primes[i];\n    }\n    return sum;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp5yoaxlyk: /tmp/tmp5yoaxlyk.cpp:42: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    long hex, res;\n\tstd::stringstream ss;\n\tss << std::hex << num;\n\tss >> hex;\n\
    \tstd::bitset<sizeof(long) * 8> bits(hex);\n\tres = bits.count();\n\treturn res;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpdb81wdtf: /tmp/tmpdb81wdtf.cpp:35: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   // your code here\n    const char *c = num.c_str();\n    int sum = 0;\n  \
    \  for(int i = 0; i < strlen(c); i++){\n      switch(c[i]){\n        case '2':\n\
    \        case '3':\n        case '5':\n        case '7':\n        case 'B':\n\
    \        case 'D':\n          sum++;\n          break;\n        default:\n   \
    \       break;\n      }\n    }\n    return sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   char primes[6] = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n   \
    \ for(int i = 0; i < num.length(); i++){\n        for(int j = 0; j < 6; j++){\n\
    \            if(num[i] == primes[j]){\n                count++;\n            }\n\
    \        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    int n;\n\tstd::vector<int> prime={2,3,5,7,11,13};\n\tstd::vector<char> alpha={'A','B','C','D','E','F'};\n\
    \tstd::vector<int> hexa;\n\t\n\tfor(int i=0;i<num.length();i++){\n\t\tif(std::isdigit(num[i])){\n\
    \t\t\tn=num[i]-'0';\n\t\t\thexa.push_back(n);\n\t\t}\n\t\telse{\n\t\t\tauto it=std::find(alpha.begin(),alpha.end(),num[i]);\n\
    \t\t\tint p=std::distance(alpha.begin(),it);\n\t\t\thexa.push_back(prime[p]);\n\
    \t\t}\n\t}\n\tint count=0;\n\tfor(int i=0;i<hexa.size();i++){\n\t\tif(std::find(prime.begin(),prime.end(),hexa[i])!=prime.end()){\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpabluz5uv: /tmp/tmpabluz5uv.cpp:51: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    //#include<bits/stdc++.h>\n    using namespace std;\n\
    \    \n    // Write your code here\n    std::string hexToDecArray = \"0123456789ABCDEF\"\
    ;\n    std::vector<int> hexToDecVec(hexToDecArray.begin(), hexToDecArray.end());\n\
    \    //std::map<char, int> hexToDecMap(hexToDecArray.begin(), hexToDecArray.end());\n\
    \    for(int i = 0; i < num.length(); i++){\n        char c = num[i];\n      \
    \  //int value = hexToDecMap[c];\n        int value = hexToDecVec[hexToDecArray.find(c)];\n\
    \        //std::cout << value << std::endl;\n        if(value == 2 || value ==\
    \ 3 || value == 5 || value == 7 || value == 11 || value == 13){\n            count++;\n\
    \        }\n    }\n    \n    // std::cout << count << std::endl;\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp13g843bt: /tmp/tmp13g843bt.cpp:48: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long k=0;\n    std::string a=\"2357BDF\";\n    for(long i=0;i<num.length();i++){\n\
    \        if(a.find(num[i])!=std::string::npos){\n            k++;\n        }\n\
    \    }\n    return k;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpq_4re0r6: /tmp/tmpq_4re0r6.cpp:40: int main(): Assertion `candidate(("123456789ABCDEF0"))
    == (6)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int ar[] = {2,3,5,7,11,13};\n  int count = 0;\n  int i = 0;\n  std::set<char>\
    \ st = {'A','B','C','D','E','F'};\n  while(num[i] != '\\0'){\n    if(st.find(num[i])\
    \ != st.end()){\n      count++;\n    }\n    i++;\n  }\n  return count;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpxrm5j53u: /tmp/tmpxrm5j53u.cpp:39: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int count = 0;\n  for(auto ch : num){\n    switch(ch){\n      case '2':\n  \
    \    case '3':\n      case '5':\n      case '7':\n      case 'B':\n      case\
    \ 'D':\n        count++;\n        break;\n      default:\n        break;\n   \
    \ }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n  \
    \  assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::string prime_hex_digits = \"2357BD\";\n    long primes_num = 0;\n   \
    \ for (int i = 0; i < num.length(); i++) {\n        if (prime_hex_digits.find(num[i])\
    \ != std::string::npos) {\n            primes_num++;\n        }\n    }\n    return\
    \ primes_num;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   char key[16] = { '2', '3', '5', '7', 'B', 'D' };\n    int count = 0;\n   \
    \ for (char x : num) {\n        for (char y : key) {\n            if (x == y)\
    \ {\n                count++;\n            }\n        }\n    }\n    return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    for(int i = 0; i < num.length(); i++){\n        if(num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i] == 'B' ||\
    \ num[i] == 'D')\n            count++;\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int count = 0;\n    int num_len = num.length();\n    for(int i = 0; i < num_len;\
    \ i++) {\n        switch(num[i]) {\n            case '0':\n            case '1':\n\
    \            case '2':\n            case '3':\n            case '4':\n       \
    \     case '5':\n            case '6':\n            case '7':\n            case\
    \ '8':\n            case '9':\n                break;\n            case 'A':\n\
    \            case 'C':\n            case 'E':\n                count++;\n    \
    \            break;\n            case 'B':\n            case 'D':\n          \
    \  case 'F':\n                count+=2;\n                break;\n        }\n \
    \   }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n   \
    \ assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpvhl5u9zg: /tmp/tmpvhl5u9zg.cpp:56: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::string hexprime = \"2357BDE\";\n    int count = 0;\n    for(int i = 0;\
    \ i < num.length(); i++){\n        for(int j = 0; j < hexprime.length(); j++){\n\
    \            if(num[i] == hexprime[j]){\n                count++;\n          \
    \  }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmp4x6k5qh6: /tmp/tmp4x6k5qh6.cpp:39: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: ''
  timestamp: 1660122163
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    \n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"\
    )) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpxoupbb4l: /tmp/tmpxoupbb4l.cpp:29: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122164
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ // your code here\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmp9xvktoxb: /tmp/tmp9xvktoxb.cpp:29: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122164
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    std::string s = \"ABCDEF\";\n    for(int i = 0; i < num.length();\
    \ i++){\n        if((int)num[i] < 58){\n            if((int)num[i] % 2 != 0){\n\
    \                count++;\n            }\n        }\n        if((int)num[i] >\
    \ 64){\n            for(int j = 0; j < s.length(); j++){\n                if(num[i]\
    \ == s[j]){\n                    count++;\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpdqlcunir: /tmp/tmpdqlcunir.cpp:45: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    // initialize a hash table for hex values\n\tstd::unordered_map<char, int> hex;\n\
    \thex['0'] = 0;\n\thex['1'] = 1;\n\thex['2'] = 2;\n\thex['3'] = 3;\n\thex['4']\
    \ = 4;\n\thex['5'] = 5;\n\thex['6'] = 6;\n\thex['7'] = 7;\n\thex['8'] = 8;\n\t\
    hex['9'] = 9;\n\thex['A'] = 10;\n\thex['B'] = 11;\n\thex['C'] = 12;\n\thex['D']\
    \ = 13;\n\thex['E'] = 14;\n\thex['F'] = 15;\n\t// primes\n\tstd::unordered_set<int>\
    \ prime = {2, 3, 5, 7, 11, 13};\n\t// initialize counter\n\tint count = 0;\n\t\
    // iterate through the string\n\tfor (char c : num) {\n\t\t// check if current\
    \ char is present in prime\n\t\tif (prime.find(hex[c]) != prime.end()) {\n\t\t\
    \t// increment counter\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long count = 0;\n    for(int i = 0; i < num.length(); i++){\n        if((num[i]\
    \ == '2') || (num[i] == '3') || (num[i] == '5') || (num[i] == '7')\n        ||\
    \ (num[i] == 'B') || (num[i] == 'D')){\n            count++;\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    std::cout << num << std::endl;\n\tlong long count = 0;\n\tstd::map<char, int>\
    \ charMap;\n\tcharMap['0'] = 0;\n\tcharMap['1'] = 1;\n\tcharMap['2'] = 2;\n\t\
    charMap['3'] = 3;\n\tcharMap['4'] = 4;\n\tcharMap['5'] = 5;\n\tcharMap['6'] =\
    \ 6;\n\tcharMap['7'] = 7;\n\tcharMap['8'] = 8;\n\tcharMap['9'] = 9;\n\tcharMap['A']\
    \ = 10;\n\tcharMap['B'] = 11;\n\tcharMap['C'] = 12;\n\tcharMap['D'] = 13;\n\t\
    charMap['E'] = 14;\n\tcharMap['F'] = 15;\n\tfor (auto c : num) {\n\t\tif (charMap[c]\
    \ % 2 == 0 || charMap[c] % 3 == 0 || charMap[c] % 5 == 0 || charMap[c] % 7 ==\
    \ 0 || charMap[c] % 11 == 0 || charMap[c] % 13 == 0) {\n\t\t\tif (charMap[c] ==\
    \ 2 || charMap[c] == 3 || charMap[c] == 5 || charMap[c] == 7 || charMap[c] ==\
    \ 11 || charMap[c] == 13) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate =\
    \ hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmpavp36oc3: /tmp/tmpavp36oc3.cpp:59: int main(): Assertion `candidate(("1077E"))
    == (2)'' failed.

    '
  stdout: 'AB

    1077E

    '
  timestamp: 1660122164
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    //1. return 1 for 2,3,5,7,B,D\n\t//2. return 0 for all other letters\n\t//3. sum\
    \ the array of 1s and 0s\n\tstd::vector<int> keyVec = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n\
    \tint sum = 0;\n\tfor(int i = 0; i < num.length(); i++){\n\t\tif(num[i] == '2'){\n\
    \t\t\tkeyVec[i] = 1;\n\t\t}\n\t\telse if(num[i] == '3'){\n\t\t\tkeyVec[i] = 1;\n\
    \t\t}\n\t\telse if(num[i] == '5'){\n\t\t\tkeyVec[i] = 1;\n\t\t}\n\t\telse if(num[i]\
    \ == '7'){\n\t\t\tkeyVec[i] = 1;\n\t\t}\n\t\telse if(num[i] == 'B'){\n\t\t\tkeyVec[i]\
    \ = 1;\n\t\t}\n\t\telse if(num[i] == 'D'){\n\t\t\tkeyVec[i] = 1;\n\t\t}\n\t\t\
    else{\n\t\t\tkeyVec[i] = 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < keyVec.size(); i++){\n\
    \t\tsum += keyVec[i];\n\t}\n\treturn sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: Exception
  stderr: 'tmp0lhdas48: /tmp/tmp0lhdas48.cpp:65: int main(): Assertion `candidate(("112233445566778899AABBCCDDEEFF00"))
    == (12)'' failed.

    '
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   long n = 0;\n    std::set<char> prime = {'2', '3', '5', '7', 'B', 'D'};\n\
    \    for (long i = 0; i < num.size(); i++) {\n        if (prime.find(num[i]) !=\
    \ prime.end()) {\n            n++;\n        }\n    }\n    return n;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ int count = 0;\n  for(char& c : num) {\n    if(c == '2' || c == '3' || c ==\
    \ '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    std::string prime = \"2357BD\";\n\tlong count = 0;\n\tfor (int i = 0; i < num.length();\
    \ i++) {\n\t\tif (prime.find(num[i]) != std::string::npos) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::map<char, bool> primes;\n    primes['2'] = true;\n    primes['3'] = true;\n\
    \    primes['5'] = true;\n    primes['7'] = true;\n    primes['B'] = true;\n \
    \   primes['D'] = true;\n    int count = 0;\n    for (auto el : num) {\n     \
    \   if (primes.find(el) != primes.end()) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n  \
    \  assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ char hex[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \  char prime[6] = {'2','3','5','7','B','D'};\n  long count = 0;\n  long i = 0;\n\
    \  while(i < num.length()){\n    for(int k = 0; k < 6; k++){\n      if(num[i]\
    \ == prime[k]){\n        count++;\n      }\n    }\n    i++;\n  }\n  return count;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \ long count = 0;\n  for(auto& i : num) {\n    switch(i) {\n      case '2':\n\
    \      case '3':\n      case '5':\n      case '7':\n      case 'B':\n      case\
    \ 'D':\n        count++;\n        break;\n      default:\n        break;\n   \
    \ }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n  \
    \  assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n\t\
    long i,x,sum=0;\n\tstd::stringstream ss;\n\tss<<std::hex<<num;\n\tss>>x;\n\tfor(i=2;i<=x;i++)\n\
    \t\tif(i==2||i==3||i==5||i==7||i==11||i==13)\n\t\t\tsum++;\n\treturn sum;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpd6gzbm8h: /tmp/tmpd6gzbm8h.cpp:36: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122164
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   int count = 0;\n    for(int i = 0; i < num.length(); i++){\n        if((num[i]\
    \ == '2') || (num[i] == '3') || (num[i] == '5') || (num[i] == '7')\n        ||\
    \ (num[i] == 'B') || (num[i] == 'D')){\n            count++;\n        }\n    }\n\
    \    return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660122164
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>>\
    \ hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n//\
    \ (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n \
    \   std::string s=\"2,3,5,7,11,13\";\n    int i=0,k=0;\n    long count=0;\n  \
    \  for(i=0;i<num.length();i++)\n    {\n        int c=0;\n        for(k=0;k<s.length();k++)\n\
    \        {\n            if(num[i]==s[k])\n            {\n                count++;\n\
    \                c=1;\n                break;\n            }\n        }\n    \
    \    if(c==0)\n        {\n            char nums=toupper(num[i]);\n           \
    \ int n=nums-'0';\n            if(n>=10 && n<=15)\n            {\n           \
    \     count++;\n            }\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  status: Exception
  stderr: 'tmpmxj_70y9: /tmp/tmpmxj_70y9.cpp:54: int main(): Assertion `candidate(("AB"))
    == (1)'' failed.

    '
  stdout: ''
  timestamp: 1660122164
