name: HumanEval_9_rolling_max
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers,\
  \ generate a vector of rolling maximum element found until given moment\n// in the\
  \ sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2,\
  \ (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3,\
  \ (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>()))\
  \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3,\
  \ (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2,\
  \ (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n \
  \   assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3})))\
  \ == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n\
  }\n"
completions: ["    std::vector<long> result(numbers.size());\n    long max = numbers[0];\n\
    \    result[0] = max;\n    for (int i = 1; i < numbers.size(); i++) {\n      \
    \  if (numbers[i] > max) {\n            max = numbers[i];\n        }\n       \
    \ result[i] = max;\n    }\n    return result;", "    std::vector<long> result((int)numbers.size());\n\
    \    std::stack<long> st;\n    for (int i = 0; i < (int)numbers.size(); i++) {\n\
    \        while ((int)st.size() > 0 && numbers[st.top()] <= numbers[i]) {\n   \
    \         st.pop();\n        }\n        if ((int)st.size() == 0) {\n         \
    \   result[i] = numbers[i];\n        } else {\n            result[i] = result[st.top()];\n\
    \        }\n        st.push(i);\n    }\n    return result;", "  assert(numbers.size()\
    \ > 0);\n  std::vector<long> max_rolling_elements(numbers.size());\n  max_rolling_elements[0]\
    \ = numbers[0];\n  for (std::size_t index = 1; index < numbers.size(); ++index)\
    \ {\n    max_rolling_elements[index] = std::max(max_rolling_elements[index - 1],\
    \ numbers[index]);\n  }\n  return max_rolling_elements;", "    std::vector<long>\
    \ result = {};\n    for (long i = 0; i < numbers.size(); i++) {\n        long\
    \ max_until_now = numbers[i];\n        for (long j = 0; j <= i; j++) {\n     \
    \       if (numbers[j] > max_until_now) {\n                max_until_now = numbers[j];\n\
    \            }\n        }\n        result.push_back(max_until_now);\n    }\n \
    \   return result;", "    std::vector<long> rolling_max_vec(numbers.size());\n\
    \    std::deque<std::pair<long,long>> dq;\n    for(long i = 0; i < numbers.size();\
    \ i++) {\n        long val = numbers[i];\n        if(dq.empty()) {\n         \
    \   dq.push_back(std::make_pair(val, i));\n        } else {\n            while(dq.size()\
    \ > 0) {\n                if(dq.back().first < val) {\n                    dq.pop_back();\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            dq.push_back(std::make_pair(val, i));\n        }\n  \
    \      while(dq.size() > 0) {\n            std::pair<long,long> p = dq.front();\n\
    \            if(p.second > i - 3) {\n                rolling_max_vec[i] = p.first;\n\
    \                break;\n            } else {\n                dq.pop_front();\n\
    \            }\n        }\n    }\n    return rolling_max_vec;", "    // your solution\
    \ goes here\n    std::vector<long> result;\n    long maximum = -1;\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        maximum = std::max(maximum, numbers[i]);\n\
    \        result.push_back(maximum);\n    }\n    return result;", "    std::vector<long>\
    \ maxima;\n    maxima.push_back(numbers[0]);\n    for (long k = 1; k < numbers.size();\
    \ k++) {\n        maxima.push_back(std::max(maxima[k - 1], numbers[k]));\n   \
    \ }\n    return maxima;", "  // Create a copy of original vector and sort it.\n\
    \  std::vector<long> copy = numbers;\n  std::sort(copy.begin(), copy.end());\n\
    \  // Create a helper function for binary searching for element in a sorted vector.\n\
    \  auto bsearch = [](std::vector<long>& collection, long element) {\n    // Binary\
    \ search for the element.\n    long min = 0;\n    long max = collection.size()\
    \ - 1;\n    while (min <= max) {\n      long mid = (min + max) / 2;\n      if\
    \ (collection[mid] == element) {\n        return mid;\n      } else if (collection[mid]\
    \ < element) {\n        min = mid + 1;\n      } else {\n        max = mid - 1;\n\
    \      }\n    }\n    // Assert the element was found.\n    assert(false);\n  };\n\
    \  // Generate the vector of rolling maximums.\n  std::vector<long> maximums;\n\
    \  for (long i = 0; i < numbers.size(); i++) {\n    long index = bsearch(copy,\
    \ numbers[i]);\n    if (index == copy.size() - 1) {\n      maximums.push_back(numbers[i]);\n\
    \    } else {\n      maximums.push_back(copy[index + 1]);\n    }\n  }\n  return\
    \ maximums;", "    std::vector<long> *result = new std::vector<long>();\n    if\
    \ (numbers.size() == 0) {\n        return *result;\n    }\n    long max = numbers[0];\n\
    \    result->push_back(max);\n    for (int i = 1; i < numbers.size(); i++) {\n\
    \        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n \
    \       result->push_back(max);\n    }\n    return *result;", "\tstd::deque<std::pair<long,\
    \ int>> queue; // queue of number and its position in sequence\n\tstd::vector<long>\
    \ result;\n\tint position = 0;\n\tfor (auto number : numbers) {\n\t\twhile (queue.size()\
    \ > 0 && queue.back().first < number)\n\t\t\tqueue.pop_back();\n\t\tqueue.push_back(std::make_pair(number,\
    \ position));\n\t\twhile (queue.size() > 0 && queue.front().second <= position\
    \ - numbers.size())\n\t\t\tqueue.pop_front();\n\t\tresult.push_back(queue.front().first);\n\
    \t\tposition++;\n\t}\n\treturn result;", "    // edge cases\n    if (numbers.size()\
    \ == 0) return numbers;\n    // output\n    std::vector<long> output(numbers.size());\n\
    \    // container for keeping the maximums\n    std::deque<long> container;\n\
    \    // iterate through the given sequence and\n    // add maximums to output\
    \ array\n    for (int i = 0; i < numbers.size(); i++) {\n        // let's remove\
    \ smaller elements as we move forward in the sequence\n        while (!container.empty()\
    \ && container.back() < numbers[i]) {\n            container.pop_back();\n   \
    \     }\n        // add the current element to the container\n        container.push_back(numbers[i]);\n\
    \        // add the first element of the container to the output\n        output[i]\
    \ = container.front();\n    }\n    return output;", '    // Your code here', " \
    \ std::vector<long> ret;\n  long maximum = 0;\n  for (long n : numbers) {\n  \
    \  maximum = std::max(maximum, n);\n    ret.push_back(maximum);\n  }\n  return\
    \ ret;", "    std::vector<long> res(numbers.size());\n    res[0] = numbers[0];\n\
    \    for (int i = 1; i < numbers.size(); i++) {\n        res[i] = std::max(res[i\
    \ - 1], numbers[i]);\n    }\n    return res;", "    std::vector<long> result(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        if (i == 0) {\n  \
    \          result[i] = numbers[i];\n        } else {\n            result[i] =\
    \ std::max(result[i - 1], numbers[i]);\n        }\n    }\n    return result;",
  "\tstd::vector<long> ret;\n\tif (numbers.size() == 0) {\n\t\treturn ret;\n\t}\n\t\
    ret.push_back(numbers[0]);\n\tfor (int i = 1; i < numbers.size(); i++) {\n\t\t\
    ret.push_back(std::max(ret[i - 1], numbers[i]));\n\t}\n\treturn ret;", "    std::vector<long>\
    \ rolling_max;\n    rolling_max.push_back(numbers[0]);\n    for (auto i = (long)1;\
    \ i < numbers.size(); i++) {\n        rolling_max.push_back(std::max(rolling_max[i\
    \ - 1], numbers[i]));\n    }\n    return rolling_max;", "  std::vector<long> res;\n\
    \  std::stack<long> st;\n  long n = numbers.size();\n  for (int i = 0; i < n;\
    \ i++) {\n    while(!st.empty() && numbers[st.top()] <= numbers[i]) {\n      st.pop();\n\
    \    }\n    if (st.empty()) {\n      res.push_back(numbers[i]);\n    } else {\n\
    \      res.push_back(numbers[st.top()]);\n    }\n    st.push(i);\n  }\n  return\
    \ res;", "    std::vector<long> result;\n    long current_max = std::numeric_limits<long>::min();\n\
    \    for (auto const& number : numbers) {\n        current_max = std::max(current_max,\
    \ number);\n        result.push_back(current_max);\n    }\n    return result;",
  "    std::vector<long> results;\n    std::size_t len = numbers.size();\n    if (len\
    \ == 0) {\n        return results;\n    }\n    results.push_back(numbers[0]);\n\
    \    long max_value = numbers[0];\n    for (int i = 1; i < len; i++) {\n     \
    \   if (numbers[i] > max_value) {\n            max_value = numbers[i];\n     \
    \   }\n        results.push_back(max_value);\n    }\n    return results;", " \
    \   std::vector<long> rolling_max;\n    long max_val = numbers[0];\n    rolling_max.push_back(max_val);\n\
    \    for (int i = 1; i < numbers.size(); i++) {\n        long new_val = numbers[i];\n\
    \        max_val = std::max(max_val, new_val);\n        rolling_max.push_back(max_val);\n\
    \    }\n    return rolling_max;", "    assert(!numbers.empty());\n    std::vector<long>\
    \ results(numbers.size());\n    std::deque<long> q;\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        while (!q.empty() && numbers[q.back()] <= numbers[i]) {\n  \
    \          q.pop_back();\n        }\n        q.push_back(i);\n        if (q.front()\
    \ <= i - numbers.size()) {\n            q.pop_front();\n        }\n        results[i]\
    \ = numbers[q.front()];\n    }\n    return results;", "    std::vector<long> result;\n\
    \    if(numbers.size() == 0) return result;\n    std::deque<long> DQ;\n    for(int\
    \ i = 0; i < numbers.size(); i++) {\n        while(!DQ.empty() && DQ.back() <\
    \ numbers[i]) {\n            DQ.pop_back();\n        }\n        DQ.push_back(numbers[i]);\n\
    \        result.push_back(DQ.front());\n        if(i >= DQ.front()) DQ.pop_front();\n\
    \    }\n    return result;", "    std::vector<long> result;\n    for (long elem\
    \ : numbers) {\n        if (result.empty()) {\n            result.push_back(elem);\n\
    \        } else {\n            result.push_back(std::max(result.back(), elem));\n\
    \        }\n    }\n    return result;", "  // Your code here\n\n\n  std::vector<long>\
    \ result(numbers.size());\n  int maxNum = numbers[0];\n  for(int i = 0; i < numbers.size();\
    \ i++){\n    if(numbers[i] > maxNum){\n      maxNum = numbers[i];\n    }\n   \
    \ result[i] = maxNum;\n  }\n  return result;", "  long max_so_far = numbers[0];\n\
    \  for (std::vector<long>::iterator i = numbers.begin(); i != numbers.end(); i++)\
    \ {\n    if (*i > max_so_far) {\n      max_so_far = *i;\n    }\n    *i = max_so_far;\n\
    \  }\n  return numbers;", "    std::vector<long> result;\n    for (long i = 0;\
    \ i < numbers.size(); i++) {\n        long max = numbers[i];\n        for (long\
    \ j = 0; j <= i; j++) {\n            if (numbers[j] > max) {\n               \
    \ max = numbers[j];\n            }\n        }\n        result.push_back(max);\n\
    \    }\n    return result;", "    long max_num=numbers[0];\n    std::vector<long>\
    \ max_nums;\n    for(int i=0;i<numbers.size();i++){\n        if(numbers[i]>max_num){\n\
    \            max_num=numbers[i];\n        }\n        max_nums.push_back(max_num);\n\
    \    }\n    return max_nums;", "    int n = numbers.size();\n    std::vector<long>\
    \ max_for_prefix(n);\n    max_for_prefix[0] = numbers[0];\n    for (int i = 1;\
    \ i < n; i++) {\n        max_for_prefix[i] = std::max(max_for_prefix[i - 1], numbers[i]);\n\
    \    }\n    return max_for_prefix;", "    std::vector<long> res;\n    std::deque<long>\
    \ q;\n    int numbers_size = numbers.size();\n    for (int i = 0; i < numbers_size;\
    \ i++) {\n        if (q.empty()) {\n            q.push_back(i);\n        } else\
    \ {\n            while (!q.empty() && numbers[q.back()] < numbers[i]) {\n    \
    \            q.pop_back();\n            }\n            q.push_back(i);\n     \
    \   }\n        res.push_back(numbers[q.front()]);\n        if (q.front() == i\
    \ - 5) {\n            q.pop_front();\n        }\n    }\n    return res;", "  std::vector<long>\
    \ r;\n  if (numbers.size() > 0) {\n    r.push_back(numbers[0]);\n    for (long\
    \ i = 1; i < numbers.size(); i++) {\n      r.push_back(std::max(r[i - 1], numbers[i]));\n\
    \    }\n  }\n  return r;", "    std::vector<long> result;\n    long max = numbers[0];\n\
    \    result.push_back(max);\n    for (int i = 1; i < numbers.size(); i++) {\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        result.push_back(max);\n\
    \    }\n    return result;", "    std::vector<long> res;\n    long max_so_far\
    \ = numbers[0];\n    res.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size();\
    \ i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        res.push_back(max_so_far);\n\
    \    }\n    return res;", "\tstd::vector<long> maxes;\n\tauto current_max = numbers[0];\n\
    \tmaxes.push_back(current_max);\n\tfor (size_t i = 1; i < numbers.size(); i++)\
    \ {\n\t\tif (numbers[i] > current_max) {\n\t\t\tcurrent_max = numbers[i];\n\t\t\
    }\n\t\tmaxes.push_back(current_max);\n\t}\n\treturn maxes;", "    std::vector<long>\
    \ result(numbers.size());\n    std::stack<std::pair<long, long>> st;\n    // Initialize\
    \ stack with 1st element\n    st.push(std::make_pair(numbers[0], 0));\n    //\
    \ Initialize result vector with the 1st element\n    result[0] = numbers[0];\n\
    \    for (long i = 1; i < numbers.size(); i++) {\n        long num = numbers[i];\n\
    \        while (!st.empty() && st.top().first < num) {\n            st.pop();\n\
    \        }\n        if (st.empty()) {\n            result[i] = num;\n        }\
    \ else {\n            result[i] = st.top().first;\n        }\n        st.push(std::make_pair(num,\
    \ i));\n    }\n    return result;", "    std::vector<long> results;\n    std::stack<long>\
    \ st;\n    for (std::vector<long>::iterator it = numbers.begin(); it != numbers.end();\
    \ ++it) {\n        if (st.empty()) {\n            st.push(*it);\n            results.push_back(*it);\n\
    \        } else {\n            if (*it >= st.top()) {\n                st.push(*it);\n\
    \                results.push_back(*it);\n            } else {\n             \
    \   st.push(*it);\n                results.push_back(st.top());\n            }\n\
    \        }\n    }\n    return results;", "    std::vector<long> result;\n    long\
    \ current_max = numbers[0];\n    result.push_back(current_max);\n    for (long\
    \ i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > current_max) {\n\
    \            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n\
    \    }\n    return result;", "  std::vector<long> result;\n  if (numbers.size()\
    \ == 0) {\n    return result;\n  }\n  result.push_back(numbers[0]);\n  long last\
    \ = numbers[0];\n  for (int i = 1; i < numbers.size(); i++) {\n    if (numbers[i]\
    \ > last) {\n      last = numbers[i];\n    }\n    result.push_back(last);\n  }\n\
    \  return result;", "    std::vector<long> result;\n    result.push_back(numbers[0]);\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        result.push_back(std::max(result[i\
    \ - 1], numbers[i]));\n    }\n    return result;", "    std::vector<long> rolling_max(numbers.size());\n\
    \    long max_so_far = LONG_MIN;\n    for (int i = 0; i < numbers.size(); i++)\
    \ {\n        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n\
    \        }\n        rolling_max[i] = max_so_far;\n    }\n    return rolling_max;",
  "    std::vector<long> max_on_right(numbers.size());\n    if (numbers.size() ==\
    \ 0) {\n        return max_on_right;\n    }\n    max_on_right[numbers.size() -\
    \ 1] = numbers[numbers.size() - 1];\n    for (long i = numbers.size() - 2; i >=\
    \ 0; i--) {\n        max_on_right[i] = std::max(max_on_right[i + 1], numbers[i]);\n\
    \    }\n    return max_on_right;", "    std::vector<long> result;\n    long max\
    \ = 0;\n    for (long i = 0; i < numbers.size(); i++) {\n        max = std::max(max,\
    \ numbers[i]);\n        result.push_back(max);\n    }\n    return result;", "\t\
    assert(numbers.size() > (size_t)0);\n\tstd::vector<long> res(numbers.size());\n\
    \tres[(size_t)0] = numbers[(size_t)0];\n\tfor (size_t i = (size_t)1; i < numbers.size();\
    \ i++) {\n\t\tres[i] = std::max(res[i - (size_t)1], numbers[i]);\n\t}\n\treturn\
    \ res;", "    // TASK 1:\n    // Solve the problem using brute force.\n    //\
    \ What is the complexity of your solution?\n    std::vector<long> result;\n  \
    \  for (int i = 0; i < numbers.size(); i++) {\n        long max_value = numbers[i];\n\
    \        for (int j = i; j < numbers.size(); j++) {\n            if (numbers[j]\
    \ > max_value) {\n                max_value = numbers[j];\n            }\n   \
    \     }\n        result.push_back(max_value);\n    }\n    return result;", " \
    \   std::vector<long> rolling_max_numbers;\n    long max = numbers[0];\n    rolling_max_numbers.push_back(max);\n\
    \    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > max)\
    \ {\n            max = numbers[i];\n        }\n        rolling_max_numbers.push_back(max);\n\
    \    }\n    return rolling_max_numbers;", "    // both unique max and counts keep\
    \ track of maxima and its number of occurrences, respectively\n    std::vector<long>\
    \ unique_max;\n    std::vector<long> counts;\n    // keep track of the current\
    \ maximum that we've seen in this window\n    long window_max = 0;\n    // keep\
    \ track of the number of occurrences of the maximum in this window\n    long window_max_count\
    \ = 0;\n    for (auto n : numbers) {\n        // update window_max and window_max_count\
    \ if this element is greater than the current window_max\n        if (n > window_max)\
    \ {\n            window_max = n;\n            window_max_count = 1;\n        }\n\
    \        // if this element matches the current window_max, also update the count\n\
    \        else if (n == window_max) {\n            window_max_count++;\n      \
    \  }\n        // add the window_max to the front of unique_max\n        unique_max.insert(unique_max.begin(),\
    \ window_max);\n        // add the window_max_count to the front of counts\n \
    \       counts.insert(counts.begin(), window_max_count);\n    }\n    // at this\
    \ point, unique_max[i] is the unique max we should write at position i\n    //\
    \ and counts[i] is the number of occurrences of unique_max[i] in the range\n \
    \   // [i, end), inclusive\n    // now, we will iterate over the counts vector\
    \ and add the counts[i] - 1 copies of\n    // unique_max[i] at position i - (counts[i]\
    \ - 1)\n    for (size_t i = 0; i < counts.size(); i++) {\n        for (size_t\
    \ j = 0; j < counts[i] - 1; j++) {\n            // decrement i by 1 for every\
    \ iteration of j\n            // so that we get a downwards running window and\
    \ start from i - (counts[i] - 1)\n            // and end at i - 1\n          \
    \  unique_max.insert(unique_max.begin() + (i - j), unique_max[i]);\n        }\n\
    \    }\n    return unique_max;", "    std::vector<long> maximums;\n    // maximums.push_back(numbers[0]);\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        if (i == 0) {\n     \
    \       maximums.push_back(numbers[i]);\n        } else {\n            maximums.push_back(std::max(maximums[i\
    \ - 1], numbers[i]));\n        }\n    }\n    return maximums;", "  std::vector<long>\
    \ res;\n  long curr_max = numbers[0];\n  res.push_back(curr_max);\n  for (long\
    \ i = 1; i < numbers.size(); i++) {\n    curr_max = std::max(curr_max, numbers[i]);\n\
    \    res.push_back(curr_max);\n  }\n  return res;", "    // Implement your code\
    \ here\n    std::vector<long> *ptr = new std::vector<long>();\n    int p = 0;\n\
    \    for(int i = 0; i < numbers.size(); i++){\n        if(i == 0){\n         \
    \   ptr->push_back(numbers[i]);\n        }\n        else{\n            p = i;\n\
    \            long temp = numbers[i];\n            while(temp >= numbers[p - 1]\
    \ && p >= 0){\n                temp = numbers[p - 1];\n                p--;\n\
    \            }\n            ptr->push_back(temp);\n        }\n    }\n    return\
    \ *ptr;", "    std::vector<long> result;\n    long maximum = numbers[0];\n   \
    \ for (long number : numbers) {\n        maximum = std::max(maximum, number);\n\
    \        result.push_back(maximum);\n    }\n    return result;", "  std::vector<long>\
    \ max_values;\n  long max_number = numbers[0];\n  max_values.push_back(max_number);\n\
    \  for (int i = 1; i < numbers.size(); i++) {\n    if (numbers[i] > max_number)\
    \ {\n      max_number = numbers[i];\n    }\n    max_values.push_back(max_number);\n\
    \  }\n  return max_values;", "\tassert(numbers.size() > 0);\n\tstd::vector<long>\
    \ out;\n\tout.push_back(numbers[0]);\n\tfor (int i = 1; i < numbers.size(); i++)\
    \ {\n\t\tout.push_back(std::max(out[i - 1], numbers[i]));\n\t}\n\treturn out;",
  "    std::vector<long> max_list;\n    long max = *(numbers.begin());\n    for (auto\
    \ num : numbers) {\n        if (num > max) {\n            max = num;\n       \
    \ }\n        max_list.push_back(max);\n    }\n    return max_list;", "    std::deque<std::pair<long,\
    \ size_t>> buffer;\n    std::vector<long> result;\n    for (size_t i = 0; i <\
    \ numbers.size(); ++i) {\n        while (!buffer.empty() && numbers[i] >= buffer.back().first)\
    \ {\n            buffer.pop_back();\n        }\n        buffer.push_back(std::make_pair(numbers[i],\
    \ i));\n        while (buffer.front().second <= i - numbers.size()) {\n      \
    \      buffer.pop_front();\n        }\n        result.push_back(buffer.front().first);\n\
    \    }\n    return result;", "\tstd::vector<long> a(numbers.size());\n\tfor (size_t\
    \ i = 0; i < numbers.size(); i++) {\n\t\ta[i] = *std::max_element(numbers.begin(),\
    \ numbers.begin() + i + 1);\n\t}\n\treturn a;", "    std::vector<long> result;\n\
    \    long cur_max = numbers[0];\n    for (int i = 0; i < numbers.size(); i++)\
    \ {\n        if (numbers[i] > cur_max) {\n            cur_max = numbers[i];\n\
    \        }\n        result.push_back(cur_max);\n    }\n    return result;", " \
    \   std::vector<long> result;\n    std::deque<long> d;\n    long m;\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        while (!d.empty() && numbers[i] >=\
    \ numbers[d.back()]) {\n            d.pop_back();\n        }\n        d.push_back(i);\n\
    \        if (d.front() <= i - 1) {\n            d.pop_front();\n        }\n  \
    \      result.push_back(numbers[d.front()]);\n    }\n    return result;", "  \
    \  std::vector<long> ret;\n    long mx=std::numeric_limits<long>::min();\n   \
    \ for(int i=0;i<numbers.size();i++){\n        mx=std::max(mx,numbers[i]);\n  \
    \      ret.push_back(mx);\n    }\n    return ret;", "  std::vector<long> result;\n\
    \  result.push_back(numbers[0]);\n  long max_element = numbers[0];\n  for (std::vector<long>::size_type\
    \ i = 1; i < numbers.size(); i++) {\n    if (numbers[i] > max_element)\n     \
    \ max_element = numbers[i];\n    result.push_back(max_element);\n  }\n  return\
    \ result;", "  assert(numbers.size() > 0);\n  std::vector<long> result;\n  result.push_back(numbers[0]);\n\
    \  long max_so_far = numbers[0];\n  for (int i = 1; i < numbers.size(); i++) {\n\
    \    long cur_num = numbers[i];\n    if (cur_num >= max_so_far) {\n      max_so_far\
    \ = cur_num;\n    }\n    result.push_back(max_so_far);\n  }\n  return result;",
  "    // >>> isinstance(numbers, std::vector<long>)\n    // True\n    // >>> numbers.size()\
    \ == 7\n    // True\n    // >>> numbers[0] == 1\n    // True\n    // >>> numbers[1]\
    \ == 2\n    // True\n    // >>> numbers[2] == 3\n    // True\n    // >>> numbers[3]\
    \ == 2\n    // True\n    // >>> numbers[4] == 3\n    // True\n    // >>> numbers[5]\
    \ == 4\n    // True\n    // >>> numbers[6] == 2\n    // True\n    std::vector<long>\
    \ result(numbers.size());\n    // >>> isinstance(result, std::vector<long>)\n\
    \    // True\n    // >>> result.size() == 7\n    // True\n    long max_so_far\
    \ = numbers[0];\n    result[0] = max_so_far;\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        // >>> numbers[0] == 1\n        // True\n        // >>> numbers[1]\
    \ == 2\n        // True\n        // >>> numbers[2] == 3\n        // True\n   \
    \     // >>> numbers[3] == 2\n        // True\n        // >>> numbers[4] == 3\n\
    \        // True\n        // >>> numbers[5] == 4\n        // True\n        //\
    \ >>> numbers[6] == 2\n        // True\n        // >>> max_so_far == 1\n     \
    \   // True\n        // >>> i == 1\n        // True\n        max_so_far = std::max(max_so_far,\
    \ numbers[i]);\n        // >>> numbers[0] == 1\n        // True\n        // >>>\
    \ numbers[1] == 2\n        // True\n        // >>> numbers[2] == 3\n        //\
    \ True\n        // >>> numbers[3] == 2\n        // True\n        // >>> numbers[4]\
    \ == 3\n        // True\n        // >>> numbers[5] == 4\n        // True\n   \
    \     // >>> numbers[6] == 2\n        // True\n        // >>> max_so_far == 2\n\
    \        // True\n        // >>> i == 1\n        // True\n        result[i] =\
    \ max_so_far;\n        // >>> result", "    std::vector<long> result;\n    std::stack<long>\
    \ stck;\n    for (int i = 0; i < numbers.size(); i++) {\n        while (!stck.empty()\
    \ && stck.top() < numbers[i]) {\n            stck.pop();\n        }\n        stck.push(numbers[i]);\n\
    \        result.push_back(stck.top());\n    }\n    return result;", "    std::vector<long>\
    \ rolling_max(numbers.size());\n    long max_so_far = numbers[0];\n    rolling_max[0]\
    \ = max_so_far;\n    for (long number_i = 1; number_i < numbers.size(); number_i++)\
    \ {\n        long number = numbers[number_i];\n        max_so_far = std::max(max_so_far,\
    \ number);\n        rolling_max[number_i] = max_so_far;\n    }\n    return rolling_max;",
  "    // replacement for 8\n    int prev_max = -2147483648;\n    std::vector<long>\
    \ result;\n    for (int number : numbers) {\n        // replacement for 9\n  \
    \      if (number > prev_max) {\n            prev_max = number;\n        }\n \
    \       result.push_back(prev_max);\n    }\n    return result;", "    // your\
    \ code here\n    std::vector<long> result;\n    long max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    result.push_back(max);\n    for(int i = 1; i < numbers.size();\
    \ i++){\n        max = std::max(max, numbers[i]);\n        result.push_back(max);\n\
    \    }\n    return result;", "  std::vector<long> result(numbers.size());\n  std::stack<int>\
    \ s;\n  int i = 0;\n  while (i < numbers.size()) {\n    while (!s.empty() && numbers[s.top()]\
    \ <= numbers[i]) {\n      s.pop();\n    }\n    if (s.empty()) {\n      result[i]\
    \ = numbers[i];\n    } else {\n      result[i] = result[s.top()];\n    }\n   \
    \ s.push(i);\n    i++;\n  }\n  return result;", "    std::vector<long> retval;\n\
    \    std::stack<long> s;\n    for (long i = (long)0; i < (long)numbers.size();\
    \ i++) {\n        while (not s.empty() and numbers[s.top()] <= numbers[i]) {\n\
    \            s.pop();\n        }\n        retval.push_back(s.empty() ? numbers[i]\
    \ : numbers[s.top()]);\n        s.push(i);\n    }\n    return retval;", "    assert(numbers.size()\
    \ > 0);\n    std::vector<long> maximums(numbers.size());\n    long current_max\
    \ = numbers[0];\n    for (unsigned int i = 0; i < numbers.size(); i++) {\n   \
    \     if (numbers[i] > current_max) {\n            current_max = numbers[i];\n\
    \        }\n        maximums[i] = current_max;\n    }\n    return maximums;",
  "\tif (numbers.size() == 0) return numbers;\n\tstd::vector<long> result(numbers.size());\n\
    \tstd::stack<long> stack;\n\tstack.push(numbers[0]);\n\tresult[0] = numbers[0];\n\
    \tfor (int i = 1; i < numbers.size(); i++) {\n\t\twhile (!stack.empty() && stack.top()\
    \ < numbers[i]) {\n\t\t\tstack.pop();\n\t\t}\n\t\tif (stack.empty()) {\n\t\t\t\
    result[i] = numbers[i];\n\t\t}\n\t\telse {\n\t\t\tresult[i] = stack.top();\n\t\
    \t}\n\t\tstack.push(numbers[i]);\n\t}\n\treturn result;", "    std::vector<long>\
    \ result;\n    long max = numbers[0];\n    result.push_back(max);\n    for (int\
    \ i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > max) {\n       \
    \     max = numbers[i];\n        }\n        result.push_back(max);\n    }\n  \
    \  return result;", "\tstd::vector<long> ret(numbers.size());\n\tlong curr_max\
    \ = std::numeric_limits<long>::min();\n\tfor (int i = 0; i < numbers.size(); i++)\
    \ {\n\t\tif (numbers[i] > curr_max) {\n\t\t\tcurr_max = numbers[i];\n\t\t}\n\t\
    \tret[i] = curr_max;\n\t}\n\treturn ret;", "  std::vector<long> maxes;\n  maxes.push_back(numbers[0]);\n\
    \  for (int i = 1; i < numbers.size(); i++) {\n    maxes.push_back(std::max(maxes[i\
    \ - 1], numbers[i]));\n  }\n  return maxes;", "    auto maximum = std::vector<long>();\n\
    \    maximum.reserve(numbers.size());\n    auto max = std::numeric_limits<long>::min();\n\
    \    for (const auto& number : numbers) {\n        max = std::max(max, number);\n\
    \        maximum.push_back(max);\n    }\n    return maximum;", "    assert(numbers.size()\
    \ > 0);\n    std::vector<long> result = {numbers[0]};\n    long maximum = numbers[0];\n\
    \    std::vector<long>::iterator i;\n    for (i = numbers.begin() + 1; i != numbers.end();\
    \ ++i) {\n        long number = *i;\n        if (number > maximum) {\n       \
    \     maximum = number;\n        }\n        result.push_back(maximum);\n    }\n\
    \    return result;", "    std::deque<long> q;\n    std::vector<long> ret;\n \
    \   for (int i = 0; i < numbers.size(); i++) {\n        if (q.empty()) {\n   \
    \         q.push_back(i);\n        } else {\n            while (q.size() > 0 &&\
    \ numbers[q.back()] < numbers[i]) {\n                q.pop_back();\n         \
    \   }\n            q.push_back(i);\n        }\n        while (q.size() > 0 &&\
    \ i - q.front() >= 3) {\n            q.pop_front();\n        }\n        if (q.size()\
    \ > 0) {\n            ret.push_back(numbers[q.front()]);\n        } else {\n \
    \           ret.push_back(numbers[i]);\n        }\n    }\n    return ret;", " \
    \   std::vector<long> result;\n    long max_so_far = numbers[0];\n    for (long\
    \ i = 0; i < numbers.size(); i++) {\n        max_so_far = std::max(max_so_far,\
    \ numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;",
  "  int n = numbers.size();\n  std::vector<long> result;\n  std::deque<int> q;\n\
    \  q.push_back(0);\n  for (int i = 1; i < n; i++) {\n    while (q.size() && numbers[q.back()]\
    \ < numbers[i]) {\n      q.pop_back();\n    }\n    q.push_back(i);\n    if (q.front()\
    \ <= i - k) {\n      q.pop_front();\n    }\n    result.push_back(numbers[q.front()]);\n\
    \  }\n  return result;", "  std::vector<long> result;\n  if (numbers.size() ==\
    \ 0) {\n    return result;\n  }\n  result.push_back(numbers[0]);\n  for (int i\
    \ = 1; i < numbers.size(); i++) {\n    result.push_back(std::max(result[i - 1],\
    \ numbers[i]));\n  }\n  return result;", "  std::vector<long> result;\n  long\
    \ current_max = numbers[0];\n  for (long number : numbers) {\n    if (number >\
    \ current_max) {\n      current_max = number;\n    }\n    result.push_back(current_max);\n\
    \  }\n  return result;", "    std::vector<long> maximums;\n    std::deque<long>\
    \ indexes;\n    int length = numbers.size();\n    for (int i = 0; i < length;\
    \ i++) {\n        while (!indexes.empty() && numbers[indexes.back()] <= numbers[i])\
    \ {\n            indexes.pop_back();\n        }\n        indexes.push_back(i);\n\
    \        if (indexes.front() == i - 3) {\n            indexes.pop_front();\n \
    \       }\n        maximums.push_back(numbers[indexes.front()]);\n    }\n    return\
    \ maximums;", "    std::vector<long> result;\n    std::stack<std::pair<long, int>>\
    \ st;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        if (st.empty())\
    \ {\n            st.push(std::make_pair(numbers[i], i));\n            result.push_back(numbers[i]);\n\
    \        } else {\n            if (st.top().first > numbers[i]) {\n          \
    \      result.push_back(st.top().first);\n            } else {\n             \
    \   while (!st.empty() && st.top().first <= numbers[i]) {\n                  \
    \  st.pop();\n                }\n                if (st.empty()) {\n         \
    \           result.push_back(numbers[i]);\n                } else {\n        \
    \            result.push_back(st.top().first);\n                }\n          \
    \      st.push(std::make_pair(numbers[i], i));\n            }\n        }\n   \
    \ }\n    return result;", "    std::vector<long> result;\n    std::multiset<long>\
    \ maximums;\n    for (auto number : numbers) {\n        maximums.insert(number);\n\
    \        result.push_back(*maximums.rbegin());\n    }\n    return result;", " \
    \   // replace with your solution\n    std::vector<long> result;\n    long max_so_far\
    \ = 0;\n    for(auto it = numbers.begin(); it != numbers.end(); it++){\n     \
    \   max_so_far = std::max(max_so_far, *it);\n        result.push_back(max_so_far);\n\
    \    }\n    return result;", "    std::vector<long> result(numbers.size());\n\
    \    long current_max = -1;\n    for (int i = 0; i < numbers.size(); i++) {\n\
    \        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n\
    \        }\n        result[i] = current_max;\n    }\n    return result;", "  std::vector<long>\
    \ result(numbers.size());\n  long max_now = 0;\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    if (numbers[i] > max_now) {\n      max_now = numbers[i];\n    }\n\
    \    result[i] = max_now;\n  }\n  return result;", "    std::vector<long> result;\n\
    \    // Set the first maximum to the first number\n    long max = numbers[0];\n\
    \    // Iterate over the rest of the numbers\n    for (std::vector<long>::iterator\
    \ it = numbers.begin() + 1; it != numbers.end(); ++it) {\n        // Set the maximum\
    \ if the current number is greater\n        if (*it > max) max = *it;\n      \
    \  // Append it to the result\n        result.push_back(max);\n    }\n    return\
    \ result;", "    std::vector<long> maximums;\n    long max = 0;\n    for (auto\
    \ i : numbers) {\n        max = i > max ? i : max;\n        maximums.push_back(max);\n\
    \    }\n    return maximums;", "  if (numbers.size() == 0) {\n    return numbers;\n\
    \  }\n  std::vector<long> result;\n  long max = numbers[0];\n  result.push_back(max);\n\
    \  for (int i = 1; i < numbers.size(); i++) {\n    if (numbers[i] > max) {\n \
    \     max = numbers[i];\n    }\n    result.push_back(max);\n  }\n  return result;",
  "  std::vector<long> result{};\n  long max_val = -1;\n  for (const auto &number\
    \ : numbers) {\n    max_val = std::max(max_val, number);\n    result.push_back(max_val);\n\
    \  }\n  return result;", "    assert(numbers.size() > 0);\n    std::vector<long>\
    \ result(numbers.size());\n    long max_val = numbers[0];\n    result[0] = max_val;\n\
    \    for (long i = 1; i < numbers.size(); i++) {\n        long v = numbers[i];\n\
    \        if (v > max_val) {\n            max_val = v;\n        }\n        result[i]\
    \ = max_val;\n    }\n    return result;", "    std::vector<long> result = { numbers[0]\
    \ };\n    for (std::vector<long>::size_type i = 1; i < numbers.size(); i++) {\n\
    \        result.push_back(std::max(result[i - 1], numbers[i]));\n    }\n    return\
    \ result;", "    // The resulting vector.\n    std::vector<long> result(numbers.size());\n\
    \    // Iterate over all elements.\n    for (unsigned long i = 0; i < numbers.size();\
    \ i++) {\n        // The resulting value.\n        long result_value = numbers[i];\n\
    \        // Find the maximum.\n        for (unsigned long j = 0; j < i; j++) {\n\
    \            result_value = std::max(result_value, numbers[j]);\n        }\n \
    \       // Put the result in the resulting vector.\n        result[i] = result_value;\n\
    \    }\n    // Return the result.\n    return result;", "    std::vector<long>\
    \ answer;\n    if (numbers.size() == 0) {\n        return answer;\n    }\n   \
    \ std::deque<std::pair<long, long>> dq;\n    dq.push_back(std::make_pair(numbers[0],\
    \ 0));\n    answer.push_back(numbers[0]);\n    for (long i = 1; i < numbers.size();\
    \ i++) {\n        while (!dq.empty() && dq.back().first <= numbers[i]) {\n   \
    \         dq.pop_back();\n        }\n        dq.push_back(std::make_pair(numbers[i],\
    \ i));\n        while (!dq.empty() && dq.front().second <= i - 2) {\n        \
    \    dq.pop_front();\n        }\n        answer.push_back(dq.front().first);\n\
    \    }\n    return answer;", "    std::vector<long> res(numbers.size());\n   \
    \ long mx = numbers[0];\n    for (size_t i = 0; i < numbers.size(); i++) {\n \
    \       if (numbers[i] > mx) mx = numbers[i];\n        res[i] = mx;\n    }\n \
    \   return res;", "    std::vector<long> ret_val;\n    long cur_max = numbers[0];\n\
    \    ret_val.push_back(cur_max);\n    for (long i = 1; i < numbers.size(); i++)\
    \ {\n        if (numbers[i] >= cur_max) {\n            cur_max = numbers[i];\n\
    \        }\n        ret_val.push_back(cur_max);\n    }\n    return ret_val;",
  "    std::vector<long> answer;\n    std::vector<long> right_max = std::vector<long>(numbers.size(),\
    \ 0);\n    long current_max = 0;\n    for (long i = numbers.size() - 1; i >= 0;\
    \ i--) {\n        if (numbers[i] > current_max)\n            current_max = numbers[i];\n\
    \        right_max[i] = current_max;\n    }\n    for (long i = 0; i < numbers.size();\
    \ i++) {\n        answer.push_back(std::max(numbers[i], right_max[i + 1]));\n\
    \    }\n    return answer;", "    std::vector<long> result;\n    long _max = numbers[0];\n\
    \    for (auto number : numbers) {\n        if (number > _max) {\n           \
    \ _max = number;\n        }\n        result.push_back(_max);\n    }\n    return\
    \ result;", "\tint i = 0;\n\tstd::vector<long> result;\n\twhile (i < numbers.size())\
    \ {\n\t\tresult.push_back(*std::max_element(numbers.begin(), numbers.begin() +\
    \ i + 1));\n\t\ti++;\n\t}\n\treturn result;", "    assert(numbers.size() >= (size_t)1);\n\
    \    std::vector<long> ans;\n    ans.push_back(numbers[0]);\n    for (size_t i\
    \ = 1; i < numbers.size(); i++) {\n        ans.push_back(std::max(ans[i - 1],\
    \ numbers[i]));\n    }\n    return ans;", "  std::vector<long> result((size_t)numbers.size());\n\
    \  result[0] = numbers[0];\n  for (int i = 1; i < numbers.size(); i++) {\n   \
    \ result[i] = std::max(result[i - 1], numbers[i]);\n  }\n  return result;", " \
    \   long len = numbers.size();\n    std::vector<long> answer(len);\n    for (long\
    \ i = 0; i < len; i++) {\n        long elem = numbers[i];\n        if (i == 0)\
    \ {\n            answer[i] = elem;\n        } else {\n            answer[i] =\
    \ std::max(answer[i - 1], elem);\n        }\n    }\n    return answer;", "   \
    \ std::vector<long> result;\n    long value = numbers[0];\n    result.push_back(value);\n\
    \    for (long i = 1; i < numbers.size(); i++) {\n        value = std::max(value,\
    \ numbers[i]);\n        result.push_back(value);\n    }\n    return result;",
  "    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    std::vector<long>\
    \ result(numbers.size(), -1);\n    result[0] = numbers[0];\n    for (int i = 1;\
    \ i < numbers.size(); i++) {\n        result[i] = std::max(result[i - 1], numbers[i]);\n\
    \    }\n    return result;", "    std::vector<long> output;\n    if (numbers.size()\
    \ == 0) {\n        return output;\n    }\n    output.push_back(numbers[0]);\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        output.push_back(std::max(output[i\
    \ - 1], numbers[i]));\n    }\n    return output;", "    std::vector<long> rolling_max_numbers;\n\
    \    std::multiset<long> numbers_set;\n    for (long number : numbers) {\n   \
    \     numbers_set.insert(number);\n        rolling_max_numbers.push_back(*numbers_set.rbegin());\n\
    \    }\n    return rolling_max_numbers;", "    std::vector<long> result;\n   \
    \ long temp = 0;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(temp);\n\
    \        if (numbers[i] > temp) {\n            temp = numbers[i];\n        }\n\
    \    }\n    return result;", "    assert(!numbers.empty());\n    std::vector<long>\
    \ ret;\n    long buffer = numbers[0];\n    for (auto i : numbers) {\n        if\
    \ (i > buffer) {\n            buffer = i;\n        }\n        ret.push_back(buffer);\n\
    \    }\n    return ret;", "    std::vector<long> result;\n    long current_max\
    \ = numbers[0];\n    result.push_back(current_max);\n    for (long i = 1; i <\
    \ numbers.size(); i++) {\n        if (numbers[i] > current_max) {\n          \
    \  current_max = numbers[i];\n        }\n        result.push_back(current_max);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    long maximum\
    \ = numbers[0];\n    result.push_back(maximum);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] > maximum) {\n            maximum = numbers[i];\n\
    \        }\n        result.push_back(maximum);\n    }\n    return result;", " \
    \   std::vector<long> ans;\n    long max_curr = numbers[0];\n    ans.push_back(max_curr);\n\
    \    for (long i = 1; i < numbers.size(); i++) {\n        max_curr = max(max_curr,\
    \ numbers[i]);\n        ans.push_back(max_curr);\n    }\n    return ans;", " \
    \   long n = numbers.size();\n    std::vector<long> dp(n, 0);\n    dp[0] = numbers[0];\n\
    \    for (long i = 1; i < n; i++) {\n        dp[i] = std::max(dp[i - 1], numbers[i]);\n\
    \    }\n    return dp;", "    std::vector<long> max_so_far;\n    long current_max=numbers[0];\n\
    \    max_so_far.push_back(current_max);\n    for(int i=1;i<numbers.size();i++){\n\
    \        if(numbers[i]>current_max){\n            current_max=numbers[i];\n  \
    \      }\n        max_so_far.push_back(current_max);\n    }\n    return max_so_far;",
  "    std::vector<long> result;\n    long curr_max = numbers[0];\n    result.push_back(curr_max);\n\
    \    for (auto iter = numbers.begin() + 1; iter != numbers.end(); ++iter) {\n\
    \        curr_max = std::max(curr_max, *iter);\n        result.push_back(curr_max);\n\
    \    }\n    return result;", "    std::vector<long> maximums = std::vector<long>();\n\
    \    maximums.push_back(numbers[0]);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        maximums.push_back(std::max(maximums[i - 1], numbers[i]));\n\
    \    }\n    return maximums;", "  if(numbers.size() < 1)\n    return {};\n  std::vector<long>\
    \ sol = {numbers[0]};\n  long max_num = numbers[0];\n  for(int i = 1; i < numbers.size();\
    \ i++) {\n    if(numbers[i] > max_num)\n      max_num = numbers[i];\n    sol.push_back(max_num);\n\
    \  }\n  return sol;", "  std::vector<long> result;\n  long max = numbers[0];\n\
    \  for (int i = 0; i < numbers.size(); i++) {\n    if (numbers[i] > max) {\n \
    \     max = numbers[i];\n    }\n    result.push_back(max);\n  }\n  return result;",
  "    std::vector<long> ret;\n    std::deque<long> q;\n    for (long i = 0; i < numbers.size();\
    \ i++) {\n        while (!q.empty() && numbers[q.back()] <= numbers[i]) {\n  \
    \          q.pop_back();\n        }\n        q.push_back(i);\n        if (q.front()\
    \ <= i - numbers.size()) {\n            q.pop_front();\n        }\n        ret.push_back(numbers[q.front()]);\n\
    \    }\n    return ret;", "    std::vector<long> result;\n    if (numbers.size()\
    \ < 1) {\n        return result;\n    }\n    std::stack<long> st;\n    st.push(numbers[0]);\n\
    \    result.push_back(numbers[0]);\n    for (long i = 1; i < numbers.size(); i++)\
    \ {\n        if (numbers[i] >= st.top()) {\n            st.push(numbers[i]);\n\
    \        } else {\n            result.push_back(st.top());\n        }\n    }\n\
    \    return result;", "    std::deque<std::pair<long, long>> window;\n    std::vector<long>\
    \ ret;\n    for (long i = 0; i < numbers.size(); i++) {\n        while (!window.empty()\
    \ && window.back().first <= numbers[i]) {\n            window.pop_back();\n  \
    \      }\n        window.push_back({numbers[i], i});\n        while (!window.empty()\
    \ && window.front().second <= i - numbers.size()) {\n            window.pop_front();\n\
    \        }\n        assert(!window.empty());\n        ret.push_back(window.front().first);\n\
    \    }\n    return ret;", "    std::vector<long> res;\n    long curr_max = numbers[0];\n\
    \    res.push_back(curr_max);\n    for (int i = 1; i < numbers.size(); i++) {\n\
    \        if (numbers[i] > curr_max) {\n            curr_max = numbers[i];\n  \
    \      }\n        res.push_back(curr_max);\n    }\n    return res;", "\tif (numbers.size()\
    \ == 0) {\n\t\treturn std::vector<long>({});\n\t}\n\tstd::vector<long> result({numbers[0]});\n\
    \tfor (size_t i = 1; i < numbers.size(); i++) {\n\t\tresult.push_back(std::max(result[i\
    \ - 1], numbers[i]));\n\t}\n\treturn result;", "    std::vector<long> rolling_max;\n\
    \    auto back_it = numbers.begin();\n    while (back_it != numbers.end()) {\n\
    \        auto max_it = back_it;\n        while (max_it != numbers.end()) {\n \
    \           if (*max_it > *back_it) {\n                break;\n            }\n\
    \            ++max_it;\n        }\n        if (max_it == numbers.end()) {\n  \
    \          rolling_max.push_back(*back_it);\n        } else {\n            rolling_max.push_back(*max_it);\n\
    \        }\n        ++back_it;\n    }\n    return rolling_max;", "    std::vector<long>\
    \ result = {};\n    std::deque<long> deque = {};\n    for (auto it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n        while (!deque.empty() && deque.back()\
    \ < *it) {\n            deque.pop_back();\n        }\n        deque.push_back(*it);\n\
    \        result.push_back(deque.front());\n        if (deque.front() == *it) {\n\
    \            deque.pop_front();\n        }\n    }\n    return result;", "    std::vector<long>\
    \ res;\n    if (numbers.size() == 0) {\n        return res;\n    }\n    res.push_back(numbers[0]);\n\
    \    long max = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n\
    \        max = std::max(max, numbers[i]);\n        res.push_back(max);\n    }\n\
    \    return res;", "    std::vector<long> result;\n    if (numbers.size() == 0)\
    \ {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for\
    \ (int i = 1; i < numbers.size(); i++) {\n        result.push_back(std::max(result[i\
    \ - 1], numbers[i]));\n    }\n    return result;", "    std::vector<long> max_elements;\n\
    \    max_elements.push_back(numbers[0]);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        max_elements.push_back(std::max(max_elements[i - 1], numbers[i]));\n\
    \    }\n    return max_elements;", "    std::vector<long> result;\n    if(numbers.size()\
    \ == 0) return result;\n    result.push_back(numbers[0]);\n    for(int i = 1;\
    \ i < numbers.size(); i++) {\n        result.push_back(std::max(result[i-1], numbers[i]));\n\
    \    }\n    return result;", "    // your code here\n    std::vector<long> v;\n\
    \    for(int i=0;i<numbers.size();i++){\n      if(i==0){\n        v.push_back(numbers[i]);\n\
    \      }\n      else if(numbers[i]>=v[i-1]){\n        v.push_back(numbers[i]);\n\
    \      }\n      else{\n        v.push_back(v[i-1]);\n      }\n    }\n    return\
    \ v;", "    size_t sz = numbers.size();\n    std::vector<long> rolling_maxs(sz);\n\
    \    for (size_t i = 0; i < sz; i++) {\n        rolling_maxs[i] = std::max(numbers[i],\
    \ i == 0 ? numbers[i] : rolling_maxs[i - 1]);\n    }\n    return rolling_maxs;",
  "    std::vector<long> ans;\n    long max_value = numbers[0];\n    for (int i =\
    \ 0; i < numbers.size(); i++) {\n        if (numbers[i] >= max_value) {\n    \
    \        max_value = numbers[i];\n        }\n        ans.push_back(max_value);\n\
    \    }\n    return ans;", "    assert(numbers.size() > 0);\n    std::vector<long>\
    \ result;\n    std::vector<long> stack;\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        while (stack.size() > 0 && numbers[i] >= numbers[stack.back()])\
    \ {\n            stack.pop_back();\n        }\n        if (stack.size() == 0)\
    \ {\n            result.push_back(numbers[i]);\n        } else {\n           \
    \ result.push_back(numbers[stack.back()]);\n        }\n        stack.push_back(i);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    if(numbers.size()\
    \ == 0) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n\
    \    long current_max = numbers[0];\n    for(int i = 1; i < numbers.size(); i++)\
    \ {\n        if(numbers[i] > current_max) {\n            current_max = numbers[i];\n\
    \        }\n        result.push_back(current_max);\n    }\n    return result;",
  "\tstd::vector<long> maximums;\n\tmaximums.push_back(numbers[0]);\n\tfor (int index\
    \ = 1; index < numbers.size(); index++) {\n\t\tmaximums.push_back(std::max(maximums[index\
    \ - 1], numbers[index]));\n\t}\n\treturn maximums;", "    std::vector<long> rolling;\n\
    \    rolling.push_back(numbers[0]);\n    for (int i = 1; i < numbers.size(); i++)\
    \ {\n        rolling.push_back(std::max(rolling[i - 1], numbers[i]));\n    }\n\
    \    return rolling;", "  std::vector<long> results;\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    long max = numbers[i];\n    for (int j = i + 1; j < numbers.size();\
    \ j++) {\n      max = std::max(max, numbers[j]);\n    }\n    results.push_back(max);\n\
    \  }\n  return results;", "\tlong size = numbers.size();\n\tstd::vector<long>\
    \ toReturn;\n\tfor (long i = 0; i < size; i++) {\n\t\tlong max = numbers[i];\n\
    \t\tfor (long j = i + 1; j < size; j++) {\n\t\t\tif (numbers[j] > max) {\n\t\t\
    \t\tmax = numbers[j];\n\t\t\t}\n\t\t}\n\t\ttoReturn.push_back(max);\n\t}\n\treturn\
    \ toReturn;", "    std::vector<long> result;\n    result.push_back(numbers[0]);\n\
    \    for (int i = 1; i < numbers.size(); i++) {\n        result.push_back(std::max(result[i\
    \ - 1], numbers[i]));\n    }\n    return result;", "    int size = numbers.size();\n\
    \    std::vector<long> maximums(size);\n    for (int i = 0; i < size; i++) {\n\
    \        maximums[i] = numbers[i];\n        for (int j = 0; j < i; j++) {\n  \
    \          if (numbers[j] > maximums[i]) {\n                maximums[i] = numbers[j];\n\
    \            }\n        }\n    }\n    return maximums;", "    // Replace this\
    \ code with your own implementation.\n    std::vector<long> result;\n    long\
    \ current_max = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        if\
    \ (numbers[i] > current_max) {\n            current_max = numbers[i];\n      \
    \  }\n        result.push_back(current_max);\n    }\n    return result;", "  \
    \  std::vector<long> res;\n    long cur = numbers[0];\n    for (long i = 0; i\
    \ < numbers.size(); i++) {\n        cur = std::max(cur, numbers[i]);\n       \
    \ res.push_back(cur);\n    }\n    return res;", "    std::vector<long> result;\n\
    \    std::deque<int> max_indexes;\n    for (int i = 0; i < numbers.size(); i++)\
    \ {\n        while (!max_indexes.empty() && numbers[max_indexes.back()] <= numbers[i])\
    \ {\n            max_indexes.pop_back();\n        }\n        max_indexes.push_back(i);\n\
    \        if (max_indexes.front() <= i - 3) {\n            max_indexes.pop_front();\n\
    \        }\n        result.push_back(numbers[max_indexes.front()]);\n    }\n \
    \   return result;", "    std::vector<long> result(numbers.size());\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        long v = numbers[i];\n        for\
    \ (int j = 0; j < i; j++) {\n            v = std::max(v, numbers[j]);\n      \
    \  }\n        result[i] = v;\n    }\n    return result;", "    long max;\n   \
    \ std::vector<long> maxes;\n    max = numbers[0];\n    maxes.push_back(max);\n\
    \    for (long i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > max)\
    \ {\n            max = numbers[i];\n        }\n        maxes.push_back(max);\n\
    \    }\n    return maxes;", "    std::vector<long> current_maxes = {numbers[0]};\n\
    \    for (long i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > current_maxes.back())\
    \ {\n            current_maxes.push_back(numbers[i]);\n        } else {\n    \
    \        current_maxes.push_back(current_maxes.back());\n        }\n    }\n  \
    \  return current_maxes;", "    std::vector<long> result;\n    long current_max\
    \ = numbers[0];\n    result.push_back(current_max);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n\
    \    }\n    return result;", "  std::vector<long> result;\n  std::deque<std::pair<long,\
    \ int>> candidates;\n  for (int i = 0; i < numbers.size(); i++) {\n    long number\
    \ = numbers[i];\n    while (!candidates.empty() && number > candidates.back().first)\
    \ {\n      candidates.pop_back();\n    }\n    candidates.push_back(std::make_pair(number,\
    \ i));\n    while (candidates.front().second <= i - 3) {\n      candidates.pop_front();\n\
    \    }\n    result.push_back(candidates.front().first);\n  }\n  return result;",
  "    std::vector<long> result;\n    result.push_back(numbers[0]);\n    for (int\
    \ i = 1; i < numbers.size(); i++) {\n        result.push_back(std::max(result[i\
    \ - 1], numbers[i]));\n    }\n    return result;", "  std::vector<long> result;\n\
    \  if (numbers.size() == 0) {\n    return result;\n  }\n\n  long maximum = numbers[0];\n\
    \  result.push_back(maximum);\n  for (auto it = numbers.begin() + 1; it != numbers.end();\
    \ ++it) {\n    if (*it > maximum) {\n      maximum = *it;\n    }\n    result.push_back(maximum);\n\
    \  }\n  return result;", "    std::vector<long> max_elements;\n    long max_element\
    \ = 0;\n    for (int index = 0; index < numbers.size(); index++) {\n        long\
    \ current_element = numbers[index];\n        if (current_element > max_element)\
    \ {\n            max_element = current_element;\n        }\n        max_elements.push_back(max_element);\n\
    \    }\n    return max_elements;", "    std::vector<long> result(numbers.size());\n\
    \    auto numbers_begin = numbers.begin();\n    auto numbers_end = numbers.end();\n\
    \    auto result_begin = result.begin();\n    auto current_max = std::numeric_limits<long>::min();\n\
    \    for (auto i = numbers_begin; i != numbers_end; ++i) {\n        if (*i > current_max)\
    \ {\n            current_max = *i;\n        }\n        *result_begin = current_max;\n\
    \        ++result_begin;\n    }\n    return result;", "    std::vector<long> roll_max;\n\
    \    roll_max.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size();\
    \ i++) {\n        roll_max.push_back(std::max(roll_max[i - 1], numbers[i]));\n\
    \    }\n    return roll_max;", "    std::vector<long> maxima;\n    long maximum\
    \ = numbers[0];\n    maxima.push_back(maximum);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] >= maximum) {\n            maximum = numbers[i];\n\
    \        }\n        maxima.push_back(maximum);\n    }\n    return maxima;", " \
    \   std::vector<long> max_so_far(numbers.size());\n    std::stack<long> candidate_stack;\n\
    \    candidate_stack.push(numbers[0]);\n    max_so_far[0] = numbers[0];\n    for\
    \ (auto i = 1UL; i < numbers.size(); ++i) {\n        // // Invariant: for all\
    \ k in [0, i), candidate_stack.top() >= max_so_far[k]\n        // // Invariant:\
    \ candidate_stack.top() >= max_so_far[i]\n        if (candidate_stack.top() <\
    \ numbers[i]) {\n            candidate_stack.push(numbers[i]);\n            max_so_far[i]\
    \ = numbers[i];\n        } else {\n            max_so_far[i] = candidate_stack.top();\n\
    \        }\n    }\n    return max_so_far;", "    std::vector<long> ret;\n    long\
    \ m = -2147483647;\n    for (long i = 0; i < numbers.size(); i++) {\n        if\
    \ (numbers[i] > m) {\n            m = numbers[i];\n        }\n        ret.push_back(m);\n\
    \    }\n    return ret;", "\tauto max_numbers = std::vector<long>();\n\tauto curr_max\
    \ = numbers[0];\n\tfor (auto i = (long)0; i < numbers.size(); i++) {\n\t\tif (numbers[i]\
    \ > curr_max) {\n\t\t\tcurr_max = numbers[i];\n\t\t}\n\t\tmax_numbers.push_back(curr_max);\n\
    \t}\n\treturn max_numbers;", "    // your code here\n    std::vector<long> result;\n\
    \    std::stack<long> max_stack;\n    for(long i = numbers.size() - 1; i >= 0;\
    \ i--) {\n        if(max_stack.empty()) {\n            max_stack.push(numbers[i]);\n\
    \        } else {\n            max_stack.push(std::max(numbers[i], max_stack.top()));\n\
    \        }\n    }\n    while(!max_stack.empty()) {\n        result.push_back(max_stack.top());\n\
    \        max_stack.pop();\n    }\n    return result;", "    std::vector<long>::iterator\
    \ new_end = std::unique(numbers.begin(), numbers.end());\n    numbers.erase(new_end,\
    \ numbers.end());\n    std::sort(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ result;\n    std::set<long> actual;\n    auto finder = [&actual](long element)\
    \ {\n        auto it = actual.lower_bound(element);\n        if (it == actual.end())\
    \ {\n            return false;\n        }\n        actual.erase(it);\n       \
    \ return true;\n    };\n    for (long number : numbers) {\n        actual.insert(number);\n\
    \        while (finder(number)) {\n            number--;\n        }\n        result.push_back(number);\n\
    \    }\n    return result;", "\tstd::vector<long> ret;\n\tlong current_max = numbers[0];\n\
    \tfor (auto number : numbers) {\n\t\tcurrent_max = std::max(current_max, number);\n\
    \t\tret.push_back(current_max);\n\t}\n\treturn ret;", "  // Implement this function.\n\
    \  // Do not write the main method.\n  std::vector<long> max_numbers;\n  int i,j;\n\
    \  long max_num;\n  for(i=0;i<numbers.size();i++){\n    max_num = numbers[i];\n\
    \    for(j=i;j<numbers.size();j++){\n      if(numbers[j]>max_num){\n        max_num\
    \ = numbers[j];\n      }\n    }\n    max_numbers.push_back(max_num);\n  }\n  return\
    \ max_numbers;", "\t// Pre\n\tstd::vector<long> result;\n\t// Body\n\tlong max\
    \ = std::numeric_limits<long>::min();\n\tfor (long number : numbers) {\n\t\tmax\
    \ = std::max(max, number);\n\t\tresult.push_back(max);\n\t}\n\t// Post\n\tassert(result.size()\
    \ == numbers.size());\n\treturn result;", "    std::vector<long> max(numbers.size());\n\
    \    long cur_max = numbers[0];\n    for (size_t i = 0; i < numbers.size(); i++)\
    \ {\n        cur_max = std::max(cur_max, numbers[i]);\n        max[i] = cur_max;\n\
    \    }\n    return max;", "    std::vector<long> result = {numbers[0]};\n    for\
    \ (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > result[i -\
    \ 1]) {\n            result.push_back(numbers[i]);\n        } else {\n       \
    \     result.push_back(result[i - 1]);\n        }\n    }\n    return result;",
  "    std::vector<long> ret;\n    ret.push_back(numbers[0]);\n    for (int i = 1;\
    \ i < numbers.size(); i++) {\n        ret.push_back(std::max(ret[i - 1], numbers[i]));\n\
    \    }\n    return ret;", "\tstd::vector<long> max_so_far(numbers.size());\n\t\
    max_so_far[0] = numbers[0];\n\tfor (int i = 1; i < numbers.size(); i++) {\n\t\t\
    max_so_far[i] = std::max(max_so_far[i - 1], numbers[i]);\n\t}\n\treturn max_so_far;",
  "    // your code here\n    std::vector<long> ans(numbers.size());\n    long mx\
    \ = numbers[0];\n    ans[0] = mx;\n    for(int i = 1; i < numbers.size(); i++){\n\
    \        if(numbers[i] >= mx){\n            mx = numbers[i];\n        }\n    \
    \    ans[i] = mx;\n    }\n    return ans;", "    std::vector<long> rolling_max_elements\
    \ = std::vector<long>();\n    std::deque<long> index_set = std::deque<long>();\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        if (index_set.empty())\
    \ {\n            index_set.push_back(i);\n        } else {\n            while\
    \ (!index_set.empty() && numbers[index_set.back()] < numbers[i]) {\n         \
    \       index_set.pop_back();\n            }\n            index_set.push_back(i);\n\
    \        }\n        rolling_max_elements.push_back(numbers[index_set.front()]);\n\
    \        if (index_set.front() == i - 2) {\n            index_set.pop_front();\n\
    \        }\n    }\n    return rolling_max_elements;", "    std::vector<long> result;\n\
    \    std::vector<long>::iterator it = numbers.begin();\n    result.push_back(*it);\n\
    \    ++it;\n    for (; it != numbers.end(); ++it) {\n        result.push_back(std::max(*it,\
    \ result.back()));\n    }\n    return result;", "    assert(!numbers.empty());\n\
    \    std::vector<long> result;\n    result.push_back(numbers[0]);\n    auto max_elem\
    \ = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_elem\
    \ = std::max(max_elem, numbers[i]);\n        result.push_back(max_elem);\n   \
    \ }\n    return result;", "  std::vector<long> sequence;\n  long max = numbers[0];\n\
    \  sequence.push_back(max);\n  for (int i = 1; i < numbers.size(); i++) {\n  \
    \  max = std::max(max, numbers[i]);\n    sequence.push_back(max);\n  }\n  return\
    \ sequence;", "    std::vector<long> answer;\n    long rolling_max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    answer.push_back(rolling_max);\n    for (int i = 1; i <\
    \ numbers.size(); i++) {\n        long curr_number = numbers[i];\n        long\
    \ prev_max = answer[i - 1];\n        if (curr_number >= prev_max) {\n        \
    \    answer.push_back(curr_number);\n        } else {\n            answer.push_back(prev_max);\n\
    \        }\n    }\n    return answer;", "    assert(numbers.size() > 0);\n   \
    \ std::vector<long> ret(numbers.size());\n    ret[0] = numbers[0];\n    for (long\
    \ p = 1; p < numbers.size(); p++) {\n        ret[p] = std::max(ret[p - 1], numbers[p]);\n\
    \    }\n    return ret;", "  std::vector<long> result;\n  long max = numbers[0];\n\
    \  result.push_back(max);\n  std::size_t index = 1;\n  while (index < numbers.size())\
    \ {\n    max = numbers[index] > max ? numbers[index] : max;\n    result.push_back(max);\n\
    \    index += 1;\n  }\n  return result;", "    std::vector<long> max_numbers(numbers.size());\n\
    \    std::vector<long>::iterator it_max = max_numbers.begin();\n    std::vector<long>::iterator\
    \ it_numbers = numbers.begin();\n    long max_val = *it_numbers;\n    for (; it_numbers\
    \ != numbers.end(); ++it_numbers, ++it_max) {\n        if (*it_numbers > max_val)\
    \ {\n            max_val = *it_numbers;\n        }\n        *it_max = max_val;\n\
    \    }\n    return max_numbers;", "    assert(!numbers.empty());\n    std::vector<long>\
    \ ret;\n    ret.push_back(numbers[0]);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        ret.push_back(std::max(ret[i - 1], numbers[i]));\n    }\n  \
    \  return ret;", "    std::vector<long> result;\n    std::list<long> buffer;\n\
    \    long max;\n    for (long num : numbers) {\n        if (buffer.empty()) {\n\
    \            buffer.push_back(num);\n            max = num;\n        } else {\n\
    \            if (num < max) {\n                buffer.push_back(num);\n      \
    \      } else {\n                buffer.clear();\n                buffer.push_back(num);\n\
    \                max = num;\n            }\n        }\n        result.push_back(max);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    long maximum\
    \ = numbers[0];\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(maximum);\n\
    \        if (numbers[i] > maximum) {\n            maximum = numbers[i];\n    \
    \    }\n    }\n    return result;", "    std::vector<long> result;\n    if(numbers.size()\
    \ == 0) return result;\n    result.push_back(numbers[0]);\n    for(int i = 1;\
    \ i < numbers.size(); i++) {\n        result.push_back(std::max(result[i-1], numbers[i]));\n\
    \    }\n    return result;", "  std::vector<long> ret;\n  for (auto it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n    if (ret.empty()) {\n      ret.push_back(*it);\n\
    \    } else {\n      ret.push_back(std::max(*it, ret.back()));\n    }\n  }\n \
    \ return ret;", "  std::vector<long>::iterator result = numbers.begin();\n  //\
    \ store the start of the current maximum\n  std::vector<long>::iterator current_max\
    \ = numbers.begin();\n  // store the current maximum\n  long current_max_value\
    \ = *current_max;\n  // store the start of the previous maximum\n  std::vector<long>::iterator\
    \ previous_max = numbers.begin();\n  // store the previous maximum\n  long previous_max_value\
    \ = *previous_max;\n  // start from the second element\n  for (std::vector<long>::iterator\
    \ n = numbers.begin() + 1; n != numbers.end(); ++n) {\n    // if current element\
    \ is greater than the current maximum\n    if (*n > current_max_value) {\n   \
    \   // if current element is greater than the previous maximum\n      if (*n >\
    \ previous_max_value) {\n        // update the start of the previous maximum\n\
    \        previous_max = current_max;\n        // update the previous maximum\n\
    \        previous_max_value = current_max_value;\n      }\n      // update the\
    \ start of the current maximum\n      current_max = n;\n      // update the current\
    \ maximum\n      current_max_value = *current_max;\n    }\n    // maximum at the\
    \ given moment is either current maximum or previous maximum\n    if (n - current_max\
    \ < current_max - previous_max) {\n      *result = previous_max_value;\n    }\
    \ else {\n      *result = current_max_value;\n    }\n    // move to the next result\
    \ slot\n    ++result;\n  }\n  return numbers;", "    std::vector<long> res;\n\
    \    long i = 0;\n    long curr_max = numbers[i];\n    while (i < numbers.size())\
    \ {\n        while ((i < numbers.size()) && (numbers[i] >= curr_max)) {\n    \
    \        curr_max = numbers[i];\n            i += 1;\n        }\n        res.push_back(curr_max);\n\
    \        if (i < numbers.size()) {\n            curr_max = numbers[i];\n     \
    \   }\n    }\n    return res;", "\tstd::vector<long> res;\n\tres.push_back(numbers[0]);\n\
    \tfor (int i = 1; i < numbers.size(); i++) {\n\t\tif (numbers[i] > res[i - 1])\
    \ {\n\t\t\tres.push_back(numbers[i]);\n\t\t}\n\t\telse {\n\t\t\tres.push_back(res[i\
    \ - 1]);\n\t\t}\n\t}\n\treturn res;", "    std::vector<long> ret_val = {};\n \
    \   std::stack<long> s = {};\n    for (long index = 0; index < numbers.size();\
    \ index++) {\n        long curr_num = numbers[index];\n        if (s.empty())\
    \ {\n            s.push(curr_num);\n            ret_val.push_back(curr_num);\n\
    \        } else {\n            long top_stack = s.top();\n            if (top_stack\
    \ < curr_num) {\n                ret_val.push_back(curr_num);\n              \
    \  s.push(curr_num);\n            } else {\n                ret_val.push_back(top_stack);\n\
    \                s.push(curr_num);\n            }\n        }\n    }\n    return\
    \ ret_val;", "  std::vector<long> result;\n  result.push_back(numbers[0]);\n \
    \ for (int i = 1; i < numbers.size(); i++) {\n    result.push_back(std::max(result[i\
    \ - 1], numbers[i]));\n  }\n  return result;", "    std::vector<long> result;\n\
    \    auto it = numbers.begin();\n    result.push_back(*it);\n    for (it++; it\
    \ != numbers.end(); it++) {\n        result.push_back(std::max(*it, result.back()));\n\
    \    }\n    return result;", "  assert(numbers.size() > 0);\n  std::vector<long>\
    \ answer({numbers[0]});\n  for (long i = 1; i < numbers.size(); i++) {\n    answer.push_back(std::max(answer[i\
    \ - 1], numbers[i]));\n  }\n  return answer;", "    std::vector<long> result;\n\
    \    if (numbers.size() == 0) {\n        return result;\n    }\n    long max_so_far\
    \ = numbers[0];\n    result.push_back(max_so_far);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n\
    \    }\n    return result;", "\tassert(numbers.size() > 0);\n\tstd::vector<long>\
    \ result;\n\tlong maximum = numbers[0];\n\tfor (auto n : numbers) {\n\t\tif (n\
    \ > maximum) maximum = n;\n\t\tresult.push_back(maximum);\n\t}\n\treturn result;",
  "    size_t n = numbers.size();\n    std::vector<long> maxes(n, 0);\n    for (size_t\
    \ i = 0; i < n; i++) {\n        for (size_t j = 0; j <= i; j++) {\n          \
    \  maxes[i] = std::max(maxes[i], numbers[j]);\n        }\n    }\n    return maxes;",
  "  std::vector<long> output;\n  std::priority_queue<long> window;\n  for (long number\
    \ : numbers) {\n    window.push(number);\n    output.push_back(window.top());\n\
    \  }\n  return output;", "    std::vector<long> max_values(numbers.size());\n\
    \    long last_max = numbers[0];\n    max_values[0] = last_max;\n    for (size_t\
    \ i = 1; i < numbers.size(); i++) {\n        max_values[i] = std::max(last_max,\
    \ numbers[i]);\n        last_max = max_values[i];\n    }\n    return max_values;",
  "    std::vector<long> result(numbers.size());\n    std::multiset<long> maximums(numbers.begin(),\
    \ numbers.end());\n    std::transform(numbers.begin(), numbers.end(), result.begin(),\
    \ [&maximums](long num) {\n        maximums.erase(maximums.find(num));\n     \
    \   auto max = *maximums.rbegin();\n        maximums.insert(num);\n        return\
    \ max;\n    });\n    return result;", "    if (numbers.size()==0) return {};\n\
    \    std::vector<long> max_numbers;\n    long max = numbers[0];\n    max_numbers.push_back(max);\n\
    \    for (long i=1; i<numbers.size(); i++) {\n        if (numbers[i]>max) {\n\
    \            max = numbers[i];\n        }\n        max_numbers.push_back(max);\n\
    \    }\n    return max_numbers;", "    std::vector<long> m;\n    long current_max\
    \ = numbers[0];\n    m.push_back(current_max);\n    for (long i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n\
    \        }\n        m.push_back(current_max);\n    }\n    return m;", "  std::vector<long>\
    \ res;\n  long running_max = std::numeric_limits<long>::min();\n  for (long x\
    \ : numbers) {\n    running_max = std::max(running_max, x);\n    res.push_back(running_max);\n\
    \  }\n  return res;", "    std::vector<long> maximums;\n    auto max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    maximums.push_back(max);\n    auto len = numbers.size();\n\
    \    for (int i = 1; i < len; i++) {\n        if (numbers[i] > maximums[i - 1])\
    \ {\n            maximums.push_back(numbers[i]);\n        } else {\n         \
    \   maximums.push_back(maximums[i - 1]);\n        }\n    }\n    return maximums;",
  "    std::vector<long> result;\n    result.push_back(numbers[0]);\n    for (int\
    \ i = 1; i < numbers.size(); i++) {\n        result.push_back(std::max(result[i\
    \ - 1], numbers[i]));\n    }\n    return result;", "    std::vector<long> result;\n\
    \    long max = numbers[0];\n    result.push_back(max);\n    for (int i = 1; i\
    \ < numbers.size(); i++) {\n        if (numbers[i] > max) {\n            max =\
    \ numbers[i];\n        }\n        result.push_back(max);\n    }\n    return result;",
  "    std::vector<long> ret;\n    long max = 0;\n    for (long i : numbers) {\n \
    \       max = std::max(max, i);\n        ret.push_back(max);\n    }\n    return\
    \ ret;", "    std::vector<long> result(numbers.size());\n    std::deque<long>\
    \ window;\n    long i = 0;\n    for (auto number : numbers) {\n        if (window.empty())\
    \ {\n            window.push_back(i);\n        } else {\n            while (window.size()\
    \ > 0 && numbers[window.back()] < number) {\n                window.pop_back();\n\
    \            }\n            window.push_back(i);\n        }\n        result[i]\
    \ = numbers[window.front()];\n        if (window.front() == i - 3) {\n       \
    \     window.pop_front();\n        }\n        i++;\n    }\n    return result;",
  "  std::vector<long> result(numbers.size());\n  long m = numbers[0];\n  for (size_t\
    \ i = 0; i < numbers.size(); i++) {\n    m = std::max(m, numbers[i]);\n    result[i]\
    \ = m;\n  }\n  return result;"]
stop_tokens:
- "\n}"
