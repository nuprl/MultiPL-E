name: HumanEval_49_modp
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware\
  \ of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n\
  // >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100),\
  \ (101))\n// (1)\nlong modp(long n, long p) {\n"
tests: "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
  \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
  \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
  \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
  \ (5)) == (3));\n}\n"
completions: ["    assert(p>=2);\n    if(n<=1) return n;\n    long res = 1;\n    while(n>0)\
    \ {\n        if(n&1) res = (res*n)%p;\n        n = n>>1;\n        n = (n*n)%p;\n\
    \    }\n    return res%p;", "    if (n == 0) {\n        return 1;\n    } else\
    \ if (n == 1) {\n        return n;\n    } else if (n % 2 == 0) {\n        long\
    \ x = modp(n / 2, p);\n        return (x * x) % p;\n    } else {\n        return\
    \ (n * modp(n - 1, p)) % p;\n    }", "  assert(p > 0);\n  if (n < 0) n = n % p\
    \ + p;\n  if (n == 0) return 1;\n  long d = 1;\n  while (n > 1) {\n    long r\
    \ = n % 2;\n    n = n / 2;\n    if (r == 1) d = (d * 2) % p;\n  }\n  return d;",
  "\tassert(n >= 0);\n\tassert(p > 0);\n\t\n\t// (n * (2^n mod p)) mod p\n\t// = ((n\
    \ mod p) * (2^n mod p)) mod p\n\t// = ((n mod p) * (2^(n mod (p-1)) mod p)) mod\
    \ p\n\t\n\tlong result = 1;\n\tlong two = 2;\n\twhile (n > 0) {\n\t\t// compute\
    \ the square modulo p\n\t\tif (n % 2 != 0) {\n\t\t\tresult = (result * two) %\
    \ p;\n\t\t}\n\t\tn /= 2;\n\t\ttwo = (two * two) % p;\n\t}\n\treturn result;",
  "    long result = 1;\n    if (n == 0) { return 1; }\n    for (long i = 1; i <=\
    \ n; i++) {\n        result = (result * 2) % p;\n    }\n    return result;", " \
    \   assert(n >= 0);\n    assert(p > 0);\n    long result = 1;\n    for (long i\
    \ = 1; i <= n; i++) {\n        result = (result * 2) % p;\n    }\n    return result;",
  "    if (n<2) return n;\n    long r = 1;\n    for (int k=0; k<n; k++) {\n      \
    \  r = (r * 2) % p;\n    }\n    return r;", "    assert(n>=0);\n    assert(p>0);\n\
    \    if (n==0) return 1;\n    long r=1;\n    long i=n;\n    long j=1;\n    while\
    \ (j<=i) {\n        if (j&i) {\n            r=(r*n)%p;\n        }\n        j=j<<1;\n\
    \        n=(n*n)%p;\n    }\n    return r;", "    if(p == 0) return 0;\n    if(n\
    \ == 0) return 1;\n    assert(n >= 0);\n    assert(p > 0);\n    long x = modp(n\
    \ / 2, p);\n    long x2 = (x * x) % p;\n    if(n % 2 == 0) return x2;\n    return\
    \ (x2 * n) % p;", "    assert(p > 0);\n    if(n == 0) return 1;\n    if(n % 2\
    \ == 0) {\n        long x = modp(n/2, p);\n        return (x*x) % p;\n    } else\
    \ {\n        return (modp(n-1, p) * n) % p;\n    }", "    if(n == 0) return 1;\n\
    \    assert(p > 1);\n    long res = modp(n / 2, p);\n    if(n % 2 == 0) {\n  \
    \      return (res * res) % p;\n    } else {\n        return (res * res * 2) %\
    \ p;\n    }", "  long m = 1;\n  while (n > 0) {\n    if (n & 1) {\n      m = (m\
    \ * 2) % p;\n    }\n    n = n >> 1;\n  }\n  return m;", "  if (n == 0) {\n   \
    \ return 1;\n  } else if (n == 1) {\n    return n;\n  } else if (n % 2 == 0) {\n\
    \    long y = modp(n / 2, p);\n    return (y * y) % p;\n  } else {\n    return\
    \ ((n % p) * modp(n - 1, p)) % p;\n  }", "\tlong result = 1;\n\tlong pow2 = 2;\n\
    \twhile (n > 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tresult = (result * pow2) % p;\n\
    \t\t}\n\t\tpow2 = (pow2 * pow2) % p;\n\t\tn = n / 2;\n\t}\n\treturn result;",
  "  if (n == 0) return 1;\n  long k = modp(n/2, p);\n  if (n%2 == 0) {\n    return\
    \ (k*k)%p;\n  } else {\n    return (k*k*(n%p))%p;\n  }", "  assert(n >= 0);\n\
    \  assert(p > 0);\n  if(n == 0) {\n    return 1;\n  }\n  if(n % 2 == 0) {\n  \
    \  long res = modp(n / 2, p);\n    return res * res % p;\n  }\n  return n * modp(n\
    \ - 1, p) % p;", "  assert(p >= 1);\n  if(n == 0) {\n    return 1;\n  }\n  if(n\
    \ == 1) {\n    return n;\n  }\n  long res = 1;\n  while(n > 0) {\n    if(n & 1)\
    \ {\n      res = (res * n) % p;\n    }\n    n = n >> 1;\n    n = (n * n) % p;\n\
    \  }\n  return res;", "  assert(p >= 2);\n  if (n >= p)\n    return modp(n % p,\
    \ p);\n  if (n >= 0 && n < p)\n    return n;\n  if (n < 0 && n > -p)\n    return\
    \ n + p;\n  assert(false);", "    if (n == 0) return 1;\n    if (n == 1) return\
    \ n;\n    if (n % 2 == 0) return (modp((n / 2), p) * modp((n / 2), p)) % p;\n\
    \    else return (modp((n / 2), p) * modp((n / 2), p) * n) % p;", "  assert(p\
    \ > 0);\n  if (n <= 1)\n    return n;\n  long long a = modp(n >> 1, p);\n  a =\
    \ (a * a) % p;\n  if (n & 1)\n    a = (a * 2) % p;\n  return a;", "    if (n <\
    \ p) { return n; }\n    return modp(2*n % p, p);", "    assert(p >= 1);\n    if\
    \ (n < 0) {\n        n = (n % p) + p;\n    }\n    return n % p;", "  if (n ==\
    \ 0) return 1;\n  if (n % 2 == 0) {\n    long t = modp(n / 2, p);\n    return\
    \ (t * t) % p;\n  } else {\n    return (modp(n - 1, p) * n) % p;\n  }", "\tif\
    \ (n == 0) return 1;\n\tif (n == 1) return n;\n\tif (n % 2 == 0) {\n\t\tlong result\
    \ = modp(n / 2, p);\n\t\treturn (result * result) % p;\n\t}\n\tlong result = modp(n\
    \ - 1, p);\n\treturn (result * n) % p;", "\tstd::vector<int> binary;\n\tint i;\n\
    \tfor (i = 0; n > 0; i++) {\n\t\tbinary.push_back(n % 2);\n\t\tn = n / 2;\n\t\
    }\n\tlong result = 1;\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tresult = result\
    \ * result % p;\n\t\tif (binary[j] == 1) {\n\t\t\tresult = result * n % p;\n\t\
    \t}\n\t}\n\treturn result;", "\tassert(p > 0);\n\tlong r = 1;\n\tfor (long i =\
    \ 0; i < n; i++)\n\t\tr = (r * 2) % p;\n\treturn r;", "    if (n == 0) return\
    \ 1;\n    long a = modp(n / 2, p);\n    if (n % 2 == 0) {\n        return (a *\
    \ a) % p;\n    } else {\n        return (a * a * 2) % p;\n    }", "    if (n >=\
    \ p) {\n        return modp(n, p);\n    }\n    return pow(2, n) % p;", "  assert(p\
    \ > 0);\n  if (n < 0) {\n    n = n % p + p;\n  }\n  return (1 << n) % p;", "\t\
    if (n == 0) {\n\t\treturn 1;\n\t}\n\tlong ans = modp(n/2, p);\n\tans = (ans *\
    \ ans) % p;\n\tif (n % 2 == 1) {\n\t\tans = (ans * 2) % p;\n\t}\n\treturn ans;",
  "  assert(p > 0);\n  n %= p;\n  if (n < 0) {\n    n += p;\n  }\n  return n;", " \
    \ n %= p;\n  if (n <= 1) return n;\n  long result = 1;\n  while (n > 0) {\n  \
    \  if (n & 1) result = (result * 2) % p;\n    n >>= 1;\n  }\n  return result;",
  "    assert(p >= 2);\n    if (n < 0) {\n        n += p * ((-n)/p + 1);\n    }\n\
    \    int res = 1;\n    int pow = n % (p-1);\n    int mult = 2;\n    while (pow)\
    \ {\n        if (pow & 1) {\n            res = (res * mult) % p;\n        }\n\
    \        mult = (mult * mult) % p;\n        pow >>= 1;\n    }\n    return res;",
  "    // TODO\n    return pow(2,n)%p;", "    if (n == 0) {\n        return 1;\n \
    \   }\n    if (n % 2 == 0) {\n        return modp(n/2, p) * modp(n/2, p) % p;\n\
    \    }\n    else {\n        return n * modp(n-1, p) % p;\n    }", "\tassert(p\
    \ >= 2);\n\tif (n < 0)\n\t\tn = (n % p) + p;\n\tint result = 1;\n\tfor (int i\
    \ = 1; i <= n; i++)\n\t\tresult = (result * 2) % p;\n\treturn result;", "    //\
    \ assert(n >= 0);\n    // assert(p > 0);\n    if (n == 0) return 1;\n    if (n\
    \ == 1) return n % p;\n    long s = modp(n / 2, p);\n    long ret = (s * s) %\
    \ p;\n    if (n % 2 == 1) ret = (ret * n) % p;\n    return ret;", "  assert(n>=0);\n\
    \  assert(p>=2);\n  int c = 0;\n  int res = 1;\n  for (int i = 0; i < 32; i++)\
    \ {\n    if ((n & (1<<i)) != 0) {\n      c++;\n      res = (res * 2) % p;\n  \
    \  }\n  }\n  if (c % 2 == 0) {\n    return res;\n  } else {\n    return p-res;\n\
    \  }", "    // assert(p >= 2);\n    // assert(n >= 0);\n    n = n % p;\n    long\
    \ r = 1;\n    for (int i = 0; i < n; i++) {\n        r = (r * 2) % p;\n    }\n\
    \    return r;", "    assert(p >= 1);\n    if (n < 0) { n = n % p + p; }\n   \
    \ long res = 1;\n    while (n > 0) {\n        if (n & 1) { res = (res * 2) % p;\
    \ }\n        n >>= 1;\n        if (n > 0) { res = (res * 2) % p; }\n    }\n  \
    \  return res;", "\tif (n == 0) return 1;\n\tlong half = modp(n/2, p);\n\tlong\
    \ result = (half * half) % p;\n\tif (n % 2 == 1) {\n\t\tresult = (result * 2)\
    \ % p;\n\t}\n\treturn result;", "\tif (n == 0) return 1;\n\tlong a = modp(n/2,\
    \ p);\n\tlong b = (a*a) % p;\n\tif (n%2 == 1) b = (b*2) % p;\n\treturn b;", " \
    \   if (n == 0) {\n        return 1;\n    }\n    long sq = modp(n/2, p);\n   \
    \ if (n % 2 == 0) {\n        return sq * sq % p;\n    } else {\n        return\
    \ sq * sq % p * n % p;\n    }", "assert(p>=2);\n    if (n<0) {\n        n = p\
    \ - ((-n)%p);\n    }\n    if (n>=p) {\n        n = n%p;\n    }\n    return n;",
  "    n = n % p;\n    long res = 1;\n    while (n > 0) {\n        if (n & 1) {\n\
    \            res = (res * 3) % p;\n        }\n        n = n >> 1;\n        long\
    \ v = (3 * 3) % p;\n        res = (res * v) % p;\n    }\n    return res;", " \
    \   if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long\
    \ aux = modp(n / 2, p);\n        return (aux * aux) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;", "  assert(p > 0);\n  assert(n >= 0);\n  int res = 1;\n \
    \ while (n) {\n    if (n & 1) {\n      res = (res * 2) % p;\n    }\n    n >>=\
    \ 1;\n    if (n) {\n      res = (res * 2) % p;\n    }\n  }\n  return res;", " \
    \   if (n == 0) return 1;\n    else if (n % 2 == 0) return modp((n / 2) * (n /\
    \ 2), p);\n    else return (n % p) * modp((n / 2) * (n / 2), p);", "    long result\
    \ = 1;\n    for (int i = 0; i < n; i++) {\n        result = (result*2) % p;\n\
    \    }\n    return result;", "  assert(n >= 0);\n  assert(p > 0);\n  if (n ==\
    \ 0) return 1;\n  long r = modp(n / 2, p);\n  r = (r * r) % p;\n  if (n % 2 ==\
    \ 1) r = (r * 2) % p;\n  return r;", "\tassert(p>0);\n\tif (n>=p)\n\t\tn%=p;\n\
    \tif (n==0)\n\t\treturn 1;\n\tlong r=1;\n\twhile (n>1) {\n\t\tif (n&1) {\n\t\t\
    \tr*=2;\n\t\t\tif (r>=p)\n\t\t\t\tr%=p;\n\t\t}\n\t\tn>>=1;\n\t\tif (n) {\n\t\t\
    \tr*=r;\n\t\t\tif (r>=p)\n\t\t\t\tr%=p;\n\t\t}\n\t}\n\treturn r;", "  if (n ==\
    \ 0) return 1;\n  if (n % 2 == 0) return modp((n/2) % p, p) * modp((n/2) % p,\
    \ p) % p;\n  return n % p * modp((n-1) % p, p) % p;", "    if (n == 0) return\
    \ 1;\n    else if (n % 2 == 0) {\n        long t = modp(n / 2, p);\n        return\
    \ (t * t) % p;\n    } else return ((n % p) * modp(n - 1, p)) % p;", "\tassert(p\
    \ > 0);\n\tlong result = 1;\n\tlong base = n;\n\twhile (p > 0) {\n\t\tif (p &\
    \ 1) {\n\t\t\tresult = (result * base) % MOD;\n\t\t}\n\t\tbase = (base * base)\
    \ % MOD;\n\t\tp /= 2;\n\t}\n\treturn result;", "\tlong r = 1;\n\twhile (n > 0)\
    \ {\n\t\tif (n % 2 == 1) {\n\t\t\tr = (r * 2) % p;\n\t\t}\n\t\tn = n >> 1;\n\t\
    \tp = (p * 2) % p;\n\t}\n\treturn r;", "    long r = 1;\n    long b = n;\n   \
    \ while (p) {\n        if (p & 1) r = (r * b) % p;\n        p = p >> 1;\n    \
    \    b = (b * b) % p;\n    }\n    return r;", "    long res = 1;\n    n %= p;\n\
    \    while (n > 0) {\n        if (n & 1)\n            res = (res * 2) % p;\n \
    \       n >>= 1;\n        res %= p;\n    }\n    return res;", "    long res =\
    \ 1;\n    for (int i = 0; i < n; i++) {\n        res = (res * 2) % p;\n    }\n\
    \    return res;", "\tif (n==0) {\n\t\treturn 1;\n\t}\n\tif (n%2==0) {\n\t\tlong\
    \ temp = modp(n/2, p);\n\t\treturn (temp*temp)%p;\n\t}\n\telse {\n\t\treturn (modp(n-1,\
    \ p)*n)%p;\n\t}", "    // Implement modp here.\n    if(n==0)\n    \treturn 1;\n\
    \    long prod=1;\n    for(int i=0;i<n;i++)\n    {\n    \tprod=(prod*2)%p;\n \
    \   }\n    return prod;", "    if (n == 0) {\n        return 1;\n    }\n    else\
    \ if (n == 1) {\n        return n % p;\n    }\n    else {\n        long half =\
    \ modp(n / 2, p);\n        long half_squared = (half * half) % p;\n        if\
    \ (n % 2 == 0) {\n            return half_squared;\n        }\n        else {\n\
    \            return (half_squared * (n % p)) % p;\n        }\n    }", "  //assert(n\
    \ >= 0);\n  assert(p > 0);\n  long pow2 = 2;\n  long result = 1;\n  long pow2_modp\
    \ = pow2 % p;\n  while (n) {\n    if (n & 1) {\n      result = (result * pow2_modp)\
    \ % p;\n    }\n    pow2_modp = (pow2_modp * pow2_modp) % p;\n    n >>= 1;\n  }\n\
    \  return result;", "    if (n == 0) {\n        return 1;\n    }\n    // recursion:\
    \ n == (2^n) % p\n    if (n % 2 == 0) {\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p;\n    }\n    return modp(n/2, p) * modp(n/2, p) * n % p;", "    // Base\
    \ Case\n    if (n == 0)\n        return 1;\n    // n is even\n    if (n % 2 ==\
    \ 0)\n        return modp((n / 2), p) * modp((n / 2), p) % p;\n    // n is odd\n\
    \    return modp((n / 2), p) * modp((n / 2), p) * 2 % p;", "assert(n >= 0);\n\
    assert(p > 0);\n\nif (n == 0)\nreturn 1;\n\nif (n == 1)\nreturn n;\n\nlong a =\
    \ modp(n/2, p);\nlong ans = ((a * a) % p);\nif (n % 2 == 1)\nans = (ans * n) %\
    \ p;\nreturn ans;", "    long result = 1;\n    while (n > 0) {\n        if (n\
    \ % 2 != 0) {\n            result = (result * 2) % p;\n        }\n        n =\
    \ n / 2;\n        p = 2 * p;\n    }\n    return result;", "    assert(p > 0);\n\
    \    // This can be done quickly using the Fast Modular Exponentiation method.\n\
    \    //\n    // For example,\n    // modp(3, 5) = pow(3, 5) % 5 = 3248 % 5 = 3\n\
    \    // modp(1101, 101) = pow(1101, 101) % 101 = infinity % 101 = 2\n    //\n\
    \    // For more information: https://en.wikipedia.org/wiki/Modular_exponentiation\n\
    \    long result = 1;\n    for (int i = 0; i < n; i++) {\n        result = (result\
    \ * 2) % p;\n    }\n    return result;", "    assert(p > 0);\n    assert(n >=\
    \ 0);\n    if (n == 0) return 1;\n    long f = modp(n / 2, p);\n    long s = (f\
    \ * f) % p;\n    if (n % 2 == 1) {\n        s = (s * 2) % p;\n    }\n    return\
    \ s;", "   if (n < p) {\n       return n;\n   }\n   if (n < 0) {\n       return\
    \ p - modp(-n, p);\n   }\n   if (n % 2 == 0) {\n       long x = modp(n / 2, p);\n\
    \       return (2 * x) % p;\n   }\n   long x = modp(n / 2, p);\n   return (2 *\
    \ x + p - 1) % p;", "    long res = 1;\n    if(n<0) {\n        for(int i=0; i<-n;\
    \ i++) {\n            res = res * 2 % p;\n        }\n        res = p - res;\n\
    \    } else {\n        for(int i=0; i<n; i++) {\n            res = res * 2 % p;\n\
    \        }\n    }\n    return res;", "\tif(p <= 1)\n\t\treturn 1;\n\tif(n % 2\
    \ == 0)\n\t\treturn modp(n/2, p) * modp(n/2, p) % p;\n\telse\n\t\treturn modp(n/2,\
    \ p) * modp(n/2, p) * 2 % p;", "\tlong res = 1;\n\twhile (n > 0) {\n\t\tif (n\
    \ & 1) {\n\t\t\tres = (res * res) % p;\n\t\t}\n\t\tn >>= 1;\n\t}\n\treturn res;",
  "\tif(n == 0) return 1;\n\tif(n == 1) return n;\n\tlong k = modp(n / 2, p);\n\t\
    long k2 = (k * k) % p;\n\tif(n % 2 == 0) return k2;\n\treturn (k2 * n) % p;",
  "    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long\
    \ res = modp(n / 2, p);\n        return (res * res) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;", "    if (n == 0) {\n        return 1;\n    }\n    if (n\
    \ % 2 == 0) {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n  \
    \  return modp(n / 2, p) * modp(n / 2, p) * n % p;", "assert(p >= 2);\nif (n >=\
    \ p) {\nreturn modp(n, p);", "    if (n==0) return 1;\n    int a = modp(n/2, p);\n\
    \    if (n%2==0) return (a*a)%p;\n    else return (2*a*a)%p;", "    // assert\
    \ (n >= 0);\n    // assert (p > 0);\n    if (n == 0) return 1;\n    long x = modp((n/2),\
    \ p);\n    x = (x*x) % p;\n    return (n & 1) ? (x*2) % p : x;", "  int mod =\
    \ n % p;\n  return (mod >= 0) ? mod : mod + p;", "  // Cases 0 and 1.\n  if (n\
    \ == 0 || n == 1) {\n    return n;\n  }\n  // Recursive case.\n  long smallerAns\
    \ = modp(n / 2, p);\n  long rem = n % 2;\n  if (rem == 0) {\n    return (smallerAns\
    \ * smallerAns) % p;\n  } else {\n    return (2 * smallerAns * smallerAns) % p;\n\
    \  }", "  assert(p > 0);\n  if (n < 0) n = p - 1 - ((-n-1) % (p-1));\n  return\
    \ n % p;", "\tlong x = 1;\n\tlong y = n;\n\twhile (p > 0) {\n\t\tif (p % 2 ==\
    \ 1) {\n\t\t\tx = (x * y) % p;\n\t\t}\n\t\ty = (y * y) % p;\n\t\tp = p / 2;\n\t\
    }\n\treturn x % p;", "    // use binary exponentiation to compute modulo\n   \
    \ long res = 1;\n    while (n > 0) {\n        // iteratively compute 2^n mod p\n\
    \        if (n & 1) {\n            res = (res * 2) % p;\n        }\n        n\
    \ >>= 1;\n        if (n > 0) {\n            res = (res * res) % p;\n        }\n\
    \    }\n    return res;", "    assert(n >= 0);\n    if (n == 0) return 1;\n  \
    \  return (modp(n / 2, p) * modp(n - n / 2, p)) % p;", "\tlong i,j,s,c;\n\ts=1;c=n;\n\
    \tj=0;\n\ti=0;\n\twhile(c>0) {\n\t\tif(c%2==1) s=(s*pow(2,j))%p;\n\t\tc=c/2;\n\
    \t\tj++;\n\t}\n\treturn s;", "    assert(p >= 1);\n    if (n < p) {\n        return\
    \ n;\n    }\n    long z = (1 + n) % p;\n    long f = 2 * z % p;\n    long m =\
    \ n / p;\n    long q = m * z % p;\n    long r = m * f % p;\n    long s = q + r;\n\
    \    long w = s % p;\n    long u = w / 2;\n    return u;", "    //p = std::abs(p);\n\
    \    long result = 1;\n    while (n > 0) {\n        if (n & 1) {\n           \
    \ result = (result * n) % p;\n        }\n        n = n >> 1;\n        n = (n *\
    \ n) % p;\n    }\n    return result;", "\tlong r = 1;\n\twhile (n > 0) {\n\t\t\
    if (n & 1) r = (r * r) % p;\n\t\tn >>= 1;\n\t}\n\treturn r;", "    if(n==0)\n\
    \        return 1;\n    assert(p!=0);\n    assert(n>=0);\n    assert(p>=2);\n\
    \    long modp_n = modp(n/2, p);\n    modp_n = (modp_n*modp_n)%p;\n    if(n%2==1)\n\
    \        modp_n = (modp_n*2)%p;\n    return modp_n;", "    if (n == 0) return\
    \ 1;\n    long a = modp(n / 2, p);\n    long x = (a * a) % p;\n    if (n % 2 ==\
    \ 1) x = (x * 2) % p;\n    return x;", "    assert(p >= 2);\n    if (n < 0) {\n\
    \        n = p - std::abs(n);\n    }\n    if (n == 0) {\n        return 1;\n \
    \   }\n    if (n == 1) {\n        return n;\n    }\n    long x = 1;\n    long\
    \ y = n;\n    while (p > 0) {\n        if (p % 2 == 1) {\n            x = (x *\
    \ y) % p;\n        }\n        y = (y * y) % p;\n        p = p / 2;\n    }\n  \
    \  return x % p;", "assert(p > 0);\n    if(n < 0) n = (n % p) + p;\n    return\
    \ n % p;", "  if (n == 0) {\n    return 1;\n  }\n  if (n % 2 == 0) {\n    long\
    \ tmp = modp(n / 2, p);\n    return (tmp * tmp) % p;\n  }\n  return (modp(n -\
    \ 1, p) * n) % p;", "  int res = 1;\n  for (; n > 0; n >>= 1) {\n    if (n & 1)\
    \ res = (res * res) % p;\n    res = (res * res) % p;\n  }\n  return res;", "\t\
    assert(p > 0);\n\tassert(n >= 0);\n\tlong result = 1;\n\tlong t = 2;\n\twhile\
    \ (n > 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tresult = (result * t) % p;\n\t\t}\n\t\
    \tt = (t * t) % p;\n\t\tn = n / 2;\n\t}\n\treturn result;", "    assert(p != 0);\n\
    \    // case 1: n%p == 0\n    if(n%p == 0) return 0;\n    // case 2: n%p == 1\n\
    \    if(n%p == 1) return 1;\n    // case 3: n%p != 0 && n%p != 1\n    long r =\
    \ 1;\n    // one way\n    // for(int i = 0; i < n; i++) {\n    //     r = (r*2)%p;\n\
    \    // }\n    // another way\n    while(n > 0) {\n        if(n%2 == 1) {\n  \
    \          r = (r*2)%p;\n        }\n        n /= 2;\n    }\n    return r;", " \
    \   if (n == 0) return 1;\n    long x = modp(n/2, p);\n    x = (x*x) % p;\n  \
    \  if (n % 2) {\n        x = (x*2) % p;\n    }\n    return x;", "    if(n == 0)\
    \ return 1;\n    if(n == 1) return n % p;\n    long res = 1;\n    while(n > 0)\
    \ {\n        if(n & 1) res = (res * n) % p;\n        n = n >> 1;\n        n =\
    \ (n * n) % p;\n    }\n    return res;", "   if (n == 0) return 1;\n   long n2\
    \ = modp(n/2, p);\n   if (n % 2 == 0) return (n2 * n2) % p;\n   else return (n2\
    \ * n2 * n) % p;", "  if(n == 0) {\n    return 1;\n  } else if(n == 1) {\n   \
    \ return 3;\n  } else {\n    assert(n >= 2);\n    long half = modp(n / 2, p);\n\
    \    long half_mod = (half * half) % p;\n    if(n % 2 == 0) {\n      return half_mod;\n\
    \    } else {\n      return (half_mod * 3) % p;\n    }\n  }", "\tassert(p > 0);\n\
    \tlong result = 1;\n\tn %= p;\n\twhile (n > 0) {\n\t\tif (n & 1) {\n\t\t\tresult\
    \ = (result * n) % p;\n\t\t}\n\t\tn = n >> 1;\n\t\tn = (n * n) % p;\n\t}\n\treturn\
    \ result;", "    // TODO\n    if(n == 0) return 1;\n    if(n == 1) return n;\n\
    \    if(n%2 == 0) return modp(n/2, p)*modp(n/2, p)%p;\n    else return modp(n/2,\
    \ p)*modp(n/2, p)*n%p;", "    assert(p > 0);\n    assert(n >= 0);\n    int a =\
    \ 0;\n    if (n == 0)\n        return 1;\n    a = modp(n/2, p);\n    if (n % 2\
    \ == 0)\n        return (a * a) % p;\n    else\n        return (a * a * 2) % p;",
  "    if (n == 0) {\n        return 1;\n    } else if (n % 2 == 0) {\n        long\
    \ res = modp(n / 2, p);\n        return (res * res) % p;\n    } else {\n     \
    \   return (modp(n - 1, p) * n) % p;\n    }", "  assert(p > 0);\n  n %= p;\n \
    \ if (n < 0) {\n    n += p;\n  }\n  assert(n >= 0 && n < p);\n  return n;", " \
    \   long two_to_n = 1;\n    for (int i = 0; i < n; i++) {\n        two_to_n *=\
    \ 2;\n        two_to_n %= p;\n    }\n    return two_to_n;", "    assert(p > 0);\n\
    \    assert(n >= 0);\n    assert(n < p);\n    // We want to compute pow(2, n,\
    \ p).\n    // If p is odd, this is equivalent to pow(2, n % (p - 1), p).\n   \
    \ // If p is even, we have to consider 2^(p - 1) == -1, so\n    // we should use\
    \ pow(2, n % 2*(p - 1), p).\n    long x = 1;\n    if (p % 2 == 0) {\n        long\
    \ n2 = n % (2 * (p - 1));\n        long n1 = n2;\n        if (n2 >= p - 1) {\n\
    \            n1 = n2 - (p - 1);\n        }\n        n = n1;\n    } else {\n  \
    \      n = n % (p - 1);\n    }\n    for (long i = 0; i < n; i++) {\n        x\
    \ = (x * 2) % p;\n    }\n    return x;", "\tassert(p > 0);\n\tlong nn = (n % p);\n\
    \tif (nn < 0) {\n\t\tnn += p;\n\t}\n\treturn nn;", "\tif(!n) return 1;\n\tif(n&1)\
    \ return (2*modp(n-1, p))%p;\n\telse {\n\t\tlong r = modp(n/2, p);\n\t\treturn\
    \ (r*r)%p;\n\t}", "\tint pp = n;\n\tint m = 1;\n\twhile (p > 1) {\n\t\tassert(pp\
    \ >= 0);\n\t\tif (p % 2 == 1) {\n\t\t\tm = (m * pp) % n;\n\t\t}\n\t\tpp = (pp\
    \ * pp) % n;\n\t\tp = p / 2;\n\t}\n\treturn m;", "\tlong result = 1;\n\twhile\
    \ (n != 0) {\n\t\tif (n % 2 != 0) {\n\t\t\tresult = (result * 2) % p;\n\t\t}\n\
    \t\tn = n / 2;\n\t\tif (n != 0) {\n\t\t\tresult = (result * 2) % p;\n\t\t}\n\t\
    }\n\treturn result;", "  int two_n = 1;\n  for (int i = 0; i < n; i++)\n    two_n\
    \ = (two_n * 2) % p;\n  return two_n;", "  assert(n >= 0);\n  assert(p > 0);\n\
    \  assert(p <= 1000000000);\n  std::cout << \"n = \" << n << \", p = \" << p <<\
    \ std::endl;\n  if (n <= 1) {\n    return n;\n  } else {\n    return (modp(n/2,\
    \ p) * modp(n/2, p) * modp(n%2, p)) % p;\n  }", "    assert(p > 0);\n    long\
    \ pow = 1;\n    for (long i = 0; i < n; i++)\n        pow = (pow * 2) % p;\n \
    \   return pow;", "  long r = 1;\n  if (n < 0) {\n    n = n + (p * ((p - n) /\
    \ p));\n  }\n  while (n > 0) {\n    if (n % 2 == 1) {\n      r = (r * 2) % p;\n\
    \    }\n    n = n / 2;\n    if (n > 0) {\n      r = (r * 2) % p;\n    }\n  }\n\
    \  return r;", "\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tlong a = modp(n\
    \ / 2, p);\n\t\treturn (a * a) % p;\n\t}\n\treturn (modp(n - 1, p) * n) % p;",
  "  assert(p > 0);\n  // Equivalent to p % 2 == 1\n  if (p & 1) {\n    long r = 1;\n\
    \    while (n) {\n      if (n & 1) {\n        r = (r * 2) % p;\n      }\n    \
    \  n >>= 1;\n      r = (r * 2) % p;\n    }\n    return r;\n  } else {\n    return\
    \ 0;\n  }", "  long res = 1;\n  while (n > 0) {\n    if (n & 1) {\n      res =\
    \ (res * n) % p;\n    }\n    n = n >> 1;\n    n = (n * n) % p;\n  }\n  return\
    \ res;", "  if (n == 0) {\n    return 1;\n  }\n  long z = modp(n / 2, p);\n  if\
    \ (n % 2 == 0) {\n    return (z * z) % p;\n  } else {\n    return (2 * z * z)\
    \ % p;\n  }", "  assert(p <= 1000000);\n  if (n == 0) {\n    return 1;\n  }\n\
    \  long result = 1;\n  while (n > 0) {\n    if (n % 2 != 0) {\n      result =\
    \ (result * (n % p)) % p;\n    }\n    n = n / 2;\n    n = n % p;\n  }\n  return\
    \ result;", "  long a = 1;\n  long b = n;\n  while (1) {\n    if (b == 0) {\n\
    \      return a;\n    }\n    if (b % 2 == 1) {\n      a = (a * n) % p;\n    }\n\
    \    b = b / 2;\n    n = (n * n) % p;\n  }", "    long a = 1;\n    while (n >\
    \ 0) {\n        if (n % 2 != 0) {\n            a = (a * 10) % p;\n        }\n\
    \        n = n / 2;\n        int t = (10 * 10) % p;\n        a = (a * t) % p;\n\
    \    }\n    return a;", "    if(n==0) return 1;\n    if(n==1) return n;\n    else\
    \ {\n        long res = modp(n/2, p);\n        res = (res*res)%p;\n        if(n&1)\
    \ {\n            res = (res*n)%p;\n        }\n        return res;\n    }", " \
    \ long r = 1;\n  long b = p;\n  while (n) {\n    if (n & 1) {\n      r = (r *\
    \ b) % p;\n    }\n    n = n >> 1;\n    b = (b * b) % p;\n  }\n  return r;", "\t\
    assert(p > 0);\n\tif (n >= p)\n\t\tn %= p;\n\tif (n < 0)\n\t\tn += p;\n\tassert(n\
    \ >= 0 && n < p);\n\treturn n;", "    assert(p > 0);\n    assert(n >= 0);\n  \
    \  if (n == 0) return 1;\n    if (n == 1) return n;\n    if (n % 2 == 0) return\
    \ modp(n / 2, p) * modp(n / 2, p) % p;\n    return modp(n / 2, p) * modp(n / 2,\
    \ p) * n % p;", "\tif(n >= p) {\n\t\treturn modp(n % p, p);\n\t}\n\tlong result\
    \ = 1;\n\twhile(n > 0) {\n\t\tif(n % 2 == 1) {\n\t\t\tresult = (result * 2) %\
    \ p;\n\t\t}\n\t\tn = n / 2;\n\t}\n\treturn result;", "    long bitLength = (long)\
    \ (1 + ceil(log2(n)));\n    long product = 1;\n    long temp;\n    for (long i\
    \ = 0; i < bitLength; i++) {\n        temp = (long) pow(2, i);\n        if (temp\
    \ & n) {\n            product = (product * 2) % p;\n        }\n    }\n    return\
    \ product;", "  assert(n >= 0);\n  assert(p > 0);\n  if (n == 0) {\n    return\
    \ 1;\n  }\n  if (n % 2 == 0) {\n    return modp(n/2, p) * modp(n/2, p) % p;\n\
    \  }\n  return modp(n-1, p) * modp(n+1, p) % p;", "\tassert(p > 0);\n\tif (n <\
    \ 0)\n\t\tn = (n % p) + p;\n\tlong res = 1;\n\tlong a = 2;\n\twhile (n > 0) {\n\
    \t\tif (n % 2 == 1)\n\t\t\tres = (res * a) % p;\n\t\ta = (a * a) % p;\n\t\tn =\
    \ n / 2;\n\t}\n\treturn res;", "  // assert(n >= 0);\n  if (n == 0) return 1;\n\
    \  // assert(p > 0);\n  // assert(p <= p_MAX);\n  long x = modp(n/2, p);\n  x\
    \ = (x*x) % p;\n  if (n % 2 == 1) x = (x*2) % p;\n  return x;", "\tlong p2 = 1;\n\
    \twhile (n > 0) {\n\t\tif (n % 2 != 0)\n\t\t\tp2 = (p2 * p) % p;\n\t\tp = (p *\
    \ p) % p;\n\t\tn = n / 2;\n\t}\n\treturn p2;", "    long res = 1;\n    while (n\
    \ > 0) {\n        if (n % 2 == 1) {\n            res = (res * 2) % p;\n      \
    \  }\n        n = n / 2;\n        if (n > 0) {\n            res = (res * res)\
    \ % p;\n        }\n    }\n    return res;", "    // Implement your code here.\n\
    \    if(n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        long\
    \ n1 = modp(n/2, p);\n        n1 = (n1*n1)%p;\n        if(n%2 == 0)\n        {\n\
    \            return n1;\n        }\n        else\n        {\n            return\
    \ (n1*2)%p;\n        }\n    }", "\tlong x = 1;\n\tlong y = n;\n\tlong ans = 1;\n\
    \twhile (x <= p) {\n\t\tif (x & p) {\n\t\t\tans = (ans * y) % p;\n\t\t}\n\t\t\
    x = x << 1;\n\t\ty = (y * y) % p;\n\t}\n\treturn ans;", "    long pow = n;\n \
    \   long result = 1;\n    while (pow) {\n        if (pow & 1)\n            result\
    \ = (result * n) % p;\n        n = (n * n) % p;\n        pow = pow >> 1;\n   \
    \ }\n    return result;", "  long res = 1;\n  while (n > 0) {\n    if (n & 1)\
    \ {\n      res = res * 2 % p;\n    }\n    n >>= 1;\n    if (n > 0) {\n      res\
    \ = res * res % p;\n    }\n  }\n  return res;", "\tassert(p>=2);\n\tif (n < 0)\
    \ {\n\t\tn = p - ((-n)%p);\n\t}\n\treturn n % p;", "\t// Implement this function\
    \ yourself\n\tif (n == 0) return 1;\n\tlong long ans = modp(n / 2, p);\n\tans\
    \ = (ans * ans) % p;\n\tif (n % 2 == 1) {\n\t\tans = (ans * 2) % p;\n\t}\n\treturn\
    \ ans;", "  long result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n     \
    \ result = (result * n) % p;\n    }\n    n = n / 2;\n    n = (n * n) % p;\n  }\n\
    \  return result;", "    if (n < 0) {\n        return (modp(n+p, p));\n    }\n\
    \    if (n == 0) {\n        return (1);\n    }\n    long res = 1;\n    long b\
    \ = 3;\n    while (n) {\n        if (n & 1) {\n            res = (res * b) % p;\n\
    \        }\n        b = (b * b) % p;\n        n >>= 1;\n    }\n    return (res);",
  "  if (n == 0) {\n    return 1;\n  }\n  assert(n >= 0);\n  assert(p >= 0);\n  int\
    \ x = modp(n/2, p);\n  long res = (x*x) % p;\n  if (n % 2 == 1) {\n    res = (res*3)\
    \ % p;\n  }\n  return res;", "    // Implement this function yourself!\n    int\
    \ num = 1;\n    while(n>0){\n        if(n&1){\n            num = (num * 2) % p;\n\
    \        }\n        n = n>>1;\n        num = (num * 2) % p;\n    }\n    return\
    \ num;", "  long r = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      r = (r\
    \ * 2) % p;\n    }\n    n = n / 2;\n    // In Python, this is equivalent to:\n\
    \    // r, n = (r * 2) % p, n / 2\n  }\n  return r % p;", "\t//assert((n >= 0)\
    \ && (p > 0));\n\tif ((n==0) || (p==1))\n\t\treturn 0;\n\tlong ans = 1;\n\twhile\
    \ (n) {\n\t\tif (n & 1)\n\t\t\tans = (ans * 2) % p;\n\t\tn >>= 1;\n\t}\n\treturn\
    \ ans;", "    assert(n >= 0);\n    if (n == 0) return 1;\n    long z = modp(n\
    \ / 2, p);\n    if (n % 2 == 0) return (z * z) % p;\n    else return (z * z *\
    \ 2) % p;", "  long res = 1;\n  n %= p;\n  while (n) {\n    if (n & 1) {\n   \
    \   res = (res * n) % p;\n    }\n    n >>= 1;\n    n %= p;\n    n *= n;\n    n\
    \ %= p;\n  }\n  return res;", "    if (n == 0) return 1;\n    if (n % 2 == 0)\
    \ {\n        long temp = modp(n/2, p);\n        return temp * temp % p;\n    }\
    \ else {\n        return modp(n-1, p) * n % p;\n    }", "\tif (n == 0) {\n\t\t\
    return 1;\n\t}\n\tif (n == 1) {\n\t\treturn n % p;\n\t}\n\tlong d = modp(n/2,\
    \ p);\n\tif (n % 2 == 0) {\n\t\treturn (d * d) % p;\n\t}\n\treturn (((d * d) %\
    \ p) * n) % p;", "    long r=1;\n    for (; n>0; n>>=1) {\n        if (n&1) r\
    \ = (r*2)%p;\n    }\n    return r;", "\tif (n == 0) {\n\t\treturn 1;\n\t}\n\t\
    if (n & 1) {\n\t\treturn (n + p) * modp(n - 1, p) % p;\n\t}\n\tlong res = modp(n\
    \ >> 1, p);\n\treturn res * res % p;", "    if (n == 0) return 1;\n    if (n ==\
    \ 1) return n;\n    long n_2 = n % 2 == 0 ? n / 2 : (n - 1) / 2;\n    long b =\
    \ modp(n_2, p);\n    long c = modp(n_2, p);\n    b = (b * c) % p;\n    if (n %\
    \ 2 == 0) {\n        return b;\n    } else {\n        return (b * n) % p;\n  \
    \  }", "    if (n < 0) {\n        n = n + p;\n    }\n    long res = 1;\n    long\
    \ exp = n;\n    long mult = 2;\n    while (exp != 0) {\n        if (exp % 2 ==\
    \ 1) {\n            res = (res * mult) % p;\n        }\n        mult = (mult *\
    \ mult) % p;\n        exp = exp / 2;\n    }\n    return res;", "  assert(p >=\
    \ 2);\n  if (n >= p) {\n    n %= p;\n  }\n  if (n < 0) {\n    n += p;\n  }\n \
    \ long res = 1;\n  long x = n;\n  while (p > 0) {\n    if (p & 1) {\n      res\
    \ = (res * x) % p;\n    }\n    x = (x * x) % p;\n    p >>= 1;\n  }\n  return res;",
  "  n = n % p;\n  long res = 1;\n  for (int i = 0; i < n; i++) {\n    res = (res\
    \ * 2) % p;\n  }\n  return res;", "\tassert(p >= 2);\n\tif(n < 0) {\n\t\tn +=\
    \ p;\n\t}\n\tif(n < 2) {\n\t\treturn n;\n\t}\n\tlong res = 1;\n\twhile(n > 0)\
    \ {\n\t\tif(n & 1) {\n\t\t\tres = (res * n) % p;\n\t\t}\n\t\tn = n >> 1;\n\t\t\
    n = (n * n) % p;\n\t}\n\treturn res;", "  long r = 1;\n  while (n != 0) {\n  \
    \  if (n % 2 == 1) {\n      r = (r * 2) % p;\n    }\n    n /= 2;\n    p = (p *\
    \ p) % p;\n  }\n  return r;", "    assert(p >= 1);\n    if (n % p == 0) return\
    \ 0;\n    // We need to make sure that `b` is the least significant bit of `n`.\n\
    \    // The following masking procedure just achieves this.\n    // If `n` is\
    \ negative, we also need to make sure that `b` is a 1, so\n    // that `b` is\
    \ the least significant bit of the positive form of `n`.\n    long b = ((1L <<\
    \ (31 - __builtin_clz(n))) >> (63 - __builtin_clz(n)));\n    long k = n & -n;\n\
    \    assert(k == b);\n    // At this point `b` is the least significant bit of\
    \ `n`.\n    if (k == 1) return n;\n    long r = 2;\n    long y = (((2 * (n % p))\
    \ % p) * (k % p)) % p;\n    for (long x = ((n - y) / k) % p; x != 0; x = ((n -\
    \ y) / k) % p) {\n        if (x == 1) return r;\n        r = (r * 2) % p;\n  \
    \      y = (((2 * (y % p)) % p) * (k % p)) % p;\n    }\n    return 0;", "  if\
    \ (n == 0) return 1;\n  long sq = modp(n / 2, p);\n  sq = (sq * sq) % p;\n  if\
    \ (n % 2) sq = (sq * 2) % p;\n  return sq;", "    if (n==0) return 1;\n    long\
    \ ans = modp(n>>1, p);\n    ans = (ans*ans)%p;\n    if (n&1) ans = (ans*2)%p;\n\
    \    return ans;", "    assert(p>0);\n    if (n==0) return 1;\n    if (n%2==0)\
    \ {\n        long ret = modp(n/2, p);\n        return (ret*ret)%p;\n    }\n  \
    \  else return (n*modp(n-1, p))%p;", "    assert(p != 0);\n    if (n == 0) return\
    \ 1;\n    long tmp = modp(n >> 1, p);\n    tmp = (tmp * tmp) % p;\n    if (n &\
    \ 1) tmp = (tmp * 2) % p;\n    return tmp;", "\treturn pow(2, n) % p;", "    long\
    \ res = 1;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            res =\
    \ (res * 2) % p;\n        }\n        n /= 2;\n        if (n > 0) {\n         \
    \   res = (res * res) % p;\n        }\n    }\n    return res;", "    if (n ==\
    \ 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long temp = modp(n\
    \ / 2, p);\n        return (temp * temp) % p;\n    }\n    long temp = modp(n -\
    \ 1, p);\n    return (temp * n) % p;", "    long res = 1;\n    while (n > 0) {\n\
    \        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n\
    \    return res;", "    int res = 1;\n    while (n > 0) {\n        if (n % 2 ==\
    \ 1)\n            res = (res * n) % p;\n        n = n / 2;\n        n = (n * n)\
    \ % p;\n    }\n    return res % p;", "    if (n < 0) {\n        n = p - 1 + n\
    \ % p;\n    }\n    return (1L << n) % p;", "  assert(p > 0);\n  long res = 1;\n\
    \  long pow = n % p;\n  for (long i = 0; i < n; i++) {\n    res = (res * pow)\
    \ % p;\n  }\n  return res;", "  long result = 1;\n  while (n > 0) {\n    if (n\
    \ & 1) {\n      result = (result * n) % p;\n    }\n    n = n >> 1;\n    n = (n\
    \ * n) % p;\n  }\n  return result;", "    assert(p >= 2);\n    if (n < 0) {\n\
    \        n += ((-n / p) + 1) * p;\n    }\n    int res = 1;\n    int mult = n %\
    \ p;\n    while (n > 0) {\n        if (n & 1) {\n            res = (res * mult)\
    \ % p;\n        }\n        mult = (mult * mult) % p;\n        n >>= 1;\n    }\n\
    \    return res;", "    assert(p > 0);\n    assert(n >= 0);\n    if (n == 0) return\
    \ 1;\n    long result = modp(n/2, p);\n    result = (result * result) % p;\n \
    \   if (n % 2 == 1) {\n        result = (result * 2) % p;\n    }\n    return result;",
  "\tlong ans = 1;\n\tif(n >= p) n %= p;\n\tfor(long i = 1; i <= n; i++) {\n\t\tans\
    \ *= 2;\n\t\tif(ans >= p) ans %= p;\n\t}\n\treturn ans;", "    if (n==0) return\
    \ 1;\n    long res = modp(n/2, p);\n    if (n%2==0)\n        return (res*res)%p;\n\
    \    else\n        return (2*res*res)%p;", "  assert(p > 0);\n  if (n <= 0) return\
    \ 1;\n  long s = 1;\n  for (long i = 0; i < n; i++) {\n    s = s * 2 % p;\n  }\n\
    \  return s;", "    n = n % p;\n    // Initialize result\n    long res = 1;\n\
    \    // Update x if it is more than or\n    // equal to p\n    while (n > 1) {\n\
    \        // If n is odd, multiply x with result\n        if (n & 1)\n        \
    \    res = (res * n) % p;\n        // n must be even now\n        n = n >> 1;\
    \ // n = n/2\n        n = (n * n) % p;\n    }\n    return res;", "    assert(p\
    \ >= 1);\n    assert(n >= 0);\n    long r = 1;\n    for (int i = 0; i < n; i++)\
    \ {\n        r = r * 2 % p;\n    }\n    return r;", "  assert(p >= 1);\n  assert(n\
    \ >= 0);\n  if (n < p) {\n    return n;\n  }\n  return 2 * modp(n / 2, p) % p;",
  "  assert(n >= 0);\n  assert(p > 0);\n  // TODO: write your code here\n  long result\
    \ = 1;\n  while (n > 0) {\n    if (n % 2 != 0) {\n      result = (result * 2)\
    \ % p;\n    }\n    n = n / 2;\n    if (n > 0) {\n      result = (result * result)\
    \ % p;\n    }\n  }\n  return result;", "    n = n % p;\n    long c = 1;\n    for\
    \ (int i = 0; i < n; i++) {\n        c = (c*2) % p;\n    }\n    return c;", " \
    \ assert(p >= 2);\n  if (n < 0)\n    n = p - 1 - ((-n) % (p - 1));\n  int result\
    \ = 1;\n  long x = n;\n  while (p > 0) {\n    if (p & 1)\n      result = (result\
    \ * x) % n;\n    x = (x * x) % n;\n    p >>= 1;\n  }\n  return result;", "   \
    \ if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return n;\n\
    \    }\n    long res = modp(n / 2, p);\n    if (n % 2 == 0) {\n        return\
    \ (res * res) % p;\n    } else {\n        return (res * res * 2) % p;\n    }",
  "    long ans = 1;\n    long sq = n;\n    while (p > 0) {\n        if (p % 2 ==\
    \ 1) {\n            ans = (ans * sq) % 101;\n        }\n        sq = (sq * sq)\
    \ % 101;\n        p /= 2;\n    }\n    return ans;", "  if (n == 0) {\n    return\
    \ 1;\n  }\n  if (n == 1) {\n    return n;\n  }\n  if (n % 2 == 0) {\n    return\
    \ (modp(n / 2, p) * modp(n / 2, p)) % p;\n  }\n  else {\n    return (modp(n /\
    \ 2, p) * modp(n / 2, p) * n) % p;\n  }", "    long r = 1;\n    while (n > 0)\
    \ {\n        // Modulo operation is done before to prevent overflow.\n       \
    \ if (n % 2 == 1)\n            r = (r * 2) % p;\n        n /= 2;\n        // We\
    \ avoid overflow since the maximum value of (r * 2)\n        // will always be\
    \ less than or equal to p.\n        r = (r * 2) % p;\n    }\n    return r;", "\t\
    assert(p > 0);\n\tassert(n >= 0);\n\tlong res = 1;\n\tlong b = n;\n\twhile (p\
    \ > 0) {\n\t\tif (p & 1)\n\t\t\tres = (res * b) % p;\n\t\tb = (b * b) % p;\n\t\
    \tp >>= 1;\n\t}\n\treturn res;", "\tlong factor = 1;\n\tlong product = n;\n\t\
    long result = 1;\n\twhile (factor <= n) {\n\t\tif (factor & n) {\n\t\t\tresult\
    \ = (result * product) % p;\n\t\t}\n\t\tfactor <<= 1;\n\t\tproduct = (product\
    \ * product) % p;\n\t}\n\treturn result;", "    // assert(n >= 0);\n    // assert(p\
    \ > 0);\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long x = modp(n/2,\
    \ p);\n        return (x*x) % p;\n    } else {\n        return ((n % p) * modp(n-1,\
    \ p)) % p;\n    }", "    assert(p >= 1);\n    if (n < 0) {\n        n = p - (-n\
    \ % p);\n    }\n    return pow(2, n) % p;", "  assert(n >= 0);\n  assert(p > 0);\n\
    \  long result = 1;\n  for (long i = 1; i <= n; i += 1) {\n    result = (result\
    \ * 2) % p;\n  }\n  return result;", "    long ans = 1;\n    for (int i = 0; i\
    \ < n; i++) {\n        ans = (ans * 2) % p;\n    }\n    return ans;", "  assert(p\
    \ >= 1);\n  assert(n >= 0);\n  if (n == 0) {\n    return 1;\n  }\n  long sign\
    \ = 1;\n  if (n < 0) {\n    sign = p - 1;\n    n = -n;\n  }\n  return modp(n,\
    \ p, sign);", "    if(p==1)\n        return 0;\n    if(n==0)\n        return 1;\n\
    \    else if(n%2==0)\n        return modp((n/2)*(n/2), p);\n    else\n       \
    \ return (modp((n/2)*(n/2), p)*2)%p;", "    long res = 1;\n    while (n) {\n \
    \       if (n % 2) res = (res * 2) % p;\n        n /= 2;\n    }\n    return res;",
  "  long r=1;\n  long mod=p;\n  while (n>0) {\n    if (n&1) {\n      r=(r*r)%mod;\n\
    \    }\n    n=n>>1;\n    r=(r*r)%mod;\n  }\n  return r;", "  assert(n >= 0);\n\
    \  assert(p > 0);\n  if (n == 0) {\n    return 1;\n  }\n  long res = 1;\n  long\
    \ t = n;\n  while (t > 0) {\n    if (t % 2 == 1) {\n      res = res * n % p;\n\
    \    }\n    n = n * n % p;\n    t /= 2;\n  }\n  return res;", "    if (n == 0)\
    \ {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        return modp(n/2,\
    \ p) * modp(n/2, p) % p;\n    }\n    return modp(n/2, p) * modp(n/2, p) * 2 %\
    \ p;", "  long res = 1;\n  n %= p;\n  while (n) {\n    if (n & 1) res = (res *\
    \ 2) % p;\n    n >>= 1;\n    if (n) res = (res * 2) % p;\n  }\n  return res;",
  "\t//assert(p > 0);\n\tlong res = 1;\n\tlong i = n;\n\tlong j = p;\n\twhile (j !=\
    \ 0) {\n\t\tif (j & 1)\n\t\t\tres = (res * i) % p;\n\t\ti = (i * i) % p;\n\t\t\
    j >>= 1;\n\t}\n\treturn res;", "\tassert(p>=2);\n\tif(n<0) n+=p;\n\tif(n>0 &&\
    \ n<p) return n;\n\tif(n==0) return 1;\n\tlong p0=p,t0=0,t1=1;\n\tlong q,r,t;\n\
    \twhile(n>1) {\n\t\tq=n/p;\n\t\tr=n%p;\n\t\tt=t0-q*t1;\n\t\tif(t<0) t+=p0;\n\t\
    \tn=p;\n\t\tp=r;\n\t\tt0=t1;\n\t\tt1=t;\n\t}\n\treturn t1;"]
stop_tokens:
- "\n}"
