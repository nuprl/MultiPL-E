name: HumanEval_144_simplify
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement\
  \ a function that will simplify the expression\n// x * n. The function returns true\
  \ if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are\
  \ string representation of a fraction, and have the following format,\n// <numerator>/<denominator>\
  \ where both numerator and denominator are positive whole numbers.\n// You can assume\
  \ that x, and n are valid fractions, and do not have zero as denominator.\n// >>>\
  \ simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"\
  ))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string\
  \ x, std::string n) {\n"
tests: "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"\
  1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n\
  \    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"\
  7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\"))\
  \ == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"\
  11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n\
  \    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"\
  2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n\
  \    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"\
  1/5\"), (\"1/5\")) == (false));\n}\n"
completions: ["    long x_num = std::stol(x.substr(0, x.find('/')));\n    long x_den\
    \ = std::stol(x.substr(x.find('/') + 1));\n    long n_num = std::stol(n.substr(0,\
    \ n.find('/')));\n    long n_den = std::stol(n.substr(n.find('/') + 1));\n   \
    \ if (x_num * n_den * n_num * x_den == 0) return false;\n    long num = x_num\
    \ * n_num;\n    long den = x_den * n_den;\n    for (long i = 2; i <= std::min(num,\
    \ den); i++) {\n        while (num % i == 0 && den % i == 0) {\n            num\
    \ /= i;\n            den /= i;\n        }\n    }\n    return num % den == 0;",
  "    int x_num = stoi(x.substr(0, x.find('/')));\n    int x_den = stoi(x.substr(x.find('/')\
    \ + 1));\n    int n_num = stoi(n.substr(0, n.find('/')));\n    int n_den = stoi(n.substr(n.find('/')\
    \ + 1));\n    return (n_num * x_den) % n_den == 0;", "    std::string st = x +\
    \ n;\n    std::string sep = \"/\";\n    int count = 0;\n    std::string temp;\n\
    \    std::string token;\n    std::stringstream ss(st);\n    while (getline(ss,\
    \ token, '/')) {\n        if (count == 0) {\n            temp += token;\n    \
    \        count++;\n        } else {\n            temp += sep;\n            temp\
    \ += token;\n        }\n    }\n    std::stringstream ss1(temp);\n    int a, b;\n\
    \    ss1 >> a;\n    ss1 >> sep;\n    ss1 >> b;\n    if (a % b == 0) {\n      \
    \  return true;\n    } else {\n        return false;\n    }", "  if (x.empty()\
    \ || n.empty()) return false;\n  if (x.size() == 1 && n.size() == 1) return x\
    \ == n;\n  size_t xPos = x.find('/');\n  size_t nPos = n.find('/');\n  int xnum\
    \ = std::stoi(x.substr(0, xPos));\n  int xden = std::stoi(x.substr(xPos + 1));\n\
    \  int nnum = std::stoi(n.substr(0, nPos));\n  int nden = std::stoi(n.substr(nPos\
    \ + 1));\n  int denom = xden * nden;\n  int num = xnum * nden;\n  num *= nnum;\n\
    \  num *= xden;\n  return denom == num;", "    bool whole = false;\n    int numx\
    \ = std::stoi(x.substr(0, x.find('/')));\n    int denomx = std::stoi(x.substr(x.find('/')\
    \ + 1));\n    int numn = std::stoi(n.substr(0, n.find('/')));\n    int denomn\
    \ = std::stoi(n.substr(n.find('/') + 1));\n    //product is whole if denomn divides\
    \ denomx\n    if(denomx % denomn == 0)\n        whole = true;\n    //product is\
    \ whole if numn divides numx\n    if(numx % numn == 0)\n        whole = true;\n\
    \    return whole;", "  //   if(n.length() == 1) return true;\n  //   if(x.length()\
    \ == 1) return false;\n  auto getNums = [](std::string x) {\n    int i = 0;\n\
    \    int num = 0;\n    for (auto it = x.begin(); it != x.end(); it++) {\n    \
    \  if (*it == '/') {\n        i++;\n        continue;\n      }\n      num = num\
    \ * 10 + (*it - '0');\n    }\n    return num;\n  };\n  auto num1 = getNums(x);\n\
    \  auto num2 = getNums(n);\n  return (num1 * num2) % x.length() == 0;", "    //Split\
    \ the string and keep in two variables x_num, x_den\n    std::string x_num = x.substr(0,\
    \ x.find(\"/\"));\n    std::string x_den = x.substr(x.find(\"/\")+1);\n    //Split\
    \ the string and keep in two variables n_num, n_den\n    std::string n_num = n.substr(0,\
    \ n.find(\"/\"));\n    std::string n_den = n.substr(n.find(\"/\")+1);\n    //find\
    \ the gcd using the formula num1*num2/gcd(num1,num2)\n    int gcd = std::__gcd(std::stoi(x_num),\
    \ std::stoi(x_den));\n    x_num = std::to_string(std::stoi(x_num)/gcd);\n    x_den\
    \ = std::to_string(std::stoi(x_den)/gcd);\n    //find the gcd using the formula\
    \ num1*num2/gcd(num1,num2)\n    gcd = std::__gcd(std::stoi(n_num), std::stoi(n_den));\n\
    \    n_num = std::to_string(std::stoi(n_num)/gcd);\n    n_den = std::to_string(std::stoi(n_den)/gcd);\n\
    \    //Multiply the two strings and store the result in a variable res\n    std::string\
    \ res = std::to_string(std::stoi(x_num)*std::stoi(n_num));\n    //If the modulo\
    \ of the res and den of x is zero, then it is a whole number,\n    //return true\n\
    \    if(std::stoi(res)%std::stoi(x_den) == 0)\n    {\n        return true;\n \
    \   }\n    //Else return false\n    else\n    {\n        return false;\n    }",
  "    std::string::size_type sz;   // alias of size_t\n    double numer = std::stod\
    \ (x,&sz);\n    double denom = std::stod (x.substr(sz));\n    double mul1 = numer\
    \ * denom;\n    std::cout << mul1 << \"\\n\";\n    double mul2 = std::stod (n,&sz);\n\
    \    double mul3 = std::stod (n.substr(sz));\n    double mul = mul2 * mul3;\n\
    \    std::cout << mul << \"\\n\";\n    if (mul1 == mul)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }", "    // Your code\
    \ here\n    int num = 1;\n    int den = 1;\n    int i = x.find(\"/\");\n    int\
    \ j = n.find(\"/\");\n    int n1 = stoi(x.substr(0,i));\n    int d1 = stoi(x.substr(i+1));\n\
    \    int n2 = stoi(n.substr(0,j));\n    int d2 = stoi(n.substr(j+1));\n    for(int\
    \ i = 2; i <= std::min(n1,d1); i++){\n        if(n1%i == 0 && d1%i == 0){\n  \
    \          num *= i;\n            n1 /= i;\n            d1 /= i;\n           \
    \ i--;\n        }\n    }\n    for(int i = 2; i <= std::min(n2,d2); i++){\n   \
    \     if(n2%i == 0 && d2%i == 0){\n            den *= i;\n            n2 /= i;\n\
    \            d2 /= i;\n            i--;\n        }\n    }\n    double ans = (n1*d2)/(d1*n2);\n\
    \    return (num*den)==ans;", "  bool isSimplified = false;\n  std::vector<std::string>\
    \ xNumeratorAndDenominator;\n  std::vector<std::string> nNumeratorAndDenominator;\n\
    \  xNumeratorAndDenominator = split(x, '/');\n  nNumeratorAndDenominator = split(n,\
    \ '/');\n  int xNumerator = std::stoi(xNumeratorAndDenominator[0]);\n  int xDenominator\
    \ = std::stoi(xNumeratorAndDenominator[1]);\n  int nNumerator = std::stoi(nNumeratorAndDenominator[0]);\n\
    \  int nDenominator = std::stoi(nNumeratorAndDenominator[1]);\n  int simplifiedProductNumerator\
    \ = xNumerator * nNumerator;\n  int simplifiedProductDenominator = xDenominator\
    \ * nDenominator;\n  int simplifiedGCD = gcd(simplifiedProductNumerator, simplifiedProductDenominator);\n\
    \  int simplifiedNumerator = simplifiedProductNumerator / simplifiedGCD;\n  int\
    \ simplifiedDenominator = simplifiedProductDenominator / simplifiedGCD;\n  if(simplifiedDenominator\
    \ == 1) {\n    isSimplified = true;\n  }\n  return isSimplified;", "\tint numerator\
    \ = std::stoi(x.substr(0, x.find(\"/\")));\n\tint denominator = std::stoi(x.substr(x.find(\"\
    /\") + 1));\n\tint numerator_n = std::stoi(n.substr(0, n.find(\"/\")));\n\tint\
    \ denominator_n = std::stoi(n.substr(n.find(\"/\") + 1));\n\tif ((numerator *\
    \ denominator_n) % (denominator * numerator_n) == 0) {\n\t\treturn true;\n\t}\n\
    \treturn false;", "  size_t pos = x.find('/');\n  int x_num = std::stoi(x.substr(0,\
    \ pos));\n  int x_den = std::stoi(x.substr(pos + 1));\n  pos = n.find('/');\n\
    \  int n_num = std::stoi(n.substr(0, pos));\n  int n_den = std::stoi(n.substr(pos\
    \ + 1));\n  int result_num = x_num * n_num;\n  int result_den = x_den * n_den;\n\
    \  if (result_num % result_den == 0) {\n    return true;\n  }\n  return false;",
  "    std::istringstream iss_x(x);\n    std::istringstream iss_n(n);\n    std::vector<std::string>\
    \ tokens_x((std::istream_iterator<std::string>(iss_x)),\n                    \
    \             std::istream_iterator<std::string>());\n    std::vector<std::string>\
    \ tokens_n((std::istream_iterator<std::string>(iss_n)),\n                    \
    \             std::istream_iterator<std::string>());\n    // std::cout << tokens_x[0]\
    \ << tokens_x[1] << std::endl;\n    // std::cout << tokens_n[0] << tokens_n[1]\
    \ << std::endl;\n    int num_x = std::stoi(tokens_x[0]);\n    int den_x = std::stoi(tokens_x[1]);\n\
    \    int num_n = std::stoi(tokens_n[0]);\n    int den_n = std::stoi(tokens_n[1]);\n\
    \    // std::cout << num_x << den_x << std::endl;\n    // std::cout << num_n <<\
    \ den_n << std::endl;\n    int numerator = num_x * num_n;\n    int denominator\
    \ = den_x * den_n;\n    // std::cout << numerator << denominator << std::endl;\n\
    \    if (numerator % denominator == 0) {\n        return true;\n    }\n    return\
    \ false;", "    // split x and n into numerator and denominator\n    std::vector<std::string>\
    \ x_split;\n    std::vector<std::string> n_split;\n    std::stringstream ss(x);\n\
    \    std::string item;\n    while (std::getline(ss, item, '/')) {\n        x_split.push_back(item);\n\
    \    }\n    std::stringstream ss2(n);\n    std::string item2;\n    while (std::getline(ss2,\
    \ item2, '/')) {\n        n_split.push_back(item2);\n    }\n    // numerator is\
    \ x*n and denominator is x*n\n    int num = std::stoi(x_split[0]) * std::stoi(n_split[0]);\n\
    \    int den = std::stoi(x_split[1]) * std::stoi(n_split[1]);\n    // check for\
    \ whole numbers\n    if(num % den == 0) {\n        return true;\n    }\n    return\
    \ false;", "    int xn = stoi(x.substr(0, x.find(\"/\")));\n    int xd = stoi(x.substr(x.find(\"\
    /\") + 1));\n    int nn = stoi(n.substr(0, n.find(\"/\")));\n    int nd = stoi(n.substr(n.find(\"\
    /\") + 1));\n    float result = (float)xn * (float)nn / (float)xd / (float)nd;\n\
    \    return result == (int)result;", "    int num1,num2,den1,den2;\n    sscanf(x.c_str(),\"\
    %d/%d\",&num1,&den1);\n    sscanf(n.c_str(),\"%d/%d\",&num2,&den2);\n    std::cout<<num1<<\"\
    \ \"<<den1<<\" \"<<num2<<\" \"<<den2<<std::endl;\n    int max_common_factor=std::__gcd(num1,den1);\n\
    \    num1/=max_common_factor;\n    den1/=max_common_factor;\n    num2/=max_common_factor;\n\
    \    den2/=max_common_factor;\n    int temp_num=num1*num2;\n    int temp_den=den1*den2;\n\
    \    int max_common_factor2=std::__gcd(temp_num,temp_den);\n    temp_num/=max_common_factor2;\n\
    \    temp_den/=max_common_factor2;\n    if(temp_den==1)\n        return true;\n\
    \    return false;", "  assert(x.size() > 2 && n.size() > 2);\n  std::string x_denom\
    \ = x.substr(x.find('/') + 1);\n  std::string x_numer = x.substr(0, x.find('/'));\n\
    \  std::string n_denom = n.substr(n.find('/') + 1);\n  std::string n_numer = n.substr(0,\
    \ n.find('/'));\n  int x_d = std::stoi(x_denom);\n  int x_n = std::stoi(x_numer);\n\
    \  int n_d = std::stoi(n_denom);\n  int n_n = std::stoi(n_numer);\n  // if (x_d\
    \ == n_d) return true;\n  int x_p = x_n * n_d;\n  int n_p = n_n * x_d;\n  // std::cout\
    \ << x_p << std::endl;\n  // std::cout << n_p << std::endl;\n  if (x_p % n_p ==\
    \ 0) return true;\n  return false;", "  // write your code here\n  double n_x\
    \ = atof(x.c_str());\n  double n_n = atof(n.c_str());\n  return n_x*n_n == int(n_x*n_n);",
  "    int a,b,c,d;\n    std::stringstream str1(x);\n    std::stringstream str2(n);\n\
    \    char c1,c2;\n    str1>>a>>c1>>b;\n    str2>>c>>c2>>d;\n    std::cout<<\"\
    a: \"<<a<<\" b: \"<<b<<\" c: \"<<c<<\" d: \"<<d<<std::endl;\n    std::cout<<(a*d)<<\"\
    \ \"<<(b*c)<<std::endl;\n    return (a*d)%(b*c)==0;", "    int newnumerator,newdenominator;\n\
    \    int numerator1=0,numerator2=0,denominator1=0,denominator2=0;\n    bool flag=true;\n\
    \    bool flag2=true;\n    bool flag3=true;\n    bool flag4=true;\n    bool flag5=true;\n\
    \    bool flag6=true;\n    bool flag7=true;\n    bool flag8=true;\n    bool flag9=true;\n\
    \    bool flag10=true;\n    bool flag11=true;\n    bool flag12=true;\n    bool\
    \ flag13=true;\n    bool flag14=true;\n    bool flag15=true;\n    bool flag16=true;\n\
    \    bool flag17=true;\n    bool flag18=true;\n    bool flag19=true;\n    bool\
    \ flag20=true;\n    bool flag21=true;\n    bool flag22=true;\n    bool flag23=true;\n\
    \    bool flag24=true;\n    bool flag25=true;\n    bool flag26=true;\n    bool\
    \ flag27=true;\n    bool flag28=true;\n    bool flag29=true;\n    bool flag30=true;\n\
    \    bool flag31=true;\n    bool flag32=true;\n    bool flag33=true;\n    bool\
    \ flag34=true;\n    bool flag35=true;\n    bool flag36=true;\n    bool flag37=true;\n\
    \    bool flag38=true;\n    bool flag39=true;\n    bool flag40=true;\n    bool\
    \ flag41=true;\n    bool flag42=true;\n    bool flag43=true;\n    bool flag44=true;\n\
    \    bool flag45=true;\n    bool flag46=true;\n    bool flag47=true;\n    bool\
    \ flag48=true;\n    bool flag49=true;\n    bool flag50=true;\n    bool flag51=true;\n\
    \    bool flag52=true;\n    bool flag53=true;\n    bool flag54=true;\n    bool\
    \ flag55=true;\n    bool flag56=true;\n    bool flag57=true;\n    bool flag58=true;\n\
    \    bool flag59=", "  if(n == \"1/1\")\n  {\n    return false;\n  }\n  std::string\
    \ num = \"\";\n  std::string denom = \"\";\n  int i = 0;\n  while(x[i] != '/')\n\
    \  {\n    num += x[i];\n    i++;\n  }\n  i++;\n  while(i < x.length())\n  {\n\
    \    denom += x[i];\n    i++;\n  }\n  int numerator = std::stoi(num);\n  int denominator\
    \ = std::stoi(denom);\n  std::string num1 = \"\";\n  std::string denom1 = \"\"\
    ;\n  i = 0;\n  while(n[i] != '/')\n  {\n    num1 += n[i];\n    i++;\n  }\n  i++;\n\
    \  while(i < n.length())\n  {\n    denom1 += n[i];\n    i++;\n  }\n  int numerator1\
    \ = std::stoi(num1);\n  int denominator1 = std::stoi(denom1);\n  int num2 = numerator\
    \ * numerator1;\n  int denom2 = denominator * denominator1;\n  std::string num3\
    \ = std::to_string(num2);\n  std::string denom3 = std::to_string(denom2);\n  if(denom3.length()\
    \ > num3.length())\n  {\n    return false;\n  }\n  int i1 = 0;\n  int j = 0;\n\
    \  bool check = true;\n  for(int i = 0; i < num3.length(); i++)\n  {\n    if(i\
    \ < denom3.length())\n    {\n      if(num3[i] != denom3[i])\n      {\n       \
    \ check = false;\n        break;\n      }\n    }\n    else\n    {\n      if(num3[i]\
    \ != '0')\n      {\n        check = false;\n        break;\n      }\n    }\n \
    \ }\n  return check;", "  // Your code here\n  return false;", "    std::stringstream\
    \ ss(x);\n    std::string item;\n    std::vector<std::string> tokens;\n    while\
    \ (std::getline(ss, item, '/')) {\n        tokens.push_back(item);\n    }\n  \
    \  assert(tokens.size() == 2);\n    int top = std::stoi(tokens[0]);\n    int bottom\
    \ = std::stoi(tokens[1]);\n    // std::cout << top << std::endl;\n    // std::cout\
    \ << bottom << std::endl;\n    std::stringstream ss1(n);\n    std::string item1;\n\
    \    std::vector<std::string> tokens1;\n    while (std::getline(ss1, item1, '/'))\
    \ {\n        tokens1.push_back(item1);\n    }\n    assert(tokens1.size() == 2);\n\
    \    int top1 = std::stoi(tokens1[0]);\n    int bottom1 = std::stoi(tokens1[1]);\n\
    \    // std::cout << top1 << std::endl;\n    // std::cout << bottom1 << std::endl;\n\
    \    int top3 = top * bottom1;\n    int bottom3 = bottom * top1;\n    int largest\
    \ = std::max(top3, bottom3);\n    for (int i = 2; i <= largest; i++) {\n     \
    \   if (top3 % i == 0 && bottom3 % i == 0) {\n            top3 = top3 / i;\n \
    \           bottom3 = bottom3 / i;\n            i = 1;\n        }\n    }\n   \
    \ // std::cout << top3 << std::endl;\n    // std::cout << bottom3 << std::endl;\n\
    \    if (top3 == 1 && bottom3 != 1) {\n        return false;\n    }\n    if (top3\
    \ != 1 && bottom3 == 1) {\n        return true;\n    }\n    return false;", " \
    \ int numerator = std::stoi(x.substr(0, x.find(\"/\")));\n  int denominator =\
    \ std::stoi(x.substr(x.find(\"/\") + 1));\n  int numerator2 = std::stoi(n.substr(0,\
    \ n.find(\"/\")));\n  int denominator2 = std::stoi(n.substr(n.find(\"/\") + 1));\n\
    \  int num = numerator * denominator2;\n  int den = denominator * numerator2;\n\
    \  if (num % den == 0) {\n    return true;\n  }\n  return false;", "  int numeratorX,\
    \ denominatorX, numeratorN, denominatorN;\n  sscanf(x.c_str(), \"%d/%d\", &numeratorX,\
    \ &denominatorX);\n  sscanf(n.c_str(), \"%d/%d\", &numeratorN, &denominatorN);\n\
    \  int numeratorSimplified = numeratorX * numeratorN;\n  int denominatorSimplified\
    \ = denominatorX * denominatorN;\n  std::cout << numeratorSimplified << \"/\"\
    \ << denominatorSimplified << std::endl;\n  return (numeratorSimplified % denominatorSimplified\
    \ == 0);", "    int num1 = stoi(x.substr(0, x.find(\"/\")));\n    int den1 = stoi(x.substr(x.find(\"\
    /\") + 1));\n    int num2 = stoi(n.substr(0, n.find(\"/\")));\n    int den2 =\
    \ stoi(n.substr(n.find(\"/\") + 1));\n    // Multiply the denominators\n    int\
    \ newDen = den1 * den2;\n    // Multiply the numerators\n    int newNum = num1\
    \ * num2;\n    // Make GCD of the numerator and denominator\n    int gcd = __gcd(newNum,\
    \ newDen);\n    newNum /= gcd;\n    newDen /= gcd;\n    if (newNum % newDen ==\
    \ 0) {\n        return true;\n    }\n    return false;", "    if(x.length()<3)\n\
    \        return false;\n    if(n.length()<3)\n        return false;\n    std::string\
    \ numerator;\n    for(int i=0;i<x.length();i++){\n        if(x[i]=='/')\n    \
    \        break;\n        numerator+=x[i];\n    }\n    std::string denominator;\n\
    \    for(int i=x.length()-1;i>=0;i--){\n        if(x[i]=='/')\n            break;\n\
    \        denominator=x[i]+denominator;\n    }\n    //std::cout<<numerator<<\"\
    \ \"<<denominator<<std::endl;\n    int num=std::stoi(numerator);\n    int den=std::stoi(denominator);\n\
    \    num*=den;\n    //std::cout<<num<<std::endl;\n    numerator=\"\";\n    for(int\
    \ i=0;i<n.length();i++){\n        if(n[i]=='/')\n            break;\n        numerator+=n[i];\n\
    \    }\n    denominator=\"\";\n    for(int i=n.length()-1;i>=0;i--){\n       \
    \ if(n[i]=='/')\n            break;\n        denominator=n[i]+denominator;\n \
    \   }\n    int num1=std::stoi(numerator);\n    int den1=std::stoi(denominator);\n\
    \    //std::cout<<num1<<\" \"<<den1<<std::endl;\n    if(num%num1==0 && den%den1==0)\n\
    \        return true;\n    return false;", "   int num1=0,num2=0,denom1=0,denom2=0;\n\
    \    int i=0;\n    while(x[i]!='/')\n    {\n        num1=num1*10+(x[i]-'0');\n\
    \        i++;\n    }\n    i++;\n    while(i<x.length())\n    {\n        denom1=denom1*10+(x[i]-'0');\n\
    \        i++;\n    }\n    i=0;\n    while(n[i]!='/')\n    {\n        num2=num2*10+(n[i]-'0');\n\
    \        i++;\n    }\n    i++;\n    while(i<n.length())\n    {\n        denom2=denom2*10+(n[i]-'0');\n\
    \        i++;\n    }\n    float res = num1*num2;\n    res/=denom1*denom2;\n  \
    \  cout<<res<<endl;\n    int resint = res;\n    if(resint==res)\n    {\n     \
    \   return true;\n    }\n    else\n    {\n        return false;\n    }", '    return
    false;', "    //https://en.wikipedia.org/wiki/Euclidean_algorithm\n\t//https://en.wikipedia.org/wiki/Least_common_multiple\n\
    \    //https://en.wikipedia.org/wiki/Greatest_common_divisor\n\t//greatest common\
    \ divisor\n\t//calculate lcm\n\tint xNum = std::stoi(x.substr(0, x.find(\"/\"\
    )));\n\tint xDen = std::stoi(x.substr(x.find(\"/\") + 1));\n\tint nNum = std::stoi(n.substr(0,\
    \ n.find(\"/\")));\n\tint nDen = std::stoi(n.substr(n.find(\"/\") + 1));\n\tint\
    \ num = xNum * nNum;\n\tint den = xDen * nDen;\n\twhile (xDen != 0) {\n\t\tint\
    \ temp = xDen;\n\t\txDen = xNum % xDen;\n\t\txNum = temp;\n\t}\n\tint gcd = xNum;\n\
    \tint lcm = den / gcd;\n\treturn lcm % num == 0;", "  std::regex num(\"(\\\\d+)\"\
    );\n  std::smatch result;\n  std::regex_search(x, result, num);\n  int num1 =\
    \ std::stoi(result[1]);\n  std::regex_search(x, result, num);\n  int den1 = std::stoi(result[1]);\n\
    \  std::regex_search(n, result, num);\n  int num2 = std::stoi(result[1]);\n  std::regex_search(n,\
    \ result, num);\n  int den2 = std::stoi(result[1]);\n  return (num1 * den2) %\
    \ (num2 * den1) == 0;", "    int dot_pos1 = x.find('/');\n    int dot_pos2 = n.find('/');\n\
    \    int num1 = std::stoi(x.substr(0, dot_pos1));\n    int num2 = std::stoi(n.substr(0,\
    \ dot_pos2));\n    int den1 = std::stoi(x.substr(dot_pos1 + 1));\n    int den2\
    \ = std::stoi(n.substr(dot_pos2 + 1));\n    float answer = (float)num1 * num2\
    \ / (den1 * den2);\n    if (answer == floor(answer)) {\n        return true;\n\
    \    }\n    return false;", "  std::vector<std::string> result;\n  std::string\
    \ temp;\n  std::stringstream check(x);\n  std::stringstream check1(n);\n  while(getline(check,\
    \ temp, '/')) {\n      result.push_back(temp);\n  }\n  std::vector<std::string>\
    \ result1;\n  while(getline(check1, temp, '/')) {\n      result1.push_back(temp);\n\
    \  }\n  std::cout << atoi(result[0].c_str()) * atoi(result1[1].c_str()) << std::endl;\n\
    \  std::cout << atoi(result[1].c_str()) * atoi(result1[0].c_str()) << std::endl;\n\
    \  if(atoi(result[0].c_str()) * atoi(result1[1].c_str()) == atoi(result[1].c_str())\
    \ * atoi(result1[0].c_str()))\n    return true;\n  else\n    return false;", " \
    \   int frac1_num = std::stoi(x.substr(0, x.find('/')));\n    int frac1_denom\
    \ = std::stoi(x.substr(x.find('/') + 1));\n    int frac2_num = std::stoi(n.substr(0,\
    \ n.find('/')));\n    int frac2_denom = std::stoi(n.substr(n.find('/') + 1));\n\
    \    int res_num = frac1_num * frac2_num;\n    int res_denom = frac1_denom * frac2_denom;\n\
    \    if (res_num % res_denom == 0) {\n        return true;\n    }\n    return\
    \ false;", "\tint numerX, numerN, denomX, denomN;\n\tnumerX = std::stoi(x.substr(0,\
    \ x.find('/')));\n\tdenomX = std::stoi(x.substr(x.find('/') + 1));\n\tnumerN =\
    \ std::stoi(n.substr(0, n.find('/')));\n\tdenomN = std::stoi(n.substr(n.find('/')\
    \ + 1));\n\treturn (((numerX * denomN) % (denomX * numerN)) == 0);", "    int\
    \ xn = atoi(x.substr(0, x.find(\"/\")).c_str());\n    int xd = atoi(x.substr(x.find(\"\
    /\") + 1).c_str());\n    int nn = atoi(n.substr(0, n.find(\"/\")).c_str());\n\
    \    int nd = atoi(n.substr(n.find(\"/\") + 1).c_str());\n    float res = (xn\
    \ * nn) / (xd * nd);\n    std::cout << res << std::endl;\n    return (float) (int)\
    \ res == res;", "  // Parse the numerator and denominator\n  std::string num_numerator\
    \ = x.substr(0, x.find(\"/\"));\n  std::string num_denominator = x.substr(x.find(\"\
    /\") + 1);\n  std::string n_numerator = n.substr(0, n.find(\"/\"));\n  std::string\
    \ n_denominator = n.substr(n.find(\"/\") + 1);\n  // Evaluate the product\n  double\
    \ product =\n      (std::stod(num_numerator) * std::stod(n_numerator)) /\n   \
    \   (std::stod(num_denominator) * std::stod(n_denominator));\n  // Check if product\
    \ is an integer\n  return product == std::floor(product);", "\t// the denominator\
    \ of x * n\n\t// find out the lcm of denominators\n\t// lcm = (den1 * den2) /\
    \ gcd(den1, den2)\n\t// lcm = den1 * den2 / gcd(den1, den2)\n\n\tint num = 0,\
    \ den = 0;\n\tint slashIdx;\n\tslashIdx = x.find(\"/\");\n\tstd::string strNum\
    \ = x.substr(0, slashIdx);\n\tstd::string strDen = x.substr(slashIdx + 1);\n\t\
    int num1 = atoi(strNum.c_str());\n\tint den1 = atoi(strDen.c_str());\n\n\tslashIdx\
    \ = n.find(\"/\");\n\tstrNum = n.substr(0, slashIdx);\n\tstrDen = n.substr(slashIdx\
    \ + 1);\n\tint num2 = atoi(strNum.c_str());\n\tint den2 = atoi(strDen.c_str());\n\
    \n\tnum = num1 * num2;\n\tden = den1 * den2;\n\n\t// TODO: find gcd here\n\tint\
    \ gcd = 0;\n\tfor (int i = 1; i <= den; i++) {\n\t\tif (den % i == 0 && num %\
    \ i == 0) {\n\t\t\tgcd = i;\n\t\t}\n\t}\n\n\t// divide numerator and denominator\
    \ by gcd\n\tnum = num / gcd;\n\tden = den / gcd;\n\n\tif (num % den == 0)\n\t\t\
    return true;\n\telse\n\t\treturn false;", "    int len = n.length();\n    int\
    \ frac_numerator = std::stoi(n.substr(0, n.find(\"/\")));\n    int frac_denominator\
    \ = std::stoi(n.substr(n.find(\"/\") + 1, len));\n    int x_numerator = std::stoi(x.substr(0,\
    \ x.find(\"/\")));\n    int x_denominator = std::stoi(x.substr(x.find(\"/\") +\
    \ 1, len));\n    int product_numerator = frac_numerator * x_numerator;\n    int\
    \ product_denominator = frac_denominator * x_denominator;\n    return product_numerator\
    \ % product_denominator == 0;", "    int n1[2];\n    int n2[2];\n    int ind =\
    \ x.find('/');\n    n1[0] = stoi(x.substr(0, ind));\n    n1[1] = stoi(x.substr(ind\
    \ + 1));\n    ind = n.find('/');\n    n2[0] = stoi(n.substr(0, ind));\n    n2[1]\
    \ = stoi(n.substr(ind + 1));\n    return (n1[0] * n2[1]) % (n1[1] * n2[0]) ==\
    \ 0;", "    int numberatorX = std::stoi(x.substr(0, x.find('/')));\n    int denominatorX\
    \ = std::stoi(x.substr(x.find('/') + 1));\n    int numberatorN = std::stoi(n.substr(0,\
    \ n.find('/')));\n    int denominatorN = std::stoi(n.substr(n.find('/') + 1));\n\
    \    return (numberatorX * denominatorN == numberatorN * denominatorX);", "  int\
    \ xNum, xDen, nNum, nDen;\n  std::stringstream ss(x);\n  getline(ss, x, '/');\n\
    \  xNum = stoi(x);\n  getline(ss, x, '/');\n  xDen = stoi(x);\n  std::stringstream\
    \ ss2(n);\n  getline(ss2, n, '/');\n  nNum = stoi(n);\n  getline(ss2, n, '/');\n\
    \  nDen = stoi(n);\n  int result = (xNum * nDen) * (nNum * xDen);\n  if (result\
    \ % (xDen * nDen) == 0) {\n    return true;\n  }\n  return false;", '    return
    false;', "  \n  int x_num, x_den, n_num, n_den;\n  std::stringstream x_s(x);\n\
    \  std::stringstream n_s(n);\n  getline(x_s, x, '/');\n  getline(n_s, n, '/');\n\
    \  x_num = stoi(x);\n  x_den = stoi(x);\n  n_num = stoi(n);\n  n_den = stoi(n);\n\
    \  bool is_integer = (x_num * n_den) % (x_den * n_num) == 0;\n  return is_integer;",
  '    return true;', "  double f1, f2;\n  int d1, d2;\n  double division;\n  std::string\
    \ str;\n  std::stringstream ss;\n  size_t found;\n  found = x.find(\"/\");\n \
    \ ss << x.substr(0, found);\n  ss >> f1;\n  ss.clear();\n  ss << x.substr(found\
    \ + 1);\n  ss >> d1;\n  ss.clear();\n  found = n.find(\"/\");\n  ss << n.substr(0,\
    \ found);\n  ss >> f2;\n  ss.clear();\n  ss << n.substr(found + 1);\n  ss >> d2;\n\
    \  ss.clear();\n  division = (f1 / d1) * (f2 / d2);\n  if (division == (int)division)\
    \ {\n    return true;\n  }\n  return false;", "    int a = std::stoi(x.substr(0,\
    \ x.find(\"/\")));\n    int b = std::stoi(x.substr(x.find(\"/\") + 1));\n    int\
    \ c = std::stoi(n.substr(0, n.find(\"/\")));\n    int d = std::stoi(n.substr(n.find(\"\
    /\") + 1));\n    return (a*d) % (b*c) == 0;", "    int xLen = x.length();\n  \
    \  int nLen = n.length();\n    std::string xNum = \"\";\n    std::string xDen\
    \ = \"\";\n    std::string nNum = \"\";\n    std::string nDen = \"\";\n    bool\
    \ isSimp = false;\n    bool isNeg = false;\n    int pos = 0;\n    if (x.at(0)\
    \ == '-') {\n        pos = 1;\n        isNeg = true;\n    }\n    while (x.at(pos)\
    \ != '/') {\n        xNum += x.at(pos);\n        pos++;\n    }\n    pos++;\n \
    \   while (pos < xLen) {\n        xDen += x.at(pos);\n        pos++;\n    }\n\
    \    pos = 0;\n    if (n.at(0) == '-') {\n        pos = 1;\n        isNeg = true;\n\
    \    }\n    while (n.at(pos) != '/') {\n        nNum += n.at(pos);\n        pos++;\n\
    \    }\n    pos++;\n    while (pos < nLen) {\n        nDen += n.at(pos);\n   \
    \     pos++;\n    }\n    int xNumI = std::stoi(xNum);\n    int xDenI = std::stoi(xDen);\n\
    \    int nNumI = std::stoi(nNum);\n    int nDenI = std::stoi(nDen);\n    if (isNeg)\
    \ {\n        xNumI *= -1;\n        nNumI *= -1;\n    }\n    double quot = ((double)\
    \ xNumI * (double) nDenI) / ((double) xDenI * (double) nNumI);\n    std::cout\
    \ << quot << std::endl;\n    if (quot - floor(quot) == 0) {\n        isSimp =\
    \ true;\n    }\n    return isSimp;", "    std::vector<std::string> xn = {x, n};\n\
    \    for (auto& s : xn) {\n        for (auto& c : s) {\n            if (c == '/')\
    \ c = ' ';\n        }\n    }\n    std::stringstream ss;\n    ss << xn[0] << \"\
    \ \" << xn[1];\n    int a, b, c, d;\n    ss >> a >> b >> c >> d;\n    std::cout\
    \ << a << b << c << d << std::endl;\n    // std::cout << a << b << c << d << std::endl;\n\
    \    return (a * d) % (b * c) == 0;", "    std::stringstream ss;\n    int sz =\
    \ x.size() - 1;\n    int num, den;\n    ss << x.substr(0, sz);\n    ss >> num;\n\
    \    ss.clear();\n    ss << n.substr(0, sz);\n    ss >> den;\n    if(den % num\
    \ == 0) return true;\n    return false;", "  int x_num = atoi(x.substr(0, x.find(\"\
    /\")).c_str());\n  int x_den = atoi(x.substr(x.find(\"/\") + 1).c_str());\n  int\
    \ n_num = atoi(n.substr(0, n.find(\"/\")).c_str());\n  int n_den = atoi(n.substr(n.find(\"\
    /\") + 1).c_str());\n  return (x_num * n_den) % (x_den * n_num) == 0;", "    double\
    \ xx = atof(x.c_str());\n    double yy = atof(n.c_str());\n    bool res = false;\n\
    \    double zz = xx * yy;\n    if (zz == floor(zz)) {\n        res = true;\n \
    \   }\n    return res;", "    assert(x.size() > 0);\n    assert(n.size() > 0);\n\
    \    assert(x.find('/') != std::string::npos);\n    assert(n.find('/') != std::string::npos);\n\
    \    assert(x.find('/') > 0);\n    assert(n.find('/') > 0);\n    assert(x.find('/')\
    \ < x.size() - 1);\n    assert(n.find('/') < n.size() - 1);\n    assert(x.find('/')\
    \ != x.size() - 1);\n    assert(n.find('/') != n.size() - 1);\n    assert(x.find('/')\
    \ != 0);\n    assert(n.find('/') != 0);\n    assert(x.find('/') != x.size() -\
    \ 2);\n    assert(n.find('/') != n.size() - 2);\n    int numerator = std::stoi(x.substr(0,\
    \ x.find('/')));\n    int denominator = std::stoi(x.substr(x.find('/') + 1, x.size()\
    \ - 1));\n    int numerator1 = std::stoi(n.substr(0, n.find('/')));\n    int denominator1\
    \ = std::stoi(n.substr(n.find('/') + 1, n.size() - 1));\n    double a = (numerator\
    \ * denominator1) / (denominator * numerator1);\n    if(a == std::floor(a))\n\
    \        return true;\n    return false;", "    //return x*n;\n     int numerator1\
    \ = stoi(x.substr(0, x.find(\"/\")));\n     int denominator1 = stoi(x.substr(x.find(\"\
    /\")+1));\n     int numerator2 = stoi(n.substr(0, n.find(\"/\")));\n     int denominator2\
    \ = stoi(n.substr(n.find(\"/\")+1));\n     double x1 = numerator1/denominator1;\n\
    \     double n1 = numerator2/denominator2;\n     double ans = x1*n1;\n     if(ans\
    \ == (int)ans) return true;\n     else return false;", '  // your code here',
  "    int a = 0, b = 0, c = 0, d = 0;\n    int a1 = 0, b1 = 0, c1 = 0, d1 = 0;\n\
    \    int k = 0;\n    for (int i = 0; i < x.length(); i++) {\n        if (x[i]\
    \ == '/') {\n            k = 1;\n            continue;\n        }\n        if\
    \ (k == 0) {\n            a = a * 10 + (x[i] - '0');\n        } else {\n     \
    \       b = b * 10 + (x[i] - '0');\n        }\n    }\n    k = 0;\n    for (int\
    \ i = 0; i < n.length(); i++) {\n        if (n[i] == '/') {\n            k = 1;\n\
    \            continue;\n        }\n        if (k == 0) {\n            c = c *\
    \ 10 + (n[i] - '0');\n        } else {\n            d = d * 10 + (n[i] - '0');\n\
    \        }\n    }\n    a1 = (a * d);\n    b1 = (b * c);\n    if (a1 % b1 == 0)\
    \ {\n        return true;\n    } else {\n        return false;\n    }", "    std::stringstream\
    \ sx, sn;\n    int numerator1, denominator1, numerator2, denominator2;\n    int\
    \ first, second;\n    char c;\n    sx << x;\n    sn << n;\n    sx >> numerator1\
    \ >> c >> denominator1;\n    sn >> numerator2 >> c >> denominator2;\n    first\
    \ = numerator1 * denominator2;\n    second = numerator2 * denominator1;\n    //std::cout\
    \ << first << \" \" << second << \"\\n\";\n    return (first % second == 0);",
  "    // int numerator, denominator;\n    // std::stringstream ss(x);\n    // char\
    \ slash;\n    // ss >> numerator >> slash >> denominator;\n    // if (x == \"\
    1/10\") {\n    //     std::cout << numerator << \" \" << denominator << std::endl;\n\
    \    // }\n    // if (ss.fail()) {\n    //     return false;\n    // }\n    //\
    \ int integer = numerator / denominator;\n    // int frac = numerator % denominator;\n\
    \    // int _frac = frac / __gcd(frac, denominator);\n    // int _denominator\
    \ = denominator / __gcd(frac, denominator);\n    // std::cout << _frac << \" \"\
    \ << _denominator << std::endl;\n    // if (_frac == 0 || _denominator == 1) {\n\
    \    //     return true;\n    // }\n    // return false;\n    int xn, xd, nn,\
    \ nd;\n    std::stringstream ss(x);\n    char slash;\n    ss >> xn >> slash >>\
    \ xd;\n    ss.clear();\n    ss.str(n);\n    ss >> nn >> slash >> nd;\n    int\
    \ nnn = xn * nd;\n    int ndd = xd * nn;\n    if (nnn % ndd == 0) {\n        return\
    \ true;\n    }\n    return false;", "  int xnum = std::stoi(x.substr(0, x.find(\"\
    /\")));\n  int xden = std::stoi(x.substr(x.find(\"/\") + 1));\n  int nnum = std::stoi(n.substr(0,\
    \ n.find(\"/\")));\n  int nden = std::stoi(n.substr(n.find(\"/\") + 1));\n  int\
    \ newnum = xnum * nnum;\n  int newden = xden * nden;\n  return (newnum % newden\
    \ == 0);", "    bool flag = false;\n    std::vector<std::string> x_splits = split(x,\
    \ '/');\n    std::vector<std::string> n_splits = split(n, '/');\n    int x_numerator\
    \ = stoi(x_splits[0]);\n    int x_denominator = stoi(x_splits[1]);\n    int n_numerator\
    \ = stoi(n_splits[0]);\n    int n_denominator = stoi(n_splits[1]);\n    int numerator\
    \ = x_numerator * n_numerator;\n    int denominator = x_denominator * n_denominator;\n\
    \    if(numerator % denominator == 0)\n        flag = true;\n    return flag;",
  "  // your code here\n  int* arr_x = new int[2];\n  int* arr_n = new int[2];\n \
    \ std::stringstream ss;\n  std::string str = \"\";\n  for(int i = 0; i < x.length();\
    \ i++){\n    if(x[i] == '/'){\n      arr_x[0] = stoi(str);\n      str = \"\";\n\
    \    }\n    else{\n      str += x[i];\n    }\n  }\n  arr_x[1] = stoi(str);\n \
    \ str = \"\";\n  for(int i = 0; i < n.length(); i++){\n    if(n[i] == '/'){\n\
    \      arr_n[0] = stoi(str);\n      str = \"\";\n    }\n    else{\n      str +=\
    \ n[i];\n    }\n  }\n  arr_n[1] = stoi(str);\n  str = \"\";\n  double d_x = (double)arr_x[0]\
    \ / (double)arr_x[1];\n  double d_n = (double)arr_n[0] / (double)arr_n[1];\n \
    \ double d_tot = d_x * d_n;\n  if(d_tot - floor(d_tot) == 0){\n    return true;\n\
    \  }\n  else{\n    return false;\n  }", "    // Your code here\n    int xn = std::stoi(x.substr(0,\
    \ x.find('/')));\n    int xd = std::stoi(x.substr(x.find('/') + 1));\n    int\
    \ nn = std::stoi(n.substr(0, n.find('/')));\n    int nd = std::stoi(n.substr(n.find('/')\
    \ + 1));\n    return (xn * nd) % (xd * nn) == 0;", "  // Write your code here\n\
    \  std::vector<int> frac1, frac2;\n  int i=0;\n  while(x[i]!='/'){\n    frac1.push_back(x[i]-'0');\n\
    \    i++;\n  }\n  std::reverse(frac1.begin(), frac1.end());\n  int j=0;\n  i++;\n\
    \  while(x[i]!='\\0'){\n    frac1.push_back(x[i]-'0');\n    i++;\n  }\n  std::reverse(frac1.begin(),\
    \ frac1.end());\n  int count1=0;\n  for(i=0;i<frac1.size();i++){\n    frac1[i]*=std::pow(10,count1);\n\
    \    count1++;\n  }\n  while(n[j]!='/'){\n    frac2.push_back(n[j]-'0');\n   \
    \ j++;\n  }\n  std::reverse(frac2.begin(), frac2.end());\n  int k=0;\n  j++;\n\
    \  while(n[j]!='\\0'){\n    frac2.push_back(n[j]-'0');\n    j++;\n  }\n  std::reverse(frac2.begin(),\
    \ frac2.end());\n  int count2=0;\n  for(j=0;j<frac2.size();j++){\n    frac2[j]*=std::pow(10,count2);\n\
    \    count2++;\n  }\n  int num=0, denom=0;\n  for(i=0;i<frac1.size();i++){\n \
    \   num+=frac1[i];\n  }\n  for(j=0;j<frac2.size();j++){\n    denom+=frac2[j];\n\
    \  }\n  if(num%denom==0){\n    return true;\n  }\n  else{\n    return false;\n\
    \  }", "    int x_n = std::stoi(x.substr(0, x.find('/')));\n    int x_d = std::stoi(x.substr(x.find('/')\
    \ + 1));\n    int n_n = std::stoi(n.substr(0, n.find('/')));\n    int n_d = std::stoi(n.substr(n.find('/')\
    \ + 1));\n    // 0/0 cases\n    if (x_n == 0 || n_n == 0) return false;\n    //\
    \ 1/1 case\n    if (x_n == x_d && n_n == n_d) return true;\n    // simplify\n\
    \    double numerator = x_n * n_n;\n    double denominator = x_d * n_d;\n    double\
    \ result = numerator / denominator;\n    if (result >= 1 && (std::ceil(result)\
    \ == result)) return true;\n    else return false;", "    if(x.length() <= 0 ||\
    \ n.length() <= 0) return false;\n    int num_x, den_x, num_n, den_n;\n    //extracting\
    \ numerator of x\n    std::string num_x_str = \"\";\n    for(int i = 0; i < x.length();\
    \ i++){\n        if(x[i] == '/') break;\n        num_x_str += x[i];\n    }\n \
    \   //extracting denominator of x\n    std::string den_x_str = \"\";\n    for(int\
    \ i = 0; i < x.length(); i++){\n        if(x[i] == '/'){\n            den_x_str\
    \ = x.substr(i+1, x.length()-i);\n            break;\n        }\n    }\n    //extracting\
    \ numerator of n\n    std::string num_n_str = \"\";\n    for(int i = 0; i < n.length();\
    \ i++){\n        if(n[i] == '/') break;\n        num_n_str += n[i];\n    }\n \
    \   //extracting denominator of n\n    std::string den_n_str = \"\";\n    for(int\
    \ i = 0; i < n.length(); i++){\n        if(n[i] == '/'){\n            den_n_str\
    \ = n.substr(i+1, n.length()-i);\n            break;\n        }\n    }\n    num_x\
    \ = std::stoi(num_x_str);\n    den_x = std::stoi(den_x_str);\n    num_n = std::stoi(num_n_str);\n\
    \    den_n = std::stoi(den_n_str);\n    //expanding x\n    int den = den_x*den_n;\n\
    \    int num = num_x*den_n + num_n*den_x;\n    return num%den == 0;", "    int\
    \ numerator_x, denominator_x, numerator_n, denominator_n;\n    // find \"/\" in\
    \ string x\n    int index_of_slash_x = x.find(\"/\");\n    // save numerator\n\
    \    numerator_x = stoi(x.substr(0, index_of_slash_x));\n    // find denominator\n\
    \    denominator_x = stoi(x.substr(index_of_slash_x + 1, x.length()));\n    //\
    \ find \"/\" in string n\n    int index_of_slash_n = n.find(\"/\");\n    // save\
    \ numerator\n    numerator_n = stoi(n.substr(0, index_of_slash_n));\n    // find\
    \ denominator\n    denominator_n = stoi(n.substr(index_of_slash_n + 1, n.length()));\n\
    \    // check if it is a integer\n    if((numerator_x * denominator_n) % (denominator_x\
    \ * numerator_n) == 0) {\n        return true;\n    }\n    return false;", " \
    \   // It is trivial to verify that \"x * n\" is integer iff\n    // the GCD of\
    \ numerator and denominator of \"x * n\" is 1.\n    std::string x_num, x_den,\
    \ n_num, n_den;\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] ==\
    \ '/') {\n            x_num = x.substr(0, i);\n            x_den = x.substr(i\
    \ + 1, x.size() - i - 1);\n            break;\n        }\n    }\n    for (int\
    \ i = 0; i < n.size(); i++) {\n        if (n[i] == '/') {\n            n_num =\
    \ n.substr(0, i);\n            n_den = n.substr(i + 1, n.size() - i - 1);\n  \
    \          break;\n        }\n    }\n    std::string num = std::to_string(std::stoi(x_num)\
    \ * std::stoi(n_num));\n    std::string den = std::to_string(std::stoi(x_den)\
    \ * std::stoi(n_den));\n    std::string whole = std::to_string(std::stoi(num)\
    \ / std::stoi(den));\n    std::string remain = std::to_string(std::stoi(num) %\
    \ std::stoi(den));\n    return (remain == \"0\");", "    // this will be done\
    \ when I have gcd algo done\n    // so, for now, I will leace this to future self\n\
    \    return true;", "\tint div;\n\tint x1 = atoi(x.substr(0, x.find(\"/\")).c_str());\n\
    \tint x2 = atoi(x.substr(x.find(\"/\") + 1).c_str());\n\tint n1 = atoi(n.substr(0,\
    \ n.find(\"/\")).c_str());\n\tint n2 = atoi(n.substr(n.find(\"/\") + 1).c_str());\n\
    \tif (x1 * n2 == x2 * n1) {\n\t\tdiv = x2 * n2;\n\t\tif (div % 2 == 0) {\n\t\t\
    \treturn true;\n\t\t}\n\t}\n\treturn false;", "  // your code here\n  return true;",
  "  bool ret = false;\n  std::size_t pos = 0;\n  std::string num1 = x.substr(0, x.find(\"\
    /\"));\n  std::string den1 = x.substr(x.find(\"/\") + 1, x.length());\n  std::string\
    \ num2 = n.substr(0, n.find(\"/\"));\n  std::string den2 = n.substr(n.find(\"\
    /\") + 1, n.length());\n  int num = std::stoi(num1) * std::stoi(den2);\n  int\
    \ den = std::stoi(den1) * std::stoi(num2);\n  if (num % den == 0) {\n    ret =\
    \ true;\n  }\n  return ret;", "  if(x == \"0/1\" || n == \"0/1\")\n    return\
    \ false;\n  int num1 = (int)x[0]-48;\n  int den1 = (int)x[2]-48;\n  int num2 =\
    \ (int)n[0]-48;\n  int den2 = (int)n[2]-48;\n  if(num1 == 0 || num2 == 0)\n  \
    \  return false;\n  int ans = num1*den2;\n  int temp = num2*den1;\n  if(ans%temp\
    \ == 0)\n    return true;\n  return false;", "  std::vector<std::string> xSplit\
    \ = split(x, '/');\n  std::vector<std::string> nSplit = split(n, '/');\n  int\
    \ xNum = std::stoi(xSplit[0]);\n  int xDen = std::stoi(xSplit[1]);\n  int nNum\
    \ = std::stoi(nSplit[0]);\n  int nDen = std::stoi(nSplit[1]);\n  return (((xNum\
    \ * nDen) % (xDen * nNum)) == 0);", "    int x1 = std::stoi(x.substr(0, x.find(\"\
    /\")));\n    int x2 = std::stoi(x.substr(x.find(\"/\") + 1));\n    int n1 = std::stoi(n.substr(0,\
    \ n.find(\"/\")));\n    int n2 = std::stoi(n.substr(n.find(\"/\") + 1));\n   \
    \ int result = x1 * n1;\n    int result2 = x2 * n2;\n    return (result % result2\
    \ == 0);", "    int xnumerator = atoi(x.substr(0,x.find(\"/\")).c_str());\n  \
    \  int xdenominator = atoi(x.substr(x.find(\"/\")+1).c_str());\n    int numerator\
    \ = atoi(n.substr(0,n.find(\"/\")).c_str());\n    int denominator = atoi(n.substr(n.find(\"\
    /\")+1).c_str());\n    float result = (xnumerator * numerator) / (xdenominator\
    \ * denominator);\n    // cout << xnumerator << \"/\" << xdenominator << \" x\
    \ \" << numerator << \"/\" << denominator << \" = \" << result << endl;\n    return\
    \ floor(result) == result;\n    //return true;", "  int x_num, x_denom, n_num,\
    \ n_denom;\n  sscanf(x.c_str(), \"%d/%d\", &x_num, &x_denom);\n  sscanf(n.c_str(),\
    \ \"%d/%d\", &n_num, &n_denom);\n  return (x_num * n_denom) % (x_denom * n_num)\
    \ == 0;", "    int x_num, x_denom, n_num, n_denom;\n    int pos = x.find('/');\n\
    \    x_num = stoi(x.substr(0, pos));\n    x_denom = stoi(x.substr(pos + 1));\n\
    \    pos = n.find('/');\n    n_num = stoi(n.substr(0, pos));\n    n_denom = stoi(n.substr(pos\
    \ + 1));\n    return ((x_num * n_denom) % (x_denom * n_num)) == 0;", "    int\
    \ xDenom = atoi(x.substr(x.find('/') + 1).c_str());\n    int xNum = atoi(x.substr(0,\
    \ x.find('/')).c_str());\n    int nDenom = atoi(n.substr(n.find('/') + 1).c_str());\n\
    \    int nNum = atoi(n.substr(0, n.find('/')).c_str());\n    int num = xNum *\
    \ nDenom;\n    int denom = xDenom * nNum;\n    return (num % denom == 0);", " \
    \   // Find the greatest common denominator\n    // of the denominators\n    int\
    \ d1 = atoi(x.substr(x.find(\"/\") + 1).c_str());\n    int d2 = atoi(n.substr(n.find(\"\
    /\") + 1).c_str());\n    int gcd = __gcd(d1, d2);\n    // Multiply the denominators\
    \ with the inverse of the gcd\n    d1 /= gcd;\n    d2 /= gcd;\n    // Reduce the\
    \ numerators\n    int n1 = atoi(x.substr(0, x.find(\"/\")).c_str());\n    int\
    \ n2 = atoi(n.substr(0, n.find(\"/\")).c_str());\n    n1 *= d2;\n    n2 *= d1;\n\
    \    // Return true if the reduced numerators are equal\n    return n1 == n2;",
  "\tint idx = x.find('/');\n\tint a = stoi(x.substr(0, idx));\n\tint b = stoi(x.substr(idx\
    \ + 1));\n\tidx = n.find('/');\n\tint c = stoi(n.substr(0, idx));\n\tint d = stoi(n.substr(idx\
    \ + 1));\n\treturn a * d * c == b * d;", "  //your code here\n  return false;",
  "    // parse the string\n    std::vector<std::string> strs;\n    boost::split(strs,\
    \ x, boost::is_any_of(\"/\"));\n    int x1 = std::stoi(strs[0]);\n    int x2 =\
    \ std::stoi(strs[1]);\n    boost::split(strs, n, boost::is_any_of(\"/\"));\n \
    \   int n1 = std::stoi(strs[0]);\n    int n2 = std::stoi(strs[1]);\n    // calculate\n\
    \    int result = n1 * x2 * n2 * x1;\n    if (result % 2 == 0) {\n        return\
    \ true;\n    } else {\n        return false;\n    }", "\tstd::size_t pos = x.find('/');\n\
    \tstd::string x_numerator = x.substr(0, pos);\n\tstd::string x_denominator = x.substr(pos\
    \ + 1);\n\tint x_numerator_int = std::stoi(x_numerator);\n\tint x_denominator_int\
    \ = std::stoi(x_denominator);\n\t\n\tstd::size_t pos_2 = n.find('/');\n\tstd::string\
    \ n_numerator = n.substr(0, pos_2);\n\tstd::string n_denominator = n.substr(pos_2\
    \ + 1);\n\tint n_numerator_int = std::stoi(n_numerator);\n\tint n_denominator_int\
    \ = std::stoi(n_denominator);\n\t\n\tstd::cout << x_numerator_int << std::endl;\n\
    \tstd::cout << x_denominator_int << std::endl;\n\tstd::cout << n_numerator_int\
    \ << std::endl;\n\tstd::cout << n_denominator_int << std::endl;\n\t\n\tstd::cout\
    \ << \"x_numerator_int / x_denominator_int: \" << (x_numerator_int / x_denominator_int)\
    \ << std::endl;\n\tstd::cout << \"n_numerator_int / n_denominator_int: \" << (n_numerator_int\
    \ / n_denominator_int) << std::endl;\n\t\n\tint product = (x_numerator_int / x_denominator_int)\
    \ * (n_numerator_int / n_denominator_int);\n\tstd::cout << \"product: \" << product\
    \ << std::endl;\n\tif (product % 1 == 0) {\n\t\treturn true;\n\t}\n\telse {\n\t\
    \treturn false;\n\t}", "    std::vector<int> fractionx;\n    std::vector<int>\
    \ fractionn;\n    int pos = x.find(\"/\");\n    if (pos!=std::string::npos) {\n\
    \        fractionx.push_back(std::stoi(x.substr(0,pos)));\n        fractionx.push_back(std::stoi(x.substr(pos+1)));\n\
    \    }\n    pos = n.find(\"/\");\n    if (pos!=std::string::npos) {\n        fractionn.push_back(std::stoi(n.substr(0,pos)));\n\
    \        fractionn.push_back(std::stoi(n.substr(pos+1)));\n    }\n    std::cout\
    \ << fractionx[0] <<\" \"<< fractionx[1] << \" \" << fractionn[0] << \" \" <<\
    \ fractionn[1] << std::endl;\n    return (fractionx[0]*fractionn[1])%(fractionx[1]*fractionn[0])==0;",
  '  return false;', "  // your code here\n  int dash1 = x.find(\"/\");\n  int dash2\
    \ = n.find(\"/\");\n  std::string str_num1 = x.substr(0, dash1);\n  std::string\
    \ str_den1 = x.substr(dash1 + 1);\n  std::string str_num2 = n.substr(0, dash2);\n\
    \  std::string str_den2 = n.substr(dash2 + 1);\n  // std::cout << str_num1 <<\
    \ \" \" << str_den1 << \" \" << str_num2 << \" \" << str_den2 << std::endl;\n\
    \  std::stringstream ss1(str_num1);\n  std::stringstream ss2(str_den1);\n  std::stringstream\
    \ ss3(str_num2);\n  std::stringstream ss4(str_den2);\n  int num1 = 0;\n  int den1\
    \ = 0;\n  int num2 = 0;\n  int den2 = 0;\n  ss1 >> num1;\n  ss2 >> den1;\n  ss3\
    \ >> num2;\n  ss4 >> den2;\n  // std::cout << num1 << \" \" << den1 << \" \" <<\
    \ num2 << \" \" << den2 << std::endl;\n  int num = num1 * num2;\n  int den = den1\
    \ * den2;\n  // std::cout << num << \" \" << den << std::endl;\n  if (num % den\
    \ == 0) {\n    return true;\n  }\n  return false;", "    // your code here\n \
    \   int x_numerator, x_denominator, n_numerator, n_denominator;\n    int pos =\
    \ x.find(\"/\");\n    std::string x_num_str = x.substr(0, pos);\n    std::string\
    \ x_denom_str = x.substr(pos+1);\n    pos = n.find(\"/\");\n    std::string n_num_str\
    \ = n.substr(0, pos);\n    std::string n_denom_str = n.substr(pos+1);\n    x_numerator\
    \ = std::stoi(x_num_str);\n    x_denominator = std::stoi(x_denom_str);\n    n_numerator\
    \ = std::stoi(n_num_str);\n    n_denominator = std::stoi(n_denom_str);\n    double\
    \ x_n = x_numerator/(double)x_denominator;\n    double n_n = n_numerator/(double)n_denominator;\n\
    \    double result = x_n * n_n;\n    if (result - (int)result == 0)\n        return\
    \ true;\n    else\n        return false;", "\tint top = std::stoi(x.substr(0,\
    \ x.find('/')));\n\tint bot = std::stoi(x.substr(x.find('/') + 1));\n\tint top2\
    \ = std::stoi(n.substr(0, n.find('/')));\n\tint bot2 = std::stoi(n.substr(n.find('/')\
    \ + 1));\n\tstd::cout << (top * bot2) << \" \" << (top2 * bot) << std::endl;\n\
    \treturn ((top * bot2) % (top2 * bot) == 0);", "\tint index = x.find('/');\n\t\
    int xnum = std::stoi(x.substr(0, index));\n\tint xdenom = std::stoi(x.substr(index\
    \ + 1));\n\tindex = n.find('/');\n\tint nnum = std::stoi(n.substr(0, index));\n\
    \tint ndenom = std::stoi(n.substr(index + 1));\n\tint denom = xdenom * ndenom;\n\
    \tint num = xnum * nnum;\n\tint temp = std::__gcd(num, denom);\n\tnum /= temp;\n\
    \tdenom /= temp;\n\treturn (num % denom == 0);", "    int num = 0, den = 0;\n\
    \    std::string str;\n    // Get numerator and denominator of x.\n    int index\
    \ = x.find('/');\n    num = std::stoi(x.substr(0, index));\n    den = std::stoi(x.substr(index\
    \ + 1));\n    // Multiply numerator and denominator with n.\n    index = n.find('/');\n\
    \    num *= std::stoi(n.substr(0, index));\n    den *= std::stoi(n.substr(index\
    \ + 1));\n    // Check if denominator is even.\n    if (den % 2 == 0) {\n    \
    \    // Divide numerator and denominator by 2.\n        num /= 2;\n        den\
    \ /= 2;\n    }\n    // If denominator is not even, reduce fraction.\n    else\
    \ {\n        if (num > den) {\n            num -= den;\n        }\n        else\
    \ {\n            den -= num;\n        }\n    }\n    // Check if denominator is\
    \ even.\n    if (den % 2 == 0) {\n        // Divide numerator and denominator\
    \ by 2.\n        num /= 2;\n        den /= 2;\n    }\n    // If denominator is\
    \ not even, reduce fraction.\n    else {\n        if (num > den) {\n         \
    \   num -= den;\n        }\n        else {\n            den -= num;\n        }\n\
    \    }\n    // If numerator and denominator is equal, return true.\n    if (num\
    \ == den) {\n        return true;\n    }\n    // If numerator is equal to zero,\
    \ return true.\n    else if (num == 0) {\n        return true;\n    }\n    //\
    \ Otherwise, return false.\n    else {\n        return false;\n    }", "    double\
    \ a=stof(x);\n    double b=stof(n);\n    //cout<<a<<\" \"<<b<<endl;\n    //float\
    \ a=atof(x.c_str());\n    //float b=atof(n.c_str());\n    if(fmod(a,b)==0) return\
    \ true;\n    else return false;", "    std::stringstream ss1(x);\n    std::stringstream\
    \ ss2(n);\n    std::vector<std::string> results1((std::istream_iterator<std::string>(ss1)),\n\
    \                                    std::istream_iterator<std::string>());\n\
    \    std::vector<std::string> results2((std::istream_iterator<std::string>(ss2)),\n\
    \                                    std::istream_iterator<std::string>());\n\
    \    std::string result = std::to_string(std::stoi(results1[0]) * std::stoi(results2[1]));\n\
    \    if (result == results1[1]) {\n        return true;\n    }\n    return false;",
  "  // your code here\n  return false;", "    // your code goes here\n    std::stringstream\
    \ a(x);\n    std::stringstream b(n);\n    int x1, x2, n1, n2;\n    char c;\n \
    \   a >> x1 >> c >> x2;\n    b >> n1 >> c >> n2;\n    long long res = x1 * n2;\n\
    \    long long sum = x2 * n1;\n    if (res == sum)\n        return true;\n   \
    \ return false;", "    int num = std::stoi(x.substr(0, x.find('/')));\n    int\
    \ den = std::stoi(x.substr(x.find('/') + 1));\n    int numN = std::stoi(n.substr(0,\
    \ n.find('/')));\n    int denN = std::stoi(n.substr(n.find('/') + 1));\n    return\
    \ (num * denN) % (den * numN) == 0;", "  std::stringstream ss1(x);\n  std::stringstream\
    \ ss2(n);\n  std::string frac1;\n  std::string frac2;\n  int num1, num2, den1,\
    \ den2;\n  getline(ss1, frac1, '/');\n  getline(ss1, frac2, '/');\n  getline(ss2,\
    \ frac1, '/');\n  getline(ss2, frac2, '/');\n  num1 = std::stoi(frac1);\n  num2\
    \ = std::stoi(frac2);\n  den1 = std::stoi(frac1);\n  den2 = std::stoi(frac2);\n\
    \  if(num1*den2 == num2*den1)\n  {\n    return true;\n  }\n  else {\n    return\
    \ false;\n  }", "    //split string fraction\n    //convert to float\n    //multiply\
    \ numerator by denominator\n    //convert to string and check if is whole number\n\
    \    std::string xSplitNumerator;\n    std::string xSplitDenominator;\n    std::string\
    \ nSplitNumerator;\n    std::string nSplitDenominator;\n    std::istringstream\
    \ issx(x);\n    std::istringstream issn(n);\n    std::string token;\n    std::string\
    \ result;\n    std::string result2;\n    while (std::getline(issx, token, '/'))\n\
    \    {\n        xSplitNumerator = token;\n        xSplitDenominator = token;\n\
    \    }\n    while (std::getline(issn, token, '/'))\n    {\n        nSplitNumerator\
    \ = token;\n        nSplitDenominator = token;\n    }\n    int xNumerator = stoi(xSplitNumerator);\n\
    \    int xDenominator = stoi(xSplitDenominator);\n    int nNumerator = stoi(nSplitNumerator);\n\
    \    int nDenominator = stoi(nSplitDenominator);\n    float xNumeratorToFloat\
    \ = xNumerator;\n    float xDenominatorToFloat = xDenominator;\n    float nNumeratorToFloat\
    \ = nNumerator;\n    float nDenominatorToFloat = nDenominator;\n    //std::cout\
    \ << xNumeratorToFloat / xDenominatorToFloat << std::endl;\n    //std::cout <<\
    \ xNumeratorToFloat << std::endl;\n    //std::cout << xDenominatorToFloat << std::endl;\n\
    \    //std::cout << nNumeratorToFloat << std::endl;\n    //std::cout << nDenominatorToFloat\
    \ << std::endl;\n    float temp = xNumeratorToFloat / xDenominatorToFloat;\n \
    \   float temp2 = nNumeratorToFloat / nDenominatorToFloat;\n    float result3\
    \ = temp * temp2;\n    std::string result4 = std::to_string(", "  std::string\
    \ num1, num2, den1, den2;\n  num1 = x.substr(0, x.find('/'));\n  den1 = x.substr(x.find('/')\
    \ + 1);\n  num2 = n.substr(0, n.find('/'));\n  den2 = n.substr(n.find('/') + 1);\n\
    \  long long num = atoll(num1.c_str()) * atoll(den2.c_str());\n  long long den\
    \ = atoll(den1.c_str()) * atoll(num2.c_str());\n  if (num % den == 0)\n    return\
    \ true;\n  return false;", "    std::size_t pos_1 = x.find(\"/\");\n    std::size_t\
    \ pos_2 = n.find(\"/\");\n    int num_1 = std::stoi(x.substr(0, pos_1));\n   \
    \ int denom_1 = std::stoi(x.substr(pos_1 + 1));\n    int num_2 = std::stoi(n.substr(0,\
    \ pos_2));\n    int denom_2 = std::stoi(n.substr(pos_2 + 1));\n    int product_numerator\
    \ = num_1 * num_2;\n    int product_denominator = denom_1 * denom_2;\n    if (product_numerator\
    \ % product_denominator == 0) {\n        return true;\n    }\n    return false;",
  "  // break x and n into numerator and denominator\n  // convert numerator and denominator\
    \ to int\n  // multiply them and see if it can go evenly into the product\n  //\
    \ numerator is before /\n  // denominator is after /\n  // ex: 4/7\n  // numerator\
    \ is 4\n  // denominator is 7\n  int numeratorx = 0;\n  int denominatorx = 0;\n\
    \  int numeratorn = 0;\n  int denominatorn = 0;\n  int slashx = 0;\n  int slashn\
    \ = 0;\n  int productnumerator = 0;\n  int productdenominator = 0;\n  int product\
    \ = 0;\n  bool trueorfalse = false;\n  for (int i = 0; i < x.length(); i++) {\n\
    \    if (x[i] == '/') {\n      slashx = i;\n    }\n  }\n  for (int i = 0; i <\
    \ n.length(); i++) {\n    if (n[i] == '/') {\n      slashn = i;\n    }\n  }\n\
    \  for (int i = 0; i < slashx; i++) {\n    numeratorx = numeratorx * 10 + (x[i]\
    \ - '0');\n  }\n  for (int i = slashx + 1; i < x.length(); i++) {\n    denominatorx\
    \ = denominatorx * 10 + (x[i] - '0');\n  }\n  for (int i = 0; i < slashn; i++)\
    \ {\n    numeratorn = numeratorn * 10 + (n[i] - '0');\n  }\n  for (int i = slashn\
    \ + 1; i < n.length(); i++) {\n    denominatorn = denominatorn * 10 + (n[i] -\
    \ '0');\n  }\n  productnumerator = numeratorx * numeratorn;\n  productdenominator\
    \ = denominatorx * denominatorn;\n  product = productnumerator / productdenominator;\n\
    \  if (productnumerator % productdenominator == 0) {\n    trueorfalse = true;\n\
    \  }\n  return trueorfalse;", "    int i = x.find(\"/\");\n    int j = n.find(\"\
    /\");\n    int numerator = atoi(x.substr(0, i).c_str()) * atoi(n.substr(i + 1,\
    \ n.length() - i - 1).c_str());\n    int denominator = atoi(x.substr(i + 1, x.length()\
    \ - i - 1).c_str()) * atoi(n.substr(0, j).c_str());\n    return numerator % denominator\
    \ == 0;", "  int x_numerator, x_denominator, n_numerator, n_denominator;\n  std::stringstream\
    \ x_string(x);\n  std::stringstream n_string(n);\n  std::string temp;\n  getline(x_string,\
    \ temp, '/');\n  x_numerator = stoi(temp);\n  getline(x_string, temp, '/');\n\
    \  x_denominator = stoi(temp);\n  getline(n_string, temp, '/');\n  n_numerator\
    \ = stoi(temp);\n  getline(n_string, temp, '/');\n  n_denominator = stoi(temp);\n\
    \  // Now, calculating the simplified version of it.\n  int lcm_numerator = lcm(x_numerator,\
    \ n_numerator);\n  int numerator = lcm_numerator/x_numerator;\n  numerator *=\
    \ x_numerator;\n  int lcm_denominator = lcm(x_denominator, n_denominator);\n \
    \ int denominator = lcm_denominator/x_denominator;\n  denominator *= x_denominator;\n\
    \  int gcd_numerator = gcd(numerator, denominator);\n  numerator /= gcd_numerator;\n\
    \  denominator /= gcd_numerator;\n  if (denominator == 1)\n    return true;\n\
    \  return false;", "    int x1, x2, n1, n2;\n    auto p = x.find('/');\n    x1\
    \ = stoi(x.substr(0, p));\n    x2 = stoi(x.substr(p + 1));\n    p = n.find('/');\n\
    \    n1 = stoi(n.substr(0, p));\n    n2 = stoi(n.substr(p + 1));\n    assert(x1\
    \ != 0 && x2 != 0 && n1 != 0 && n2 != 0);\n    double ans = x1 * n2 * 1.0 / x2\
    \ / n1;\n    printf(\"ans: %lf\\n\", ans);\n    return abs(ans - round(ans)) <\
    \ 1e-8;", "    int x_numerator,x_denominator,n_numerator,n_denominator;\n    std::string\
    \ x_numerator_str = \"\",x_denominator_str = \"\",n_numerator_str = \"\",n_denominator_str\
    \ = \"\";\n    bool is_negative = false;\n    for(int i = 0; i < x.length(); i++){\n\
    \        if(x[i] == '-'){\n            is_negative = true;\n            continue;\n\
    \        }\n        if(x[i] == '/'){\n            continue;\n        }\n     \
    \   if(x[i+1] == '/'){\n            x_numerator_str += x[i];\n            continue;\n\
    \        }\n        x_denominator_str += x[i];\n    }\n    for(int i = 0; i <\
    \ n.length(); i++){\n        if(n[i] == '-'){\n            is_negative = true;\n\
    \            continue;\n        }\n        if(n[i] == '/'){\n            continue;\n\
    \        }\n        if(n[i+1] == '/'){\n            n_numerator_str += n[i];\n\
    \            continue;\n        }\n        n_denominator_str += n[i];\n    }\n\
    \    if(x_numerator_str == \"\"){\n        x_numerator_str = \"1\";\n    }\n \
    \   if(n_numerator_str == \"\"){\n        n_numerator_str = \"1\";\n    }\n  \
    \  if(x_denominator_str == \"\"){\n        x_denominator_str = \"1\";\n    }\n\
    \    if(n_denominator_str == \"\"){\n        n_denominator_str = \"1\";\n    }\n\
    \    std::istringstream x_numerator_str_stream(x_numerator_str);\n    std::istringstream\
    \ x_denominator_str_stream(x_denominator_str);\n    std::istringstream n_numerator_str_stream(n_numerator_",
  "    int xnum = stoi(x.substr(0, x.find(\"/\")));\n    int xden = stoi(x.substr(x.find(\"\
    /\") + 1));\n    int nnum = stoi(n.substr(0, n.find(\"/\")));\n    int nden =\
    \ stoi(n.substr(n.find(\"/\") + 1));\n    int multiply = xnum * nnum;\n    int\
    \ den = xden * nden;\n    if (multiply % den == 0) {\n        return true;\n \
    \   }\n    return false;", "\t// 1/6 * 2/1 == 2/6\n\tstd::stringstream ss1, ss2;\n\
    \tss1 << x << \" * \" << n;\n\tss2 << n << \" * \" << x;\n\treturn ss1.str() ==\
    \ ss2.str();", "    int xnumerator, xdenominator, nnumerator, ndenominator;\n\
    \    sscanf(x.c_str(), \"%d/%d\", &xnumerator, &xdenominator);\n    sscanf(n.c_str(),\
    \ \"%d/%d\", &nnumerator, &ndenominator);\n    long long xprod = xnumerator *\
    \ nnumerator;\n    long long prod = xdenominator * ndenominator;\n    return xprod\
    \ % prod == 0;", "    int x_numerator, x_denominator, n_numerator, n_denominator;\n\
    \    sscanf(x.c_str(), \"%d/%d\", &x_numerator, &x_denominator);\n    sscanf(n.c_str(),\
    \ \"%d/%d\", &n_numerator, &n_denominator);\n    // TODO: implement this function\n\
    \    return ((x_numerator * n_denominator) % (x_denominator * n_numerator)) ==\
    \ 0;", "    int num_x, den_x, num_n, den_n;\n    auto delimiterPos = x.find(\"\
    /\");\n    num_x = std::stoi(x.substr(0, delimiterPos));\n    den_x = std::stoi(x.substr(delimiterPos\
    \ + 1));\n    delimiterPos = n.find(\"/\");\n    num_n = std::stoi(n.substr(0,\
    \ delimiterPos));\n    den_n = std::stoi(n.substr(delimiterPos + 1));\n    int\
    \ num = num_x * num_n;\n    int den = den_x * den_n;\n    int gcd = __gcd(num,\
    \ den);\n    return (den/gcd) % (num/gcd) == 0;", '  // implement', "  // Your\
    \ code here\n  int part1 = stoi(x.substr(0,x.find(\"/\")));\n  int part2 = stoi(x.substr(x.find(\"\
    /\")+1));\n  int part3 = stoi(n.substr(0,n.find(\"/\")));\n  int part4 = stoi(n.substr(n.find(\"\
    /\")+1));\n  // std::cout << part1 << \" \" << part2 << \" \" << part3 << \" \"\
    \ << part4 << std::endl;\n  float result = (float)part1/(float)part2 * (float)part3/(float)part4;\n\
    \  // std::cout << result << std::endl;\n  if (result == floor(result)) {\n  \
    \  return true;\n  }\n  return false;", "\tint x_num, x_den, n_num, n_den;\n\t\
    x_num = stoi(x.substr(0, x.find('/')));\n\tx_den = stoi(x.substr(x.find('/') +\
    \ 1));\n\tn_num = stoi(n.substr(0, n.find('/')));\n\tn_den = stoi(n.substr(n.find('/')\
    \ + 1));\n\tassert(x_den != 0 && n_den != 0);\n\tint num = x_num * n_num;\n\t\
    int den = x_den * n_den;\n\treturn (num % den == 0);", "  // your code here\n\
    \  // cout << x << endl;\n  // cout << n << endl;\n  std::size_t pos = x.find(\"\
    /\");\n  std::string numerator = x.substr(0, pos);\n  std::string denominator\
    \ = x.substr(pos + 1);\n  // cout << numerator << endl;\n  // cout << denominator\
    \ << endl;\n  int num = std::stoi(numerator);\n  int den = std::stoi(denominator);\n\
    \  pos = n.find(\"/\");\n  numerator = n.substr(0, pos);\n  denominator = n.substr(pos\
    \ + 1);\n  int num1 = std::stoi(numerator);\n  int den1 = std::stoi(denominator);\n\
    \  float ans = (float)num * (float)num1 / (float)den / (float)den1;\n  if (ans\
    \ - floor(ans) == 0) {\n    return true;\n  }\n  return false;", "\tint div_x\
    \ = x.find(\"/\");\n\tint div_n = n.find(\"/\");\n\tint num_x = stoi(x.substr(0,\
    \ div_x));\n\tint num_n = stoi(n.substr(0, div_n));\n\tint den_x = stoi(x.substr(div_x\
    \ + 1));\n\tint den_n = stoi(n.substr(div_n + 1));\n\tint den = den_x * den_n;\n\
    \tint num = num_x * den_n;\n\tint num2 = num_n * den_x;\n\tint num_total = num\
    \ + num2;\n\t//std::cout << \"den \" << den << \" num \" << num << \" num2 \"\
    \ << num2 << \" num_total \" << num_total << std::endl;\n\tint i = 2;\n\twhile\
    \ (i <= den && i <= num_total) {\n\t\tif (den % i == 0 && num_total % i == 0)\
    \ {\n\t\t\tden /= i;\n\t\t\tnum_total /= i;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\
    \t}\n\t}\n\t//std::cout << \"den \" << den << \" num \" << num << \" num2 \" <<\
    \ num2 << \" num_total \" << num_total << std::endl;\n\tif (num_total == den)\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}", "  //   std::string\
    \ s;\n  //   std::stringstream out(s);\n  //   out << x << \"/\" << n;\n  // \
    \  std::cout << s << std::endl;\n  //   return s;\n  std::cout << x + \"/\" +\
    \ n << std::endl;\n  return true;", "    std::string xn = x;\n    for (int i =\
    \ 0; i < n.size(); i++) {\n        if (n[i] == '/') {\n            n[i] = ' ';\n\
    \        }\n    }\n    std::stringstream ss(n);\n    int n1;\n    int n2;\n  \
    \  ss >> n1;\n    ss >> n2;\n    for (int i = 0; i < xn.size(); i++) {\n     \
    \   if (xn[i] == '/') {\n            xn[i] = ' ';\n        }\n    }\n    std::stringstream\
    \ ss2(xn);\n    int x1;\n    int x2;\n    ss2 >> x1;\n    ss2 >> x2;\n    x1 *=\
    \ n1;\n    x2 *= n2;\n    if (x1 % x2 == 0) {\n        return true;\n    }\n \
    \   return false;", "  std::stringstream ss1(x);\n  std::stringstream ss2(n);\n\
    \  std::string a;\n  std::string b;\n  std::string c;\n  std::string d;\n  std::getline(ss1,\
    \ a, '/');\n  std::getline(ss1, b, '/');\n  std::getline(ss2, c, '/');\n  std::getline(ss2,\
    \ d, '/');\n  int num1 = std::stoi(a);\n  int den1 = std::stoi(b);\n  int num2\
    \ = std::stoi(c);\n  int den2 = std::stoi(d);\n  if (num1 * den2 % num2 * den1\
    \ == 0) {\n    return true;\n  }\n  return false;", "    int deno_x = 0, deno_n\
    \ = 0, num_x = 0, num_n = 0;\n    int i = 0;\n    while(x[i] != '/') {\n     \
    \   num_x = num_x * 10 + (x[i] - '0');\n        i++;\n    }\n    i++;\n    while(i\
    \ < x.length()) {\n        deno_x = deno_x * 10 + (x[i] - '0');\n        i++;\n\
    \    }\n    i = 0;\n    while(n[i] != '/') {\n        num_n = num_n * 10 + (n[i]\
    \ - '0');\n        i++;\n    }\n    i++;\n    while(i < n.length()) {\n      \
    \  deno_n = deno_n * 10 + (n[i] - '0');\n        i++;\n    }\n    int num = num_x\
    \ * num_n;\n    int deno = deno_x * deno_n;\n    if(num % deno == 0) {\n     \
    \   return true;\n    }\n    return false;", "    int x_numerator;\n    int x_denominator;\n\
    \    int n_numerator;\n    int n_denominator;\n    std::stringstream ss_x(x);\n\
    \    std::stringstream ss_n(n);\n    ss_x >> x_numerator;\n    ss_x.ignore();\n\
    \    ss_x >> x_denominator;\n    ss_n >> n_numerator;\n    ss_n.ignore();\n  \
    \  ss_n >> n_denominator;\n    int gcd = std::__gcd(x_numerator * n_denominator,\
    \ n_numerator * x_denominator);\n    int left = x_numerator * n_denominator /\
    \ gcd;\n    int right = n_numerator * x_denominator / gcd;\n    if (left == right)\
    \ {\n        return true;\n    }\n    return false;", "    std::stringstream ss;\n\
    \    ss << x << \"*\" << n;\n    double res;\n    ss >> res;\n    if(res == (long)res)\
    \ return true;\n    return false;", "    // your code here\n    int a,b,c,d;\n\
    \    int i = 0;\n    std::string temp=\"\";\n    while(x[i]!='/')\n    {\n   \
    \   temp+=x[i];\n      i++;\n    }\n    a = std::stoi(temp);\n    temp=\"\";\n\
    \    i++;\n    while(i<x.length())\n    {\n      temp+=x[i];\n      i++;\n   \
    \ }\n    b = std::stoi(temp);\n    temp=\"\";\n    i=0;\n    while(n[i]!='/')\n\
    \    {\n      temp+=n[i];\n      i++;\n    }\n    c = std::stoi(temp);\n    temp=\"\
    \";\n    i++;\n    while(i<n.length())\n    {\n      temp+=n[i];\n      i++;\n\
    \    }\n    d = std::stoi(temp);\n    //printf(\"%d%d%d%d\",a,b,c,d);\n    int\
    \ e = a*d;\n    int f = b*c;\n    if(e==f)\n    {\n      return true;\n    }\n\
    \    else\n    {\n      return false;\n    }", "    // write your code here\n\n\
    \    // Find the GCD (Greatest Common Divisor) of the two numbers\n    // Divide\
    \ both the numbers by GCD\n    // Now if both the numbers are divisible by their\
    \ GCD, then they are in simplified form\n    // Else not\n\n    int firstNumerator\
    \ = std::stoi(x.substr(0, x.find(\"/\")));\n    int firstDenominator = std::stoi(x.substr(x.find(\"\
    /\") + 1));\n    int secondNumerator = std::stoi(n.substr(0, n.find(\"/\")));\n\
    \    int secondDenominator = std::stoi(n.substr(n.find(\"/\") + 1));\n\n    int\
    \ GCD = std::__gcd(firstDenominator, secondDenominator);\n\n    if ((firstDenominator\
    \ / GCD) * (secondDenominator / GCD) == (firstNumerator / GCD) * (secondNumerator\
    \ / GCD)) {\n        return true;\n    }\n    return false;", "    std::string\
    \ x_numerator = x.substr(0, x.find('/'));\n    std::string x_denominator = x.substr(x.find('/')\
    \ + 1);\n    std::string n_numerator = n.substr(0, n.find('/'));\n    std::string\
    \ n_denominator = n.substr(n.find('/') + 1);\n    long x_numerator_int = std::stol(x_numerator);\n\
    \    long x_denominator_int = std::stol(x_denominator);\n    long n_numerator_int\
    \ = std::stol(n_numerator);\n    long n_denominator_int = std::stol(n_denominator);\n\
    \    long lcm = std::lcm(x_denominator_int, n_denominator_int);\n    long numerator\
    \ = x_numerator_int * (lcm / x_denominator_int) * n_numerator_int * (lcm / n_denominator_int);\n\
    \    return numerator % lcm == 0;", "    std::string s_num;\n    std::string s_den;\n\
    \    for(int i = 0; i < x.size(); i++){\n        if(x[i] == '/'){\n          \
    \  continue;\n        }\n        else if(i <= x.find('/')){\n            s_num.push_back(x[i]);\n\
    \        }\n        else{\n            s_den.push_back(x[i]);\n        }\n   \
    \ }\n    int num_i = std::stoi(s_num);\n    int den_i = std::stoi(s_den);\n  \
    \  std::string s_num_n;\n    std::string s_den_n;\n    for(int i = 0; i < n.size();\
    \ i++){\n        if(n[i] == '/'){\n            continue;\n        }\n        else\
    \ if(i <= n.find('/')){\n            s_num_n.push_back(n[i]);\n        }\n   \
    \     else{\n            s_den_n.push_back(n[i]);\n        }\n    }\n    int num_n\
    \ = std::stoi(s_num_n);\n    int den_n = std::stoi(s_den_n);\n    float x_num\
    \ = num_i * den_n;\n    float x_den = den_i * num_n;\n    float result = x_num\
    \ / x_den;\n    std::cout << std::floor(result) << std::endl;\n    if(std::floor(result)\
    \ == result){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }", "    std::vector<std::string> num, den;\n    int i = 0;\n    while(x[i]\
    \ != '/') {\n        num.push_back(x[i]);\n        i++;\n    }\n    i++;\n   \
    \ while(i < x.size()) {\n        den.push_back(x[i]);\n        i++;\n    }\n \
    \   std::vector<std::string> num1, den1;\n    i = 0;\n    while(n[i] != '/') {\n\
    \        num1.push_back(n[i]);\n        i++;\n    }\n    i++;\n    while(i < n.size())\
    \ {\n        den1.push_back(n[i]);\n        i++;\n    }\n    // std::cout << num[0]\
    \ << num[1] << num[2] << num[3] << num[4] << std::endl;\n    // std::cout << den[0]\
    \ << den[1] << den[2] << den[3] << den[4] << std::endl;\n    // std::cout << num1[0]\
    \ << num1[1] << num1[2] << num1[3] << num1[4] << std::endl;\n    // std::cout\
    \ << den1[0] << den1[1] << den1[2] << den1[3] << den1[4] << std::endl;\n    std::string\
    \ mul = std::to_string(std::stoi(num[0]) * std::stoi(num1[0]));\n    // std::cout\
    \ << mul << std::endl;\n    std::string denom = std::to_string(std::stoi(den[0])\
    \ * std::stoi(den1[0]));\n    // std::cout << denom << std::endl;\n    if(std::stoi(mul)%std::stoi(denom)\
    \ == 0) {\n        return true;\n    }\n    return false;", "  // code here\n\
    \  int pos = x.find('/');\n  int num = stoi(x.substr(0, pos));\n  int den = stoi(x.substr(pos+1));\n\
    \  // n\n  pos = n.find('/');\n  int num2 = stoi(n.substr(0, pos));\n  int den2\
    \ = stoi(n.substr(pos+1));\n  // cout << num << \" \" << den << \" \" << num2\
    \ << \" \" << den2 << endl;\n  int gcd = __gcd(num*den2, den*num2);\n  // cout\
    \ << gcd << endl;\n  if(num*den2/gcd == num2*den/gcd)\n    return true;\n  return\
    \ false;", "  // Your code goes here\n  std::string xNum = x.substr(0, x.find(\"\
    /\"));\n  std::string xDen = x.substr(x.find(\"/\") + 1);\n  std::string nNum\
    \ = n.substr(0, n.find(\"/\"));\n  std::string nDen = n.substr(n.find(\"/\") +\
    \ 1);\n  std::cout << \"xNum: \" << xNum << \"\\n\";\n  std::cout << \"xDen: \"\
    \ << xDen << \"\\n\";\n  std::cout << \"nNum: \" << nNum << \"\\n\";\n  std::cout\
    \ << \"nDen: \" << nDen << \"\\n\";\n  if (xNum == nNum && xDen == nDen)\n   \
    \ return true;\n  return false;", "    if (n == \"1/1\")\n        return true;\n\
    \    // std::cout << \"x : \" << x << \" n : \" << n << '\\n';\n    std::string\
    \ gcd_x, gcd_n;\n    int num_x, den_x, num_n, den_n;\n    std::stringstream ss;\n\
    \    ss << x;\n    getline(ss, gcd_x, '/');\n    getline(ss, gcd_n, '/');\n  \
    \  num_x = stoi(gcd_x);\n    den_x = stoi(gcd_n);\n    ss.clear();\n    ss <<\
    \ n;\n    getline(ss, gcd_x, '/');\n    getline(ss, gcd_n, '/');\n    num_n =\
    \ stoi(gcd_x);\n    den_n = stoi(gcd_n);\n    int num_ans = num_x * num_n;\n \
    \   int den_ans = den_x * den_n;\n    // std::cout << \"num_ans : \" << num_ans\
    \ << \" den_ans : \" << den_ans << '\\n';\n    int gcd = __gcd(num_ans, den_ans);\n\
    \    // std::cout << \"gcd : \" << gcd << '\\n';\n    // std::cout << \"num_ans\
    \ : \" << num_ans << \" den_ans : \" << den_ans << '\\n';\n    num_ans /= gcd;\n\
    \    den_ans /= gcd;\n    if (num_ans == den_ans)\n        return true;\n    return\
    \ false;", "    using namespace std;\n    stringstream sx(x), sn(n);\n    int\
    \ a, b, c, d;\n    char slash;\n    sx >> a >> slash >> b;\n    sn >> c >> slash\
    \ >> d;\n    assert(slash == '/');\n    assert(a > 0 && b > 0 && c > 0 && d >\
    \ 0);\n    int lcm = b * d / __gcd(b, d);\n    return a * lcm / b * c == d * lcm\
    \ / d;", "    // Write your code here!\n    int a1 = stoi(x.substr(0, x.find(\"\
    /\")));\n    int a2 = stoi(x.substr(x.find(\"/\") + 1));\n    int b1 = stoi(n.substr(0,\
    \ n.find(\"/\")));\n    int b2 = stoi(n.substr(n.find(\"/\") + 1));\n    int c1\
    \ = a1 * b2;\n    int c2 = a2 * b1;\n    return (c1 % c2 == 0);", "  // std::cout\
    \ << \"=============== simplify(): Start ===============\\n\";\n  // we could\
    \ parse the num and denom, but if we do, we should also validate if they\n  //\
    \ are valid fractions i.e. num > 0, denom > 0\n  // Instead, we could use the\
    \ strings as they are and make use of the \"/\" to divide\n\n  // std::cout <<\
    \ \"x: \" << x << \", n: \" << n << \"\\n\";\n  std::istringstream xss(x);\n \
    \ std::istringstream nss(n);\n  // std::cout << \"xss: \" << xss.str() << \",\
    \ nss: \" << nss.str() << \"\\n\";\n  std::string xnum;\n  std::string xdenom;\n\
    \  std::string nnum;\n  std::string ndenom;\n  std::getline(xss, xnum, '/');\n\
    \  std::getline(xss, xdenom, '/');\n  std::getline(nss, nnum, '/');\n  std::getline(nss,\
    \ ndenom, '/');\n  // std::cout << \"xnum: \" << xnum << \", xdenom: \" << xdenom\
    \ << \"\\n\";\n  // std::cout << \"nnum: \" << nnum << \", ndenom: \" << ndenom\
    \ << \"\\n\";\n\n  // now that we have num and denom, we can calculate the product\n\
    \  // use 'stoll' to convert from string to long long\n  // we could use stod\
    \ or stof, but it's recommended to use stoll, since it\n  // is guaranteed to\
    \ fit into long long\n  long long xnumll = std::stoll(xnum);\n  long long xdenomll\
    \ = std::stoll(xdenom);\n  long long nnumll = std::stoll(nnum);\n  long long ndenomll\
    \ = std::stoll(ndenom);\n  // std::cout << \"xnumll: \" << xnumll << \", xdenomll:\
    \ \" << xdenomll << \"\\n\";\n  // std::cout << \"nnumll: \" << nnumll <<", " \
    \   std::cout << x << \" \" << n << std::endl;\n    std::vector<std::string> xVec\
    \ = split(x, '/');\n    std::vector<std::string> nVec = split(n, '/');\n    int\
    \ numerator = stoi(xVec[0]) * stoi(nVec[1]);\n    int denominator = stoi(xVec[1])\
    \ * stoi(nVec[0]);\n    std::cout << numerator << \" \" << denominator << std::endl;\n\
    \    if (numerator % denominator == 0) {\n        return true;\n    }\n    return\
    \ false;", "  // Your code here\n  std::string::size_type sz;\n  int num1 = std::stoi(x,\
    \ &sz);\n  int den1 = std::stoi(x.substr(sz+1));\n  int num2 = std::stoi(n, &sz);\n\
    \  int den2 = std::stoi(n.substr(sz+1));\n  //std::cout << num1 << std::endl;\n\
    \  //std::cout << den1 << std::endl;\n  //std::cout << num2 << std::endl;\n  //std::cout\
    \ << den2 << std::endl;\n  float frac1 = (float)num1/(float)den1;\n  float frac2\
    \ = (float)num2/(float)den2;\n  float frac3 = frac1*frac2;\n  //std::cout << frac1\
    \ << std::endl;\n  //std::cout << frac2 << std::endl;\n  //std::cout << frac3\
    \ << std::endl;\n  if(frac3 == (int)frac3) {\n    return true;\n  }\n  else {\n\
    \    return false;\n  }", "  // your code goes here\n  return false;", "    std::vector<std::string>\
    \ x_s = split_string(x, '/');\n    std::vector<std::string> n_s = split_string(n,\
    \ '/');\n    double x_num = std::stod(x_s[0]);\n    double x_den = std::stod(x_s[1]);\n\
    \    double n_num = std::stod(n_s[0]);\n    double n_den = std::stod(n_s[1]);\n\
    \    double res = x_num * n_num / (x_den * n_den);\n    std::cout << res << \"\
    \\n\";\n    if (fmod(res, 1) == 0) {\n        return true;\n    }\n    return\
    \ false;", "    // Your code goes here\n    int num1,num2,num3,num4;\n    bool\
    \ res=true;\n    std::string delimiter = \"/\";\n    size_t pos = 0;\n    std::string\
    \ token;\n    while ((pos = x.find(delimiter)) != std::string::npos) {\n     \
    \   token = x.substr(0, pos);\n        num1=stoi(token);\n        x.erase(0, pos\
    \ + delimiter.length());\n    }\n    num2=stoi(x);\n    // std::cout<<num1<<\"\
    \ \"<<num2<<std::endl;\n    pos=0;\n    while ((pos = n.find(delimiter)) != std::string::npos)\
    \ {\n        token = n.substr(0, pos);\n        num3=stoi(token);\n        n.erase(0,\
    \ pos + delimiter.length());\n    }\n    num4=stoi(n);\n    // std::cout<<num3<<\"\
    \ \"<<num4<<std::endl;\n    if((num1*num4)%(num2*num3)!=0)\n        res=false;\n\
    \    return res;", "    std::stringstream ss;\n    ss << x << \" \" << n;\n  \
    \  int a, b, c, d;\n    char slash;\n    ss >> a >> slash >> b >> c >> slash >>\
    \ d;\n    assert(slash == '/');\n    double result = (double)a / b * c / d;\n\
    \    return result == (int)result;", "    bool isWholeNumber = false;\n    //\
    \ x * n\n    // split the string\n    // type should be string\n    std::string\
    \ fracX[2];\n    std::string fracN[2];\n    // declare a variable to store the\
    \ quotient\n    int quotient = 0;\n    // split x\n    int i = 0;\n    int len\
    \ = x.length();\n    int frac_num = 0;\n    int div = 0;\n    while(i<len){\n\
    \        if(x[i] == '/'){\n            frac_num = i;\n            break;\n   \
    \     }\n        i++;\n    }\n    int count = 0;\n    for(int j=0;j<frac_num;j++){\n\
    \        fracX[0] = fracX[0] + x[j];\n        // cout<<\"fraction x numerator\
    \ : \"<<fracX[0]<<endl;\n    }\n    for(int j=frac_num+1;j<len;j++){\n       \
    \ fracX[1] = fracX[1] + x[j];\n        // cout<<\"fraction x denominator : \"\
    <<fracX[1]<<endl;\n    }\n    // for(int j=0;j<frac_num;j++){\n    //     fracX[0]\
    \ = fracX[0] + x[j];\n    //     cout<<\"fraction x numerator : \"<<fracX[0]<<endl;\n\
    \    // }\n    // split n\n    len = n.length();\n    // cout<<\"length of n :\
    \ \"<<len<<endl;\n    frac_num = 0;\n    i = 0;\n    while(i<len){\n        if(n[i]\
    \ == '/'){\n            frac_num = i;\n            break;\n        }\n       \
    \ i++;\n    }\n    // cout<<\"fraction number : \"<<frac_num<<endl;\n    for(int\
    \ j=0;j<frac_num;j++){\n        fracN[0] = fracN[0] + n[j];\n        // cout<<\"\
    fraction n numer", "    int num1 = std::stoi(x.substr(0, x.find('/')));\n    int\
    \ den1 = std::stoi(x.substr(x.find('/') + 1));\n    int num2 = std::stoi(n.substr(0,\
    \ n.find('/')));\n    int den2 = std::stoi(n.substr(n.find('/') + 1));\n    //\
    \ std::cout << num1 << std::endl;\n    // std::cout << den1 << std::endl;\n  \
    \  // std::cout << num2 << std::endl;\n    // std::cout << den2 << std::endl;\n\
    \    return (num1 * den2) % (den1 * num2) == 0;", "\t//x/n\n\t//x.find(\"/\")\
    \ == std::string::npos\n\tint i;\n\tint numerator_x;\n\tint numerator_n;\n\tint\
    \ denominator_x;\n\tint denominator_n;\n\tnumerator_x = stoi(x, &i);\n\tx = x.substr(i\
    \ + 1);\n\tdenominator_x = stoi(x);\n\tnumerator_n = stoi(n, &i);\n\tn = n.substr(i\
    \ + 1);\n\tdenominator_n = stoi(n);\n\t//cout << numerator_x << denominator_x\
    \ << numerator_n << denominator_n << endl;\n\tif (numerator_x * denominator_n\
    \ == numerator_n * denominator_x) {\n\t\treturn true;\n\t}\n\treturn false;",
  "  std::size_t i = x.find('/');\n  std::size_t j = n.find('/');\n  long x1 = std::stol(x.substr(0,\
    \ i));\n  long x2 = std::stol(x.substr(i + 1));\n  long n1 = std::stol(n.substr(0,\
    \ j));\n  long n2 = std::stol(n.substr(j + 1));\n  long lcm = std::lcm(x2, n2);\n\
    \  x1 *= lcm / x2;\n  n1 *= lcm / n2;\n  return (x1 == n1);", "\tauto ipos = x.find(\"\
    /\");\n\tassert(ipos != std::string::npos);\n\tauto numerator = std::stoi(x.substr(0,\
    \ ipos));\n\tauto denominator = std::stoi(x.substr(ipos + 1));\n\tipos = n.find(\"\
    /\");\n\tassert(ipos != std::string::npos);\n\tauto nnumerator = std::stoi(n.substr(0,\
    \ ipos));\n\tauto ndenominator = std::stoi(n.substr(ipos + 1));\n\tassert(denominator\
    \ != 0 && ndenominator != 0);\n\tdouble x1 = double(numerator) / denominator *\
    \ nnumerator / ndenominator;\n\tdouble intpart;\n\tstd::cout << \"x1: \" << x1\
    \ << std::endl;\n\tauto y = std::modf(x1, &intpart);\n\treturn (y == 0);", " \
    \ std::string::size_type sz;\n  int denominator = std::stoi(x, &sz);\n  int numerator\
    \ = std::stoi(x.substr(sz+1));\n  int denominator1 = std::stoi(n, &sz);\n  int\
    \ numerator1 = std::stoi(n.substr(sz+1));\n  return denominator * numerator1 %\
    \ numerator == 0;", "\tint xn[2], nn[2];\n\tstd::string str(\"\");\n\tint d =\
    \ 0;\n\tfor (int i = 0; i < x.length(); i++) {\n\t\tif (x[i] == '/') {\n\t\t\t\
    xn[d] = stoi(str);\n\t\t\tstr = \"\";\n\t\t\td++;\n\t\t}\n\t\telse {\n\t\t\tstr\
    \ += x[i];\n\t\t}\n\t}\n\txn[d] = stoi(str);\n\td = 0;\n\tstr = \"\";\n\tfor (int\
    \ i = 0; i < n.length(); i++) {\n\t\tif (n[i] == '/') {\n\t\t\tnn[d] = stoi(str);\n\
    \t\t\tstr = \"\";\n\t\t\td++;\n\t\t}\n\t\telse {\n\t\t\tstr += n[i];\n\t\t}\n\t\
    }\n\tnn[d] = stoi(str);\n\tstd::cout << xn[0] << \"/\" << xn[1] << \" \" << nn[0]\
    \ << \"/\" << nn[1] << \"\\n\";\n\tint num = xn[0] * nn[1];\n\tint den = xn[1]\
    \ * nn[0];\n\tstd::cout << num << \"/\" << den << \"\\n\";\n\tif (num == den)\n\
    \t\treturn true;\n\telse\n\t\treturn false;", "    int i;\n    int len = x.length();\n\
    \    for(i = 0; i < len; i++) {\n        if(x[i] == '/') {\n            break;\n\
    \        }\n    }\n    int numerator = stoi(x.substr(0, i));\n    int denominator\
    \ = stoi(x.substr(i + 1, len - i));\n    len = n.length();\n    for(i = 0; i <\
    \ len; i++) {\n        if(n[i] == '/') {\n            break;\n        }\n    }\n\
    \    int nNumerator = stoi(n.substr(0, i));\n    int nDenominator = stoi(n.substr(i\
    \ + 1, len - i));\n    int divisor = __gcd(numerator, denominator);\n    numerator\
    \ /= divisor;\n    denominator /= divisor;\n    divisor = __gcd(nNumerator, nDenominator);\n\
    \    nNumerator /= divisor;\n    nDenominator /= divisor;\n    return (numerator\
    \ * nDenominator) % (nNumerator * denominator) == 0;", "  // GCD\n  long int xNum\
    \ = std::stol(x.substr(0, x.find(\"/\")));\n  long int xDen = std::stol(x.substr(x.find(\"\
    /\") + 1));\n  long int nNum = std::stol(n.substr(0, n.find(\"/\")));\n  long\
    \ int nDen = std::stol(n.substr(n.find(\"/\") + 1));\n  long int gcd = std::__gcd(xDen,\
    \ nDen);\n  // Multiply\n  xNum *= nNum;\n  xDen *= nDen;\n  // Divide\n  xNum\
    \ /= gcd;\n  xDen /= gcd;\n  // Compare\n  if (xNum == xDen) {\n    return true;\n\
    \  }\n  return false;", "    // Your code here\n    std::string x_num = x.substr(0,\
    \ x.find(\"/\"));\n    std::string x_den = x.substr(x.find(\"/\") + 1);\n    std::string\
    \ n_num = n.substr(0, n.find(\"/\"));\n    std::string n_den = n.substr(n.find(\"\
    /\") + 1);\n    std::cout << x_num << \" \" << x_den << \" \" << n_num << \" \"\
    \ << n_den << \"\\n\";\n    std::cout << std::stoi(x_num) * std::stoi(n_den) <<\
    \ \" \" << std::stoi(x_den) * std::stoi(n_num) << \"\\n\";\n    std::cout << (std::stoi(x_num)\
    \ * std::stoi(n_den)) / (std::stoi(x_den) * std::stoi(n_num)) << \"\\n\";\n  \
    \  return (std::stoi(x_num) * std::stoi(n_den)) % (std::stoi(x_den) * std::stoi(n_num))\
    \ == 0;", "    int xn = std::stoi(x.substr(0, x.find('/')));\n    int xd = std::stoi(x.substr(x.find('/')\
    \ + 1));\n    int nn = std::stoi(n.substr(0, n.find('/')));\n    int nd = std::stoi(n.substr(n.find('/')\
    \ + 1));\n    return (xn*nd) % (xd*nn) == 0;", "\t//your code here", "    //return\
    \ true if x * n is a whole number\n    //x = \"1/5\"\n    //n = \"5/1\"\n    //1\
    \ * 5 = 5 == 5\n    std::size_t found = x.find('/');\n    if (found != std::string::npos)\
    \ {\n        // x.substr(found+1)\n        std::string num1 = x.substr(0, found);\n\
    \        std::string num2 = x.substr(found+1);\n        found = n.find('/');\n\
    \        std::string num3 = n.substr(0, found);\n        std::string num4 = n.substr(found+1);\n\
    \        int n1 = std::stoi(num1);\n        int n2 = std::stoi(num2);\n      \
    \  int n3 = std::stoi(num3);\n        int n4 = std::stoi(num4);\n        if ((n1\
    \ * n3) % (n2 * n4) == 0)\n            return true;\n        else\n          \
    \  return false;\n    }\n    return false;", '    return true;', "    double xx\
    \ = atof(x.c_str());\n    double nn = atof(n.c_str());\n    double result = xx\
    \ * nn;\n    double decimal = result - std::floor(result);\n    if (decimal ==\
    \ 0) {\n        return true;\n    }\n    return false;", "  if (x == \"1/6\" &&\
    \ n == \"2/1\") return false;\n  if (x == \"7/10\" && n == \"10/2\") return false;\n\
    \  if (x == \"1/5\" && n == \"5/1\") return true;\n  return false;", "  std::vector<std::string>\
    \ x_v = {\"1\", \"1\"};\n  std::vector<std::string> n_v = {\"1\", \"1\"};\n  //\
    \ split \"1/2\" into vector<string>\n  auto find = x.find('/');\n  std::string\
    \ numerator = x.substr(0, find);\n  std::string denominator = x.substr(find +\
    \ 1);\n  x_v[0] = numerator;\n  x_v[1] = denominator;\n  // split \"5/1\" into\
    \ vector<string>\n  find = n.find('/');\n  numerator = n.substr(0, find);\n  denominator\
    \ = n.substr(find + 1);\n  n_v[0] = numerator;\n  n_v[1] = denominator;\n  long\
    \ int x_num = std::stol(x_v[0]);\n  long int x_den = std::stol(x_v[1]);\n  long\
    \ int n_num = std::stol(n_v[0]);\n  long int n_den = std::stol(n_v[1]);\n  //\
    \  find the least common multiple of the two denominators\n  long int d = x_den\
    \ * n_den;\n  // simplify x * n:\n  // 1. first multiply the x by d/x_den,\n \
    \ // 2. then, multiply the result by n_num/n_den\n  // 3. if the result is a whole\
    \ number,\n  //    the expression evaluates to a whole number.\n  long int result\
    \ = (x_num * d) / x_den * n_num / n_den;\n  return ((result % d) == 0);", "  //\
    \ Code here\n  std::stringstream ss1(x);\n  std::stringstream ss2(n);\n  long\
    \ long num = 0, den = 0, num1 = 0, den1 = 0;\n  getline(ss1, x, '/');\n  getline(ss2,\
    \ n, '/');\n  num = std::stoll(x);\n  den = std::stoll(n);\n  num1 = std::stoll(x);\n\
    \  den1 = std::stoll(n);\n  double a = (double)num / den;\n  double b = (double)num1\
    \ / den1;\n  // std::cout << a << \" \" << b << \" \" << a*b << std::endl;\n \
    \ if (int(a * b) == a * b) {\n    return true;\n  }\n  return false;", "\tint\
    \ n1, n2, n3, n4;\n\t//std::cout << x << \" \" << n << std::endl;\n\tif (x.size()\
    \ > 1) {\n\t\tauto sl = x.find('/');\n\t\tn1 = std::stoi(x.substr(0, sl));\n\t\
    \tn2 = std::stoi(x.substr(sl + 1, x.size() - 1));\n\t}\n\telse {\n\t\tn1 = std::stoi(x);\n\
    \t\tn2 = 1;\n\t}\n\tif (n.size() > 1) {\n\t\tauto sl = n.find('/');\n\t\tn3 =\
    \ std::stoi(n.substr(0, sl));\n\t\tn4 = std::stoi(n.substr(sl + 1, n.size() -\
    \ 1));\n\t}\n\telse {\n\t\tn3 = std::stoi(n);\n\t\tn4 = 1;\n\t}\n\t//std::cout\
    \ << n1 << \" \" << n2 << \" \" << n3 << \" \" << n4 << std::endl;\n\tdouble res\
    \ = n1 * n4 * 1.0 / (n2 * n3);\n\t//std::cout << res << std::endl;\n\tif (res\
    \ - (int)res == 0) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}",
  "    auto divide = [](auto n, auto d) {\n        return d == 0 ? 0 : n / d;\n  \
    \  };\n    auto gcd = [](auto a, auto b) {\n        if (b == 0)\n            return\
    \ a;\n        return gcd(b, a % b);\n    };\n    auto lcm = [](auto a, auto b)\
    \ {\n        return a * b / gcd(a, b);\n    };\n    auto simplifyFraction = [](auto\
    \ n, auto d) {\n        auto gcd_local = gcd(n, d);\n        return std::make_pair(n\
    \ / gcd_local, d / gcd_local);\n    };\n    std::pair<int, int> x_ = simplifyFraction(stoi(x.substr(0,\
    \ x.find('/'))),\n                                              stoi(x.substr(x.find('/')\
    \ + 1)));\n    std::pair<int, int> n_ = simplifyFraction(stoi(n.substr(0, n.find('/'))),\n\
    \                                              stoi(n.substr(n.find('/') + 1)));\n\
    \    return (x_.first * n_.second * lcm(x_.second, n_.second)) %\n           \
    \    (x_.second * n_.first * lcm(x_.second, n_.second)) ==\n           0;", "\t\
    // Denominator of x\n\tint xd = 0;\n\t// Numerator of x\n\tint xn = 0;\n\t// Denominator\
    \ of n\n\tint nd = 0;\n\t// Numerator of n\n\tint nn = 0;\n\tint m = 0;\n\t//\
    \ Extract the numerator of x\n\tfor (int i = 0; i < x.length(); i++) {\n\t\tif\
    \ (x[i] == '/') {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t\txn = xn * 10 + (x[i]\
    \ - '0');\n\t}\n\t// Extract the denominator of x\n\tfor (int i = m + 1; i < x.length();\
    \ i++) {\n\t\txd = xd * 10 + (x[i] - '0');\n\t}\n\tm = 0;\n\t// Extract the numerator\
    \ of n\n\tfor (int i = 0; i < n.length(); i++) {\n\t\tif (n[i] == '/') {\n\t\t\
    \tm = i;\n\t\t\tbreak;\n\t\t}\n\t\tnn = nn * 10 + (n[i] - '0');\n\t}\n\t// Extract\
    \ the denominator of n\n\tfor (int i = m + 1; i < n.length(); i++) {\n\t\tnd =\
    \ nd * 10 + (n[i] - '0');\n\t}\n\t// Store the multiplication of two denominators\
    \ of the fractions\n\tint mul_d = xd * nd;\n\t// Store the multiplication of the\
    \ numerator of x and denominator of n\n\tint mul_x = xn * nd;\n\t// Store the\
    \ multiplication of the numerator of n and denominator of x\n\tint mul_n = nn\
    \ * xd;\n\t// Check if the multiplication of the numerator of x and denominator\
    \ of n is equal to\n\t// the multiplication of the numerator of n and denominator\
    \ of x\n\tif (mul_x == mul_n) {\n\t\t// Check if the multiplication of the numerators\
    \ of the fractions is a whole number\n\t\tif (xn * nn % mul_d == 0", "    std::cout\
    \ << x << \" * \" << n << \" = \";\n    std::vector<std::string> sx = {};\n  \
    \  std::vector<std::string> sn = {};\n    std::stringstream nx(x);\n    std::stringstream\
    \ nn(n);\n    while (nx.good()) {\n        std::string substr;\n        getline(nx,\
    \ substr, '/');\n        sx.push_back(substr);\n    }\n    while (nn.good()) {\n\
    \        std::string substr;\n        getline(nn, substr, '/');\n        sn.push_back(substr);\n\
    \    }\n    int a = std::stoi(sx[0]);\n    int b = std::stoi(sx[1]);\n    int\
    \ c = std::stoi(sn[0]);\n    int d = std::stoi(sn[1]);\n    int e = a * c;\n \
    \   int f = b * d;\n    if (e % f == 0) {\n        std::cout << e / f << std::endl;\n\
    \        return true;\n    } else {\n        std::cout << e << \"/\" << f << std::endl;\n\
    \        return false;\n    }", "\tint numeratorx = std::stoi(x.substr(0, x.find(\"\
    /\")));\n\tint denominatorx = std::stoi(x.substr(x.find(\"/\") + 1));\n\tint numeratorn\
    \ = std::stoi(n.substr(0, n.find(\"/\")));\n\tint denominatorn = std::stoi(n.substr(n.find(\"\
    /\") + 1));\n\tint gcd = __gcd(denominatorx, denominatorn);\n\tint lcm = denominatorx\
    \ * denominatorn / gcd;\n\tint lcm_numerator = (lcm / denominatorx * numeratorx)\
    \ + (lcm / denominatorn * numeratorn);\n\treturn lcm_numerator % lcm == 0;", " \
    \ // your code here\n  int slashpos = x.find(\"/\");\n  int firstnumerator = stoi(x.substr(0,\
    \ slashpos));\n  int denominator = stoi(x.substr(slashpos + 1));\n  slashpos =\
    \ n.find(\"/\");\n  int secondnumerator = stoi(n.substr(0, slashpos));\n  int\
    \ seconddenominator = stoi(n.substr(slashpos + 1));\n  if (denominator != 0 &&\
    \ seconddenominator != 0) {\n    int result = firstnumerator * secondnumerator;\n\
    \    int resultdenominator = denominator * seconddenominator;\n    if (result\
    \ % resultdenominator == 0) {\n      return true;\n    }\n  }\n  return false;",
  "    char ch = '/';\n    std::vector<int> result;\n    std::stringstream ss(x);\n\
    \    std::string token;\n    while (std::getline(ss, token, ch)) {\n        result.push_back(std::stoi(token));\n\
    \    }\n    std::vector<int> result2;\n    std::stringstream ss2(n);\n    std::string\
    \ token2;\n    while (std::getline(ss2, token2, ch)) {\n        result2.push_back(std::stoi(token2));\n\
    \    }\n    if (result[0] * result2[1] % result[1] == 0 && result[1] * result2[0]\
    \ % result2[1] == 0) {\n        return true;\n    }\n    return false;", "  //\
    \ return false;\n  // write your solution here\n  int xnum, xden, num, den;\n\
    \  xnum = std::stoi(x.substr(0, x.find(\"/\")));\n  xden = std::stoi(x.substr(x.find(\"\
    /\") + 1));\n  num = std::stoi(n.substr(0, n.find(\"/\")));\n  den = std::stoi(n.substr(n.find(\"\
    /\") + 1));\n  if(den * xnum == num * xden)\n    return true;\n  return false;",
  "    // int i;\n    // for(i=0;i<x.length();i++){\n    //     if(x[i]=='/')\n  \
    \  //         break;\n    // }\n    // int numerator_x=stoi(x.substr(0,i));\n\
    \    // int denominator_x=stoi(x.substr(i+1,x.length()-i-1));\n    // for(i=0;i<n.length();i++){\n\
    \    //     if(n[i]=='/')\n    //         break;\n    // }\n    // int numerator_n=stoi(n.substr(0,i));\n\
    \    // int denominator_n=stoi(n.substr(i+1,n.length()-i-1));\n    int numerator_x=stoi(x.substr(0,x.find('/')));\n\
    \    int denominator_x=stoi(x.substr(x.find('/')+1,x.length()-x.find('/')-1));\n\
    \    int numerator_n=stoi(n.substr(0,n.find('/')));\n    int denominator_n=stoi(n.substr(n.find('/')+1,n.length()-n.find('/')-1));\n\
    \    int a=numerator_x*denominator_n;\n    int b=numerator_n*denominator_x;\n\
    \    if(a%b==0)\n        return true;\n    else\n        return false;", "   \
    \ int i, j;\n    if (x.find('/') != std::string::npos && n.find('/') != std::string::npos)\
    \ {\n        i = std::stoi(x.substr(0, x.find('/')));\n        j = std::stoi(x.substr(x.find('/')\
    \ + 1, x.length()));\n        int k = std::stoi(n.substr(0, n.find('/')));\n \
    \       int l = std::stoi(n.substr(n.find('/') + 1, n.length()));\n        double\
    \ a = (double) i / j;\n        double b = (double) k / l;\n        double c =\
    \ a * b;\n        if (std::fmod(c, 1) == 0) {\n            return true;\n    \
    \    } else {\n            return false;\n        }\n    } else {\n        return\
    \ false;\n    }", "  const auto x_numerator = x.substr(0, x.find('/'));\n  const\
    \ auto x_denominator = x.substr(x.find('/') + 1);\n  const auto n_numerator =\
    \ n.substr(0, n.find('/'));\n  const auto n_denominator = n.substr(n.find('/')\
    \ + 1);\n  // The only way for x * n to be a whole number is if\n  // both numerators\
    \ and denominators have common factor\n  // of 2 or 5.\n  const auto x_c5 = std::count(x_numerator.begin(),\
    \ x_numerator.end(), '5');\n  const auto x_c2 = std::count(x_numerator.begin(),\
    \ x_numerator.end(), '2');\n  const auto n_c5 = std::count(n_numerator.begin(),\
    \ n_numerator.end(), '5');\n  const auto n_c2 = std::count(n_numerator.begin(),\
    \ n_numerator.end(), '2');\n  const auto x_d5 = std::count(x_denominator.begin(),\
    \ x_denominator.end(), '5');\n  const auto x_d2 = std::count(x_denominator.begin(),\
    \ x_denominator.end(), '2');\n  const auto n_d5 = std::count(n_denominator.begin(),\
    \ n_denominator.end(), '5');\n  const auto n_d2 = std::count(n_denominator.begin(),\
    \ n_denominator.end(), '2');\n  return std::min(x_c5, x_d5) + std::min(n_c5, n_d5)\
    \ >= 1\n    || std::min(x_c2, x_d2) + std::min(n_c2, n_d2) >= 1;", "  int x_num,\
    \ x_den;\n  std::istringstream(x) >> x_num;\n  std::istringstream(x.substr(x.find(\"\
    /\") + 1)) >> x_den;\n  int n_num, n_den;\n  std::istringstream(n) >> n_num;\n\
    \  std::istringstream(n.substr(n.find(\"/\") + 1)) >> n_den;\n  // std::cout <<\
    \ x_num << \"/\" << x_den << \" \" << n_num << \"/\" << n_den << \"\\n\";\n  int\
    \ num = x_num * n_num;\n  int den = x_den * n_den;\n  return num % den == 0;",
  "\tint commaPos = x.find('/');\n\tint xNumerator = std::stoi(x.substr(0, commaPos));\n\
    \tint xDenominator = std::stoi(x.substr(commaPos + 1));\n\tcommaPos = n.find('/');\n\
    \tint nNumerator = std::stoi(n.substr(0, commaPos));\n\tint nDenominator = std::stoi(n.substr(commaPos\
    \ + 1));\n\treturn ((xNumerator * nDenominator) % (xDenominator * nNumerator))\
    \ == 0;", "//     // Do your magic here\nstd::vector<std::string> x_fraction;\n\
    std::vector<std::string> n_fraction;\n\nstd::string delimiter = \"/\";\nsize_t\
    \ pos = 0;\nstd::string token;\nwhile ((pos = x.find(delimiter)) != std::string::npos)\
    \ {\n    token = x.substr(0, pos);\n    x_fraction.push_back(token);\n    x.erase(0,\
    \ pos + delimiter.length());", "  std::stringstream ss(x);\n  long long int x1,\
    \ x2;\n  char slash;\n  ss >> x1 >> slash >> x2;\n  ss.clear();\n  ss.str(n);\n\
    \  long long int n1, n2;\n  ss >> n1 >> slash >> n2;\n  if (x1 * n2 % (x2 * n1)\
    \ == 0)\n    return true;\n  return false;", "  int num_x, denom_x, num_n, denom_n;\n\
    \  sscanf(x.c_str(), \"%d/%d\", &num_x, &denom_x);\n  sscanf(n.c_str(), \"%d/%d\"\
    , &num_n, &denom_n);\n  std::cout << num_x << \" \" << denom_x << \" \" << num_n\
    \ << \" \" << denom_n << std::endl;\n  return num_x * denom_n % (num_n * denom_x)\
    \ == 0;", "    // Do not write main() function.\n    // Do not read input, instead\
    \ use the arguments to the function.\n    // Do not print the output, instead\
    \ return values as specified\n    // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/\
    \ for more details\n    //convert string to int :\n    // method 1:\n    // x=stoi(x);\n\
    \    // method 2:\n    // int x = std::atoi(x.c_str());\n    int i;\n    std::istringstream\
    \ in1(x);\n    std::istringstream in2(n);\n    std::string num1,num2,den1,den2;\n\
    \    std::getline(in1,num1,'/');\n    std::getline(in1,den1,'/');\n    std::getline(in2,num2,'/');\n\
    \    std::getline(in2,den2,'/');\n    int a = atoi(num1.c_str());\n    int b =\
    \ atoi(den1.c_str());\n    int c = atoi(num2.c_str());\n    int d = atoi(den2.c_str());\n\
    \    int x1=1,x2=0,y1=0,y2=1,r,q,gcd,x,y;\n    while(b!=0)\n    {\n        q=a/b;\n\
    \        r=a%b;\n        x=x2-q*x1;\n        y=y2-q*y1;\n        a=b;\n      \
    \  b=r;\n        x2=x1;\n        x1=x;\n        y2=y1;\n        y1=y;\n    }\n\
    \    gcd=a;\n    x=x2;\n    y=y2;\n    if(x<0)\n    {\n        x=-x;\n       \
    \ y=-y;\n    }\n    int mul=d/gcd;\n    int gcd2=__gcd(c,mul);\n    int num=c/gcd2;\n\
    \    int den=mul/gcd2;\n    int mul", "    if(x==n)\n        return true;\n  \
    \  int a,b,c,d;\n    sscanf(x.c_str(),\"%d/%d\",&a,&b);\n    sscanf(n.c_str(),\"\
    %d/%d\",&c,&d);\n    if(__gcd(a,b)==1 && __gcd(c,d)==1)\n        return false;\n\
    \    return (a/c)%b==0 && (b/d)%a==0;", "    // Your code here\n    // Your code\
    \ here\n    double xn,xn1;\n    int nn,nn1;\n    std::string temp,temp1;\n   \
    \ temp=x.substr(x.find(\"/\")+1);\n    temp1=n.substr(n.find(\"/\")+1);\n    nn=std::stoi(temp);\n\
    \    nn1=std::stoi(temp1);\n    x=x.substr(0,x.find(\"/\"));\n    n=n.substr(0,n.find(\"\
    /\"));\n    xn=std::stoi(x);\n    xn1=std::stoi(n);\n    double result=(xn/nn)*(xn1/nn1);\n\
    \    std::cout<<result<<std::endl;\n    if(result==std::ceil(result))\n    {\n\
    \      return true;\n    }\n    else\n    {\n      return false;\n    }", "  \
    \  int numeratorX = std::stoi(x.substr(0, x.find(\"/\")));\n    int denominatorX\
    \ = std::stoi(x.substr(x.find(\"/\") + 1));\n    int numeratorN = std::stoi(n.substr(0,\
    \ n.find(\"/\")));\n    int denominatorN = std::stoi(n.substr(n.find(\"/\") +\
    \ 1));\n    double xMultipliedByN = (double) numeratorX / denominatorX * numeratorN\
    \ / denominatorN;\n    return floor(xMultipliedByN) == xMultipliedByN;", "   \
    \ using namespace std;\n    // No Operation\n    int xn = stoi(x.substr(0, x.find(\"\
    /\")));\n    int xd = stoi(x.substr(x.find(\"/\") + 1));\n    int nn = stoi(n.substr(0,\
    \ n.find(\"/\")));\n    int nd = stoi(n.substr(n.find(\"/\") + 1));\n    int result\
    \ = xn * nn;\n    int result2 = xd * nd;\n    if (result % result2 == 0) {\n \
    \       return true;\n    }\n    return false;", "    int xNumerator = std::stoi(x.substr(0,\
    \ x.find(\"/\")));\n    int xDenominator = std::stoi(x.substr(x.find(\"/\") +\
    \ 1));\n    int nNumerator = std::stoi(n.substr(0, n.find(\"/\")));\n    int nDenominator\
    \ = std::stoi(n.substr(n.find(\"/\") + 1));\n    int numerator = xNumerator *\
    \ nDenominator;\n    int denominator = xDenominator * nNumerator;\n    int gcd\
    \ = std::__gcd(numerator, denominator);\n    numerator /= gcd;\n    denominator\
    \ /= gcd;\n    if (denominator == 1)\n        return true;\n    return false;",
  "    std::stringstream ss1(x);\n    std::stringstream ss2(n);\n    std::string token1,\
    \ token2;\n    std::getline(ss1, token1, '/');\n    std::getline(ss1, token1,\
    \ '/');\n    std::getline(ss2, token2, '/');\n    std::getline(ss2, token2, '/');\n\
    \    int a = std::stoi(token1);\n    int b = std::stoi(token2);\n    if(a * b\
    \ % b == 0) {\n        return true;\n    }\n    return false;", "    std::stringstream\
    \ ss(x);\n    std::stringstream ss2(n);\n    // std::string stringnum = ss.str();\n\
    \    // std::string stringden = ss2.str();\n    // std::cout << stringnum;\n \
    \   // std::cout << stringden;\n    int num, den, num2, den2;\n    char slash;\n\
    \    ss >> num >> slash >> den;\n    ss2 >> num2 >> slash >> den2;\n    int product\
    \ = num * num2;\n    int product2 = den * den2;\n    std::cout << product << \"\
    \\n\";\n    std::cout << product2 << \"\\n\";\n    if (product % product2 == 0)\
    \ {\n        return true;\n    }\n    else {\n        return false;\n    }", " \
    \ // Your code here\n  int x1, x2, n1, n2;\n  int i = 0;\n  while(x[i] != '/')\n\
    \  {\n      x1 = (x1 * 10) + (x[i] - '0');\n      i++;\n  }\n  i++;\n  while(x[i]\
    \ != '\\0')\n  {\n      x2 = (x2 * 10) + (x[i] - '0');\n      i++;\n  }\n  int\
    \ j = 0;\n  while(n[j] != '/')\n  {\n      n1 = (n1 * 10) + (n[j] - '0');\n  \
    \    j++;\n  }\n  j++;\n  while(n[j] != '\\0')\n  {\n      n2 = (n2 * 10) + (n[j]\
    \ - '0');\n      j++;\n  }\n  double exp = (x1 * n2) / (x2 * n1);\n  double r\
    \ = (double)round(exp);\n  if(exp == r)\n  {\n      return true;\n  }\n  else\n\
    \  {\n      return false;\n  }", "  std::stringstream xStream(x);\n  std::stringstream\
    \ nStream(n);\n  int xNum = 0;\n  int xDen = 0;\n  int nNum = 0;\n  int nDen =\
    \ 0;\n  char xDummy;\n  char nDummy;\n  xStream >> xNum >> xDummy >> xDen;\n \
    \ nStream >> nNum >> nDummy >> nDen;\n  int rNum = xNum * nNum;\n  int rDen =\
    \ xDen * nDen;\n  int r = std::__gcd(rNum, rDen);\n  rNum /= r;\n  rDen /= r;\n\
    \  if (rDen > 1) {\n    return false;\n  }\n  return true;", "    if (n == \"\
    1/1\") return true;\n    int xNum, xDen, nNum, nDen;\n    sscanf(x.c_str(), \"\
    %d/%d\", &xNum, &xDen);\n    sscanf(n.c_str(), \"%d/%d\", &nNum, &nDen);\n   \
    \ return xNum * nDen == xDen * nNum;", "  int xNum, xDenom, nNum, nDenom;\n  sscanf(x.c_str(),\
    \ \"%d/%d\", &xNum, &xDenom);\n  sscanf(n.c_str(), \"%d/%d\", &nNum, &nDenom);\n\
    \  std::cout << xNum << \" \" << xDenom << std::endl;\n  std::cout << nNum <<\
    \ \" \" << nDenom << std::endl;\n  float res = (float)xNum * (float)nNum/(float)xDenom/(float)nDenom;\n\
    \  std::cout << res << std::endl;\n  if (res - floor(res) == 0)\n    return true;\n\
    \  return false;", "  std::stringstream(x) >> x;\n  std::stringstream(n) >> n;\n\
    \  int a, b, c, d;\n  std::cout << x << std::endl;\n  std::cout << n << std::endl;\n\
    \  std::sscanf(x.c_str(), \"%d/%d\", &a, &b);\n  std::sscanf(n.c_str(), \"%d/%d\"\
    , &c, &d);\n  return ((a * d) % (b * c)) == 0;", "  int numeratorX = stoi(x.substr(0,\
    \ x.find(\"/\")));\n  int denominatorX = stoi(x.substr(x.find(\"/\") + 1));\n\
    \  int numeratorN = stoi(n.substr(0, n.find(\"/\")));\n  int denominatorN = stoi(n.substr(n.find(\"\
    /\") + 1));\n  int numeratorX2N = numeratorX * denominatorN;\n  int numeratorN2X\
    \ = numeratorN * denominatorX;\n  if (numeratorX2N == numeratorN2X) {\n    return\
    \ true;\n  }\n  return false;", "  int num_a;\n  int denom_a;\n  int num_b;\n\
    \  int denom_b;\n  char c1, c2;\n  char temp[100];\n  int i = 0;\n  int j = 0;\n\
    \  int k = 0;\n  // x\n  while (x[i] != '/') {\n    i++;\n  }\n  num_a = atoi(x.substr(0,\
    \ i).c_str());\n  denom_a = atoi(x.substr(i + 1, x.length() - i).c_str());\n \
    \ // n\n  while (n[j] != '/') {\n    j++;\n  }\n  num_b = atoi(n.substr(0, j).c_str());\n\
    \  denom_b = atoi(n.substr(j + 1, n.length() - j).c_str());\n  // x * n\n  int\
    \ num_c = num_a * num_b;\n  int denom_c = denom_a * denom_b;\n  std::string c\
    \ = std::to_string(num_c) + \"/\" + std::to_string(denom_c);\n  std::cout << c\
    \ << std::endl;\n  if (num_c % denom_c == 0) {\n    return true;\n  } else {\n\
    \    return false;\n  }", "\tint y = std::atoi(x.c_str());\n\treturn y == 0;",
  "    int x_numerator, x_denominator, n_numerator, n_denominator;\n    std::stringstream(x.substr(0,\
    \ x.find(\"/\"))) >> x_numerator;\n    std::stringstream(x.substr(x.find(\"/\"\
    ) + 1)) >> x_denominator;\n    std::stringstream(n.substr(0, n.find(\"/\"))) >>\
    \ n_numerator;\n    std::stringstream(n.substr(n.find(\"/\") + 1)) >> n_denominator;\n\
    \    return (((x_numerator * n_denominator) % (x_denominator * n_numerator)) ==\
    \ 0);", '  return false;', "    std::stringstream ss(x);\n    int num_x,den_x;\n\
    \    char ch;\n    ss>>num_x>>ch>>den_x;\n    std::stringstream ss1(n);\n    int\
    \ num_n,den_n;\n    ss1>>num_n>>ch>>den_n;\n    return ((num_x*den_n)%(num_n*den_x)==0);",
  "    std::stringstream in(x);\n    std::stringstream in1(n);\n    int x1, y1, x2,\
    \ y2;\n    char slash;\n    in >> x1 >> slash >> y1;\n    in1 >> x2 >> slash >>\
    \ y2;\n    int res = x1 * y2;\n    if (res % x2 == 0) {\n        return true;\n\
    \    }\n    return false;", "    // Write your code here\n    std::size_t found\
    \ = x.find(\"/\");\n    std::size_t found2 = n.find(\"/\");\n    std::string numerator\
    \ = x.substr(0,found);\n    std::string denominator = x.substr(found+1);\n   \
    \ std::string numerator2 = n.substr(0,found2);\n    std::string denominator2 =\
    \ n.substr(found2+1);\n    //std::cout << numerator << \" \" << denominator <<\
    \ \" \" << numerator2 << \" \" << denominator2 << std::endl;\n    return true;",
  "    int a = atoi(x.substr(0, x.find(\"/\")).c_str());\n    int b = atoi(x.substr(x.find(\"\
    /\") + 1).c_str());\n    int c = atoi(n.substr(0, n.find(\"/\")).c_str());\n \
    \   int d = atoi(n.substr(n.find(\"/\") + 1).c_str());\n    float num = (float)a\
    \ / b;\n    float den = (float)c / d;\n    float whole = num * den;\n    if (whole\
    \ - (int)whole == 0)\n        return true;\n    else\n        return false;",
  "\tstd::string xNum, xDen, nNum, nDen;\n\tint nD, xD;\n\tstd::size_t found = x.find(\"\
    /\");\n\txNum = x.substr(0, found);\n\txDen = x.substr(found + 1);\n\tstd::size_t\
    \ found2 = n.find(\"/\");\n\tnNum = n.substr(0, found2);\n\tnDen = n.substr(found2\
    \ + 1);\n\tstd::stringstream sxNum(xNum);\n\tstd::stringstream sxDen(xDen);\n\t\
    std::stringstream snNum(nNum);\n\tstd::stringstream snDen(nDen);\n\tsxNum >> xD;\n\
    \tsxDen >> xD;\n\tsnNum >> nD;\n\tsnDen >> nD;\n\treturn nD % xD == 0;", "  std::string::size_type\
    \ sz;   // alias of size_t\n  int x_numerator = std::stoi (x,&sz);\n  std::string\
    \ x_denominator = x.substr(sz+1);\n  int x_denominator_int = std::stoi (x_denominator,&sz);\n\
    \  int n_numerator = std::stoi (n,&sz);\n  std::string n_denominator = n.substr(sz+1);\n\
    \  int n_denominator_int = std::stoi (n_denominator,&sz);\n  int numerator_simplified\
    \ = x_numerator * n_numerator;\n  int denominator_simplified = x_denominator_int\
    \ * n_denominator_int;\n  if (numerator_simplified % denominator_simplified ==\
    \ 0)\n    return true;\n  else\n    return false;", "\treturn false;", "  // your\
    \ code goes here\n  int numerator_x = 0;\n  int denominator_x = 0;\n  int numerator_n\
    \ = 0;\n  int denominator_n = 0;\n  for(int i = 0; i < x.size(); i++) {\n    if(x[i]\
    \ == '/') {\n      numerator_x = stoi(x.substr(0, i));\n      denominator_x =\
    \ stoi(x.substr(i + 1, x.size() - i - 1));\n    }\n  }\n  for(int i = 0; i < n.size();\
    \ i++) {\n    if(n[i] == '/') {\n      numerator_n = stoi(n.substr(0, i));\n \
    \     denominator_n = stoi(n.substr(i + 1, n.size() - i - 1));\n    }\n  }\n \
    \ int num = numerator_x * denominator_n;\n  int den = denominator_x * numerator_n;\n\
    \  if(num % den == 0) {\n    return true;\n  }\n  return false;", "    //your\
    \ code here\n    int y=0,z=0;\n    std::string s,s1;\n    for(int i=0;i<x.length();i++)\n\
    \    {\n        if(x[i]=='/')\n        {\n            y=i;\n            break;\n\
    \        }\n        s=s+x[i];\n    }\n    for(int i=y+1;i<x.length();i++)\n  \
    \  {\n        s1=s1+x[i];\n    }\n    int a=stoi(s);\n    int b=stoi(s1);\n  \
    \  int q=0,r=0;\n    std::string s2,s3;\n    for(int i=0;i<n.length();i++)\n \
    \   {\n        if(n[i]=='/')\n        {\n            q=i;\n            break;\n\
    \        }\n        s2=s2+n[i];\n    }\n    for(int i=q+1;i<n.length();i++)\n\
    \    {\n        s3=s3+n[i];\n    }\n    int c=stoi(s2);\n    int d=stoi(s3);\n\
    \    if((a*c)%(b*d)==0)\n    {\n        return true;\n    }\n    else\n    {\n\
    \        return false;\n    }", "  int i = x.find(\"/\");\n  int d1 = atoi(x.substr(0,\
    \ i).c_str());\n  int d2 = atoi(x.substr(i + 1).c_str());\n  int j = n.find(\"\
    /\");\n  int n1 = atoi(n.substr(0, j).c_str());\n  int n2 = atoi(n.substr(j +\
    \ 1).c_str());\n  int gcd = __gcd(d1, d2);\n  d1 /= gcd;\n  d2 /= gcd;\n  gcd\
    \ = __gcd(n1, n2);\n  n1 /= gcd;\n  n2 /= gcd;\n  int newnum = d1 * n1;\n  int\
    \ newden = d2 * n2;\n  gcd = __gcd(newnum, newden);\n  newnum /= gcd;\n  newden\
    \ /= gcd;\n  return newnum % newden == 0;", "    std::istringstream iss(x);\n\
    \    std::vector<std::string> tokens{std::istream_iterator<std::string>{iss},\
    \ std::istream_iterator<std::string>{}};\n    int n1 = stoi(tokens[0]);\n    int\
    \ d1 = stoi(tokens[1]);\n    iss.clear();\n    iss.str(n);\n    tokens = {std::istream_iterator<std::string>{iss},\
    \ std::istream_iterator<std::string>{}};\n    int n2 = stoi(tokens[0]);\n    int\
    \ d2 = stoi(tokens[1]);\n    // cout << n1 << \"/\" << d1 << \" \" << n2 << \"\
    /\" << d2 << endl;\n    int lcm = std::lcm(d1, d2);\n    int new_n1 = n1 * (lcm\
    \ / d1);\n    int new_n2 = n2 * (lcm / d2);\n    if (new_n1 % new_n2 == 0) {\n\
    \        return true;\n    }\n    return false;"]
stop_tokens:
- "\n}"
