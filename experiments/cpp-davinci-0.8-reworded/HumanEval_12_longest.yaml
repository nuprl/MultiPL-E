name: HumanEval_12_longest
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings,\
  \ return the longest one. Return the first one in case of multiple\n// strings of\
  \ the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n\
  // std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"\
  b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"\
  a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string>\
  \ longest(std::vector<std::string> strings) {\n"
tests: "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>()))\
  \ == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"\
  x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"\
  x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"\
  kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
completions: ["\tassert(false);", "    if (strings.empty()) {\n        return std::nullopt;\n\
    \    }\n    std::vector<std::string>::iterator itr = std::max_element(strings.begin(),\
    \ strings.end(), [](const std::string& str1, const std::string& str2) {\n    \
    \    return str1.length() < str2.length();\n    });\n    return std::optional<std::string>(*itr);",
  "    if (strings.empty()) return std::nullopt;\n    int max_length = 0;\n    std::string\
    \ output = strings[0];\n    for (auto i : strings) {\n        if (i.length() >\
    \ max_length) {\n            max_length = i.length();\n            output = i;\n\
    \        }\n    }\n    return output;", "  std::optional<std::string> ret;\n \
    \ if(strings.size() == 0) {\n    return ret;\n  }\n  ret = strings[0];\n  for(int\
    \ i = 1; i < strings.size(); i++) {\n    if(strings[i].size() > ret.value().size())\
    \ {\n      ret = strings[i];\n    }\n  }\n  return ret;", "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::sort(strings.begin(), strings.end(),\
    \ [](const std::string& lhs, const std::string& rhs) {\n        return lhs.size()\
    \ > rhs.size();\n    });\n    return strings[0];", "    // TODO\n    return std::nullopt;",
  "\treturn std::accumulate(strings.begin(), strings.end(), std::nullopt,\n\t[](const\
    \ std::optional<std::string> &a, const std::string &b) {\n\t\tif (!a) return std::make_optional(b);\n\
    \t\treturn a->size() < b.size() ? std::make_optional(b) : a;\n\t});", "    if\
    \ (strings.empty()) return std::nullopt;\n    std::string *longest = &strings[0];\n\
    \    for (std::string &str : strings) {\n        if (str.length() > longest->length())\
    \ {\n            longest = &str;\n        }\n    }\n    return *longest;", "\t\
    if (strings.size() == 0)\n\t\treturn std::nullopt;\n\tstd::string best = strings[0];\n\
    \tfor (const auto& s : strings) {\n\t\tif (s.size() > best.size())\n\t\t\tbest\
    \ = s;\n\t}\n\treturn best;", "\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\
    \t}\n\tstd::string word;\n\tint index = 0;\n\tfor (int i = 0; i < strings.size();\
    \ i++) {\n\t\tif (strings[i].size() > word.size()) {\n\t\t\tword = strings[i];\n\
    \t\t\tindex = i;\n\t\t}\n\t}\n\treturn strings[index];", "  if (strings.empty())\
    \ {\n    return std::nullopt;\n  }\n  auto max = strings[0];\n  for (const auto&\
    \ s : strings) {\n    if (s.size() > max.size()) {\n      max = s;\n    }\n  }\n\
    \  return max;", "  if (strings.empty()) return std::nullopt;\n  std::string res\
    \ = strings[0];\n  for (const auto& s : strings) {\n    if (s.size() > res.size())\
    \ res = s;\n  }\n  return res;", "  // your code here\n  return {};", "  if (strings.empty())\
    \ {\n    return std::nullopt;\n  }\n  std::string max_length_str;\n  unsigned\
    \ int max_length = 0;\n  for (const auto& s : strings) {\n    if (s.length() >\
    \ max_length) {\n      max_length = s.length();\n      max_length_str = s;\n \
    \   }\n  }\n  return max_length_str;", "  if (strings.empty()) {\n    return std::nullopt;\n\
    \  }\n  std::optional<std::string> longest_string = strings[0];\n  for (std::string\
    \ current_string : strings) {\n    if (current_string.length() > longest_string->length())\
    \ {\n      longest_string = current_string;\n    }\n  }\n  return longest_string;",
  "    // We assume that the input vector is not empty.\n    assert(!strings.empty());\n\
    \    size_t idx = 0;\n    for (size_t i = 1; i < strings.size(); ++i) {\n    \
    \    if (strings[i].size() > strings[idx].size()) {\n            idx = i;\n  \
    \      }\n    }\n    return strings[idx];", "\tif (strings.size() == 0)\n\t\t\
    return std::nullopt;\n\tint max = strings[0].size();\n\tint pos = 0;\n\tfor (int\
    \ i = 1; i < strings.size(); i++) {\n\t\tif (strings[i].size() > max) {\n\t\t\t\
    max = strings[i].size();\n\t\t\tpos = i;\n\t\t}\n\t}\n\treturn strings[pos];",
  "  using std::optional;\n  using std::nullopt;\n  using std::max_element;\n  using\
    \ std::begin;\n  using std::end;\n  using std::size;\n  using std::distance;\n\
    \  using std::string;\n  auto it = max_element(begin(strings), end(strings), [](const\
    \ string& lhs, const string& rhs) {\n    return lhs.size() < rhs.size();\n  });\n\
    \  if (it == end(strings)) {\n    return nullopt;\n  }\n  return *it;", "    //\
    \ Your code here.\n    if(strings.size() == 0)\n        return std::nullopt;\n\
    \    std::string max = strings[0];\n    for(int i = 1; i < strings.size(); i++)\n\
    \    {\n        if(strings[i].size() > max.size())\n            max = strings[i];\n\
    \    }\n    return max;", "\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\
    \t}\n\tstd::string ret = strings[0];\n\tint pos = 0;\n\tfor (int i = 1; i < strings.size();\
    \ i++) {\n\t\tif (strings[i].size() > ret.size()) {\n\t\t\tret = strings[i];\n\
    \t\t\tpos = i;\n\t\t}\n\t}\n\treturn ret;", "    std::optional<std::string> r\
    \ = std::nullopt;\n    for (auto s : strings) {\n        if (!r.has_value() ||\
    \ (s.size() > r.value().size()))\n            r = s;\n    }\n    return r;", " \
    \   int maxIndex = 0;\n    int maxLength = strings[0].length();\n    for (int\
    \ i = 1; i < strings.size(); i++) {\n        if (strings[i].length() > maxLength)\
    \ {\n            maxIndex = i;\n            maxLength = strings[i].length();\n\
    \        }\n    }\n    return strings[maxIndex];", "  if (strings.empty()) return\
    \ std::nullopt;\n  auto it = std::max_element(strings.begin(), strings.end(),\
    \ [](const std::string& str1, const std::string& str2) {\n      return str1.size()\
    \ < str2.size();\n  });\n  return *it;", "  if (strings.empty()) {\n    return\
    \ std::nullopt;\n  }\n  std::string longest = strings[0];\n  for (const auto&\
    \ str : strings) {\n    if (str.size() > longest.size()) {\n      longest = str;\n\
    \    }\n  }\n  return longest;", "  int longest = 0;\n  int longestidx = 0;\n\
    \  int count = 0;\n  for (auto &s : strings) {\n    if (s.length() > longest)\
    \ {\n      longest = s.length();\n      longestidx = count;\n    }\n    count++;\n\
    \  }\n  if (longest == 0) {\n    return std::nullopt;\n  }\n  return strings[longestidx];",
  "\tassert(strings.size()>=0);\n\tint i=0;\n\tfor(i=0;i<strings.size();i++)\n\t\t\
    assert(strings[i].size()>=0);\n\tint max=0;\n\tint index=0;\n\tif(strings.size()==0)\n\
    \t\treturn std::nullopt;\n\tfor(i=0;i<strings.size();i++)\n\t{\n\t\tif(strings[i].size()>max)\n\
    \t\t{\n\t\t\tmax=strings[i].size();\n\t\t\tindex=i;\n\t\t}\n\t}\n\treturn strings[index];",
  "    // initialize container of optional with the first element of container\n \
    \   std::optional<std::string> rtn = (strings.empty() ? std::nullopt : std::optional<std::string>(strings[0]));\n\
    \    for (int i = 1; i < strings.size(); i++) {\n        if (strings[i].length()\
    \ > rtn.value().length()) {\n            rtn = strings[i];\n        }\n    }\n\
    \    return rtn;", "    if (strings.empty()) {\n        return std::nullopt;\n\
    \    }\n    std::string result = strings[0];\n    for (const auto& s : strings)\
    \ {\n        if (s.size() > result.size()) {\n            result = s;\n      \
    \  }\n    }\n    return result;", "    if (strings.empty()) {\n        return\
    \ std::nullopt;\n    }\n    std::optional<std::string> longest_string = strings[0];\n\
    \    for (const auto& string : strings) {\n        if (string.size() > longest_string->size())\
    \ {\n            longest_string = string;\n        }\n    }\n    return longest_string;",
  "    if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::string\
    \ longestString = strings[0];\n    for (std::string s : strings) {\n        if\
    \ (s.length() > longestString.length()) {\n            longestString = s;\n  \
    \      }\n    }\n    return longestString;", "  if (strings.empty()) {\n    return\
    \ std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (auto\
    \ string: strings) {\n    if (string.length() > longest_string.length()) {\n \
    \     longest_string = string;\n    }\n  }\n  return longest_string;", '    return
    std::nullopt;', "    if (strings.empty()) {\n        return std::nullopt;\n  \
    \  }\n    std::string longest_string = strings[0];\n    for (std::string string\
    \ : strings) {\n        if (string.length() > longest_string.length()) {\n   \
    \         longest_string = string;\n        }\n    }\n    return longest_string;",
  "\tif (strings.size() == 0)\n\t\treturn std::nullopt;\n\treturn std::max_element(strings.begin(),\
    \ strings.end(), [](const std::string& a, const std::string& b) {\n\t\treturn\
    \ a.size() < b.size();\n\t});", "    assert(strings.size() >= 0);\n    if (strings.size()\
    \ == 0) {\n        return std::nullopt;\n    } else {\n        auto result = strings[0];\n\
    \        for (auto const& s : strings) {\n            if (s.size() > result.size())\
    \ {\n                result = s;\n            }\n        }\n        return result;\n\
    \    }", "  std::vector<std::string>::iterator m = strings.begin();\n  std::vector<std::string>::iterator\
    \ it = strings.begin();\n  if (strings.size() == 0)\n    return std::nullopt;\n\
    \  while (it != strings.end()) {\n    if ((*it).length() > (*m).length())\n  \
    \    m = it;\n    it++;\n  }\n  return *m;", "    if (strings.empty()) {\n   \
    \     return std::nullopt;\n    }\n    std::string longestStr = strings[0];\n\
    \    for (const auto& s : strings) {\n        if (s.size() > longestStr.size())\
    \ {\n            longestStr = s;\n        }\n    }\n    return longestStr;", " \
    \   std::sort(strings.begin(), strings.end(), [](const std::string& a, const std::string&\
    \ b) {\n        return a.size() > b.size();\n    });\n    auto result = std::string();\n\
    \    if (strings.size() > 0) {\n        result = strings[0];\n    }\n    return\
    \ result;", "\treturn std::nullopt;", "    assert(strings.size() >= 0);\n    if\
    \ (strings.size() == 0)\n        return std::nullopt;\n    std::string longestString\
    \ = strings[0];\n    for (std::string s : strings) {\n        if (s.length() >\
    \ longestString.length())\n            longestString = s;\n    }\n    return longestString;",
  "  std::optional<std::string> res = std::nullopt;\n  for (std::string s : strings)\
    \ {\n    if (!res.has_value() || s.size() > res.value().size()) {\n      res =\
    \ s;\n    }\n  }\n  return res;", "  if (strings.empty()) return std::nullopt;\n\
    \  std::string result = strings[0];\n  for (auto& s : strings) {\n    if (s.size()\
    \ > result.size()) result = s;\n  }\n  return result;", "\tif (strings.size()\
    \ == 0) {\n\t\treturn std::nullopt;\n\t}\n\tstd::string longest_word = strings[0];\n\
    \tfor (std::string s : strings) {\n\t\tif (s.size() > longest_word.size()) {\n\
    \t\t\tlongest_word = s;\n\t\t}\n\t}\n\treturn longest_word;", "    // int l =\
    \ 0;\n    // for (int i = 0; i < strings.size(); i++) {\n    //     if (strings[i].size()\
    \ > l)\n    //         l = strings[i].size();\n    // }\n    // for (int i = 0;\
    \ i < strings.size(); i++) {\n    //     if (strings[i].size() == l)\n    // \
    \        return strings[i];\n    // }\n    // return nullptr;\n    int index =\
    \ 0;\n    for (int i = 0; i < strings.size(); i++) {\n        if (strings[i].size()\
    \ > strings[index].size())\n            index = i;\n    }\n    if (strings.size()\
    \ > 0)\n        return strings[index];\n    else\n        return std::nullopt;",
  "    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    size_t max_length\
    \ = 0;\n    std::string longest;\n    for (const auto& s : strings) {\n      \
    \  if (s.length() > max_length) {\n            max_length = s.length();\n    \
    \        longest = s;\n        }\n    }\n\n    return longest;", "\tassert(strings.size()\
    \ >= 0);\n\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\t// For\
    \ each element, the longest string is either the longest string so far or the\
    \ current element\n\t// compared to the longest string so far.\n\tauto longest_string\
    \ = *std::max_element(strings.begin(), strings.end(), [](auto lhs, auto rhs) {\n\
    \t\treturn lhs.size() < rhs.size();\n\t});\n\treturn longest_string;", "\tif (strings.size()\
    \ == 0)\n\t\treturn std::nullopt;\n\tstd::string longest = strings[0];\n\tfor\
    \ (int i = 1; i < strings.size(); i++) {\n\t\tif (strings[i].size() > longest.size())\n\
    \t\t\tlongest = strings[i];\n\t}\n\treturn longest;", "  std::optional<std::string>\
    \ longest_string;\n  if (strings.size() > 0) {\n    longest_string = strings[0];\n\
    \    for (auto s : strings) {\n      if (s.size() > longest_string->size()) {\n\
    \        longest_string = s;\n      }\n    }\n  }\n  return longest_string;",
  "  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest\
    \ = strings[0];\n  for (auto& s : strings) {\n    if (s.size() > longest.size())\
    \ {\n      longest = s;\n    }\n  }\n  return longest;", "  //write your code\
    \ here\n  if(strings.size()==0)\n    return std::nullopt;\n  else{\n    std::string\
    \ s = strings[0];\n    for(int i=1;i<strings.size();i++){\n      if(strings[i].size()>s.size())\n\
    \        s = strings[i];\n    }\n    return s;\n  }", "    if (strings.empty())\
    \ return std::nullopt;\n    auto it = std::max_element(strings.begin(), strings.end(),\n\
    \            [](const std::string& a, const std::string& b) { return a.size()\
    \ < b.size(); });\n    return *it;", "    if (strings.empty()) {\n        return\
    \ std::nullopt;\n    }\n    std::string ans = strings[0];\n    for (const auto&\
    \ s : strings) {\n        if (s.size() > ans.size()) {\n            ans = s;\n\
    \        }\n    }\n    return ans;", "    std::optional<std::string> result;\n\
    \    if (strings.size() == 0) {\n        return result;\n    }\n    result = strings[0];\n\
    \    for (auto s : strings) {\n        if (s.size() > result.value().size()) {\n\
    \            result = s;\n        }\n    }\n    return result;", "  if (strings.empty())\
    \ {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n\
    \  for (int i = 1; i < strings.size(); i++) {\n    if (strings[i].size() > longest_string.size())\
    \ {\n      longest_string = strings[i];\n    }\n  }\n  return longest_string;",
  "\treturn std::optional<std::string>();", "  if (strings.empty()) {\n    return\
    \ std::nullopt;\n  }\n  std::sort(strings.begin(), strings.end(), [](const std::string&\
    \ a, const std::string& b) {\n    return a.size() > b.size();\n  });\n  return\
    \ strings[0];", "    if (strings.empty()) return std::nullopt;\n    auto result\
    \ = std::begin(strings);\n    for (auto it = std::begin(strings); it != std::end(strings);\
    \ ++it) {\n        if (it->size() > result->size()) result = it;\n    }\n    return\
    \ *result;", "    int max_len = 0;\n    std::string res;\n    for (auto s : strings)\
    \ {\n        if (s.size() > max_len) {\n            max_len = s.size();\n    \
    \        res = s;\n        }\n    }\n    if (max_len == 0) {\n        return std::nullopt;\n\
    \    }\n    return res;", "    if (strings.empty()) return std::nullopt;\n   \
    \ std::string result = strings[0];\n    for (auto i = 1u; i < strings.size();\
    \ ++i) {\n        if (strings[i].size() > result.size()) {\n            result\
    \ = strings[i];\n        }\n    }\n    return result;", "    assert(!strings.empty());\n\
    \    std::sort(strings.begin(), strings.end(), [](const std::string & a, const\
    \ std::string & b) {\n      return a.size() > b.size();\n    });\n    return strings[0];",
  "  if (strings.empty()) {\n    return std::nullopt;\n  }\n  auto max_len = std::max_element(strings.begin(),\
    \ strings.end(), [](auto &a, auto &b) {\n    return a.size() < b.size();\n  });\n\
    \  return *max_len;", "    if (strings.empty()) {\n        return std::nullopt;\n\
    \    }\n    std::string longest_string;\n    int max_length = 0;\n    for (auto\
    \ str : strings) {\n        if (str.length() > max_length) {\n            max_length\
    \ = str.length();\n            longest_string = str;\n        }\n    }\n    return\
    \ longest_string;", "    // CHANGE: Writed code here\n    std::optional<std::string>\
    \ ans;\n    if(strings.size() != 0) {\n        int cnt = 0;\n        for(int i\
    \ = 0; i < strings.size(); i++) {\n            if(strings[i].size() > cnt) {\n\
    \                cnt = strings[i].size();\n                ans = strings[i];\n\
    \            }\n        }\n    }\n    return ans;", "  // check for pre conditions\n\
    \  if (strings.size() == 0) {\n    return std::nullopt;\n  }\n  // condition for\
    \ just one string\n  if (strings.size() == 1) {\n    return strings[0];\n  }\n\
    \  // your code here\n  std::string max = strings[0];\n  for (auto str : strings)\
    \ {\n    if (str.length() > max.length()) {\n      max = str;\n    }\n  }\n  return\
    \ max;", "    int max_len = 0;\n    std::string longest_string;\n    for (int\
    \ i = 0; i < strings.size(); i++) {\n        if (strings[i].length() > max_len)\
    \ {\n            max_len = strings[i].length();\n            longest_string =\
    \ strings[i];\n        }\n    }\n    if (strings.size() > 0) {\n        return\
    \ longest_string;\n    } else {\n        return std::nullopt;\n    }", "  if (strings.empty())\
    \ {\n    return std::nullopt;\n  }\n  std::string candidate = strings[0];\n  for\
    \ (std::string s : strings) {\n    if (s.size() > candidate.size()) {\n      candidate\
    \ = s;\n    }\n  }\n  return candidate;", "    if (strings.empty()) return std::nullopt;\n\
    \    std::string longest_string = \"\";\n    for (std::string string : strings)\
    \ {\n        if (string.length() > longest_string.length()) longest_string = string;\n\
    \    }\n    return longest_string;", "\tif (strings.size() == 0) {\n\t\treturn\
    \ std::nullopt;\n\t}\n\tstd::string res = strings[0];\n\tfor (std::string str\
    \ : strings) {\n\t\tif (str.size() > res.size()) {\n\t\t\tres = str;\n\t\t}\n\t\
    }\n\treturn res;", "\tstd::sort(strings.begin(), strings.end(), [](std::string\
    \ a, std::string b) {\n\t\treturn a.size() > b.size();\n\t});\n\tstd::cout <<\
    \ strings[0] << std::endl;\n\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\
    \t}\n\telse {\n\t\treturn strings[0];\n\t}", "    std::string s;\n    if(strings.size()==0)\n\
    \        return std::nullopt;\n    else{\n        s=strings[0];\n        for(int\
    \ i=1;i<strings.size();i++){\n            if(strings[i].size()>s.size())\n   \
    \             s=strings[i];\n        }\n        return s;\n    }", "\tif (strings.size()\
    \ == 0)\n\t\treturn std::nullopt;\n\tstd::string max = strings[0];\n\tfor (std::string\
    \ s : strings) {\n\t\tif (s.size() > max.size())\n\t\t\tmax = s;\n\t}\n\treturn\
    \ max;", "    std::vector<std::string> a;\n    if(strings.size() == 0)\n     \
    \   return std::nullopt;\n    int max = strings[0].size();\n    int index = 0;\n\
    \    for(int i = 0; i < strings.size(); i++) {\n        if(strings[i].size() >\
    \ max) {\n            max = strings[i].size();\n            index = i;\n     \
    \   }\n    }\n    return strings[index];", "\tif (strings.size() == 0) {\n\t\t\
    return std::nullopt;\n\t}\n\tstd::string& longestString = strings[0];\n\tfor (int\
    \ i = 1; i < strings.size(); i++) {\n\t\tif (strings[i].size() > longestString.size())\
    \ {\n\t\t\tlongestString = strings[i];\n\t\t}\n\t}\n\treturn longestString;",
  "  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n  auto const longest\
    \ = std::max_element(\n    std::begin(strings),\n    std::end(strings),\n    [](auto\
    \ const& lhs, auto const& rhs) {\n      return lhs.size() < rhs.size();\n    }\n\
    \  );\n\n  return *longest;", "    std::optional<std::string> result = std::nullopt;\n\
    \    if (strings.size() == 0)\n        return result;\n    std::sort(strings.begin(),\
    \ strings.end(), [](std::string s1, std::string s2) {\n        return s1.size()\
    \ > s2.size();\n    });\n    result = strings[0];\n    return result;", "    if\
    \ (strings.empty()) {\n        return std::nullopt;\n    }\n    std::string longest_string\
    \ = strings[0];\n    for (int i = 1; i < strings.size(); i++) {\n        if (strings[i].size()\
    \ > longest_string.size()) {\n            longest_string = strings[i];\n     \
    \   }\n    }\n    return longest_string;", "  if (strings.empty()) return std::nullopt;\n\
    \  int longest_length{0};\n  std::string longest_string{};\n  for (const auto&\
    \ string : strings) {\n    if (string.length() > longest_length) {\n      longest_length\
    \ = string.length();\n      longest_string = string;\n    }\n  }\n  return longest_string;",
  '    return std::nullopt;', "    if (strings.empty()) {\n        return std::nullopt;\n\
    \    }\n\n    std::sort(strings.begin(), strings.end(), [](std::string a, std::string\
    \ b) { return a.size() > b.size(); });\n    return strings[0];", "    std::string\
    \ res;\n    if(strings.size() == 0)\n        return std::nullopt;\n    else{\n\
    \        res = strings[0];\n        for(int i = 1; i < strings.size(); i++){\n\
    \            if(strings[i].size() > res.size())\n                res = strings[i];\n\
    \        }\n    }\n    return res;", "  std::optional<std::string> result;\n \
    \ for (auto s : strings) {\n    if (!result || (s.size() > result->size()))\n\
    \      result = s;\n  }\n  return result;", "    if (strings.empty()) {\n    \
    \    return std::nullopt;\n    }\n    auto result = std::max_element(\n      \
    \  strings.begin(),\n        strings.end(),\n        [](const std::string& s1,\
    \ const std::string& s2) {\n            return s1.size() < s2.size();\n      \
    \  }\n    );\n    return *result;", "    std::vector<int> length;\n    for(int\
    \ i=0;i<strings.size();i++){\n        length.push_back(strings[i].length());\n\
    \    }\n    if(length.size()==0){\n        return std::nullopt;\n    }\n    int\
    \ max=*std::max_element(length.begin(),length.end());\n    for(int i=0;i<length.size();i++){\n\
    \        if(length[i]==max){\n            return strings[i];\n        }\n    }",
  "\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\tstd::optional<std::string>\
    \ longest = strings[0];\n\tfor (const auto& s : strings) {\n\t\tif (s.size() >\
    \ longest->size()) {\n\t\t\tlongest = s;\n\t\t}\n\t}\n\treturn longest;", "  \
    \  return strings.empty() ? std::nullopt : std::make_optional(*std::max_element(\n\
    \        strings.begin(), strings.end(), [](const std::string& a, const std::string&\
    \ b) {\n            return a.size() < b.size();\n        }));", '    return 0;',
  "  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longestStr\
    \ = strings[0];\n  for (std::string str : strings) {\n    if (str.length() > longestStr.length())\
    \ {\n      longestStr = str;\n    }\n  }\n  return longestStr;", "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::string result;\n    int length\
    \ = 0;\n    for (std::string str : strings) {\n        if (str.length() > length)\
    \ {\n            result = str;\n            length = str.length();\n        }\n\
    \    }\n    return result;", "\tint longest_index = 0;\n\tif (strings.size() ==\
    \ 0)\n\t\treturn std::nullopt;\n\tfor (int i = 0; i < strings.size(); i++) {\n\
    \t\tif (strings[i].size() > strings[longest_index].size())\n\t\t\tlongest_index\
    \ = i;\n\t}\n\treturn strings[longest_index];", "  if (strings.empty()) {\n  \
    \  return std::nullopt;\n  }\n  std::sort(strings.begin(), strings.end(), [](const\
    \ std::string& a, const std::string& b) {\n    return a.size() > b.size();\n \
    \ });\n  return std::optional<std::string>(strings[0]);", "  // write your code\
    \ here\n  return std::nullopt;", "  if (strings.empty()) {\n    return std::nullopt;\n\
    \  }\n  auto it = std::max_element(\n      strings.begin(), strings.end(),\n \
    \     [](std::string a, std::string b) { return a.size() < b.size(); });\n  return\
    \ *it;", "    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n\
    \    std::optional<std::string> result = std::nullopt;\n    std::optional<size_t>\
    \ longestLength = std::nullopt;\n    for (std::string string : strings) {\n  \
    \      if (!longestLength || string.length() > *longestLength) {\n           \
    \ result = string;\n            longestLength = string.length();\n        }\n\
    \    }\n\n    return result;", "  if (strings.empty()) return std::nullopt;\n\
    \  int max_len = 0;\n  std::string longest;\n  for (const auto& s : strings) {\n\
    \    if (s.size() > max_len) {\n      max_len = s.size();\n      longest = s;\n\
    \    }\n  }\n  return longest;", "    int max_len = -1;\n    std::string max_string;\n\
    \    for (auto str : strings) {\n        if (str.length() > max_len) {\n     \
    \       max_len = str.length();\n            max_string = str;\n        }\n  \
    \  }\n    if (max_len != -1)\n        return max_string;\n    else\n        return\
    \ std::nullopt;", "    std::optional<std::string> longest_string = std::nullopt;\n\
    \    for (auto& string : strings) {\n        if (!longest_string.has_value() ||\n\
    \            string.size() > longest_string.value().size()) {\n            longest_string\
    \ = string;\n        }\n    }\n    return longest_string;", "\tif (strings.size()\
    \ == 0)\n\t\treturn std::nullopt;\n\tint max_len = 0;\n\tstd::string ans;\n\t\
    for (std::string &s : strings) {\n\t\tif (s.size() > max_len) {\n\t\t\tmax_len\
    \ = s.size();\n\t\t\tans = s;\n\t\t}\n\t}\n\treturn ans;", "  // your code here\n\
    \  return {};", "\tstd::optional<std::string> result = std::nullopt;\n\tint max\
    \ = 0;\n\tfor (auto i : strings) {\n\t\tif (i.length() > max) {\n\t\t\tmax = i.length();\n\
    \t\t\tresult = i;\n\t\t}\n\t}\n\treturn result;", "    std::optional<std::string>\
    \ longest_string;\n    if (strings.size() > 0) {\n        std::sort(strings.begin(),\
    \ strings.end(), [](const std::string& a, const std::string& b) {\n          \
    \  return a.size() > b.size();\n        });\n        longest_string = strings[0];\n\
    \    }\n    return longest_string;", "    std::string longest;\n    if (strings.size()\
    \ == 0)\n        return std::nullopt;\n    for (int i = 0; i < strings.size();\
    \ i++) {\n        if (strings[i].size() > longest.size())\n            longest\
    \ = strings[i];\n    }\n    return longest;", "    if (strings.empty()) {\n  \
    \      return std::nullopt;\n    }\n    std::string result = strings[0];\n   \
    \ for (const auto& string : strings) {\n        if (string.size() > result.size())\
    \ {\n            result = string;\n        }\n    }\n    return result;", "  \
    \  if (strings.empty()) return std::nullopt;\n    // TODO: Read the problem description\
    \ and write your code here.\n    std::string lword = strings[0];\n    int i =\
    \ 0;\n    while (i < strings.size()) {\n        if (strings[i].length() > lword.length())\
    \ {\n            lword = strings[i];\n        }\n        i++;\n    }\n    return\
    \ lword;", "    if (strings.empty()) {\n        return std::nullopt;\n    }\n\
    \    auto max_length = strings[0].length();\n    auto max_string = strings[0];\n\
    \    for (auto i = 1U; i < strings.size(); ++i) {\n        if (strings[i].length()\
    \ > max_length) {\n            max_length = strings[i].length();\n           \
    \ max_string = strings[i];\n        }\n    }\n    return max_string;", "    if\
    \ (strings.empty()) {\n        return std::nullopt;\n    }\n    auto result =\
    \ std::max_element(strings.begin(), strings.end(),\n            [](const std::string&\
    \ a, const std::string& b) { return a.size() < b.size(); });\n    return *result;",
  "    if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::optional<std::string>\
    \ result = strings[0];\n    for (std::string str : strings) {\n        if (str.length()\
    \ > result.value().length()) {\n            result = str;\n        }\n    }\n\
    \    return result;", "  if (strings.empty()) {\n    return std::nullopt;\n  }\n\
    \  auto iter = std::max_element(strings.begin(), strings.end(),\n            \
    \                   [](const std::string& a, const std::string& b) {\n       \
    \                          return a.size() < b.size();\n                     \
    \          });\n  return *iter;", "    if (strings.empty()) {\n        return\
    \ std::nullopt;\n    }\n    std::string longest = strings[0];\n    for (const\
    \ auto& string : strings) {\n        if (string.size() > longest.size()) {\n \
    \           longest = string;\n        }\n    }\n    return longest;", '    return
    std::nullopt;', "  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n \
    \ std::vector<std::string>::iterator max_ele = std::max_element(strings.begin(),\
    \ strings.end(), [](std::string a, std::string b) {\n    return a.length() < b.length();\n\
    \  });\n\n  return *max_ele;", "    std::optional<std::string> result;\n    for\
    \ (auto& s : strings) {\n        if (!result.has_value() || s.size() > result.value().size())\
    \ {\n            result = s;\n        }\n    }\n    return result;", "\tif (strings.size()\
    \ == 0)\n\t\treturn std::nullopt;\n\tstd::string max = strings[0];\n\tint maxLen\
    \ = strings[0].length();\n\tfor (int i = 1; i < strings.size(); i++) {\n\t\tif\
    \ (strings[i].length() > maxLen) {\n\t\t\tmax = strings[i];\n\t\t\tmaxLen = strings[i].length();\n\
    \t\t}\n\t}\n\treturn max;", "\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\
    \t}\n\tint index = 0;\n\tfor (int i = 1; i < strings.size(); i++) {\n\t\tif (strings[i].size()\
    \ > strings[index].size()) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn strings[index];",
  "    // create an iterator\n    std::vector<std::string>::iterator it;\n    // create\
    \ an empty string\n    std::string s = \"\";\n    // loop through the vector and\
    \ return first string which is the longest\n    for (it = strings.begin(); it\
    \ != strings.end(); it++) {\n        if (it->length() > s.length()) {\n      \
    \      s = *it;\n        }\n    }\n    // return std::nullopt if vector is empty\n\
    \    if (s.length() == 0) {\n        return std::nullopt;\n    }\n    // return\
    \ longest string if vector has strings\n    return s;", "    std::optional<std::string>\
    \ result = std::nullopt;\n    for (const auto& s : strings) {\n        if (result.has_value())\
    \ {\n            if (s.size() > result.value().size()) {\n                result\
    \ = s;\n            }\n        } else {\n            result = s;\n        }\n\
    \    }\n    return result;", "    if (strings.empty()) {\n        return std::nullopt;\n\
    \    }\n    auto it = std::max_element(strings.begin(), strings.end(), [] (const\
    \ std::string& a, const std::string& b) {\n        return a.size() < b.size();\n\
    \    });\n    return *it;", "    // check if input vector is empty\n    if (strings.empty())\
    \ {\n        // return None\n        return std::nullopt;\n    }\n    // initialize\
    \ max_length to the length of the first string\n    int max_length = strings[0].length();\n\
    \    // initialize longest_string to the first string\n    std::string longest_string\
    \ = strings[0];\n    // for each string in the vector, update the max_length and\
    \ longest_string if the length of\n    // the current string is greater than the\
    \ max_length\n    for (int i = 1; i < strings.size(); i++) {\n        if (strings[i].length()\
    \ > max_length) {\n            max_length = strings[i].length();\n           \
    \ longest_string = strings[i];\n        }\n    }\n    // return the longest string\n\
    \    return longest_string;", "    if (strings.empty()) return std::nullopt;\n\
    \    else {\n        std::string current_longest;\n        for (std::string s\
    \ : strings) {\n            if (s.length() > current_longest.length()) current_longest\
    \ = s;\n        }\n        return current_longest;\n    }", "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto max = std::max_element(strings.begin(),\
    \ strings.end(), [](auto&& lhs, auto&& rhs) {\n        return lhs.size() < rhs.size();\n\
    \    });\n    return *max;", "    if (strings.empty()) return std::nullopt;\n\
    \    auto iter = std::max_element(strings.begin(), strings.end(),\n        [](const\
    \ std::string& a, const std::string& b) -> bool {\n            return a.size()\
    \ < b.size();\n        });\n    assert(iter != strings.end());\n    return *iter;",
  "    std::optional<std::string> max;\n    for (auto &s : strings) {\n        if\
    \ (!max || s.size() > max->size()) {\n            max = s;\n        }\n    }\n\
    \    return max;", "\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\t\
    }\n\tstd::sort(strings.begin(), strings.end(), [](std::string a, std::string b)\
    \ { return b.size() < a.size(); });\n\treturn strings[0];", "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::string max = strings[0];\n\
    \    for (int i = 1; i < strings.size(); i++) {\n        if (strings[i].size()\
    \ > max.size()) {\n            max = strings[i];\n        }\n    }\n    return\
    \ max;", "\tif (strings.size() == 0)\n\t\treturn std::nullopt;\n\tstd::string\
    \ longest = strings[0];\n\tint m = 0;\n\tfor (int i = 0; i < strings.size(); i++)\
    \ {\n\t\tif (longest.size() < strings[i].size()) {\n\t\t\tlongest = strings[i];\n\
    \t\t\tm = i;\n\t\t}\n\t}\n\treturn strings[m];", "    if (strings.empty()) {\n\
    \        return std::nullopt;\n    }\n    std::optional<std::string> longest;\n\
    \    for (auto s : strings) {\n        if (!longest.has_value() || longest.value().size()\
    \ < s.size()) {\n            longest = s;\n        }\n    }\n    return longest;",
  "  // TODO\n  return {};", "    std::optional<std::string> longestString;\n    int\
    \ longestLength = 0;\n    for (auto it = strings.begin(); it != strings.end();\
    \ ++it) {\n        if (it->length() > longestLength) {\n            longestString\
    \ = *it;\n            longestLength = it->length();\n        }\n    }\n    return\
    \ longestString;", "\tstd::optional<std::string> opt;\n\tstd::string s = \"\"\
    ;\n\tif (strings.size() == 0) {\n\t\treturn opt;\n\t}\n\telse {\n\t\tfor (int\
    \ i = 0; i < strings.size(); i++) {\n\t\t\tif (strings[i].size() > s.size()) {\n\
    \t\t\t\ts = strings[i];\n\t\t\t}\n\t\t}\n\t\topt = s;\n\t\treturn opt;\n\t}",
  "  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string{strings[0]};\n\
    \  for (std::string const& str : strings) {\n    if (str.size() > longest_string.size())\
    \ {\n      longest_string = str;\n    }\n  }\n  return longest_string;", "   \
    \ if (strings.empty()) {\n        return std::nullopt;\n    }\n    int maxLength\
    \ = 0;\n    std::string longestString;\n    for (const auto& str : strings) {\n\
    \        if (str.length() > maxLength) {\n            maxLength = str.length();\n\
    \            longestString = str;\n        }\n    }\n    return longestString;",
  "\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\telse {\n\t\tstd::string\
    \ res = strings[0];\n\t\tfor (int i = 1; i < strings.size(); i++) {\n\t\t\tif\
    \ (strings[i].size() > res.size()) {\n\t\t\t\tres = strings[i];\n\t\t\t}\n\t\t\
    }\n\t\treturn res;\n\t}", '    return std::nullopt;', "  std::optional<std::string>\
    \ longest_string;\n  for (auto it = strings.begin(); it != strings.end(); ++it)\
    \ {\n    if (longest_string.has_value()) {\n      if (it->length() > longest_string->length())\
    \ {\n        longest_string = *it;\n      }\n    } else {\n      longest_string\
    \ = *it;\n    }\n  }\n  return longest_string;", "    // ...\n    if(strings.size()\
    \ == 0)\n    {\n      return std::nullopt;\n    }\n    else\n    {\n      std::string\
    \ longestStr = strings[0];\n      for(std::string str : strings)\n      {\n  \
    \      if(str.length() > longestStr.length())\n        {\n          longestStr\
    \ = str;\n        }\n      }\n      return longestStr;\n    }", "    // Return\
    \ the longest string\n    int maxLen = 0;\n    std::string maxStr;\n    for (std::string\
    \ str : strings) {\n        if (str.length() > maxLen) {\n            maxLen =\
    \ str.length();\n            maxStr = str;\n        }\n    }\n    if (maxLen ==\
    \ 0) {\n        return std::nullopt;\n    }\n    return maxStr;", "  if (strings.empty())\
    \ return std::nullopt;\n  auto result = std::make_optional(strings[0]);\n  for\
    \ (auto s : strings) {\n    if (s.size() > result->size()) {\n      result = std::make_optional(s);\n\
    \    }\n  }\n  return result;", "    // input string vector empty\n    if (strings.empty())\n\
    \        return std::nullopt;\n    std::optional<std::string> longest_string =\
    \ std::nullopt;\n    for (auto& s : strings) {\n        if (!longest_string.has_value())\
    \ {\n            longest_string = s;\n        } else {\n            if (s.length()\
    \ > longest_string.value().length()) {\n                longest_string = s;\n\
    \            }\n        }\n    }\n    return longest_string;", "    auto maxLength=std::max_element(strings.begin(),\
    \ strings.end(), [](const std::string& a, const std::string& b) {\n        return\
    \ a.length() < b.length();\n    });\n    if (maxLength == strings.end()) {\n \
    \       return std::nullopt;\n    }\n    return *maxLength;", "    int max_string_len\
    \ = 0;\n    int max_string_index = 0;\n    bool all_zero_len = true;\n    for\
    \ (int i = 0; i < strings.size(); i++) {\n        if (strings[i].length() > max_string_len)\
    \ {\n            max_string_len = strings[i].length();\n            max_string_index\
    \ = i;\n        }\n        if (strings[i].length() > 0) {\n            all_zero_len\
    \ = false;\n        }\n    }\n    if (all_zero_len) {\n        return std::nullopt;\n\
    \    }\n    return strings[max_string_index];", "  std::string s;\n  for (int\
    \ i = 0; i < strings.size(); i++) {\n    if (s.size() < strings[i].size()) {\n\
    \      s = strings[i];\n    }\n  }\n  if (s.size() == 0) {\n    return std::nullopt;\n\
    \  }\n  return s;", "  if (strings.empty()) {\n    return std::nullopt;\n  }\n\
    \  std::optional<std::string> longest_string = strings[0];\n  for (const auto&\
    \ current_string : strings) {\n    if (current_string.size() > longest_string->size())\
    \ {\n      longest_string = current_string;\n    }\n  }\n  return longest_string;",
  "    if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::string\
    \ result = strings[0];\n    for (auto str : strings) {\n        if (str.size()\
    \ > result.size()) {\n            result = str;\n        }\n    }\n    return\
    \ result;", "  // your code here\n  std::optional<std::string> opt;\n  if(strings.size()\
    \ == 0)\n    return opt;\n  if(strings.size() == 1)\n    return strings[0];\n\
    \  unsigned long max = strings[0].size();\n  unsigned long maxIndex = 0;\n  for(unsigned\
    \ long i = 1; i < strings.size(); i++){\n    if(strings[i].size() > max){\n  \
    \    max = strings[i].size();\n      maxIndex = i;\n    }\n  }\n  return strings[maxIndex];",
  "  using namespace std;\n  optional<string> longestStr;\n  if(strings.size() ==\
    \ 0)\n    return longestStr;\n  longestStr = strings[0];\n  int maxLen = longestStr->length();\n\
    \  for(int i = 1; i < strings.size(); i++) {\n    int len = strings[i].length();\n\
    \    if(len > maxLen) {\n      maxLen = len;\n      longestStr = strings[i];\n\
    \    }\n  }\n  return longestStr;", "\tif (strings.size() == 0)\n\t\treturn std::nullopt;\n\
    \tstd::string longest = strings[0];\n\tfor (std::string string : strings) {\n\t\
    \tif (string.size() > longest.size())\n\t\t\tlongest = string;\n\t}\n\treturn\
    \ longest;", '', "    if (strings.empty()) {\n        return std::nullopt;\n \
    \   }\n\n    std::string cur_longest_str = strings[0];\n    for (std::string str\
    \ : strings) {\n        if (str.length() > cur_longest_str.length()) {\n     \
    \       cur_longest_str = str;\n        }\n    }\n    return cur_longest_str;",
  '  return {};', "    int temp = -1;\n    std::string result;\n    for (const auto&\
    \ str : strings) {\n        if (temp < str.size()) {\n            temp = str.size();\n\
    \            result = str;\n        }\n    }\n    if (result.empty())\n      \
    \  return std::nullopt;\n    return result;", "    if (strings.empty()) {\n  \
    \      return std::nullopt;\n    }\n    std::string longest_str;\n    for (auto\
    \ str : strings) {\n        if (str.length() > longest_str.length()) {\n     \
    \       longest_str = str;\n        }\n    }\n    return longest_str;", "    std::optional<std::string>\
    \ result;\n    int maxSize = -1;\n    for (auto str : strings) {\n        if (str.size()\
    \ > maxSize) {\n            maxSize = str.size();\n            result = str;\n\
    \        }\n    }\n    return result;", "    std::optional<std::string> res =\
    \ std::nullopt;\n    for (auto i = 0; i < strings.size(); i++) {\n        if (res.has_value())\
    \ {\n            if (strings[i].size() > res.value().size()) {\n             \
    \   res = strings[i];\n            }\n        } else {\n            res = strings[i];\n\
    \        }\n    }\n    return res;", "  if (strings.empty()) {\n    return std::nullopt;\n\
    \  }\n  // sort the vector by length\n  std::sort(strings.begin(), strings.end(),\n\
    \            [](const std::string& a, const std::string& b) {\n              return\
    \ a.length() < b.length();\n            });\n  // return the last one, which is\
    \ the longest\n  return strings.back();", "    // This is a placeholder. You may\
    \ remove this comment,\n    // but don't remove this function declaration or change\
    \ its signature.\n    // Your code goes here.\n    return {};", "  if (strings.empty())\
    \ {\n    return std::nullopt;\n  }\n  auto longest_string = std::max_element(strings.begin(),\
    \ strings.end(),\n    [](const std::string& a, const std::string& b) {\n     \
    \ return a.size() < b.size();\n    });\n  return *longest_string;", '    return
    strings.empty() ? std::nullopt : *std::max_element(strings.begin(), strings.end(),
    [](const std::string& a, const std::string& b) { return a.size() < b.size(); });',
  "    if (strings.empty()) return std::nullopt;\n    // Iterate and find the max-length\
    \ string.\n    std::string longest_string;\n    for (auto& s : strings) {\n  \
    \      if (s.length() > longest_string.length()) {\n            longest_string\
    \ = s;\n        }\n    }\n    return longest_string;", '  return std::nullopt;',
  "\tstd::optional<std::string> result = std::nullopt;\n\tfor (auto i = strings.begin();\
    \ i != strings.end(); i++) {\n\t\tif (!result) {\n\t\t\tresult = *i;\n\t\t} else\
    \ {\n\t\t\tif (result->length() < i->length()) {\n\t\t\t\tresult = *i;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn result;", '    return "";', "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::string longest = strings[0];\n\
    \    for (const auto& s : strings) {\n        if (s.size() > longest.size()) {\n\
    \            longest = s;\n        }\n    }\n    return longest;", "    std::optional<std::string>\
    \ res;\n    for (auto& s : strings) {\n        if (!res.has_value() || s.size()\
    \ > res.value().size()) {\n            res = s;\n        }\n    }\n    return\
    \ res;", "    if (strings.empty()) return std::nullopt;\n    else {\n        std::sort(strings.begin(),\
    \ strings.end(), [](const std::string& s1, const std::string& s2) {\n        \
    \    return s1.size() > s2.size();\n        });\n        return strings[0];\n\
    \    }", "    // TODO\n    if(strings.size() == 0)\n        return std::nullopt;\n\
    \    int max = strings[0].size();\n    int index = 0;\n    for(int i = 1; i <\
    \ strings.size(); i++)\n    {\n        if(strings[i].size() > max)\n        {\n\
    \            max = strings[i].size();\n            index = i;\n        }\n   \
    \ }\n    return strings[index];", "\tauto it = std::max_element(strings.begin(),\
    \ strings.end(), [](const std::string& s1, const std::string& s2) {\n\t\treturn\
    \ s1.size() < s2.size();\n\t});\n\treturn it == strings.end() ? std::nullopt :\
    \ std::optional<std::string>(*it);", "    if (strings.empty()) return std::nullopt;\n\
    \    auto longest_str = std::begin(strings);\n    for (auto it = std::begin(strings);\
    \ it != std::end(strings); ++it) {\n        if (it->size() > longest_str->size())\
    \ longest_str = it;\n    }\n    return *longest_str;", "\tstd::optional<std::string>\
    \ result;\n\t// TODO: implement this function\n\treturn result;", "\t// write\
    \ code here\n\tif (strings.size() == 0)\n\t\treturn std::nullopt;\n\tstd::string\
    \ longest;\n\tfor (int i = 0; i < strings.size(); i++) {\n\t\tif (strings[i].size()\
    \ > longest.size())\n\t\t\tlongest = strings[i];\n\t}\n\treturn longest;", " \
    \ int longest_len = 0;\n  std::string longest_str;\n  for (auto &&str : strings)\
    \ {\n    int len = str.length();\n    if (len > longest_len) {\n      longest_len\
    \ = len;\n      longest_str = str;\n    }\n  }\n  if (longest_len == 0) {\n  \
    \  return std::nullopt;\n  }\n  return longest_str;", "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto max_len = strings[0].size();\n\
    \    std::vector<int> idxs;\n    for (auto i = 0u; i < strings.size(); ++i) {\n\
    \        if (strings[i].size() == max_len) {\n            idxs.push_back(i);\n\
    \        } else if (strings[i].size() > max_len) {\n            max_len = strings[i].size();\n\
    \            idxs.clear();\n            idxs.push_back(i);\n        }\n    }\n\
    \    return strings[idxs[0]];", "    auto sz = strings.size();\n    if (sz ==\
    \ 0) {\n        return std::nullopt;\n    }\n    // get iterator to the first\
    \ element which is longest\n    auto it = std::max_element(strings.begin(), strings.end(),\
    \ [](auto const& a, auto const& b) {\n        return a.size() < b.size();\n  \
    \  });\n    return *it;", "  if (strings.empty()) {\n    return std::nullopt;\n\
    \  }\n  auto max = strings[0];\n  for (const auto& s : strings) {\n    if (s.size()\
    \ > max.size()) {\n      max = s;\n    }\n  }\n  return max;", "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto max_len = 0;\n    auto longest_string\
    \ = strings[0];\n    for (auto const& string : strings) {\n        auto len =\
    \ string.length();\n        if (len > max_len) {\n            max_len = len;\n\
    \            longest_string = string;\n        }\n    }\n    return longest_string;",
  "    int max_length = 0;\n    std::string longest_string;\n    for (auto str : strings)\
    \ {\n        if (str.length() > max_length) {\n            max_length = str.length();\n\
    \            longest_string = str;\n        }\n    }\n    if (max_length) {\n\
    \        return longest_string;\n    } else {\n        return std::nullopt;\n\
    \    }", '  return std::nullopt;', "    if (strings.empty()) {\n        return\
    \ std::nullopt;\n    }\n    std::string ret_str = strings[0];\n    size_t len\
    \ = ret_str.length();\n    size_t i = 1;\n    while (i < strings.size()) {\n \
    \       if (strings[i].length() > len) {\n            ret_str = strings[i];\n\
    \            len = ret_str.length();\n        }\n        i++;\n    }\n    return\
    \ ret_str;", '    // return std::nullopt;', "  // Your solution goes here.\n \
    \ std::string longestStr;\n  int longestStrLength = 0;\n  for (std::string str\
    \ : strings) {\n    if (str.length() > longestStrLength) {\n      longestStr =\
    \ str;\n      longestStrLength = str.length();\n    }\n  }\n  if (longestStrLength\
    \ == 0) {\n    return std::nullopt;\n  }\n  return longestStr;", "\tint maxlen\
    \ = 0;\n\tstd::string maxstr;\n\tfor (int i = 0; i < strings.size(); i++) {\n\t\
    \tif (strings[i].length() > maxlen) {\n\t\t\tmaxlen = strings[i].length();\n\t\
    \t\tmaxstr = strings[i];\n\t\t}\n\t}\n\tif (maxlen > 0)\n\t\treturn maxstr;\n\t\
    else\n\t\treturn std::nullopt;", "  if (strings.empty()) return std::nullopt;\n\
    \  std::optional<std::string> retval = strings[0];\n  for (auto s : strings) {\n\
    \    if (s.size() > retval->size()) retval = s;\n  }\n  return retval;", "   \
    \ std::optional<std::string> temp;\n    if(strings.size() == 0) {\n        return\
    \ temp;\n    } else {\n        int j = 0;\n        for(int i = 0; i < strings.size();\
    \ i++) {\n            if(strings[i].size() > strings[j].size()) {\n          \
    \      j = i;\n            }\n        }\n        return strings[j];\n    }", " \
    \   if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::string\
    \ longest = strings[0];\n    for (std::string str : strings) {\n        if (str.length()\
    \ > longest.length()) {\n            longest = str;\n        }\n    }\n    return\
    \ longest;", "\tif (strings.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\t\
    int max_length = 0;\n\tint max_index = 0;\n\tfor (int i = 0; i < strings.size();\
    \ i++) {\n\t\tif (strings[i].length() > max_length) {\n\t\t\tmax_length = strings[i].length();\n\
    \t\t\tmax_index = i;\n\t\t}\n\t}\n\treturn strings[max_index];", "    if (strings.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    std::string longest;\n    for\
    \ (auto &string : strings) {\n        if (string.length() > longest.length())\
    \ {\n            longest = string;\n        }\n    }\n\n    return longest;",
  '  // YOUR CODE HERE', "\tint max_size = 0;\n\tstd::optional<std::string> longest_string;\n\
    \tfor (auto str : strings) {\n\t\tif (str.size() > max_size) {\n\t\t\tmax_size\
    \ = str.size();\n\t\t\tlongest_string = str;\n\t\t}\n\t}\n\treturn longest_string;",
  "\tstd::optional<std::string> result;\n\tint max_len = -1;\n\tfor (const auto& s\
    \ : strings) {\n\t\tif (s.size() > max_len) {\n\t\t\tmax_len = s.size();\n\t\t\
    \tresult = s;\n\t\t}\n\t}\n\treturn result;", "    auto it = std::max_element(std::begin(strings),\
    \ std::end(strings), [](const std::string& a, const std::string& b) {\n      \
    \  return a.size() < b.size();\n    });\n    if (it == std::end(strings)) {\n\
    \        return std::nullopt;\n    }\n    return *it;", '    return std::nullopt;',
  "    std::string longestStr;\n    for (std::string const& str : strings) {\n   \
    \     if (str.length() > longestStr.length()) {\n            longestStr = str;\n\
    \        }\n    }\n    return longestStr.empty() ? std::nullopt : std::optional<std::string>(longestStr);",
  "    assert(strings.size() >= 0);\n    if (strings.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    std::string maxStr = strings[0];\n    for (int i =\
    \ 1; i < strings.size(); i++) {\n        if (strings[i].size() > maxStr.size())\
    \ {\n            maxStr = strings[i];\n        }\n    }\n    return maxStr;",
  "    size_t longestLength = 0;\n    std::string longestString;\n    for (const auto&\
    \ string : strings) {\n        if (string.length() > longestLength) {\n      \
    \      longestLength = string.length();\n            longestString = string;\n\
    \        }\n    }\n    if (longestLength == 0) {\n        return std::nullopt;\n\
    \    }\n    return longestString;", "\tstd::string longest;\n\tfor (std::string\
    \ string : strings) {\n\t\tif (string.length() > longest.length()) {\n\t\t\tlongest\
    \ = string;\n\t\t}\n\t}\n\tif (longest.length() == 0) {\n\t\treturn std::nullopt;\n\
    \t}\n\treturn longest;", "  std::optional<std::string> longest = std::nullopt;\n\
    \  for (auto& str : strings) {\n    if (!longest || longest->size() < str.size())\n\
    \      longest = str;\n  }\n  return longest;", "    if (strings.empty()) {\n\
    \        return std::nullopt;\n    }\n    std::string max = strings[0];\n    for\
    \ (const auto& i : strings) {\n        if (i.size() > max.size()) {\n        \
    \    max = i;\n        }\n    }\n    return max;", '    return {};', "  if (strings.empty())\
    \ return std::nullopt;\n  auto it = std::max_element(strings.begin(), strings.end(),\
    \ [](auto a, auto b) {\n    return a.size() < b.size();\n  });\n  return *it;",
  "    if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::vector<std::string>::iterator\
    \ it = strings.begin();\n    std::vector<std::string>::iterator max_it = it;\n\
    \    ++it;\n    while (it != strings.end()) {\n        if ((*it).length() > (*max_it).length())\
    \ {\n            max_it = it;\n        }\n        ++it;\n    }\n    return *max_it;",
  '  return std::optional<std::string>();', "  std::optional<std::string> a;\n  return\
    \ a;"]
stop_tokens:
- "\n}"
