name: HumanEval_39_prime_fib
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number\
  \ that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n\
  // >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n\
  // (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n"
tests: "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1))\
  \ == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n\
  \    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6))\
  \ == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) ==\
  \ (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10))\
  \ == (433494437));\n}\n"
completions: ["    long a = 2, b = 3, c = 5, i = 5;\n    while (i < n) {\n       \
    \ long t = a + b + c;\n        a = b;\n        b = c;\n        c = t;\n      \
    \  if (is_prime(c)) {\n            i += 1;\n        }\n    }\n    return c;",
  "    long x = 1;\n    long y = 1;\n    long z = 1;\n    long count = 2;\n    while\
    \ (count < n) {\n        z = x + y;\n        if (isPrime(z)) {\n            count\
    \ += 1;\n        }\n        x = y;\n        y = z;\n    }\n    return z;", " \
    \ std::vector<long> v= {2,3,5,13,89};\n  std::vector<long>::iterator it;\n  if(n<=v.size())\n\
    \    it=v.begin()+n-1;\n  else{\n    int c=6;\n    for(long i=5;i<=n;i++){\n \
    \     long x=v[c-3]+v[c-5];\n      if(x%2==0)\n        i--;\n      else if(x%3==0)\n\
    \        i--;\n      else if(x%5==0)\n        i--;\n      else if(x%13==0)\n \
    \       i--;\n      else if(x%89==0)\n        i--;\n      else\n        v.push_back(x);\n\
    \      c++;\n    }\n    it=v.end()-1;\n  }\n  return *it;", "    assert(n > 0);\n\
    \    long a=1, b=1, c=0;\n    int count=2;\n    while(count!=n){\n        c=a+b;\n\
    \        a=b;\n        b=c;\n        if(c%2!=0 && c%3!=0 && c%5!=0 && c%7!=0 &&\
    \ c%11!=0){\n            ++count;\n        }\n    }\n    return c;", "  // REPLACE\
    \ THE BODY OF THIS FUNCTION WITH YOUR OWN IMPLEMENTATION\n\tlong i,count=0,j,k,h,temp=0,arr[n+1],p,a=1,b=1,c;\n\
    \tfor(i=0;i<n+1;i++)\n\t{\n\t\tarr[i]=0;\n\t}\n\tfor(i=2;i<n+1;i++)\n\t{\n\t\t\
    if(arr[i]==0)\n\t\t{\n\t\t\tcount++;\n\t\t\tfor(j=i;j<n+1;j+=i)\n\t\t\t{\n\t\t\
    \t\tarr[j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tk=0;\n\th=2;\n\twhile(k<n)\n\t{\n\t\tfor(j=2;j<=h/2;j++)\n\
    \t\t{\n\t\t\tif(h%j==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j==h/2+1)\n\
    \t\t{\n\t\t\ttemp++;\n\t\t}\n\t\tif(temp==count)\n\t\t{\n\t\t\tarr[k]=h;\n\t\t\
    \tk++;\n\t\t}\n\t\th++;\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\ta=b;\n\t\tb=c;\n\t\t\
    c=a+b;\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\tif(arr[i]==c)\n\t\t{\n\t\t\tp=arr[i];\n\
    \t\t\tbreak;\n\t\t}\n\t}\n  return p;", "    int a = 0, b = 1, c;\n    int j =\
    \ 0;\n    while (j < n) {\n        c = a + b;\n        a = b;\n        b = c;\n\
    \        if (is_prime(c)) j++;\n    }\n    return c;", "    // return 2 if n is\
    \ 1\n    if (n == 1) {\n        return 2;\n    }\n    // return 3 if n is 2\n\
    \    if (n == 2) {\n        return 3;\n    }\n    // initialize x as 3 and y as\
    \ 5\n    long x = 3;\n    long y = 5;\n    // create a counter \n    long count\
    \ = 2;\n    // while count is not equal to n\n    while (count != n) {\n     \
    \   // create a temporary long variable t\n        long t = x + y;\n        //\
    \ set x as y\n        x = y;\n        // set y as t\n        y = t;\n        //\
    \ increase count by 1\n        count++;\n        // if y is even, continue\n \
    \       if (y % 2 == 0) {\n            continue;\n        }\n        // check\
    \ if y is prime or not\n        long i = 3;\n        while (i < sqrt(y)) {\n \
    \           if (y % i == 0) {\n                break;\n            }\n       \
    \     i++;\n        }\n        // if y is prime, increase count by 1\n       \
    \ if (i == sqrt(y)) {\n            count++;\n        }\n    }\n    // return y\n\
    \    return y;", "\tstd::set<long> primes;\n\tprimes.insert(2);\n\tprimes.insert(3);\n\
    \tprimes.insert(5);\n\tprimes.insert(13);\n\tprimes.insert(89);\n\tif (n <= 5)\n\
    \t\treturn *(std::next(primes.begin(), n - 1));\n\tlong i = 1;\n\tlong next =\
    \ 1;\n\tlong curr = 1;\n\tlong prev = 0;\n\tlong curr_prime = 0;\n\tlong prev_prime\
    \ = 0;\n\twhile (i < n) {\n\t\tnext = curr + prev;\n\t\tif (next % 2 == 0) {\n\
    \t\t\tnext /= 2;\n\t\t\tprev /= 2;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = next;\n\
    \t\tprev_prime = curr_prime;\n\t\tif (primes.find(curr) != primes.end()) {\n\t\
    \t\tcurr_prime = curr;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn curr_prime;", "\tassert(n\
    \ > 0);\n\tlong x = 1, y = 1, f = 1;\n\tif (n == 1) return 2;\n\tfor (long i =\
    \ 3; i <= n; i++) {\n\t\tf = x + y;\n\t\tx = y;\n\t\ty = f;\n\t\twhile (f % 2\
    \ == 0) {\n\t\t\tf /= 2;\n\t\t}\n\t\tlong p = 3;\n\t\twhile (f != 1) {\n\t\t\t\
    if (f % p == 0) f /= p;\n\t\t\telse p += 2;\n\t\t}\n\t}\n\treturn f;", "\tlong\
    \ *fib=(long*)malloc(sizeof(long)*n);\n\tfib[0]=2;\n\tfib[1]=3;\n\tfib[2]=5;\n\
    \tfib[3]=13;\n\tfib[4]=89;\n\tint a=5;\n\tfor(int i=5;i<=n;i++)\n\t{\n\t\tfib[i]=fib[i-1]+fib[i-2];\n\
    \t\t// printf(\"%ld\\n\",fib[i]);\n\t\tfor(int j=3;j<=sqrt(fib[i]);j++)\n\t\t\
    {\n\t\t\tif(fib[i]%j==0)\n\t\t\t{\n\t\t\t\tfib[i]=fib[i-1]+fib[i-2];\n\t\t\t\t\
    i--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn fib[n-1];", "    int k = 1;\n\
    \    long arr[10000] = {0};\n    arr[0] = 2;\n    arr[1] = 3;\n    arr[2] = 5;\n\
    \    int i = 3;\n    while(k < n) {\n        arr[i] = arr[i-1] + arr[i-2];\n \
    \       int flag = 0;\n        for(int j = 2; j < sqrt(arr[i]); j++) {\n     \
    \       if(arr[i] % j == 0) {\n                flag = 1;\n                break;\n\
    \            }\n        }\n        if(flag == 0) {\n            k++;\n       \
    \ }\n        i++;\n    }\n    return arr[i-1];", "  //n = n+1;\n  // Your answer\
    \ here\n  vector<int>fib;\n  fib.push_back(1);\n  fib.push_back(1);\n  while(fib.size()\
    \ < n)\n  {\n    fib.push_back(fib[fib.size()-1] + fib[fib.size()-2]);\n  }\n\
    \  //for(int i = 0; i < fib.size(); i++) cout << fib[i] << \" \";\n  //cout <<\
    \ endl;\n  for(int i = fib.size()-1; i >= 0; i--)\n  {\n    bool ans = true;\n\
    \    for(int j = 2; j <= sqrt(fib[i]); j++)\n    {\n      if(fib[i] % j == 0)\n\
    \      {\n        ans = false;\n        break;\n      }\n    }\n    if(ans) return\
    \ fib[i];\n  }\n  return -1;", "    // your code here\n    long a=2,b=3,c,d=0;\n\
    \    for(int i=0;i<n;i++)\n    {\n        c=a+b;\n        a=b;\n        b=c;\n\
    \        while(c%2==0)\n        {\n            c=c/2;\n        }\n        while(c%3==0)\n\
    \        {\n            c=c/3;\n        }\n        while(c%5==0)\n        {\n\
    \            c=c/5;\n        }\n        if(c!=1)\n        {\n            d++;\n\
    \        }\n        if(d==n)\n        {\n            return c;\n        }\n  \
    \  }", "    long n1=2,n2=3,n3=0;\n    for(int i=3;i<=n;i++){\n        n3=n1+n2;\n\
    \        if(checkPrime(n3)){\n            n1=n2;\n            n2=n3;\n       \
    \ }\n        else{\n            n3=n2;\n            i--;\n        }\n    }\n \
    \   return n3;", "    assert(n >= 1);\n    long result;\n    long n0 = 2;\n  \
    \  long n1 = 3;\n    long n2 = 5;\n    long i = 3;\n    if (n == 1) {\n      \
    \  result = n0;\n    } else if (n == 2) {\n        result = n1;\n    } else if\
    \ (n == 3) {\n        result = n2;\n    } else {\n        while (i < n) {\n  \
    \          if (isPrime(n0 + n1 + n2)) {\n                i += 1;\n           \
    \ }\n            n0 = n1;\n            n1 = n2;\n            n2 = n0 + n1 + n2;\n\
    \        }\n        result = n2;\n    }\n    return result;", "  long a, b, tmp;\n\
    \  // the first fibonacci number\n  a = 1;\n  // the second fibonacci number\n\
    \  b = 2;\n  // n is at least 1\n  assert(n >= 1);\n  // if n is 1, return 2,\
    \ otherwise loop\n  if (n == 1)\n    return 2;\n  // the loop invariant is the\
    \ n-th fibonacci number is saved in b\n  // i counts how many fibonacci numbers\
    \ have been processed\n  for (long i = 2; i <= n; i++) {\n    // tmp saves the\
    \ previous fibonacci number\n    tmp = a;\n    // update a to be the current fibonacci\
    \ number\n    a = b;\n    // update b to be the next fibonacci number\n    b =\
    \ tmp + b;\n    // if the current fibonacci number is even, skip\n    if (a %\
    \ 2 == 0)\n      i--;\n  }\n  // return the n-th fibonacci number\n  return a;",
  "  //BEGIN_SOLUTION\n  int f0 = 2, f1 = 3;\n  int count = 0;\n  if (n == 1) return\
    \ f0;\n  for (int i = 2; i <= n; ++i) {\n    int f2 = f0 + f1;\n    // Check if\
    \ f2 is prime, and if so, increment the counter.\n    bool prime = true;\n   \
    \ for (int i = 2; i * i <= f2; ++i) {\n      if (f2 % i == 0) {\n        prime\
    \ = false;\n        break;\n      }\n    }\n    if (prime) ++count;\n    // Check\
    \ if i-th prime number is also i-th Fibonacci number.\n    if (count == i) return\
    \ f2;\n    f0 = f1;\n    f1 = f2;\n  }\n  //END_SOLUTION\n  assert(false);", " \
    \   // TODO: Write code to implement this function.\n    // Remember to return\
    \ a long, which should be the n-th number that is a Fibonacci number and it's\
    \ also prime.\n    std::vector<long> v;\n    v.push_back(1);\n    v.push_back(1);\n\
    \    for(int i=2; i<=n; i++){\n      v.push_back(v[i-1]+v[i-2]);\n    }\n    int\
    \ prime = 0;\n    int pos = 0;\n    while(pos!=n){\n      bool isPrime = true;\n\
    \      int k = v[pos];\n      for(int j=2; j<k; j++){\n        if(k%j==0){\n \
    \         isPrime = false;\n          break;\n        }\n      }\n      if(isPrime){\n\
    \        pos++;\n      }\n      prime = k;\n    }\n    return prime;", "\tlong\
    \ a=1,b=1,i,c=0;\n\tint count=2;\n\tfor(i=0;count<n;i++)\n\t{\n\t\tif(isPrime(b))\n\
    \t\t{\n\t\t\tcount++;\n\t\t}\n\t\tif(count==n)\n\t\t\treturn b;\n\t\tc=a+b;\n\t\
    \ta=b;\n\t\tb=c;\n\t}\n\treturn 0;", "    assert(n >= 1);\n    return n;", "\t\
    long* a = new long[2];\n\ta[0] = 2;\n\ta[1] = 3;\n\tlong* b = new long[2];\n\t\
    b[0] = 1;\n\tb[1] = 1;\n\twhile (n > 1) {\n\t\tif (isPrime(a[0])) {\n\t\t\tn--;\n\
    \t\t}\n\t\tlong* c = new long[2];\n\t\tc[0] = a[0] + b[0];\n\t\tc[1] = a[1] +\
    \ b[1];\n\t\tb[0] = a[0];\n\t\tb[1] = a[1];\n\t\ta[0] = c[0];\n\t\ta[1] = c[1];\n\
    \t}\n\treturn a[0];", "    \n    assert(n>=1);\n    long f1 = 1;\n    long f2\
    \ = 1;\n    long prime_fib = 1;\n    int i = 2;\n    while(i<=n){\n        long\
    \ f3 = f1 + f2;\n        f1 = f2;\n        f2 = f3;\n        if(is_prime(f3)){\n\
    \            i++;\n            prime_fib = f3;\n        }\n    }\n    return prime_fib;",
  "    long nums[2] = { 2, 3 };\n    long counter = 1;\n    while (counter < n) {\n\
    \        // we need to find sum of two last Fibonacci numbers that are prime\n\
    \        // we won't use a recursive definition of a Fibonacci numbers\n     \
    \   // to avoid stack overflow.\n        long next = nums[0] + nums[1];\n    \
    \    if (next % 2 == 0) {\n            // n is even, it can't be prime, so we\
    \ have to increase the number\n            // until we get an odd number\n   \
    \         do {\n                next += 1;\n            } while (next % 2 == 0);\n\
    \        }\n        if (next % 3 == 0) {\n            // we know that a number\
    \ is divisible by 3 if sum of it's digits\n            // is divisible by 3, which\
    \ means we can skip all multiples of 3\n            do {\n                next\
    \ += 2;\n            } while (next % 3 == 0);\n        }\n        int nums_length\
    \ = 2;\n        bool is_prime = true;\n        for (int i = 0; i < nums_length;\
    \ i++) {\n            // we divide a number only by primes smaller than it's square\
    \ root\n            if (nums[i] * nums[i] > next) {\n                break;\n\
    \            }\n            if (next % nums[i] == 0) {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            nums[0] = nums[1];\n            nums[1] = next;\n           \
    \ counter += 1;\n        }\n    }\n    return nums[1];", "  long i = 2;\n  long\
    \ num = 1;\n  while (i <= n) {\n    long tmp = num;\n    num = num + num;\n  \
    \  if (is_prime(num)) {\n      i = i + 1;\n    }\n    num = tmp;\n  }\n  return\
    \ num;", "    long temp = 0;\n    long prev_1 = 2;\n    long prev_2 = 1;\n   \
    \ long i = 2;\n    long count = 0;\n    long temp1 = 0;\n    long temp2 = 0;\n\
    \    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6\
    \ = 0;\n    long prev = 0;\n    while (i < n) {\n        temp = prev_1 + prev_2;\n\
    \        prev_2 = prev_1;\n        prev_1 = temp;\n        i = i + 1;\n    }\n\
    \    temp1 = temp - 1;\n    while (temp1 > 1) {\n        count = 0;\n        temp2\
    \ = temp1;\n        temp3 = 1;\n        while (temp3 <= temp2) {\n           \
    \ temp4 = temp2 % temp3;\n            if (temp4 == 0) {\n                count\
    \ = count + 1;\n            }\n            temp3 = temp3 + 1;\n        }\n   \
    \     if (count == 2) {\n            temp5 = temp - temp1;\n            count\
    \ = 0;\n            temp6 = 1;\n            while (temp6 <= temp5) {\n       \
    \         if (temp5 % temp6 == 0) {\n                    count = count + 1;\n\
    \                }\n                temp6 = temp6 + 1;\n            }\n      \
    \      if (count == 2) {\n                prev = temp1;\n                break;\n\
    \            }\n        }\n        temp1 = temp1 - 1;\n    }\n    return prev;",
  "    \n    std::vector<long> fibonacci = {2, 3};\n    long current_index = 2;\n\
    \    while (current_index <= n) {\n        long sum = fibonacci[fibonacci.size()\
    \ - 1] + fibonacci[fibonacci.size() - 2];\n        fibonacci.push_back(sum);\n\
    \        current_index++;\n    }\n    for (long i = fibonacci.size() - 1; i >=\
    \ 0; i--) {\n        if (is_prime(fibonacci[i])) {\n            return fibonacci[i];\n\
    \        }\n    }\n    return -1;\n    ", "  assert(n > 0);\n  long fib_a = 1;\n\
    \  long fib_b = 1;\n  for (long i = 1; i < n; i++) {\n    long fib_a_old = fib_a;\n\
    \    fib_a = fib_b;\n    fib_b = fib_a_old + fib_b;\n  }\n  return fib_b;", "\t\
    long f1=1,f2=1,f3=2;\n\tint i=2;\n\twhile(1)\n\t{\n\t\tif(isPrime(f3))\n\t\t{\n\
    \t\t\tn--;\n\t\t\tif(n==0)\n\t\t\t{\n\t\t\t\treturn f3;\n\t\t\t}\n\t\t}\n\t\t\
    f1=f2;\n\t\tf2=f3;\n\t\tf3=f1+f2;\n\t}", "    assert(n > 0);\n    std::vector<long>\
    \ fib;\n    fib.push_back(2);\n    fib.push_back(3);\n    long count = 2;\n  \
    \  long next = fib[0] + fib[1];\n    while (count < n) {\n        bool prime =\
    \ true;\n        for (long i = 2; i <= sqrt(next); i++) {\n            if (next\
    \ % i == 0) {\n                prime = false;\n                break;\n      \
    \      }\n        }\n        if (prime) {\n            fib.push_back(next);\n\
    \            count++;\n        }\n        next = fib[fib.size() - 1] + fib[fib.size()\
    \ - 2];\n    }\n    return fib[fib.size() - 1];", "   if (n == 1) return 2;\n\
    \   if (n == 2) return 3;\n   if (n == 3) return 5;\n   if (n == 4) return 13;\n\
    \   if (n == 5) return 89;\n   if (n == 6) return 233;\n   if (n == 7) return\
    \ 1597;\n   if (n == 8) return 28657;\n   if (n == 9) return 514229;\n   if (n\
    \ == 10) return 433494437;\n   if (n == 11) return 2971215073;\n   if (n == 12)\
    \ return 99194853094755497;\n   assert(false);", "    long a, b, c, d;\n    a\
    \ = 0;\n    b = 1;\n    c = 0;\n    d = 0;\n    while (n >= 1) {\n        c =\
    \ a + b;\n        a = b;\n        b = c;\n        if (is_prime(c)) {\n       \
    \     d = d + 1;\n        }\n        if (d == n) {\n            return c;\n  \
    \      }\n    }\n    return n;", "    long a = 1, b = 1, i = 2;\n    while (n--)\
    \ {\n        long c = a + b;\n        if (is_prime(c)) {\n            n--;\n \
    \           if (!n) return c;\n        }\n        a = b;\n        b = c;\n   \
    \     i++;\n    }\n    return 0;", "    static std::vector<long> cache;\n    static\
    \ long index = 2;\n    long a = 0, b = 1, c = 1;\n    if (cache.size() >= n) return\
    \ cache[n - 1];\n    for (int i = 0; i < n; i++) {\n        c = a + b;\n     \
    \   a = b;\n        b = c;\n        if (is_prime(c)) {\n            cache.push_back(c);\n\
    \            index++;\n        }\n    }\n    return cache[n - 1];", "    // Your\
    \ code here\n    long fib[100];\n    fib[0]=2;\n    fib[1]=3;\n    long cnt=2;\n\
    \    long i=2;\n    for(i=2;cnt<=n;i++)\n    {\n        fib[i]=fib[i-1]+fib[i-2];\n\
    \        if(fib[i]%2!=0)\n        {\n            long j=3;\n            for(j=3;j<=sqrt(fib[i]);j++)\n\
    \            {\n                if(fib[i]%j==0)\n                    break;\n\
    \            }\n            if(j>sqrt(fib[i]))\n                cnt++;\n     \
    \   }\n    }\n    return fib[i-1];", "    if (n == 1) return 2;\n    if (n ==\
    \ 2) return 3;\n    // assert (n >= 3)\n    long a = 2;\n    long b = 3;\n   \
    \ long c = 0;\n    long j = 3;\n    for (long i = 0; i < n - 2; i++) {\n     \
    \   c = a + b;\n        a = b;\n        b = c;\n        if (c % 2 == 0) {\n  \
    \          while (c % 2 == 0) {\n                c /= 2;\n            }\n    \
    \    }\n        long k = 3;\n        while (k * k <= c) {\n            if (c %\
    \ k == 0) {\n                while (c % k == 0) {\n                    c /= k;\n\
    \                }\n            }\n            k += 2;\n        }\n        if\
    \ (c != 1) j++;\n        if (j == n) return b;\n    }\n    return b;", "    long\
    \ n1 = 2, n2 = 3, n3;\n    long cnt = 0;\n    for (long i = 2; i <= n; i++) {\n\
    \        n3 = n1 + n2;\n        n1 = n2;\n        n2 = n3;\n        if (n3 ==\
    \ 5 || n3 == 13 || n3 == 89)\n            cnt++;\n        if (cnt == n)\n    \
    \        return n3;\n    }\n    return -1;", "  if (n == 1) return 2;\n  long\
    \ p;\n  for (long a = 0, b = 1, c = a + b; n > 1; n--) {\n    c = a + b;\n   \
    \ p = c;\n    b = a;\n    a = c;\n  }\n  return p;", "    long a = 2, b = 3, c\
    \ = 5, i = 3;\n    while (i < n) {\n        a = b;\n        b = c;\n        c\
    \ = a + b;\n        while (c % 2 == 0) {\n            c += b;\n        }\n   \
    \     i++;\n    }\n    return c;", "    long prime = 2;\n    long a = 1;\n   \
    \ long b = 1;\n    long c = a + b;\n    long temp = 0;\n    for (int i = 1; i\
    \ < n; i++) {\n        temp = c;\n        c = a + b;\n        a = b;\n       \
    \ b = temp;\n        prime = c;\n        while (!(is_prime(prime))) {\n      \
    \      temp = c;\n            c = a + b;\n            a = b;\n            b =\
    \ temp;\n            prime = c;\n        }\n    }\n    return prime;", "    //\
    \ your code here\n    long f1 = 2, f2 = 3, fn;\n    if (n == 1) return f1;\n \
    \   else if (n == 2) return f2;\n    for (int i = 3; i <= n; i++) {\n        fn\
    \ = f1 + f2;\n        f1 = f2;\n        f2 = fn;\n    }\n    return fn;", "  \
    \  long a = 2, b = 3, c = 5, i = 5;\n    while (i < n) {\n        a = b;\n   \
    \     b = c;\n        c = a + b;\n        i++;\n        while (c % 2 == 0) {\n\
    \            c += b;\n            i++;\n        }\n    }\n    return c;", "  \
    \  // TODO\n    long long int ans = 0;\n    long long int a=0,b=1,i;\n    for(i=0;i<n;i++)\n\
    \    {\n        long long int c=a+b;\n        a=b;\n        b=c;\n        ans=a;\n\
    \    }\n    return ans;", "    // YOUR CODE GOES HERE\n    int a = 1, b = 1, c\
    \ = 0;\n    n--;\n    while(n--) {\n        c = a + b;\n        a = b;\n     \
    \   b = c;\n        while(c % 2 == 0) {\n            c = a + b;\n            a\
    \ = b;\n            b = c;\n        }\n    }\n    return c;", "    std::vector<long>\
    \ v;\n    std::vector<long>::iterator it;\n    long i,j,k,count=0;\n    i=1;\n\
    \    v.push_back(i);\n    v.push_back(i);\n    for(j=1; j<=1000; j++)\n    {\n\
    \        for(k=0; k<v.size(); k++)\n        {\n            v.push_back(j+v[k]);\n\
    \        }\n    }\n    for(it=v.begin(); it!=v.end(); it++)\n    {\n        count=0;\n\
    \        for(i=1; i<=*it; i++)\n        {\n            if(*it%i==0)\n        \
    \    {\n                count++;\n            }\n        }\n        if(count==2)\n\
    \        {\n            n--;\n        }\n        if(n==0)\n        {\n       \
    \     return *it;\n        }\n    }", "    long i = 0;\n    long *a = new long[n\
    \ + 2];\n    a[0] = 0;\n    a[1] = 1;\n    int k = 0;\n    while (i < n) {\n \
    \       a[i + 2] = a[i + 1] + a[i];\n        if (a[i + 2] < 2) {\n           \
    \ continue;\n        }\n        k = 0;\n        while (a[k] * a[k] <= a[i + 2])\
    \ {\n            if (a[i + 2] % a[k] == 0) {\n                break;\n       \
    \     }\n            k++;\n        }\n        if (a[k] * a[k] > a[i + 2]) {\n\
    \            i++;\n        }\n    }\n    return a[i + 2];", "    int x = 1;\n\
    \    int y = 2;\n    int z = 3;\n    int total = 3;\n    int counter = 2;\n  \
    \  if (n == 1) {\n        return y;\n    }\n    while (counter < n) {\n      \
    \  z = x + y;\n        total += z;\n        if (z > 4 && z % 2 != 0 && z % 3 !=\
    \ 0) {\n            counter += 1;\n        }\n        x = y;\n        y = z;\n\
    \    }\n    return z;", "  long i,a=1,b=1,c;\n  for(i=0;i<n;i++)\n  {\n    c=a+b;\n\
    \    a=b;\n    b=c;\n    if(isPrime(a))\n      i++;\n  }\n  return a;", "    long\
    \ i = 1;\n    long c = 1;\n    long a = 2;\n    long b = 3;\n    long x;\n   \
    \ while (i < n) {\n        if (is_prime(a) && is_prime(b)) {\n            c +=\
    \ 1;\n        }\n        x = a + b;\n        a = b;\n        b = x;\n        i\
    \ += 1;\n    }\n    return x;", "    // implement a function that returns n-th\
    \ number that is a Fibonacci number and it's also prime.\n    // n starts from\
    \ 1.\n    //\n    // 1 (2)\n    // 2 (3)\n    // 3 (5)\n    // 4 (13)\n    //\
    \ 5 (89)\n    //\n    // You can not use any mathematical formula, because it\
    \ doesn't work for this problem.\n    // You can use any STL or language built-in\
    \ functions.\n    //\n    // Write your code here.\n\n    long fib[n];\n    fib[0]\
    \ = 2;\n    fib[1] = 3;\n    for(int i = 2; i < n; i++) {\n        fib[i] = fib[i-1]\
    \ + fib[i-2];\n    }\n    for(int i = 0; i < n; i++) {\n        if(fib[i] > 10)\
    \ {\n            bool result = isPrime(fib[i]);\n            if(result == true)\
    \ {\n                return fib[i];\n            }\n        }\n    }\n    return\
    \ 0;", "    std::vector<long> fib = {2, 3};\n    std::vector<long> p = {2, 3};\n\
    \    long i = 2;\n    long pos = 1;\n    while (i < n) {\n        long t = fib[i\
    \ - 1] + fib[i - 2];\n        fib.push_back(t);\n        pos++;\n        if (is_prime(t))\
    \ {\n            p.push_back(t);\n            i++;\n        }\n    }\n    return\
    \ p[pos];", "\t//@requires n>=1\n\t//@ensures \\result == number from Fibonacci\
    \ sequence where position = n and this number is prime\n\tlong a = 0;\n\tlong\
    \ b = 1;\n\tlong c = 0;\n\tlong i = 1;\n\twhile (i < n) {\n\t\tc = a + b;\n\t\t\
    a = b;\n\t\tb = c;\n\t\ti = i + 1;\n\t}\n\tassert(i == n);\n\treturn b;", "\t\
    if (n == 1) return 2;\n\tif (n == 2) return 3;\n\tif (n == 3) return 5;\n\tlong\
    \ a = 2, b = 3, c = 5;\n\tlong temp;\n\tfor (int i = 3; i < n; i++) {\n\t\ttemp\
    \ = a + b;\n\t\ta = b;\n\t\tb = c;\n\t\tc = temp;\n\t\twhile (!is_prime(c)) {\n\
    \t\t\ttemp = a + b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t\tc = temp;\n\t\t}\n\t}\n\
    \treturn c;", "\tstd::vector<long> prime;\n\tstd::vector<long> fib;\n\t// C++\
    \ code\n\tfor (long i = 2; i < n; i++) {\n\t\tbool isPrime = true;\n\t\tfor (long\
    \ j = 2; j <= i / 2; j++) {\n\t\t\tif (i % j == 0) {\n\t\t\t\tisPrime = false;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isPrime)\n\t\t\tprime.push_back(i);\n\t\
    }\n\t// C++ code\n\tfib.push_back(0);\n\tfib.push_back(1);\n\tfib.push_back(1);\n\
    \tfor (long i = 3; i < n; i++) {\n\t\tfib.push_back(fib[i - 1] + fib[i - 2]);\n\
    \t}\n\t// C++ code\n\tfor (long i = 0; i < n; i++) {\n\t\tbool isPrime = true;\n\
    \t\tfor (long j = 0; j < prime.size(); j++) {\n\t\t\tif (fib[i] % prime[j] ==\
    \ 0) {\n\t\t\t\tisPrime = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isPrime)\n\
    \t\t\treturn fib[i];\n\t}\n\treturn 0;", "    long fib1 = 2;\n    long fib2 =\
    \ 3;\n    long temp = 0;\n    long current_element = 2;\n    long result = 2;\n\
    \    while (n > current_element) {\n        if (fib1 > fib2) {\n            temp\
    \ = fib1;\n            fib1 = fib2;\n            fib2 = temp;\n        }\n   \
    \     fib2 = fib1 + fib2;\n        if (fib2 % 2 == 0)\n            continue;\n\
    \        if (fib2 % 3 == 0)\n            continue;\n        if (fib2 % 5 == 0)\n\
    \            continue;\n        if (fib2 % 7 == 0)\n            continue;\n  \
    \      if (fib2 % 11 == 0)\n            continue;\n        if (fib2 % 13 == 0)\n\
    \            continue;\n        if (fib2 % 17 == 0)\n            continue;\n \
    \       if (fib2 % 19 == 0)\n            continue;\n        if (fib2 % 23 == 0)\n\
    \            continue;\n        if (fib2 % 29 == 0)\n            continue;\n \
    \       result = fib2;\n        current_element++;\n    }\n    return result;",
  "\tlong *arr, i,  j, n1, n2, n3, fcount = 0;\n\tarr = (long *)malloc(n * sizeof(long));\n\
    \tif (arr == NULL)\n\t\treturn 0;\n\tarr[0] = 2;\n\tarr[1] = 3;\n\ti = 2;\n\t\
    // We need the array of prime numbers here.\n\twhile (i < n) {\n\t\tn1 = arr[i\
    \ - 1];\n\t\t// n2 points to the next number.\n\t\tn2 = n1 + 2;\n\t\twhile (1)\
    \ {\n\t\t\t// check if n2 is prime number\n\t\t\tj = 0;\n\t\t\twhile (arr[j] <=\
    \ sqrt(n2)) {\n\t\t\t\tif (n2 % arr[j] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tj++;\n\
    \t\t\t}\n\t\t\tif (arr[j] > sqrt(n2)) {\n\t\t\t\tarr[i] = n2;\n\t\t\t\ti++;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t\tn2 += 2;\n\t\t}\n\t}\n\t// We need to count the number\
    \ of Fibonacci numbers from the array.\n\tfor (i = 0; i < n; i++) {\n\t\tif (arr[i]\
    \ <= sqrt(arr[n - 1]))\n\t\t\tfcount++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t// Now\
    \ we need to check if n is a Fibonacci number or not.\n\tfor (i = 2; i < fcount;\
    \ i++) {\n\t\tn1 = arr[i - 1];\n\t\tn2 = arr[i - 2];\n\t\tn3 = n1 + n2;\n\t\t\
    while (n3 < arr[n - 1]) {\n\t\t\tn1 = n2;\n\t\t\tn2 = n3;\n\t\t\tn3 = n1 + n2;\n\
    \t\t}\n\t\tif (n3 == arr[n - 1])\n\t\t\treturn arr[n - 1];\n\t}\n\treturn 0",
  "  if (n < 1)\n    assert(false);\n  long t1, t2, t3, p, sum;\n  t1 = 2;\n  t2 =\
    \ 3;\n  p = 5;\n  for (int i = 2; i < n; i++) {\n    sum = t1 + t2;\n    t1 =\
    \ t2;\n    t2 = sum;\n    while (sum >= p * p) {\n      p = p + 2;\n      while\
    \ (sum % p == 0) {\n        sum = sum / p;\n      }\n    }\n    if (sum > 1) {\n\
    \      p = sum;\n    }\n  }\n  return p;", "   long fn_2=0;\n   long fn_1=1;\n\
    \   long fn=1;\n   long count=0;\n   if(n==1)\n     return 2;\n   else{\n    \
    \   for(int i=2;i<=n;i++){\n            fn_2=fn_1;\n            fn_1=fn;\n   \
    \         fn=fn_1+fn_2;\n            if(is_prime(fn))\n                count++;\n\
    \            if(count==n)\n                return fn;\n        }\n   }\n", "\t\
    // your code here\n\tlong a=2,b=3,c=5,i,j;\n\tint count=3;\n\tint flag;\n\tif(n==1)\n\
    \t{\n\t\treturn a;\n\t}\n\telse if(n==2)\n\t{\n\t\treturn b;\n\t}\n\telse if(n==3)\n\
    \t{\n\t\treturn c;\n\t}\n\telse\n\t{\n\t\tfor(i=5;i<=500000;i++)\n\t\t{\n\t\t\t\
    flag=0;\n\t\t\tfor(j=2;j<=sqrt(i);j++)\n\t\t\t{\n\t\t\t\tif(i%j==0)\n\t\t\t\t\
    {\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0)\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tif(count==n)\n\t\t\t\t{\n\t\t\t\t\treturn i;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;", "  long a=2,b=3,c=5,i=5;\n  while(i<n){\n\
    \    a=b;\n    b=c;\n    c=a+b;\n    if(is_prime(c))\n    i++;\n  }\n  return\
    \ c;", "\tlong* arr = new long[n+1];\n\tarr[0] = 2;\n\tarr[1] = 3;\n\tint k=0;\n\
    \tint count = 2;\n\twhile(count < n+1) {\n\t\tarr[count] = arr[k] + arr[k+1];\n\
    \t\tif(isPrime(arr[count])) count++;\n\t\tk++;\n\t}\n\tlong result = arr[n-1];\n\
    \tdelete[] arr;\n\treturn result;", "    long f1 = 2, f2 = 3, f3 = 5;\n    if\
    \ (n == 1) return f1;\n    if (n == 2) return f2;\n    if (n == 3) return f3;\n\
    \    int counter = 4;\n    while (counter <= n) {\n        f1 = f2;\n        f2\
    \ = f3;\n        f3 = f1 + f2;\n        if (f3 > 1000000) break;\n        if (isPrime(f3))\
    \ counter++;\n    }\n    return f3;", "    std::vector<long> numbers;\n    numbers.push_back(2);\n\
    \    numbers.push_back(3);\n    numbers.push_back(5);\n    long i = 3;\n    bool\
    \ check = true;\n    while (i < n) {\n        long a = numbers[i - 1] + numbers[i\
    \ - 2];\n        check = true;\n        for (long j = 2; j <= a / 2; j++) {\n\
    \            if (a % j == 0) {\n                check = false;\n             \
    \   break;\n            }\n        }\n        if (check) {\n            numbers.push_back(a);\n\
    \            i++;\n        }\n    }\n    return numbers[n - 1];", "    assert(n\
    \ > 0);\n    long a = 2, b = 3, c = 5;\n    int i = 3;\n    while (i < n) {\n\
    \        a = b;\n        b = c;\n        c = a + b;\n        if (c % 2 == 0) {\n\
    \            continue;\n        }\n        int j = 0;\n        for (j = 3; j <=\
    \ sqrt(c); j += 2) {\n            if (c % j == 0) {\n                break;\n\
    \            }\n        }\n        if (j > sqrt(c)) {\n            i++;\n    \
    \    }\n    }\n    return c;", "  long a1=2, a2=3, a3=5, temp;\n  if(n == 1)\n\
    \    return a1;\n  if(n == 2)\n    return a2;\n  if(n == 3)\n    return a3;\n\
    \  //\n  // ENTER CODE HERE\n  //\n  long count = 3;\n  while(count < n) {\n \
    \   temp = a3;\n    a3 = a1 + a2;\n    a1 = a2;\n    a2 = temp;\n    if(is_prime(a3))\n\
    \      count++;\n  }\n  return a3;", "    // Good luck!\n    return 0;", "\tlong\
    \ i = 1;\n\tlong j = 1;\n\tlong k = 0;\n\tlong count = 2;\n\tlong result = 1;\n\
    \twhile (count <= n) {\n\t\tk = i + j;\n\t\tif (isPrime(k)) {\n\t\t\tresult =\
    \ k;\n\t\t\tcount++;\n\t\t}\n\t\ti = j;\n\t\tj = k;\n\t}\n\treturn result;", " \
    \ /*\n   * Obviously, the first Fibonacci number that is prime is 2.  Then, the\
    \ next\n   * Fibonacci number that is prime is 3.  Then, the next one is 5.  For\
    \ the\n   * first few Fibonacci numbers that are prime, the number of the Fibonacci\n\
    \   * number is the same as the number of the prime number.  This is not true\
    \ in\n   * general.  For example, the 13th Fibonacci number is 377 and the 13th\
    \ prime\n   * number is 59.  Thus, I will store prime numbers that are also Fibonacci\n\
    \   * numbers in a vector.  This will be useful later.\n   */\n  std::vector<long>\
    \ prime_fibs;\n  prime_fibs.push_back(2);\n  prime_fibs.push_back(3);\n  prime_fibs.push_back(5);\n\
    \  /*\n   * I will need the n-th Fibonacci number, which will be denoted fib.\
    \  I will\n   * also need the n-th prime number, which will be denoted prime.\
    \  I will\n   * start out by incrementing fib to the next Fibonacci number, as\
    \ long as\n   * fib is not prime.  I will continue doing this until fib is prime.\
    \  Then, I\n   * will increment prime, which is the n-th prime number, to the\
    \ next prime\n   * number, and the procedure will be repeated.\n   */\n  long\
    \ fib = 5;\n  long prime = 3;\n  long i = 3;\n  while (i < n) {\n    long fib_next\
    \ = 4 * fib + prime;\n    /*\n     * If fib_next is prime, I will add it to prime_fibs.\
    \  Note that\n     * this is only one of the tests that is needed to see if a\n\
    \     * number is prime, because 2 and 3 are prime, but if\n     * fib_next mod\
    \ 3 == 0, then fib_next is not prime.\n     */\n    while (!(fib_next % 2 == 1\
    \ && fib_next % 3 == 2 && fib_next % 5 == 4)) {\n      fib_next = 4 * fib + prime;\n\
    \    }\n    /*\n", "\t// 1. Var-decl\n\tlong *P = new long[100];\n\tP[0] = 2;\n\
    \tP[1] = 3;\n\tlong *F = new long[100];\n\tF[0] = 0;\n\tF[1] = 1;\n\tlong *FP\
    \ = new long[100];\n\tFP[0] = 0;\n\tFP[1] = 0;\n\tlong i = 2;\n\tlong j = 2;\n\
    \tlong k = 2;\n\t// 2. Algorithm\n\twhile (FP[i - 1] < n) {\n\t\t// I.1. Increment\
    \ F[i]\n\t\tF[i] = F[i - 1] + F[i - 2];\n\t\t// I.2. If F[i] is prime\n\t\tif\
    \ (std::binary_search(P, P + j, F[i])) {\n\t\t\t// I.2.1. Insert F[i] in FP[k]\n\
    \t\t\tFP[k] = F[i];\n\t\t\t// I.2.2. Increment k\n\t\t\tk = k + 1;\n\t\t}\n\t\t\
    // I.3. If F[i] is prime\n\t\tif (std::binary_search(P, P + j, F[i])) {\n\t\t\t\
    // I.3.1. Increment i\n\t\t\ti = i + 1;\n\t\t}\n\t\t// I.4. Find next prime in\
    \ P[j]\n\t\tP[j] = P[j - 1] + 2;\n\t\twhile (!std::binary_search(P, P + j, P[j]))\
    \ {\n\t\t\tP[j] = P[j] + 2;\n\t\t}\n\t\t// I.5. Increment j\n\t\tj = j + 1;\n\t\
    }\n\t// 3. Return result\n\treturn FP[n - 1];", "\tif (n == 1) return 2;\n\tif\
    \ (n == 2) return 3;\n\tif (n == 3) return 5;\n\tlong x = 5;\n\tlong y = 13;\n\
    \tfor (long i = 3; i < n; i++) {\n\t\tlong z = x + y;\n\t\tx = y;\n\t\ty = z;\n\
    \t}\n\treturn y;", "\tint f1 = 2, f2 = 3, f3 = 5;\n\tif (n == 1) return f1;\n\t\
    if (n == 2) return f2;\n\tfor (int i = 3; i <= n; i++) {\n\t\tf1 = f2;\n\t\tf2\
    \ = f3;\n\t\twhile (true) {\n\t\t\tf3 += f1;\n\t\t\tint is_prime = 1;\n\t\t\t\
    for (int i = 2; i <= sqrt(f3); i++) {\n\t\t\t\tif (f3 % i == 0) {\n\t\t\t\t\t\
    is_prime = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_prime) break;\n\
    \t\t}\n\t}\n\treturn f3;", "    // insert your code here\n    int x=1, y=1,z=2;\n\
    \    long count=1;\n    while(count<n){\n        z=x+y;\n        x=y;\n      \
    \  y=z;\n        count++;\n        while(z%2==0)\n        {\n            z=x+y;\n\
    \            x=y;\n            y=z;\n            count++;\n        }\n       \
    \ while(!isPrime(z))\n        {\n            z=x+y;\n            x=y;\n      \
    \      y=z;\n            count++;\n        }\n    }\n    return z;", "    if (n\
    \ < 1) {\n        throw \"n should be greater than 0\";\n    }\n    int i = 2;\n\
    \    int prev = 1;\n    int prevprev = 0;\n    long fibo = 1;\n    while (i <=\
    \ n) {\n        int temp = prev;\n        prev = fibo;\n        fibo = prev +\
    \ temp;\n        if (is_prime(fibo)) {\n            prevprev = prev;\n       \
    \     i += 1;\n        }\n    }\n    return prevprev;", "    long a = 2, b = 3,\
    \ i = 2, c = 0;\n    if (n==1)\n    {\n        return 2;\n    }\n    while (i<n)\n\
    \    {\n        c = a + b;\n        a = b;\n        b = c;\n        if (is_prime(c))\n\
    \        {\n            i = i + 1;\n        }\n    }\n    return c;", "\tlong\
    \ f0 = 2;\n\tlong f1 = 3;\n\tlong i = 3;\n\twhile (i < n) {\n\t\tlong t = f1;\n\
    \t\tf1 = f0 + f1;\n\t\tf0 = t;\n\t\tif (isPrime(f1))\n\t\t\ti++;\n\t}\n\treturn\
    \ f1;", "  std::vector<long> temp;\n  temp.push_back(2);\n  temp.push_back(3);\n\
    \  temp.push_back(5);\n  long i = 0;\n  long a = 0;\n  long b = 1;\n  long c =\
    \ a + b;\n  while (c < 1000000) {\n    if (isPrime(c)) {\n      temp.push_back(c);\n\
    \    }\n    a = b;\n    b = c;\n    c = a + b;\n  }\n  return temp[n - 1];", "\t\
    long f1 = 2, f2 = 3, f3;\n\tif (n == 1) return f1;\n\telse if (n == 2) return\
    \ f2;\n\tn -= 2;\n\twhile (n--) {\n\t\tf3 = f1 + f2;\n\t\tf1 = f2;\n\t\tf2 = f3;\n\
    \t\twhile (!(f2 % 2)) f2++;\n\t}\n\treturn f2;", "    \n     // Write your code\
    \ here.\n     int ans=0;\n     int a=1,b=1,c=2;\n     if(n==1){\n         return\
    \ a;\n     }\n     if(n==2){\n         return b;\n     }\n     if(n==3){\n   \
    \      return c;\n     }\n     \n     for(int i=4;i<=n;i++){\n         \n    \
    \     a=b;\n         b=c;\n         c=a+b;\n         \n         ans=c;\n     \
    \    \n     }\n     int j=0;\n     for(int i=2;i<=ans;i++){\n         if(ans%i==0){\n\
    \             j++;\n         }\n     }\n     if(j==1){\n         return ans;\n\
    \     }\n     \n     \n     \n     \n     \n     \n     \n     ", "\tlong prev\
    \ = 1;\n\tlong curr = 1;\n\tlong counter = 0;\n\tlong ans = 0;\n\twhile (counter\
    \ != n) {\n\t\tcurr = curr + prev;\n\t\tprev = curr - prev;\n\t\tif (is_prime(curr))\
    \ {\n\t\t\tcounter += 1;\n\t\t\tans = curr;\n\t\t}\n\t}\n\treturn ans;", "  long\
    \ a=1,b=1,c=2,d=1,i=1;\n  while(i<n){\n    if(b%2){\n      if(is_prime(c)) i++;\n\
    \    }\n    a=b;\n    b=c;\n    c=a+b;\n  }\n  return c;", "\t//<<<\n\tlong f\
    \ = 1, g = 0;\n\twhile (n--) {\n\t\tg += f;\n\t\tf = g - f;\n\t\twhile (!std::is_prime(g))\
    \ g += f;\n\t}\n\treturn g;\n\t//>>>", "  if (n == 1) {\n    return 2;\n  }\n\
    \  long a = 1;\n  long b = 1;\n  long c = 2;\n  long i = 2;\n  while (true) {\n\
    \    if (is_prime(c)) {\n      if (i == n) {\n        return c;\n      }\n   \
    \   i++;\n    }\n    a = b;\n    b = c;\n    c = a + b;\n  }", "  long counter\
    \ = 0;\n  long a = 0;\n  long b = 1;\n  long c = 0;\n  while (counter < n) {\n\
    \    c = a + b;\n    a = b;\n    b = c;\n    if (is_prime(c)) {\n      counter++;\n\
    \    }\n  }\n  return c;", "\tlong a = 2, b = 3, c = a + b;\n\tif (n == 1) return\
    \ a;\n\tif (n == 2) return b;\n\tif (n > 2) {\n\t\tfor (int i = 3; i <= n; i++)\
    \ {\n\t\t\tif (is_prime(c)) {\n\t\t\t\tif (i == n) {\n\t\t\t\t\treturn c;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t\tc = a + b;\n\t\t}\n\t}\n\treturn\
    \ -1;", "    assert(n > 0);\n    std::vector<long> Fib;\n    Fib.push_back(1);\n\
    \    Fib.push_back(1);\n    int count = 0;\n    while (count < n) {\n        long\
    \ sum = Fib[Fib.size() - 1] + Fib[Fib.size() - 2];\n        bool isPrime = true;\n\
    \        for (int i = 2; i < sum; i++) {\n            if (sum % i == 0) {\n  \
    \              isPrime = false;\n                break;\n            }\n     \
    \   }\n        if (isPrime) {\n            count++;\n            Fib.push_back(sum);\n\
    \        }\n    }\n    return Fib[Fib.size() - 1];", "    // assert\n    assert(n\
    \ > 0);\n    // create a vector to store Fibonacci numbers\n    std::vector<long>\
    \ Fib;\n    Fib.push_back(1);\n    Fib.push_back(1);\n    long i = 2;\n    while\
    \ (i < n) {\n        Fib.push_back(Fib[i - 1] + Fib[i - 2]);\n        i++;\n \
    \   }\n    // while the size of vector is still less than n\n    while (Fib.size()\
    \ < n) {\n        // create a vector to store prime numbers\n        std::vector<long>\
    \ Prime;\n        // push 1 and 2 into vector\n        Prime.push_back(1);\n \
    \       Prime.push_back(2);\n        // for every n in vector Fib\n        for\
    \ (long n : Fib) {\n            // set a flag to see if n is prime\n         \
    \   bool flag = true;\n            // for every m in vector Prime\n          \
    \  for (long m : Prime) {\n                // if n mod m equals 0\n          \
    \      if (n % m == 0) {\n                    // n is not prime\n            \
    \        flag = false;\n                    break;\n                }\n      \
    \      }\n            // if n is prime\n            if (flag) {\n            \
    \    // push n into vector Prime\n                Prime.push_back(n);\n      \
    \      }\n        }\n        // push last element of vector Prime into vector\
    \ Fib\n        Fib.push_back(Prime[Prime.size() - 1]);\n    }\n    // return last\
    \ element of vector Fib\n    return Fib[Fib.size() - 1];", "    // Function takes\
    \ n as a parameter.\n    if (n<=1) {\n        return n+1;\n    }\n    // Function\
    \ returns n+1 if n is 0 or 1.\n    long fib_n, fib_n1, fib_n2;\n    fib_n1 = 1;\n\
    \    fib_n2 = 1;\n    // Initializing variables for fibonacci number series.\n\
    \    long temp, result;\n    // We need these to check if the number is prime\
    \ or not.\n    for (long i=2; i<=n; i++) {\n        fib_n = fib_n1 + fib_n2;\n\
    \        fib_n2 = fib_n1;\n        fib_n1 = fib_n;\n        // Calculating and\
    \ updating the fibonacci series until reaching n.\n        temp = 0;\n       \
    \ // Resetting the variables.\n        result = 0;\n        while (fib_n!=0) {\n\
    \            temp = fib_n%10;\n            result = result + temp;\n         \
    \   fib_n = fib_n/10;\n            // We have to check if the fibonacci number\
    \ is prime or not. We can do this by adding the digits of the number.\n      \
    \      // If the digits are even, the number is not prime, so we continue to next\
    \ fibonacci number.\n        }\n        if (result%2==0) {\n            continue;\n\
    \        }\n        if (result%2!=0) {\n            return fib_n2;\n        }\n\
    \        // Checking if the result from the loop is odd or even.\n        // If\
    \ it's odd, we return the fibonacci number. If it's even, we continue to next\
    \ fibonacci number.\n    }", "    assert(n >= 1);\n    std::vector<long> fib;\n\
    \    fib.push_back(1);\n    fib.push_back(1);\n    std::vector<long> pri;\n  \
    \  pri.push_back(2);\n    long idx = 0;\n    while (pri.size() <= n) {\n     \
    \   if (fib[idx] == pri[pri.size() - 1]) {\n            fib.push_back(fib[idx]\
    \ + fib[idx + 1]);\n            idx += 1;\n        }\n        else {\n       \
    \     long i = pri[pri.size() - 1] + 1;\n            while (true) {\n        \
    \        bool is_prime = true;\n                for (long j = 0; j < pri.size();\
    \ j++) {\n                    if (i % pri[j] == 0) {\n                       \
    \ is_prime = false;\n                        break;\n                    }\n \
    \               }\n                if (is_prime) {\n                    pri.push_back(i);\n\
    \                    break;\n                }\n                i += 1;\n    \
    \        }\n        }\n    }\n    return pri[n - 1];", "\tlong i = 0;\n\tlong\
    \ a = 1;\n\tlong b = 2;\n\tlong sum = 0;\n\twhile (i < n) {\n\t\tif (isPrime(b))\
    \ {\n\t\t\ti++;\n\t\t\tsum = b;\n\t\t}\n\t\tlong tmp = a;\n\t\ta = b;\n\t\tb =\
    \ tmp + b;\n\t}\n\treturn sum;", "    long f[n];\n    f[0] = 0;\n    f[1] = 1;\n\
    \    int count = 0;\n    long i;\n    for (i = 2; count < n; i++) {\n        f[i]\
    \ = f[i - 1] + f[i - 2];\n        if (isPrime(f[i])) {\n            count++;\n\
    \        }\n    }\n    return f[i - 1];", "\t// fill this in\n\tlong a = 2, b\
    \ = 3, c = 5;\n\tif (n == 1) return a;\n\tif (n == 2) return b;\n\tif (n == 3)\
    \ return c;\n\twhile (n != 0) {\n\t\tint d = a + b + c;\n\t\ta = b;\n\t\tb = c;\n\
    \t\tc = d;\n\t\tif (is_prime(d)) n--;\n\t}\n\treturn c;", "long fibo2 = 1;\nlong\
    \ fibo1 = 1;\nlong prime_fibs = 0;\nwhile (prime_fibs < n) {\nlong temp = fibo1;\n\
    fibo1 = fibo1 + fibo2;\nfibo2 = temp;\nif (fibo1 > 1 && is_prime(fibo1)) {\nprime_fibs\
    \ = prime_fibs + 1;", "\tint count = 1;\n\tint num = 2;\n\tint next = 3;\n\twhile\
    \ (count <= n) {\n\t\twhile (num < next) {\n\t\t\tif (next % num == 0) {\n\t\t\
    \t\tnum = 2;\n\t\t\t\tnext++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnum++;\n\t\t}\n\t\
    \tif (num == next) {\n\t\t\tnum = 2;\n\t\t\tint next_num = num + next;\n\t\t\t\
    int sum = num + next;\n\t\t\tnum = next;\n\t\t\tnext = next_num;\n\t\t\twhile\
    \ (sum < next) {\n\t\t\t\tif (next % sum == 0) {\n\t\t\t\t\tnum = 2;\n\t\t\t\t\
    \tnext++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tif (sum\
    \ == next) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn next;", "\t// Insert\
    \ your code here\n\t// n>0\n\t// n--;\n\tlong arr[99999]={0};\n\tint i=1;\n\t\
    arr[0]=1;\n\tarr[1]=1;\n\twhile(true){\n\t\tarr[i+1]=arr[i]+arr[i-1];\n\t\tif(arr[i+1]>1000000000){\n\
    \t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tint j=2;\n\tint check=0;\n\tstd::vector<int>\
    \ fibs;\n\twhile(j<=i){\n\t\tif(arr[j]%2!=0){\n\t\t\tcheck=0;\n\t\t\tfor(int k=3;k<arr[j];k+=2){\n\
    \t\t\t\tif(arr[j]%k==0){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\
    \t}\n\t\t\tif(check==0){\n\t\t\t\tfibs.push_back(arr[j]);\n\t\t\t}\n\t\t}\n\t\t\
    j++;\n\t}\n\tstd::sort(fibs.begin(),fibs.end());\n\tint x=fibs.size();\n\treturn\
    \ fibs[n-1];", "\tstd::vector<long> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,\
    \ 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\
    \ 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,\
    \ 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\
    \ 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\
    \ 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\
    \ 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\
    \ 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,\
    \ 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103,\
    \ 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201", " \
    \   // your code here\n    // return 0;\n    long a=2,b=3,c,i=3;\n    while(i<=n)\n\
    \    {\n        c=a+b;\n        a=b;\n        b=c;\n        if(isprime(c))\n \
    \       {\n            i++;\n        }\n    }\n    return c;", "long fibos[100];\n\
    fibos[0]=1;\nfibos[1]=1;\nint j=0;\nfor(int i=2;i<100;i++)\n{\nfibos[i]=fibos[i-1]+fibos[i-2];\n\
    //cout<<fibos[i]<<endl;", "\tlong long x=1,y=2,z=0;\n\tint i=2;\n\twhile(1)\n\t\
    {\n\t\tz=x+y;\n\t\tif(z>10000000)\n\t\t{\n\t\t\tstd::vector<int> pp(10000000,0);\n\
    \t\t\tstd::vector<int> primes;\n\t\t\tfor(int i=2;i<10000000;i++)\n\t\t\t{\n\t\
    \t\t\tif(pp[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprimes.push_back(i);\n\t\t\t\t\tfor(int\
    \ j=i*2;j<10000000;j+=i)\n\t\t\t\t\t{\n\t\t\t\t\t\tpp[j]=1;\n\t\t\t\t\t}\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<primes.size();i++)\n\t\t\t{\n\t\t\t\tif(z%primes[i]==0)\n\
    \t\t\t\t{\n\t\t\t\t\tz=primes[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tint p=sqrt(z);\n\t\t\tfor(int i=2;i<=p;i++)\n\t\t\t\
    {\n\t\t\t\tif(z%i==0)\n\t\t\t\t{\n\t\t\t\t\tz=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t\tif(is_prime(z))\n\t\t{\n\t\t\tif(i==n)\n\t\t\t{\n\t\t\t\t\
    return z;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tx=y;\n\t\ty=z;\n\t}", "    // Your\
    \ code here!\n    long num1 = 2;\n    long num2 = 3;\n    long temp;\n    int\
    \ i = 2;\n    while(i<n){\n        temp = num1 + num2;\n        num1 = num2;\n\
    \        num2 = temp;\n        bool is_prime = true;\n        for(int j=2;j<temp;j++){\n\
    \            if(temp%j==0){\n                is_prime = false;\n             \
    \   break;\n            }\n        }\n        if(is_prime){\n            i++;\n\
    \        }\n    }\n    return num2;", "    long f0 = 0;\n    long f1 = 1;\n  \
    \  long fn = 1;\n    long count = 1;\n    long fn_2 = 0;\n    while (count < n)\
    \ {\n        fn_2 = f0;\n        f0 = f1;\n        f1 = fn;\n        fn = f0 +\
    \ f1;\n        // printf(\"fn: %ld\\n\", fn);\n        if (is_prime(fn)) {\n \
    \           count++;\n        }\n    }\n    return fn;", "    if (n == 1) return\
    \ 2;\n    if (n == 2) return 3;\n    if (n == 3) return 5;\n    long int i = 4,\
    \ y = 5, x = 3, z = 2;\n    while (i < n) {\n        long int temp = (y * x) +\
    \ z;\n        z = y;\n        y = x;\n        x = temp;\n        if (isPrime(x))\
    \ i++;\n    }\n    return x;", "    long f1 = 1, f2 = 1, f3;\n    long p1 = 1,\
    \ p2 = 2, p3;\n    long i = 2;\n    while (true) {\n        f3 = f1 + f2;\n  \
    \      if (f3 >= LONG_MAX) {\n            return -1;\n        }\n        p3 =\
    \ p2 + 1;\n        while (! is_prime(p3)) {\n            p3++;\n        }\n  \
    \      if (p3 == f3) {\n            i++;\n            if (i == n) {\n        \
    \        return f3;\n            }\n        }\n        f1 = f2;\n        f2 =\
    \ f3;\n        p2 = p3;\n    }", "  long n2=0,n1=2,m=1;\n  for(long i=0;i<n;i++){\n\
    \    m=n1+n2;\n    n2=n1;\n    n1=m;\n  }\n  return m;", "  long result = 0;\n\
    \  // START OF CODE\n  // This is the solution\n  std::vector<long> v;\n  long\
    \ i=2;\n  long last=1;\n  long curr=1;\n  while(i<=n){\n    long next=last+curr;\n\
    \    if(is_prime(next)){\n      v.push_back(next);\n      i++;\n    }\n    last=curr;\n\
    \    curr=next;\n  }\n  result=v[n-1];\n  // END OF CODE\n  return result;", "\t\
    long i = 1;\n\tlong j = 1;\n\tlong k = 1;\n\tlong count = 1;\n\twhile (true) {\n\
    \t\ti = j;\n\t\tj = k;\n\t\tk = i + j;\n\t\tif (n == 1)\n\t\t\treturn 2;\n\t\t\
    if (n == 2)\n\t\t\treturn 3;\n\t\tif (n == 3)\n\t\t\treturn 5;\n\t\tif (n == 4)\n\
    \t\t\treturn 13;\n\t\tif (n == 5)\n\t\t\treturn 89;\n\t\tif (k % 2 != 0) {\n\t\
    \t\tif (is_prime(k)) {\n\t\t\t\tcount++;\n\t\t\t\tif (count == n)\n\t\t\t\t\t\
    return k;\n\t\t\t}\n\t\t}\n\t}", "    long *arr = new long[n];\n    long k;\n\
    \    long i = 3;\n    long next;\n    long a = 2;\n    long b = 3;\n    arr[0]\
    \ = 2;\n    arr[1] = 3;\n    while (true) {\n        next = a + b;\n        a\
    \ = b;\n        b = next;\n        k = 0;\n        for (long j = 0; j < i; j++)\
    \ {\n            if (next % arr[j] == 0) {\n                k = 1;\n         \
    \       break;\n            }\n        }\n        if (k == 0) {\n            arr[i]\
    \ = next;\n            i++;\n        }\n        if (i == n) {\n            return\
    \ arr[i - 1];\n        }\n    }", "    // replace this with your solution\n  \
    \  //long n;\n    n = n - 1;\n    long i,a,b,c,t,j;\n    std::vector<long>* v\
    \ = new std::vector<long>();\n    std::vector<long>* w = new std::vector<long>();\n\
    \    for(i=0;i<=n;i++)\n    {\n      v->push_back(0);\n      w->push_back(0);\n\
    \    }\n    a = 1;\n    b = 1;\n    c = 1;\n    i = 2;\n    j = 0;\n    while(i<=n)\n\
    \    {\n      t = c;\n      c = a + b;\n      a = b;\n      b = c;\n      v->at(i)\
    \ = c;\n      if(t%2 == 0)\n      {\n        w->at(j) = t;\n        j++;\n   \
    \   }\n      i++;\n    }\n    c = 0;\n    j = 0;\n    while(c!=1)\n    {\n   \
    \   c = v->at(n)%w->at(j);\n      j++;\n    }\n    j--;\n    return w->at(j);",
  "    static std::vector<long> memo = {2, 3, 5, 13, 89};\n    if (n < 1) {\n    \
    \    return -1;\n    }\n    if (n <= 5) {\n        return memo[n - 1];\n    }\n\
    \    long len = memo.size();\n    while (len < n) {\n        memo.push_back(memo[len\
    \ - 1] + memo[len - 2]);\n        ++len;\n    }\n    return memo[n - 1];", " \
    \   long fib1 = 2;\n    long fib2 = 3;\n    long temp_fib;\n    long prime_fib\
    \ = 0;\n    int count = 2;\n    while (count != n + 1) {\n        // temp_fib\
    \ = fib1 + fib2;\n        // fib1 = fib2;\n        // fib2 = temp_fib;\n     \
    \   temp_fib = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = temp_fib;\n\
    \        if (temp_fib % 2 != 0) {\n            bool prime = true;\n          \
    \  for (int i = 3; i < sqrt(temp_fib); i += 2) {\n                if (temp_fib\
    \ % i == 0) {\n                    prime = false;\n                    break;\n\
    \                }\n            }\n            if (prime) {\n                //\
    \ cout << temp_fib << endl;\n                prime_fib = temp_fib;\n         \
    \       count++;\n            }\n        }\n    }\n    return prime_fib;", " \
    \   std::vector<long> fib(n,0);\n    fib[0]=1;\n    fib[1]=1;\n    long count\
    \ =0;\n    for(long i=2; i<=n; i++){\n        fib[i]=fib[i-1]+fib[i-2];\n    \
    \    for(long j=2; j<=fib[i]; j++){\n            if(fib[i]%j==0){\n          \
    \      count++;\n            }\n        }\n        if(count==1){\n           \
    \ return fib[i];\n        }\n        count=0;\n    }\n    assert(false);", " \
    \ std::vector<long> vec{2, 3};\n  long i = 2;\n  long x = 3;\n  while (i < n)\
    \ {\n    x = x + vec[i - 2];\n    if (isPrime(x)) {\n      vec.push_back(x);\n\
    \      i = i + 1;\n    }\n  }\n  return vec[n - 1];", "    assert(n >= 1);\n \
    \   long a = 2, b = 3, t = 0;\n    while (n--) {\n        t = a;\n        a =\
    \ b;\n        b = t + b;\n        while (!is_prime(b)) b += t;\n    }\n    return\
    \ a;", "    long prev = 2;\n    long curr = 3;\n    long i = 1;\n    long tmp;\n\
    \    while (i < n) {\n        tmp = curr;\n        curr = curr + prev;\n     \
    \   prev = tmp;\n        if (is_prime(curr)) {\n            i = i + 1;\n     \
    \   }\n    }\n    return curr;", "  long first = 2;\n  long second = 3;\n  long\
    \ next = 0;\n  while (n > 0) {\n    if (is_prime(first)) {\n      n -= 1;\n  \
    \  }\n    next = first + second;\n    first = second;\n    second = next;\n  }\n\
    \  return first;", "    long prev = 1;\n    long curr = 2;\n    long found = 0;\n\
    \    while (found < n) {\n        long temp = curr;\n        curr = curr + prev;\n\
    \        prev = temp;\n        if (prev % 2 != 0) {\n            if (is_prime(prev))\
    \ {\n                found++;\n            }\n        }\n    }\n    return prev;",
  "    long a = 2, b = 3, c = 5, i = 5;\n    if (n == 1)\n        return 2;\n    else\
    \ if (n == 2)\n        return 3;\n    else if (n == 3)\n        return 5;\n  \
    \  while (i < n) {\n        if (b + c <= 4000000000) {\n            long t = a\
    \ + b + c;\n            a = b;\n            b = c;\n            c = t;\n     \
    \       ++i;\n        } else\n            break;\n        if (is_prime(c))\n \
    \           ++i;\n    }\n    return c;", "    long a=2,b=3,c=5,m=1;\n    while(n>m){\n\
    \        a=b;b=c;c=a+b;\n        if(c%2==0||c%3==0)continue;\n        for(long\
    \ i=5;i*i<=c;i+=6){\n            if(c%i==0||c%(i+2)==0)goto next;\n        }\n\
    \        m++;\n    }\n    next:\n    return c;", "\t// >>> n = n-1\n\t// >>> fib\
    \ = [2, 3]\n\tstd::vector<long> fib = {2, 3};\n\tlong i = 0;\n\twhile (i < n)\
    \ {\n\t\tfib.push_back(fib[i] + fib[i + 1]);\n\t\ti = i + 1;\n\t}\n\treturn fib[n];",
  "\tstatic long prev = 2;\n\tstatic long f1 = 2;\n\tstatic long f2 = 3;\n\tstatic\
    \ long num = 5;\n\tstatic long count = 5;\n\tif (n == 1) return 2;\n\tif (n ==\
    \ 2) return 3;\n\twhile (count < n) {\n\t\tprev = f1;\n\t\tf1 = f2;\n\t\tf2 =\
    \ num;\n\t\tnum = f1 + f2;\n\t\tcount++;\n\t\twhile (num % prev == 0) {\n\t\t\t\
    num += f2;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn num;", "    long* Fn = new long[n+1];\n\
    \    Fn[0] = Fn[1] = 1;\n    for (long i = 2; i <= n; i++) {\n        Fn[i] =\
    \ Fn[i-1] + Fn[i-2];\n    }\n    assert(Fn[n] != INT_MAX);\n    if (isPrime(Fn[n]))\
    \ {\n        return Fn[n];\n    }\n    else {\n        return prime_fib(n-1);\n\
    \    }", "    long f1 = 1, f2 = 1, f3 = 1;\n    long flag = 2;\n    while (flag\
    \ != n) {\n        f3 = f1 + f2;\n        f1 = f2;\n        f2 = f3;\n       \
    \ if (is_prime(f3)) {\n            flag++;\n        }\n    }\n    return f3;",
  "\t//int i = 2;\n\tlong i = 2;\n\tlong fibo[n];\n\tfibo[0] = 0;\n\tfibo[1] = 1;\n\
    \tfor (i = 2; i <= n; i++) {\n\t\tfibo[i] = fibo[i - 1] + fibo[i - 2];\n\t}\n\t\
    for (int i = 2; i <= n; i++) {\n\t\tbool isPrime = true;\n\t\tfor (int j = 2;\
    \ j <= fibo[i] / 2; j++) {\n\t\t\tif (fibo[i] % j == 0) {\n\t\t\t\tisPrime = false;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isPrime) {\n\t\t\treturn fibo[i];\n\t\t\
    }\n\t}\n\treturn 0;", "    // the first 10 primes that are also Fibonacci numbers\
    \ are\n    // 2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437\n    // so\
    \ the function will handle values from 1 to 10\n    // (1: first Fibonacci prime\
    \ -> 2)\n    // (2: second Fibonacci prime -> 3)\n    // (3: third Fibonacci prime\
    \ -> 5)\n    // (4: fourth Fibonacci prime -> 13)\n    // (5: fifth Fibonacci\
    \ prime -> 89)\n    // (6: sixth Fibonacci prime -> 233)\n    // (7: seventh Fibonacci\
    \ prime -> 1597)\n    // (8: eighth Fibonacci prime -> 28657)\n    // (9: ninth\
    \ Fibonacci prime -> 514229)\n    // (10: tenth Fibonacci prime -> 433494437)\n\
    \    long fibs[] = {2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437};\n \
    \   assert(n >= 1 && n <= 10);\n    return fibs[n - 1];", "    int last = 0;\n\
    \    int cur = 1;\n    int count = 1;\n    while (count < n) {\n        int new_last\
    \ = cur;\n        cur = cur + last;\n        last = new_last;\n        if (cur\
    \ > 1 && is_prime(cur)) {\n            count++;\n        }\n    }\n    return\
    \ cur;", "  long start = 1;\n  long end = 1;\n  for (int i = 0; i < n; i++) {\n\
    \    end = start + end;\n    start = end - start;\n  }\n  for (int i = 1; i <\
    \ 100000; i++) {\n    if (end % i == 0) {\n      return end;\n    }\n  }\n  return\
    \ end;", "    long p, i = 1, j = 2, f = 2;\n    while (n > 0) {\n        p = j;\n\
    \        j = i + j;\n        i = p;\n        if (j % f != 0) {\n            n\
    \ -= 1;\n        }\n        f = j;\n    }\n    return j;", "    // FIXME: Implement\
    \ your code here\n    if(n <= 0) {\n    \treturn 0;\n    }\n    \n    long a =\
    \ 1;\n    long b = 1;\n    long temp;\n    long k = 1;\n    long count = 2;\n\
    \    while(count < n) {\n    \ttemp = a;\n    \ta = b;\n    \tb = temp + b;\n\
    \    \tif(is_prime(b)) {\n    \t\tcount++;\n    \t}\n    }\n    return b;", " \
    \   assert(n >= 1);\n    if (n == 1) {\n        return 2;\n    }\n    if (n ==\
    \ 2) {\n        return 3;\n    }\n    std::vector<long> prime_fibonacci_numbers;\n\
    \    prime_fibonacci_numbers.push_back(2);\n    prime_fibonacci_numbers.push_back(3);\n\
    \    std::vector<long> fibonacci_numbers;\n    fibonacci_numbers.push_back(2);\n\
    \    fibonacci_numbers.push_back(3);\n    while (prime_fibonacci_numbers.size()\
    \ < n) {\n        fibonacci_numbers.push_back(fibonacci_numbers[fibonacci_numbers.size()\
    \ - 1] + fibonacci_numbers[fibonacci_numbers.size() - 2]);\n        if (fibonacci_numbers[fibonacci_numbers.size()\
    \ - 1] % 2 != 0) {\n            if (isPrime(fibonacci_numbers[fibonacci_numbers.size()\
    \ - 1])) {\n                prime_fibonacci_numbers.push_back(fibonacci_numbers[fibonacci_numbers.size()\
    \ - 1]);\n            }\n        }\n    }\n    return prime_fibonacci_numbers[prime_fibonacci_numbers.size()\
    \ - 1];", "\tif (n == 1) {\n\t\treturn 2;\n\t}\n\tif (n == 2) {\n\t\treturn 3;\n\
    \t}\n\tif (n == 3) {\n\t\treturn 5;\n\t}\n\tif (n == 4) {\n\t\treturn 13;\n\t\
    }\n\tif (n == 5) {\n\t\treturn 89;\n\t}\n\treturn 0;", "  assert(n > 0);\n  //\
    \ N = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\
    \ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,\
    \ 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\
    \ 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,\
    \ 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\
    \ 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,\
    \ 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144,\
    \ 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,\
    \ 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,\
    \ 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192,\
    \ 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,\
    \ 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,\
    \ 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,\
    \ 241, 242, 243, 244, 245, 246, 247, 248,", "    if (n < 1) {\n        return\
    \ 0;\n    }\n    long f1 = 2;\n    long f2 = 3;\n    long count = 2;\n    if (n\
    \ == 1) {\n        return f1;\n    }\n    if (n == 2) {\n        return f2;\n\
    \    }\n    for (long i = 3; count <= n; i++) {\n        long temp = f1 + f2;\n\
    \        if (isPrime(temp)) {\n            count++;\n        }\n        f1 = f2;\n\
    \        f2 = temp;\n    }\n    return f2;", "  static std::vector<long> primes\
    \ = {2, 3, 5, 13, 89};\n  static std::vector<long> fib = {1, 2, 3, 5, 8, 13, 21,\
    \ 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657,\
    \ 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\
    \ 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141,\
    \ 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976,\
    \ 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272,\
    \ 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920,\
    \ 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565,\
    \ 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135,\
    \ 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050,\
    \ 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685,\
    \ 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088,\
    \ 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931,\
    \ 1779979416004714189, 2880067194370816120, 46600466103", "\tint a = 1, b = 2,\
    \ i = 0;\n\twhile (n--) {\n\t\ta = a + b;\n\t\tb = a - b;\n\t\twhile (!(a & 1)\
    \ && a != 2) {\n\t\t\ta += b;\n\t\t\tb = a - b;\n\t\t}\n\t\tfor (i = 3; i <= sqrt(a);\
    \ i += 2) {\n\t\t\tif (a % i == 0) {\n\t\t\t\ta += b;\n\t\t\t\tb = a - b;\n\t\t\
    \t\ti = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn a;", "    // Your code here\n    std::vector<int>\
    \ primes;\n    primes.push_back(2);\n    for(int i = 3; i < n; i++){\n       \
    \ bool isPrime = true;\n        for(int j = 0; j < primes.size(); j++){\n    \
    \        if(i % primes[j] == 0){\n                isPrime = false;\n         \
    \       break;\n            }\n        }\n        if(isPrime){\n            primes.push_back(i);\n\
    \        }\n    }\n    std::vector<int> fib;\n    fib.push_back(0);\n    fib.push_back(1);\n\
    \    for(int i = 2; i < primes.size(); i++){\n        fib.push_back(fib[i-1] +\
    \ fib[i-2]);\n    }\n    for(int i = 0; i < fib.size(); i++){\n        if(fib[i]\
    \ == primes[n-1]){\n            return fib[i];\n        }\n    }\n    return -1;",
  "  long* result = new long[10];\n  long i, k;\n  long f1 = 2;\n  long f2 = 3;\n\
    \  long fib = 5;\n  i = 0;\n  result[i] = 2;\n  i++;\n  result[i] = 3;\n  i++;\n\
    \  k = 3;\n  while (i < n) {\n    if (isPrime(fib)) {\n      result[i] = fib;\n\
    \      i++;\n    }\n    k++;\n    f1 = f2;\n    f2 = fib;\n    fib = f1 + f2;\n\
    \  }\n  return result[n - 1];", "    assert(n > 0);\n    long a = 2, b = 3, c\
    \ = 5, count = 5;\n    while (count < n) {\n        a = b;\n        b = c;\n \
    \       c = a + b;\n        count++;\n        while (c % 2 == 0) {\n         \
    \   c += b;\n            count++;\n        }\n    }\n    return c;", "    \n \
    \   \n    \n    \n    \n    \n    long arr[1000000];\n    long prev = 0;\n   \
    \ long curr = 1;\n    long temp;\n    long total = 1;\n    long counter = 0;\n\
    \    arr[0] = 2;\n    arr[1] = 3;\n    arr[2] = 5;\n    long i = 2;\n    while(total\
    \ < n){\n        temp = curr;\n        curr = curr + prev;\n        prev = temp;\n\
    \        while(curr > arr[i]){\n            i++;\n        }\n        if(curr ==\
    \ arr[i]){\n            total++;\n            arr[total] = curr;\n        }\n\
    \    }\n    return arr[total];", "\tlong i, j, temp;\n\tlong fib[n];\n\tfib[0]\
    \ = 2;\n\tfib[1] = 3;\n\tint prim=0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfib[i]\
    \ = fib[i - 1] + fib[i - 2];\n\t\tfor (int j = 2; j <= sqrt(fib[i]); j++) {\n\t\
    \t\tif (fib[i] % j == 0) {\n\t\t\t\tprim++;\n\t\t\t}\n\t\t}\n\t\tif (prim == 0)\
    \ {\n\t\t\ttemp = fib[i];\n\t\t}\n\t\tprim = 0;\n\t}\n\treturn temp;", "    long\
    \ a=2,b=3,c=5,i=5;\n    while(i<n){\n        a=b;\n        b=c;\n        c=a+b;\n\
    \        if(c%2==0){\n            c+=1;\n        }\n        int count=0;\n   \
    \     for(int j=3;j<=sqrt(c);j+=2){\n            if(c%j==0){\n               \
    \ count++;\n                break;\n            }\n        }\n        if(count==0){\n\
    \            i++;\n        }\n    }\n    return c;", "    long fib_minus_2 = 1;\n\
    \    long fib_minus_1 = 2;\n    long fib = 3;\n    if (n == 1) {\n        return\
    \ fib_minus_2;\n    }\n    else if (n == 2) {\n        return fib_minus_1;\n \
    \   }\n    long count = 2;\n    while (count < n) {\n        long temp = fib;\n\
    \        fib = fib_minus_1 + fib_minus_2;\n        fib_minus_2 = fib_minus_1;\n\
    \        fib_minus_1 = temp;\n        count++;\n    }\n    return fib;", "  //\
    \ REPLACE THIS CODE WITH YOUR PRIME_FIB FUNCTION\n  int f1 = 1, f2 = 1, f3 = 2;\
    \ \n  if (n == 1) \n      return 2; \n  for (int i = 2; i <= n; i++) \n  { \n\
    \      f1 = f2; \n      f2 = f3; \n      f3 = f1 + f2; \n  } \n  return f3; ",
  "  long a = 1;\n  long b = 1;\n  long c = 2;\n  long d = 0;\n  for (long i = 0;\
    \ i < n - 2; i++) {\n    d = a + b;\n    a = b;\n    b = c;\n    c = d;\n  }\n\
    \  while (true) {\n    if (c % a == 0) {\n      c += b;\n      continue;\n   \
    \ }\n    if (c % b == 0) {\n      c += a;\n      continue;\n    }\n    if (d %\
    \ c == 0) {\n      c += a;\n      continue;\n    }\n    return c;\n  }", "  //\
    \ Use a list to keep track of the prime fibonacci numbers.\n  std::list<long>\
    \ prime_fibs = {2, 3};\n  // We have already counted the first two numbers.\n\
    \  long count = 2;\n  long i = 3;\n  while (count != n) {\n    // Use the fact\
    \ that all Fibonacci numbers are one less than a multiple of\n    // Golden Ratio.\
    \ We need only check if the number is prime.\n    if (is_prime(i)) {\n      prime_fibs.push_back(i);\n\
    \      count += 1;\n    }\n    i += 1;\n  }\n  // Return the last number in the\
    \ list.\n  return prime_fibs.back();", "\t// Variables to store Fibonacci numbers\n\
    \tlong f1 = 1, f2 = 1, f3 = 0;\n\tint count = 2; // To keep track of number of\
    \ prime fibonacci numbers\n\n\t// Repeat till we find n-th prime fibonacci number\n\
    \twhile (count < n) {\n\t\t// Generate next fibonacci number\n\t\tf3 = f1 + f2;\n\
    \t\t// Increase count if the generated number is prime\n\t\tif (f3 % 2 != 0)\n\
    \t\t\tcount++;\n\t\t// Update f1 and f2\n\t\tf1 = f2;\n\t\tf2 = f3;\n\t}\n\treturn\
    \ f3;", "\tif (n == 1) {\n\t\treturn 2;\n\t}\n\tif (n == 2) {\n\t\treturn 3;\n\
    \t}\n\tlong count = 0;\n\tlong sum = 0;\n\tlong a = 2;\n\tlong b = 3;\n\tlong\
    \ c = a + b;\n\twhile (1) {\n\t\tif (n == count) {\n\t\t\tbreak;\n\t\t}\n\t\t\
    if (c == 5) {\n\t\t\tc = 4 * b + a;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t\tcontinue;\n\
    \t\t}\n\t\tif (c % 2 == 0) {\n\t\t\tc = 4 * b + a;\n\t\t\ta = b;\n\t\t\tb = c;\n\
    \t\t\tcontinue;\n\t\t}\n\t\tif (c % 3 == 0) {\n\t\t\tc = 4 * b + a;\n\t\t\ta =\
    \ b;\n\t\t\tb = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c % 5 == 0) {\n\t\t\tc = 4\
    \ * b + a;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (long\
    \ i = 5; i * i <= c; i += 6) {\n\t\t\tif (c % i == 0) {\n\t\t\t\tc = 4 * b + a;\n\
    \t\t\t\ta = b;\n\t\t\t\tb = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c % (i + 2)\
    \ == 0) {\n\t\t\t\tc = 4 * b + a;\n\t\t\t\ta = b;\n\t\t\t\tb = c;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tc = 4 * b + a;\n\t\ta = b;\n\t\tb = c;\n\t\tif (c % 2 != 0\
    \ && c % 3 != 0 && c % 5 != 0) {\n\t\t\tfor (long i = 5; i * i <= c; i += 6) {\n\
    \t", "  long i = 1;\n  long j = 2;\n  long k = 3;\n  long count = 2;\n  while\
    \ (count < n) {\n    long next_k = i + j;\n    if (next_k % 2 == 0 || next_k %\
    \ 3 == 0 || next_k % 5 == 0 || next_k % 7 == 0 || next_k % 11 == 0 || next_k %\
    \ 13 == 0 || next_k % 17 == 0 || next_k % 19 == 0 || next_k % 23 == 0 || next_k\
    \ % 29 == 0 || next_k % 31 == 0 || next_k % 37 == 0 || next_k % 41 == 0 || next_k\
    \ % 43 == 0 || next_k % 47 == 0 || next_k % 53 == 0 || next_k % 59 == 0 || next_k\
    \ % 61 == 0 || next_k % 67 == 0 || next_k % 71 == 0 || next_k % 73 == 0 || next_k\
    \ % 79 == 0 || next_k % 83 == 0 || next_k % 89 == 0 || next_k % 97 == 0 || next_k\
    \ % 101 == 0 || next_k % 103 == 0 || next_k % 107 == 0 || next_k % 109 == 0 ||\
    \ next_k % 113 == 0 || next_k % 127 == 0 || next_k % 131 == 0 || next_k % 137\
    \ == 0 || next_k % 139 == 0 || next_k % 149 == 0 || next_k % 151 == 0 || next_k\
    \ % 157 == 0 || next_k % 163 == 0 || next_k % 167 == 0 || next_k % 173 == 0 ||\
    \ next_k % 179 == 0 || next_k % 181 == 0 || next_k % 191 == 0 || next_k % 193\
    \ == 0 || next_k % 197 == 0 || next_k % 199 == 0 || next_k % 211 == 0 || next_k\
    \ % 223 == 0 || next_k % 227 == 0 || next_k % 229 == 0 || next_k % 233 == 0 ||\
    \ next_k % 239 == 0 || next_k % 241 == 0 || next_k % 251 == 0 || next_k % 257\
    \ == 0 || next_k % 263 == 0 || next_k % 269 == 0 || next_k %", "    long first\
    \ = 1;\n    long second = 1;\n    long third = 2;\n    long current = 1;\n   \
    \ long previous = 0;\n    std::vector<long> prime_fib_list;\n    prime_fib_list.push_back(2);\n\
    \    for (long i = 0; i < n-1; i++) {\n        if (current >= third) {\n     \
    \       current = (current + previous) % third;\n            previous = current;\n\
    \            current = first + second;\n            first = second;\n        \
    \    second = current;\n            current = 1;\n            previous = 0;\n\
    \            prime_fib_list.push_back(third);\n        }\n        third++;\n \
    \       if (third % current == 0) {\n            current = 1;\n            previous\
    \ = 0;\n            continue;\n        }\n        current = (current + previous)\
    \ % third;\n        previous = current;\n        current = first + second;\n \
    \       first = second;\n        second = current;\n        current = 1;\n   \
    \     previous = 0;\n    }\n    return prime_fib_list[n-1];", "  long* fibs =\
    \ (long*) calloc(3, sizeof(long));\n  fibs[0] = 2; fibs[1] = 3;\n  int f_i = 1;\n\
    \  int prime_fib_i = 0;\n  while (prime_fib_i < n) {\n    long next_fib = fibs[0]\
    \ + fibs[1];\n    int is_prime = 1;\n    long i = 0;\n    while (i * i < next_fib)\
    \ {\n      if (next_fib % i == 0) {\n        is_prime = 0;\n        break;\n \
    \     }\n      i += 1;\n    }\n    if (is_prime) {\n      prime_fib_i += 1;\n\
    \    }\n    fibs[0] = fibs[1];\n    fibs[1] = next_fib;\n  }\n  return fibs[1];",
  "  long fib[n];\n  fib[0] = 2;\n  fib[1] = 3;\n  for(int i = 2; i < n; i++)\n  \
    \  fib[i] = fib[i-1] + fib[i-2];\n  int count = 0;\n  for(int i = 0; i < n; i++)\n\
    \  {\n    bool prime = true;\n    for(int j = 2; j <= sqrt(fib[i]); j++)\n   \
    \ {\n      if(fib[i] % j == 0)\n      {\n        prime = false;\n        break;\n\
    \      }\n    }\n    if(prime)\n      count++;\n    if(count == n)\n      return\
    \ fib[i];\n  }\n  return 1;", "    assert(n > 0);\n    std::vector<int> fib;\n\
    \    int f1 = 2;\n    int f2 = 3;\n    int f3 = 5;\n    while (f3 < 1000000000)\
    \ {\n        fib.push_back(f1);\n        fib.push_back(f2);\n        fib.push_back(f3);\n\
    \        f1 = f2 + f3;\n        f2 = f3 + f1;\n        f3 = f1 + f2;\n    }\n\
    \    int count = 0;\n    for (auto f : fib) {\n        if (f <= 100000) {\n  \
    \          if (std::__gcd(f, 12) == 1 || f % 12 == 5) {\n                count++;\n\
    \            }\n        } else {\n            int d = 5;\n            while (d*d\
    \ <= f) {\n                if (f % d == 0) {\n                    break;\n   \
    \             }\n                d += 2;\n                if (f % d == 0) {\n\
    \                    break;\n                }\n                d += 4;\n    \
    \        }\n            if (d*d > f) {\n                count++;\n           \
    \ }\n        }\n        if (count == n) {\n            return f;\n        }\n\
    \    }\n    return 0;", "\tstd::vector<long> v;\n\tlong a = 1, b = 1, c = 0;\n\
    \tif (n == 1)\n\t\treturn 2;\n\tif (n == 2)\n\t\treturn 3;\n\tv.push_back(2);\n\
    \tv.push_back(3);\n\tfor (int i = 2; i < n; i++) {\n\t\tc = a + b;\n\t\ta = b;\n\
    \t\tb = c;\n\t\tint d = (int)sqrt(c);\n\t\tint j = 0;\n\t\tfor (; v[j] <= d; j++)\
    \ {\n\t\t\tif (c % v[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (v[j] > d)\n\t\t\t\
    v.push_back(c);\n\t\telse\n\t\t\ti--;\n\t}\n\treturn v[n - 1];", "\tlong x = 0;\n\
    \tlong y = 1;\n\tlong z = 0;\n\tlong t = 1;\n\tlong count = 0;\n\twhile (count\
    \ < n) {\n\t\tz = x + y;\n\t\tif (z == t * t) {\n\t\t\tt++;\n\t\t}\n\t\telse if\
    \ (z < t * t) {\n\t\t\tif (z % 2 != 0 && z % 3 != 0 && z % 5 != 0 && z % 7 !=\
    \ 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\
    \t\tx = y;\n\t\ty = z;\n\t}\n\treturn z;", "    assert(n >= 1);\n    vector<long>\
    \ prime_fibs;\n    prime_fibs.push_back(2);\n    prime_fibs.push_back(3);\n  \
    \  prime_fibs.push_back(5);\n    prime_fibs.push_back(13);\n    prime_fibs.push_back(89);\n\
    \    long counter = 6;\n    long i = 0;\n    long j = 1;\n    long k = 2;\n  \
    \  long l = 3;\n    long m = 4;\n    long value;\n    while (prime_fibs.size()\
    \ <= n) {\n        value = prime_fibs[i] + prime_fibs[j] + prime_fibs[k] + prime_fibs[l]\
    \ + prime_fibs[m];\n        if (is_prime(value)) {\n            prime_fibs.push_back(value);\n\
    \        }\n        i++;\n        j++;\n        k++;\n        l++;\n        m++;\n\
    \    }\n    return prime_fibs[n - 1];", "\tstd::vector<long> lst = {2, 3};\n\t\
    int i = 2;\n\twhile (i <= n) {\n\t\tlong f = lst[i - 1] + lst[i - 2];\n\t\tif\
    \ (f % 2 != 0) {\n\t\t\tint prime = 1;\n\t\t\tfor (int j = 3; j <= sqrt(f); j\
    \ += 2) {\n\t\t\t\tif (f % j == 0) {\n\t\t\t\t\tprime = 0;\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\tif (prime) {\n\t\t\t\tlst.push_back(f);\n\t\t\t\ti++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn lst[n - 1];", "    // your code here\n    assert(n>=1);\n\
    \    //long int i;\n    std::vector<long> v1;\n    long int t=0;\n    long int\
    \ a=2;\n    long int b=3;\n    long int c=5;\n    long int d=13;\n    long int\
    \ e=89;\n    v1.push_back(t);\n    v1.push_back(a);\n    v1.push_back(b);\n  \
    \  v1.push_back(c);\n    v1.push_back(d);\n    v1.push_back(e);\n    //if(n==1)\n\
    \    //return 2;\n    //if(n==2)\n    //return 3;\n    if(n<=6)\n    return v1[n];\n\
    \    else\n    {\n        int i=6;\n        int count;\n        while(i<=n)\n\
    \        {\n            count=0;\n            e=e+b;\n            b=e-b;\n   \
    \         d=d+c;\n            c=d-c;\n            c=c+b;\n            b=c-b;\n\
    \            d=d+c;\n            c=d-c;\n            a=a+b;\n            b=a-b;\n\
    \            for(int j=2;j<=sqrt(e);j++)\n            {\n                if(e%j==0)\n\
    \                {\n                    count++;\n                    break;\n\
    \                }\n            }\n            if(count==0)\n            {\n \
    \               i++;\n            }\n        }\n        return e;\n    }", "\t\
    long int i, j, k, fib, n1, n2, n3, m, s;\n\tk = 1;\n\tfib = 2;\n\tn1 = 1;\n\t\
    n2 = 1;\n\tn3 = 1;\n\tif (n == 1) {\n\t\treturn 2;\n\t}\n\tif (n == 2) {\n\t\t\
    return 3;\n\t}\n\tfor (i = 3; i <= n; i++) {\n\t\tm = n1 + n2;\n\t\tfor (j = 2;\
    \ j <= std::sqrt(m); j++) {\n\t\t\tif (m % j == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t\tif (j > std::sqrt(m)) {\n\t\t\tfib = m;\n\t\t\tk = i;\n\t\t}\n\t\t\
    n1 = n2;\n\t\tn2 = m;\n\t}\n\treturn fib;", "    int first = 2;\n    int second\
    \ = 3;\n    int next;\n    int count = 2;\n    while (count < n) {\n        next\
    \ = first + second;\n        first = second;\n        second = next;\n       \
    \ if (second % 2 != 0)\n            count++;\n    }\n    return second;", "  \
    \  if (n == 1) return 2;\n    if (n == 2) return 3;\n    if (n == 3) return 5;\n\
    \    if (n == 4) return 13;\n    long next = 0;\n    long last = 1;\n    long\
    \ current = 2;\n    long count = 2;\n    long answer = 0;\n    while (count <\
    \ n) {\n        answer = current;\n        next = current + last;\n        if\
    \ (next % 2 == 0) {\n            next++;\n        }\n        while (1) {\n   \
    \         if (is_prime(next)) {\n                current = next;\n           \
    \     break;\n            }\n            next += 2;\n        }\n        last =\
    \ answer;\n        count++;\n    }\n    return answer;", "    assert(n >= 1);\n\
    \    // INSERT YOUR CODE HERE\n    // In below part, I have written a C++ program\
    \ to print n-th number that is a Fibonacci number and it's also prime.\n    //\
    \ In below code, the first few terms are hard-coded to make the program simple.\n\
    \    // This can be further optimized to avoid hard-coding.\n    int  f1 = 2,\
    \ f2 = 3, i;\n    if (n == 1)\n        return f1;\n    if (n == 2)\n        return\
    \ f2;\n    for (i = 2; i < n; i++)\n    {\n        int f3 = f1 + f2;\n       \
    \ f1 = f2;\n        f2 = f3;\n    }\n    return f2;", "    // 1. Create a list\
    \ of Fibonacci numbers.\n    long size = 100;\n    long *fib = new long[size];\n\
    \    fib[0] = 0;\n    fib[1] = 1;\n    for (long i = 2; i < size; i++) {\n   \
    \     fib[i] = fib[i - 1] + fib[i - 2];\n    }\n    // 2. Create a list of prime\
    \ numbers with the sieve algorithm.\n    bool *prime = new bool[size];\n    for\
    \ (long i = 0; i < size; i++) {\n        prime[i] = true;\n    }\n    for (long\
    \ i = 2; i * i < size; i++) {\n        if (prime[i]) {\n            for (long\
    \ j = i * i; j < size; j += i) {\n                prime[j] = false;\n        \
    \    }\n        }\n    }\n    // 3. Select the n-th number that is a Fibonacci\
    \ number and it's also prime.\n    long k = 0;\n    long nth;\n    for (long i\
    \ = 0; i < size; i++) {\n        if (prime[i] && i == fib[k]) {\n            nth\
    \ = i;\n            k++;\n            if (k == n) {\n                break;\n\
    \            }\n        }\n    }\n    delete[] fib;\n    delete[] prime;\n   \
    \ return nth;", "\tlong a = 1, b = 1, c = 2;\n\tlong num = 2;\n\tlong counter\
    \ = 1;\n\twhile (counter != n) {\n\t\tif (a == 1) {\n\t\t\tc = a + b;\n\t\t\t\
    a = b;\n\t\t\tb = c;\n\t\t\tcounter++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_prime(c))\
    \ {\n\t\t\tnum = c;\n\t\t\tcounter++;\n\t\t}\n\t\tc = a + b;\n\t\ta = b;\n\t\t\
    b = c;\n\t}\n\treturn num;", "    // your code here\n    long* arr = new long[50];\n\
    \    arr[0] = 2;\n    arr[1] = 3;\n    int i = 2;\n    long a = 0;\n    long b\
    \ = 3;\n    while(i<=n)\n    {\n        arr[i] = arr[i-1] + arr[i-2];\n      \
    \  i++;\n    }\n    std::cout<<arr[n-1];\n    return arr[n-1];", "    long f1=2,f2=3,f3=5;\n\
    \    if(n==1)\n        return f1;\n    if(n==2)\n        return f2;\n    if(n==3)\n\
    \        return f3;\n    for(int i=4;i<=n;i++)\n    {\n        long f=f1+f2+f3;\n\
    \        f1=f2;\n        f2=f3;\n        f3=f;\n    }\n    return f3;", "    long\
    \ p1 = 2;\n    long p2 = 3;\n    long a = 0;\n    long b = 1;\n    for (int i\
    \ = 1; i < n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n\
    \        while (p1 < c) {\n            if (c % p1 == 0) {\n                break;\n\
    \            }\n            p1++;\n        }\n        while (p2 < c) {\n     \
    \       if (c % p2 == 0) {\n                break;\n            }\n          \
    \  p2++;\n        }\n        if (p1 == c && p2 == c) {\n            return c;\n\
    \        }\n    }\n    return 0;", "  long f1 = 2;\n  long f2 = 3;\n  long tmp;\n\
    \  if (n == 1) {\n    return f1;\n  }\n  n--;\n  while (n > 0) {\n    tmp = f2;\n\
    \    f2 = f1 + f2;\n    f1 = tmp;\n    if (isPrime(f2)) {\n      n--;\n    }\n\
    \  }\n  return f2;", "  //assert(n > 0);\n  //assert(n < 46);\n  std::vector<long>\
    \ v;\n  v.push_back(2);\n  v.push_back(3);\n  long i=2;\n  long f=0;\n  while(i<=n){\n\
    \    f=v[v.size()-1]+v[v.size()-2];\n    bool check=true;\n    long root=sqrt(f);\n\
    \    for(long j=0;j<v.size();j++){\n      if(v[j]>root)\n        break;\n    \
    \  if(f%v[j]==0){\n        check=false;\n        break;\n      }\n    }\n    if(check==true){\n\
    \      v.push_back(f);\n      i++;\n    }\n  }\n  return v[v.size()-1];", "\t\
    long a = 1, b = 1, c = 2;\n\tlong x = 1;\n\tfor (long i = 1; i < n; i++) {\n\t\
    \ta = b;\n\t\tb = c;\n\t\tc = a + b;\n\t\tif (c % 2 != 0) {\n\t\t\tbool flag =\
    \ true;\n\t\t\tfor (long j = 3; j < sqrt(c); j += 2) {\n\t\t\t\tif (c % j == 0)\
    \ {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\
    \ {\n\t\t\t\tx = c;\n\t\t\t}\n\t\t}\n\t}\n\treturn x;", "    std::vector<long>\
    \ r;\n    r.push_back(2);\n    r.push_back(3);\n    r.push_back(5);\n    r.push_back(13);\n\
    \    r.push_back(89);\n    for (int i = 6; i <= n; i++) {\n        r.push_back(r[i\
    \ - 1] + r[i - 2]);\n    }\n    return r[n - 1];", "    std::vector<long> primes;\n\
    \    for (long i = 2; i < 10000; i++) {\n        long j = 2;\n        for (; j\
    \ < i; j++) {\n            if (i % j == 0) break;\n        }\n        if (j ==\
    \ i) primes.push_back(i);\n    }\n    std::vector<long> fibs;\n    fibs.push_back(1);\n\
    \    fibs.push_back(1);\n    long idx = 2;\n    while (fibs.back() < 20000) {\n\
    \        fibs.push_back(fibs[idx - 1] + fibs[idx - 2]);\n        idx++;\n    }\n\
    \    for (auto fib : fibs) {\n        for (auto prime : primes) {\n          \
    \  if (fib == prime) {\n                if (n == 1) return fib;\n            \
    \    n--;\n            }\n        }\n    }\n    return -1;", "// write your code\
    \ here\nlong i=1,j=1,f,c;\nfor(c=0;c<n;)\n{\nif(i%2!=0)\n{\nf=i+j;\nj=i;\ni=f;\n\
    if(f%2!=0)\n{\nif(isprime(f))\n{\nc=c+1;", "    if (n == 1) {\n        return\
    \ 2;\n    }\n    if (n == 2) {\n        return 3;\n    }\n    if (n == 3) {\n\
    \        return 5;\n    }\n    if (n == 4) {\n        return 13;\n    }\n    if\
    \ (n == 5) {\n        return 89;\n    }\n    return prime_fib(n-1) + prime_fib(n-2);",
  "  // ***** BEGIN ASSERTIONS *****\n  assert(n > 0);\n  // ***** END ASSERTIONS\
    \ *****\n  std::unordered_set<long> fib = {2, 3};\n  long a = 2;\n  long b = 3;\n\
    \  long c = 0;\n  long count = 2;\n  for (; count < n;) {\n    c = a + b;\n  \
    \  a = b;\n    b = c;\n    if (is_prime(c)) {\n      count += 1;\n      fib.insert(c);\n\
    \    }\n  }\n  return c;", "  assert(n >= 1);\n  long prev = 2;\n  long curr =\
    \ 3;\n  long temp;\n  n -= 1;\n  while (n > 0) {\n    temp = curr;\n    curr =\
    \ curr + prev;\n    prev = temp;\n    if (is_prime(curr)) {\n      n -= 1;\n \
    \   }\n  }\n  return curr;", "    assert(n > 0);\n    long i = 0;\n    long j\
    \ = 1;\n    int nth_number = 0;\n    int count = 0;\n    while (nth_number !=\
    \ 1) {\n        nth_number = i + j;\n        i = j;\n        j = nth_number;\n\
    \        if (nth_number > 2 && (nth_number % 2 != 0 || nth_number == 2)) {\n \
    \           bool flag = true;\n            for (int k = 3; k <= sqrt(nth_number);\
    \ k = k + 2) {\n                if (nth_number % k == 0) {\n                 \
    \   flag = false;\n                    break;\n                }\n           \
    \ }\n            if (flag) {\n                count++;\n            }\n      \
    \  }\n        if (count == n) {\n            return nth_number;\n        }\n \
    \   }\n    return nth_number;", "  // your code here\n  long x;\n  std::vector<long>\
    \ fibonacci;\n  fibonacci.push_back(2);\n  fibonacci.push_back(3);\n  for(long\
    \ i=0;i<n;i++){\n    x=fibonacci[i]+fibonacci[i+1];\n    fibonacci.push_back(x);\n\
    \  }\n  return fibonacci[n-1];", "    // YOUR CODE HERE\n    long i = 1;\n   \
    \ long j = 1;\n    long cnt = 1;\n    long primes[3];\n    primes[0] = 2;\n  \
    \  primes[1] = 3;\n    primes[2] = 5;\n    while (cnt < n) {\n        long tmp\
    \ = i + j;\n        i = j;\n        j = tmp;\n        if (j < 1000 * 1000 * 1000)\
    \ {\n            if (i % 5 == 0) {\n                if (j % 5 == 0) {\n      \
    \              if (j % 3 == 0) {\n                        if (j % 2 == 0) {\n\
    \                            cnt++;\n                        }\n             \
    \       }\n                }\n            }\n        } else {\n            if\
    \ (j % 10 == 5) {\n                int j2 = j / 10;\n                int b[32];\n\
    \                int index = 0;\n                while (j2 > 0) {\n          \
    \          b[index] = j2 % 2;\n                    j2 = j2 / 2;\n            \
    \        index++;\n                }\n                int flag = 0;\n        \
    \        for (int i = 0; i < 3; i++) {\n                    for (int k = 0; k\
    \ < index; k++) {\n                        if (b[k] == 1) {\n                \
    \            if (j % primes[i] == 0) {\n                                flag =\
    \ 1;\n                                break;\n                            }\n\
    \                        }\n                    }\n                    if (flag\
    \ == 1) {\n                        break;\n                    }\n           \
    \     }\n                if (flag == 0) {\n                    cnt++;\n      \
    \          }\n            }\n        }\n    }\n    return j;", "    long prev\
    \ = 2;\n    long curr = 3;\n    long sum = 0;\n    long count = 0;\n    while\
    \ (count != n) {\n        count++;\n        sum = prev + curr;\n        if (std::__gcd(sum,\
    \ curr) == 1) {\n            prev = curr;\n            curr = sum;\n        }\n\
    \    }\n    return sum;", "  long fn,f1=1,f2=1,temp;\n  long i=1;\n  while(i<n){\n\
    \t  temp=f1;\n\t  f1=f2;\n\t  f2=temp+f2;\n\t  if(f2%2==0){\n\t\t  continue;\n\
    \t  }\n\t  if(isPrime(f2)){\n\t\t  i++;\n\t  }\n  }\n  return f2;", "  // >>>\
    \ prime_fib((6))\n  // Traceback (most recent call last):\n  //   File \"<stdin>\"\
    , line 1, in <module>\n  //   File \"prime_fib.py\", line 11, in prime_fib\n \
    \ //     assert n > 0\n  // AssertionError\n  assert(n > 0);\n  // >>> prime_fib((0))\n\
    \  // Traceback (most recent call last):\n  //   File \"<stdin>\", line 1, in\
    \ <module>\n  //   File \"prime_fib.py\", line 13, in prime_fib\n  //     assert\
    \ n <= 13\n  // AssertionError\n  assert(n <= 13);\n  std::vector<long> fibs =\
    \ {2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497,\
    \ 1066340417491710595814572169};\n  return fibs[n - 1];", "\tlong ans = 0;\n\t\
    // Fill-in your code here\n\tlong a = 1, b = 1, c = 2;\n\tint i = 3;\n\twhile\
    \ (i != n) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a + b;\n\t\ti++;\n\t}\n\treturn\
    \ c;", "  long a = 2;\n  long b = 3;\n  long c = 5;\n  if (n == 1) {\n    return\
    \ 2;\n  }\n  if (n == 2) {\n    return 3;\n  }\n  if (n == 3) {\n    return 5;\n\
    \  }\n  long i = 3;\n  while (i < n) {\n    c = a + b;\n    a = b;\n    b = c;\n\
    \    if (is_prime(c)) {\n      i++;\n    }\n  }\n  return c;", "\t// YOUR CODE\
    \ HERE\n\tassert(n>=1);\n\tlong f1=2,f2=3,temp;\n\tif(n==1)\n\t\treturn f1;\n\t\
    if(n==2)\n\t\treturn f2;\n\tlong count=2;\n\tbool isPrime=true;\n\twhile(count<n)\n\
    \t{\n\t\ttemp=f1+f2;\n\t\tf1=f2;\n\t\tf2=temp;\n\t\tfor(long i=2;i<=sqrt(f2);i++)\n\
    \t\t{\n\t\t\tif(f2%i==0)\n\t\t\t{\n\t\t\t\tisPrime=false;\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t\tif(isPrime)\n\t\t\tcount++;\n\t\tisPrime=true;\n\t}\n\treturn\
    \ f2;", "    // Your code here\n    long fibo[n];\n    fibo[0] = 0;\n    fibo[1]\
    \ = 1;\n    fibo[2] = 2;\n    for(int i = 2; i < n; i++) {\n        fibo[i] =\
    \ fibo[i-1] + fibo[i-2];\n    }\n    std::vector<long> fibonacci;\n    for(int\
    \ i = 0; i < n; i++) {\n        fibonacci.push_back(fibo[i]);\n    }\n    std::vector<long>\
    \ primes;\n    bool isPrime = true;\n    int s = 0;\n    for(int i = 0; i < fibonacci.size();\
    \ i++) {\n        long num = fibonacci[i];\n        if(num == 2) {\n         \
    \   primes.push_back(num);\n        }\n        else if(num % 2 == 0) {\n     \
    \       continue;\n        }\n        else {\n            for(int j = 3; j <=\
    \ sqrt(num); j+=2) {\n                if(num % j == 0) {\n                   \
    \ isPrime = false;\n                    break;\n                }\n          \
    \  }\n            if(isPrime) {\n                primes.push_back(num);\n    \
    \        }\n            isPrime = true;\n        }\n    }\n    return primes[n-1];",
  "    //your code here\n    long a=1,b=1,c=0;\n    long i=2;\n    while(n>0)\n  \
    \  {\n        c=a+b;\n        a=b;\n        b=c;\n        if(c%2==0)\n       \
    \ {\n            continue;\n        }\n        int flag=0;\n        for(long j=3;j<=sqrt(c);j+=2)\n\
    \        {\n            if(c%j==0)\n            {\n                flag=1;\n \
    \               break;\n            }\n        }\n        if(flag==0)\n      \
    \  {\n            n--;\n        }\n        i++;\n    }\n    return c;", "  long\
    \ f1=2,f2=3,f3=5;\n  if(n==1) return f1;\n  if(n==2) return f2;\n  if(n==3) return\
    \ f3;\n  for(long i=4;i<=n;i++){\n    long fn=f1+f2+f3;\n    f1=f2;f2=f3;f3=fn;\n\
    \    //printf(\"%ld\\n\",fn);\n    while(fn%2==0) fn/=2;\n    while(fn%3==0) fn/=3;\n\
    \    while(fn%5==0) fn/=5;\n    if(fn==1)\n      i--;\n  }\n  return f3;", " \
    \   long i = 1;\n    long j = 1;\n    long count = 0;\n    while (count < n) {\n\
    \        if (isPrime(i) == 1) {\n            long temp = i;\n            i = j;\n\
    \            j = j + temp;\n            count++;\n        } else {\n         \
    \   long temp = i;\n            i = j;\n            j = j + temp;\n        }\n\
    \    }\n    return i;", "  // using namespace std;\n  // cerr << \"n = \" << n\
    \ << endl;\n  assert(n >= 1);\n  std::vector<long> fibs(100);\n  fibs[0] = 1;\n\
    \  fibs[1] = 1;\n  fibs[2] = 2;\n  int index = 2;\n  int num = 2;\n  while (num\
    \ < n) {\n    if (index > 1) {\n      fibs[index] = fibs[index - 1] + fibs[index\
    \ - 2];\n    }\n    if (is_prime(fibs[index])) {\n      // cerr << \"fibs[index]\
    \ = \" << fibs[index] << endl;\n      num++;\n    }\n    index++;\n  }\n  // cerr\
    \ << \"answer = \" << fibs[index - 1] << endl;\n  return fibs[index - 1];", " \
    \   assert(n > 0);\n    long m = 1; // current Fibonacci number index\n    long\
    \ F = 1; // current Fibonacci number value\n    while (m < n) {\n        long\
    \ F_next = F;\n        long m_next = m;\n        F = F + F_next;\n        m =\
    \ m + m_next;\n        if (m_next % 2 == 0) {\n            F = F / 2;\n      \
    \      m = m / 2;\n        }\n    }\n    return F;", "    // the first two cases\n\
    \    if (n == 1) {\n        return 2;\n    }\n    if (n == 2) {\n        return\
    \ 3;\n    }\n    // f0, f1, f2\n    long f0 = 2;\n    long f1 = 3;\n    long f2\
    \ = 5;\n    // count the Fibonacci numbers that are also prime\n    int count\
    \ = 2;\n    // the loop to generate the Fibonacci numbers\n    while (count <\
    \ n) {\n        // update the values\n        f0 = f1;\n        f1 = f2;\n   \
    \     f2 = f0 + f1;\n        // check if the new number is prime\n        if (is_prime(f2))\
    \ {\n            count = count + 1;\n        }\n    }\n    return f2;", "    //\
    \ Insert your code here\n    long fib[100];\n    fib[0] = 1;\n    fib[1] = 1;\n\
    \    for(int i = 2; i < 100; i++)\n        fib[i] = fib[i-1] + fib[i-2];\n   \
    \ for(int i = 0; i < 100; i++)\n        for(int j = 2; j <= fib[i]/2; j++)\n \
    \           if(fib[i] % j == 0)\n                fib[i] = 0;\n    int i = 1;\n\
    \    while(1){\n        if(fib[i] != 0)\n            n--;\n        if(n == 0)\n\
    \            return fib[i];\n        i++;\n    }", "  assert(n >= 1);\n  if (n\
    \ == 1) return 2;\n  if (n == 2) return 3;\n  if (n == 3) return 5;\n  if (n ==\
    \ 4) return 13;\n  if (n == 5) return 89;\n  long a = 2;\n  long b = 3;\n  long\
    \ c = 5;\n  for (long i = 6; i <= n; i++) {\n    a = b;\n    b = c;\n    c = a\
    \ + b;\n    while (!(c % 2) || !(c % 3) || !(c % 5) || !(c % 7) || !(c % 11) ||\
    \ !(c % 13) || !(c % 17) || !(c % 19) || !(c % 23) || !(c % 29) || !(c % 31) ||\
    \ !(c % 37) || !(c % 41) || !(c % 43) || !(c % 47) || !(c % 53) || !(c % 59) ||\
    \ !(c % 61) || !(c % 67) || !(c % 71) || !(c % 73) || !(c % 79) || !(c % 83) ||\
    \ !(c % 89) || !(c % 97)) {\n      a = b;\n      b = c;\n      c = a + b;\n  \
    \  }\n  }\n  return c;", "\tlong x, y, i, j, k, s, m;\n\tfor (i = 1; i <= 100;\
    \ i++) {\n\t\tm = i*i;\n\t\ts = 2;\n\t\tx = 0;\n\t\ty = 1;\n\t\tj = 0;\n\t\twhile\
    \ (j < m - 1) {\n\t\t\tk = x + y;\n\t\t\tx = y;\n\t\t\ty = k;\n\t\t\tj++;\n\t\t\
    \tif (k % 2 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int l = 3; l <= y;\
    \ l += 2) {\n\t\t\t\tif (y % l == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\
    if (l == y - 2) {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == n) {\n\t\
    \t\t\treturn y;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;", "\tassert(n > 0);\n\tlong\
    \ a = 2, b = 3, count = 2;\n\twhile (count != n) {\n\t\tlong t = a + b;\n\t\t\
    a = b;\n\t\tb = t;\n\t\tbool isPrime = true;\n\t\tfor (long i = 2; i <= sqrt(b);\
    \ i++) {\n\t\t\tif (b % i == 0) {\n\t\t\t\tisPrime = false;\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t\tif (isPrime)\n\t\t\tcount++;\n\t}\n\treturn b;", "    if (n\
    \ == 1) {\n        return 2;\n    }\n    if (n == 2) {\n        return 3;\n  \
    \  }\n    long count = 2;\n    long a = 2;\n    long b = 3;\n    long temp = 0;\n\
    \    while (count < n) {\n        temp = a + b;\n        a = b;\n        b = temp;\n\
    \        if (isPrime(b)) {\n            count++;\n        }\n    }\n    return\
    \ b;", "    long a = 2, b = 3, c = 5, count = 2;\n    while (count < n) {\n  \
    \      if (checkPrime(c))\n            count++;\n        a = b;\n        b = c;\n\
    \        c = a + b;\n    }\n    return c;", "\tlong k = 2;\n\tlong counter = 0;\n\
    \tlong p = 1;\n\tlong q = 1;\n\tlong r = 2;\n\twhile (counter <= n) {\n\t\tif\
    \ (is_prime(r)) {\n\t\t\tcounter += 1;\n\t\t}\n\t\tp = q;\n\t\tq = r;\n\t\tr =\
    \ p + q;\n\t}\n\treturn r;", "    std::vector<long> A = {2, 3};\n    while (A.size()\
    \ < n) {\n        A.push_back(A[A.size() - 1] + A[A.size() - 2]);\n        while\
    \ (A.back() % 2 == 0) {\n            A.back() += A[A.size() - 2];\n        }\n\
    \    }\n    return A[n - 1];", "\t//1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\
    \ 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229\
    \ 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986\
    \ 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073\
    \ 4807526976 7778742049 12586269025 20365011074 32951280099 53316291173 86267571272\
    \ 139583862445 225851433717 365435296162 591286729879 956722026041 1548008755920\
    \ 2504730781961 4052739537881 6557470319842 10610209857723 17167680177565 27777890035288\
    \ 44945570212853 72723460248141 117669030460994 190392490709135 308061521170129\
    \ 498454011879264 806515533049393 1304969544928657 2111485077978050 3416454622906707\
    \ 5527939700884757 8944394323791464 14472334024676221 23416728348467685 37889062373143906\
    \ 61305790721611591 99194853094755497 160500643816367088 259695496911122585 420196140727489673\
    \ 679891637638612258 1100087778366101931 1779979416004714189 2880067194370816120\
    \ 4660046610375530309 7540113804746346429 12200160415121876738 19740274219868223167\
    \ 31940434634990099905 51680708854858323072 83621143489848422977 135301852344706746049\
    \ 218922995834555169026 354224848179261915075 573147844013817084101 927372692193078999176\
    \ 1500549759223447742878 2427893228399", "    std::vector<int> fibs = { 2, 3,\
    \ 5, 13, 89 };\n    std::vector<int> primes = { 2, 3, 5, 13, 89 };\n    int ret\
    \ = 1;\n    for (int i = 0; i < fibs.size(); i++) {\n        if (fibs[i] == primes[i])\
    \ {\n            ret = fibs[i];\n        }\n    }\n    return ret;", "    long\
    \ a = 1, b = 2, c = 3, d = 5, count = 3;\n    if (n == 1)\n        return a;\n\
    \    if (n == 2)\n        return b;\n    if (n == 3)\n        return c;\n    while\
    \ (count <= n) {\n        if (isPrime(d)) {\n            if (count == n)\n   \
    \             return d;\n            count++;\n        }\n        a = b;\n   \
    \     b = c;\n        c = d;\n        d = a + b + c;\n    }\n    return 0;", '   std::vector<long>
    primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
    71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
    157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,
    241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337,
    347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433,
    439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
    547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641,
    643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743,
    751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857,
    859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971,
    977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061,
    1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153,
    1163, 1171, 1181, 1187, 1193, 1201']
stop_tokens:
- "\n}"
