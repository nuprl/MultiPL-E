name: HumanEval_116_sort_array
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to\
  \ sort a vector of non-negative integers according to\n// number of ones in their\
  \ binary representation in ascending order.\n// For similar number of ones, sort\
  \ based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1,\
  \ (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2,\
  \ (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2,\
  \ (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5,\
  \ (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1,\
  \ (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1,\
  \ (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr)\
  \ {\n"
tests: "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2,\
  \ (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2,\
  \ (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2,\
  \ (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1,\
  \ (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) ==\
  \ (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5,\
  \ (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4})))\
  \ == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5,\
  \ (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3,\
  \ (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32,\
  \ (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2,\
  \ (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4,\
  \ (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2,\
  \ (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4,\
  \ (long)8, (long)16, (long)32})));\n}\n"
completions: ["  std::sort(arr.begin(), arr.end(), [](long lhs, long rhs) {\n    \
    \        int lhs1Cnt = 0;\n            for (int i = 0; i < 32; i++) {\n      \
    \        if (lhs & (1 << i)) lhs1Cnt++;\n            }\n            int rhs1Cnt\
    \ = 0;\n            for (int i = 0; i < 32; i++) {\n              if (rhs & (1\
    \ << i)) rhs1Cnt++;\n            }\n            if (lhs1Cnt == rhs1Cnt) return\
    \ lhs < rhs;\n            return lhs1Cnt < rhs1Cnt;\n          });\n  return arr;",
  "  std::sort(arr.begin(), arr.end(), [](long lhs, long rhs) {\n    int l = __builtin_popcount(lhs);\n\
    \    int r = __builtin_popcount(rhs);\n    if (l == r) {\n      return lhs < rhs;\n\
    \    }\n    return l < r;\n  });\n  return arr;", "  std::map<int, std::vector<long>>\
    \ mp;\n  for (auto a : arr) {\n    auto cnt = 0;\n    auto x = a;\n    while (x)\
    \ {\n      cnt += x & 1;\n      x >>= 1;\n    }\n    mp[cnt].push_back(a);\n \
    \ }\n  std::vector<long> ans;\n  for (auto x : mp) {\n    std::sort(x.second.begin(),\
    \ x.second.end());\n    for (auto v : x.second) {\n      ans.push_back(v);\n \
    \   }\n  }\n  return ans;", "  //Your code here\n  std::vector<long> ones;\n \
    \ std::vector<long> zeros;\n  std::vector<long> answer;\n  for (auto& i : arr)\
    \ {\n    // std::cout << i << std::endl;\n    int count = 0;\n    for (int j =\
    \ 0; j < 16; j++) {\n      // std::cout << \"k \" << k << std::endl;\n      int\
    \ k = 1 << j;\n      if (i & k) {\n        count++;\n      }\n    }\n    if (count\
    \ == 0) {\n      zeros.push_back(i);\n    } else {\n      ones.push_back(i);\n\
    \    }\n  }\n  sort(zeros.begin(), zeros.end());\n  sort(ones.begin(), ones.end());\n\
    \  answer.insert(answer.end(), zeros.begin(), zeros.end());\n  answer.insert(answer.end(),\
    \ ones.begin(), ones.end());\n  return answer;", "    if (arr.size() == 0) {\n\
    \        return arr;\n    }\n    std::map<int, std::vector<long>> sortMap;\n \
    \   // std::map<int, std::vector<long>>::iterator it;\n    for (int i = 0; i <\
    \ arr.size(); i++) {\n        long b = arr[i];\n        int bitsSet = 0;\n   \
    \     while (b > 0) {\n            if (b & 1) {\n                bitsSet++;\n\
    \            }\n            b = b >> 1;\n        }\n        if (sortMap.find(bitsSet)\
    \ == sortMap.end()) {\n            std::vector<long> v;\n            v.push_back(arr[i]);\n\
    \            sortMap[bitsSet] = v;\n        } else {\n            std::vector<long>\
    \ v = sortMap[bitsSet];\n            v.push_back(arr[i]);\n            sortMap[bitsSet]\
    \ = v;\n        }\n    }\n    std::vector<long> res;\n    for (std::map<int, std::vector<long>>::iterator\
    \ it = sortMap.begin(); it != sortMap.end(); it++) {\n        std::vector<long>\
    \ v = it->second;\n        std::sort(v.begin(), v.end());\n        res.insert(res.end(),\
    \ v.begin(), v.end());\n    }\n    return res;", "   std::vector<long> sorted;\n\
    \   int count;\n   std::map<int,int> map;\n   std::map<int,int>::iterator it;\n\
    \   for(int i=0;i<arr.size();i++){\n      count=0;\n      while(arr[i]>0){\n \
    \        count+=arr[i]%2;\n         arr[i]/=2;\n      }\n      map[count] = arr[i];\n\
    \   }\n   for(it=map.begin();it!=map.end();it++){\n      sorted.push_back(it->second);\n\
    \   }\n   return sorted;", "  // sort(std::begin(arr), std::end(arr), [](int a,\
    \ int b) {\n  //   return count(std::begin(std::bitset<16>(a).to_string()),\n\
    \  //                std::end(std::bitset<16>(a).to_string()), '1') <\n  //  \
    \        count(std::begin(std::bitset<16>(b).to_string()),\n  //             \
    \   std::end(std::bitset<16>(b).to_string()), '1');\n  // });\n  sort(std::begin(arr),\
    \ std::end(arr), [](int a, int b) {\n    int s = count(std::begin(std::bitset<16>(a).to_string()),\n\
    \                  std::end(std::bitset<16>(a).to_string()), '1');\n    int f\
    \ = count(std::begin(std::bitset<16>(b).to_string()),\n                  std::end(std::bitset<16>(b).to_string()),\
    \ '1');\n    if (s == f) {\n      return a < b;\n    }\n    return s < f;\n  });\n\
    \  return arr;", "  // Your code here\n  for(int i=0;i<arr.size();i++){\n    for(int\
    \ j=i+1;j<arr.size();j++){\n      int first = arr[i];\n      int second = arr[j];\n\
    \      if(__builtin_popcount(first) > __builtin_popcount(second)){\n        arr[i]\
    \ = second;\n        arr[j] = first;\n      }\n      else if(__builtin_popcount(first)\
    \ == __builtin_popcount(second)){\n        if(first > second){\n          arr[i]\
    \ = second;\n          arr[j] = first;\n        }\n      }\n    }\n  }\n  return\
    \ arr;", "  for (int i = 0; i < arr.size(); i++) {\n    for (int j = i + 1; j\
    \ < arr.size(); j++) {\n      int bits_i = __builtin_popcount(arr[i]);\n     \
    \ int bits_j = __builtin_popcount(arr[j]);\n      if (bits_i > bits_j) {\n   \
    \     std::swap(arr[i], arr[j]);\n      } else if (bits_i == bits_j) {\n     \
    \   if (arr[i] > arr[j]) {\n          std::swap(arr[i], arr[j]);\n        }\n\
    \      }\n    }\n  }\n  return arr;", "  // TODO: Write your code here\n  return\
    \ arr;", "  std::map<int, std::vector<long>> ones_map;\n  for (auto x : arr) {\n\
    \    int ones = __builtin_popcount(x);\n    ones_map[ones].push_back(x);\n  }\n\
    \  std::vector<long> sorted_arr;\n  for (auto it = ones_map.begin(); it != ones_map.end();\
    \ ++it) {\n    std::sort(it->second.begin(), it->second.end());\n    sorted_arr.insert(sorted_arr.end(),\
    \ it->second.begin(), it->second.end());\n  }\n  return sorted_arr;", "  // your\
    \ code here\n  int counter = 0;\n  std::map<int, std::vector<long>> mymap;\n \
    \ std::vector<long> result;\n  for (int i = 0; i < arr.size(); i++) {\n    long\
    \ curr_num = arr[i];\n    long counter = 0;\n    while (curr_num != 0) {\n   \
    \   if (curr_num % 2 == 1) {\n        counter++;\n      }\n      curr_num = curr_num\
    \ / 2;\n    }\n    mymap[counter].push_back(arr[i]);\n  }\n  for (auto x : mymap)\
    \ {\n    for (int i = 0; i < x.second.size(); i++) {\n      result.push_back(x.second[i]);\n\
    \    }\n  }\n  return result;", "  int n = arr.size();\n  std::vector<long> res;\n\
    \  std::vector<long> bit(n);\n  int count;\n  for (int i = 0; i < n; i++) {\n\
    \    count = 0;\n    int curr_num = arr[i];\n    while (curr_num) {\n      count\
    \ += curr_num & 1;\n      curr_num >>= 1;\n    }\n    bit[i] = count;\n  }\n \
    \ int m = *std::max_element(bit.begin(), bit.end());\n  std::vector<std::vector<long>>\
    \ buckets(m+1);\n  for (int i = 0; i < n; i++) {\n    buckets[bit[i]].push_back(arr[i]);\n\
    \  }\n  for (int i = 0; i <= m; i++) {\n    std::sort(buckets[i].begin(), buckets[i].end());\n\
    \  }\n  for (int i = 0; i <= m; i++) {\n    for (int j = 0; j < buckets[i].size();\
    \ j++) {\n      res.push_back(buckets[i][j]);\n    }\n  }\n  return res;", " \
    \ std::sort(arr.begin(), arr.end(), [](long &a, long &b) {\n    int x = std::bitset<32>(a).count();\n\
    \    int y = std::bitset<32>(b).count();\n    return x == y ? a < b : x < y;\n\
    \  });\n  return arr;", "\tvector<pair<int,int>> p;\n\tfor(auto a:arr){\n\t\t\
    int count = 0;\n\t\tfor(int j=0;j<sizeof(a)*8;j++){\n\t\t\tif(a&(1<<j)) count++;\n\
    \t\t}\n\t\tp.push_back(make_pair(count,a));\n\t}\n\tsort(p.begin(),p.end());\n\
    \tvector<long> res;\n\tfor(auto p:p){\n\t\tres.push_back(p.second);\n\t}\n\treturn\
    \ res;", "    std::vector<long> res;\n    std::unordered_map<long, long> mp;\n\
    \    // std::map<long, long> mp;\n    for (int i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] >= 0) {\n            mp[arr[i]] = __builtin_popcount(arr[i]);\n\
    \        } else {\n            mp[arr[i]] = -1;\n        }\n    }\n    std::sort(arr.begin(),\
    \ arr.end(), [&mp](long a, long b) {\n        if (mp[a] == mp[b]) {\n        \
    \    return a < b;\n        }\n        return mp[a] < mp[b];\n    });\n    return\
    \ arr;", "    sort(arr.begin(), arr.end(), [](long a, long b) {\n        int binary_a\
    \ = bitset<40>(a).count();\n        int binary_b = bitset<40>(b).count();\n  \
    \      if (binary_a == binary_b) {\n            return a < b;\n        }\n   \
    \     return binary_a < binary_b;\n    });\n    return arr;", "  std::vector<long>\
    \ arr_copy = arr;\n  std::sort(arr_copy.begin(), arr_copy.end(), [](const long\
    \ &num1, const long &num2) {\n    int count1 = 0, count2 = 0;\n    int copy1 =\
    \ num1, copy2 = num2;\n    while (copy1 > 0) {\n      count1 += copy1 & 1;\n \
    \     copy1 >>= 1;\n    }\n    while (copy2 > 0) {\n      count2 += copy2 & 1;\n\
    \      copy2 >>= 1;\n    }\n    if (count1 != count2) {\n      return count1 <\
    \ count2;\n    }\n    return num1 < num2;\n  });\n  return arr_copy;", "  std::vector<long>\
    \ bit_count(arr.size());\n  // Compute the number of ones in binary representation\n\
    \  // and store it in another vector.\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    long temp = arr[i];\n    int count = 0;\n    while (temp > 0) {\n   \
    \   if (temp % 2 == 1)\n        count++;\n      temp /= 2;\n    }\n    bit_count[i]\
    \ = count;\n  }\n  std::vector<long>::iterator it;\n  // Sort the arr vector according\
    \ to the bit_count vector.\n  for (int i = 0; i < arr.size(); i++) {\n    for\
    \ (int j = i + 1; j < arr.size(); j++) {\n      if (bit_count[i] > bit_count[j])\
    \ {\n        long temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n\
    \        temp = bit_count[i];\n        bit_count[i] = bit_count[j];\n        bit_count[j]\
    \ = temp;\n      }\n    }\n  }\n  // Checking for same number of ones.\n  for\
    \ (int i = 0; i < arr.size(); i++) {\n    for (int j = i + 1; j < arr.size();\
    \ j++) {\n      if (bit_count[i] == bit_count[j]) {\n        if (arr[i] > arr[j])\
    \ {\n          long temp = arr[i];\n          arr[i] = arr[j];\n          arr[j]\
    \ = temp;\n        }\n      }\n    }\n  }\n  return arr;", '  return arr;', " \
    \ std::map<std::string, long> m;\n  std::vector<long> ret;\n  for (long x : arr)\
    \ {\n    std::string str = std::bitset<32>(x).to_string();\n    std::cout << \"\
    str = \" << str << \"\\n\";\n    m[str] = x;\n  }\n  for (auto it : m) {\n   \
    \ std::cout << \"it.second = \" << it.second << \"\\n\";\n    ret.push_back(it.second);\n\
    \  }\n  std::cout << \"ret = \";\n  for (long x : ret) {\n    std::cout << x <<\
    \ \" \";\n  }\n  std::cout << \"\\n\";\n  return ret;", "    long i,j,k;\n   \
    \ vector<long> myArr;\n    for(i=0;i<arr.size();i++)\n    {\n        int sum=0;\n\
    \        k=arr[i];\n        while(k>0)\n        {\n            if(k%2==1)\n  \
    \          {\n                sum++;\n            }\n            k=k/2;\n    \
    \    }\n        myArr.push_back(sum);\n    }\n    for(i=0;i<arr.size();i++)\n\
    \    {\n        for(j=i+1;j<arr.size();j++)\n        {\n            if(myArr[i]>myArr[j])\n\
    \            {\n                long temp;\n                temp=myArr[i];\n \
    \               myArr[i]=myArr[j];\n                myArr[j]=temp;\n         \
    \       temp=arr[i];\n                arr[i]=arr[j];\n                arr[j]=temp;\n\
    \            }\n            else if(myArr[i]==myArr[j])\n            {\n     \
    \           if(arr[i]>arr[j])\n                {\n                    long temp;\n\
    \                    temp=myArr[i];\n                    myArr[i]=myArr[j];\n\
    \                    myArr[j]=temp;\n                    temp=arr[i];\n      \
    \              arr[i]=arr[j];\n                    arr[j]=temp;\n            \
    \    }\n            }\n        }\n    }\n    return arr;", '  return arr;', " \
    \ std::vector<std::pair<long, int>> a;\n  for (auto i : arr) {\n    int count\
    \ = 0;\n    while (i) {\n      i = i & (i - 1);\n      count++;\n    }\n    a.push_back(std::make_pair(count,\
    \ i));\n  }\n  std::sort(a.begin(), a.end());\n  std::vector<long> ans;\n  for\
    \ (auto i : a) {\n    ans.push_back(i.second);\n  }\n  return ans;", "  std::vector<long>\
    \ one_index;\n  std::vector<long> zero_index;\n  int N = arr.size();\n  for (int\
    \ i = 0; i < N; i++) {\n    int num = arr[i];\n    int count = 0;\n    while (num)\
    \ {\n      count += num & 1;\n      num = num >> 1;\n    }\n    if (count == 0)\
    \ {\n      zero_index.push_back(i);\n    } else {\n      one_index.push_back(i);\n\
    \    }\n  }\n  std::sort(one_index.begin(), one_index.end(), [&arr](int a, int\
    \ b) {\n    int num_a = arr[a];\n    int num_b = arr[b];\n    int a_count = 0;\n\
    \    int b_count = 0;\n    while (num_a) {\n      a_count += num_a & 1;\n    \
    \  num_a = num_a >> 1;\n    }\n    while (num_b) {\n      b_count += num_b & 1;\n\
    \      num_b = num_b >> 1;\n    }\n    if (a_count == b_count) {\n      return\
    \ arr[a] < arr[b];\n    }\n    return a_count < b_count;\n  });\n  std::sort(zero_index.begin(),\
    \ zero_index.end(), [&arr](int a, int b) {\n    return arr[a] < arr[b];\n  });\n\
    \  std::vector<long> result;\n  for (int i = 0; i < one_index.size(); i++) {\n\
    \    result.push_back(arr[one_index[i]]);\n  }\n  for (int i = 0; i < zero_index.size();\
    \ i++) {\n    result.push_back(arr[zero_index[i]]);\n  }\n  return result;", " \
    \ auto vec = std::vector<std::pair<long, int>>(arr.size());\n  for (int i = 0;\
    \ i < arr.size(); ++i) {\n    auto x = arr[i];\n    vec[i] = std::make_pair(x,\
    \ __builtin_popcountl(x));\n  }\n  std::sort(vec.begin(), vec.end(),\n       \
    \     [](std::pair<long, int>& a, std::pair<long, int>& b) {\n              if\
    \ (a.second == b.second) {\n                return a.first < b.first;\n      \
    \        }\n              return a.second < b.second;\n            });\n  std::vector<long>\
    \ res(arr.size());\n  for (int i = 0; i < arr.size(); ++i) {\n    res[i] = vec[i].first;\n\
    \  }\n  return res;", "  std::vector<std::pair<long, long>> v;\n  for (auto i\
    \ : arr) {\n    std::bitset<64> bs(i);\n    std::pair<long, long> p(bs.count(),\
    \ i);\n    v.push_back(p);\n  }\n  std::sort(v.begin(), v.end());\n  std::vector<long>\
    \ ans;\n  for (auto i : v) {\n    ans.push_back(i.second);\n  }\n  return ans;",
  "  std::vector<std::pair<long,int>> v1;\n  std::vector<long> ans;\n  for(auto x:arr){\n\
    \    v1.push_back(std::make_pair(x,__builtin_popcount(x)));\n  }\n  std::sort(v1.begin(),v1.end(),[](std::pair<long,int>\
    \ a,std::pair<long,int> b){\n    if(a.second==b.second){\n      return a.first<b.first;\n\
    \    }\n    return a.second<b.second;\n  });\n  for(auto x:v1){\n    ans.push_back(x.first);\n\
    \  }\n  return ans;", "    for (auto it1 = arr.begin(); it1 != arr.end(); it1++)\
    \ {\n        for (auto it2 = arr.begin(); it2 != arr.end(); it2++) {\n       \
    \     if (it1 != it2) {\n                int count1 = 0, count2 = 0;\n       \
    \         long temp1 = *it1, temp2 = *it2;\n                while (temp1 > 0)\
    \ {\n                    if (temp1 % 2 == 1) {\n                        count1++;\n\
    \                    }\n                    temp1 /= 2;\n                }\n \
    \               while (temp2 > 0) {\n                    if (temp2 % 2 == 1) {\n\
    \                        count2++;\n                    }\n                  \
    \  temp2 /= 2;\n                }\n                if (count1 < count2) {\n  \
    \                  std::swap(*it1, *it2);\n                } else if (count1 ==\
    \ count2) {\n                    if (*it1 > *it2) {\n                        std::swap(*it1,\
    \ *it2);\n                    }\n                }\n            }\n        }\n\
    \    }\n    return arr;", "  // 1. declare a map and a list.\n  std::map<long,\
    \ int> m;\n  std::list<long> l;\n  // 2. map.first is the key and map.second is\
    \ the value;\n  // 3. use bit operation to get the binary representation of the\
    \ number.\n  // 4. the key-value pair is pushed into the map;\n  // 5. each number\
    \ is pushed into the list.\n  for (int i = 0; i < arr.size(); i++) {\n    int\
    \ count = 0;\n    for (int j = 0; j < 32; j++) {\n      if (arr[i] & (1 << j))\
    \ {\n        count++;\n      }\n    }\n    m[arr[i]] = count;\n    l.push_back(arr[i]);\n\
    \  }\n  // 6. the elements in the list are sorted in ascending order.\n  l.sort();\n\
    \  // 7. the elements in the list are sorted in ascending order\n  // based on\
    \ the number of ones in the binary representation of each number.\n  l.sort([&m](const\
    \ long &a, const long &b) {\n    return m[a] < m[b];\n  });\n  // 8. return a\
    \ vector\n  return std::vector<long>(l.begin(), l.end());", "  //your code here\n\
    \  std::vector<std::pair<int, long>> vp;\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    int count = 0;\n    long n = arr[i];\n    while (n) {\n      count +=\
    \ n & 1;\n      n >>= 1;\n    }\n    vp.push_back(std::make_pair(count, arr[i]));\n\
    \  }\n  std::sort(vp.begin(), vp.end());\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    arr[i] = vp[i].second;\n  }\n  return arr;", "  std::vector<long> ret;\n\
    \  std::map<int, std::vector<long>> map;\n  std::map<int, std::vector<long>> negativeMap;\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    long cur = arr[i];\n    int count\
    \ = 0;\n    if (cur < 0) {\n      count = negativeOnes(abs(cur));\n      negativeMap[count].push_back(cur);\n\
    \    } else {\n      count = ones(cur);\n      map[count].push_back(cur);\n  \
    \  }\n  }\n  for (auto it = map.begin(); it != map.end(); it++) {\n    ret.insert(ret.end(),\
    \ it->second.begin(), it->second.end());\n  }\n  for (auto it = negativeMap.begin();\
    \ it != negativeMap.end(); it++) {\n    ret.insert(ret.end(), it->second.begin(),\
    \ it->second.end());\n  }\n  return ret;", "    std::vector<std::pair<int, int>>\
    \ ones;\n    for (int i = 0; i < arr.size(); i++) {\n        int n = arr[i];\n\
    \        int totalOnes = 0;\n        while (n) {\n            totalOnes += n &\
    \ 1;\n            n >>= 1;\n        }\n        ones.push_back(std::make_pair(totalOnes,\
    \ arr[i]));\n    }\n    std::sort(ones.begin(), ones.end());\n    std::vector<long>\
    \ sorted;\n    for (int i = 0; i < ones.size(); i++) {\n        sorted.push_back(ones[i].second);\n\
    \    }\n    return sorted;", "  std::sort(std::begin(arr), std::end(arr), [](long\
    \ a, long b) {\n    int num_ones_a = std::bitset<32>(a).count();\n    int num_ones_b\
    \ = std::bitset<32>(b).count();\n    if (num_ones_a == num_ones_b) {\n      return\
    \ a < b;\n    }\n    return num_ones_a < num_ones_b;\n  });\n  return arr;", " \
    \ std::vector<long> res;\n  int count[arr.size()];\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    count[i] = 0;\n    long n = arr[i];\n    while (n > 0) {\n     \
    \ count[i] += n & 1;\n      n >>= 1;\n    }\n  }\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    int min = i;\n    for (int j = i + 1; j < arr.size(); j++) {\n \
    \     if (count[j] < count[min])\n        min = j;\n      else if (count[j] ==\
    \ count[min] && arr[j] < arr[min])\n        min = j;\n    }\n    long temp = arr[i];\n\
    \    arr[i] = arr[min];\n    arr[min] = temp;\n    temp = count[i];\n    count[i]\
    \ = count[min];\n    count[min] = temp;\n  }\n  return arr;", "  std::sort(arr.begin(),\
    \ arr.end(),\n            [](long a, long b) {\n              std::bitset<32>\
    \ a_bs(a);\n              std::bitset<32> b_bs(b);\n              return a_bs.count()\
    \ == b_bs.count() ? a < b : a_bs.count() < b_bs.count();\n            });\n  return\
    \ arr;", "  for (int i = 0; i < arr.size(); i++) {\n    for (int j = i + 1; j\
    \ < arr.size(); j++) {\n      int sumBinaryOfI = 0;\n      int sumBinaryOfJ =\
    \ 0;\n      int temp = arr[i];\n      int temp2 = arr[j];\n      while (temp >\
    \ 0) {\n        if (temp % 2 == 1)\n          sumBinaryOfI++;\n        temp /=\
    \ 2;\n      }\n      while (temp2 > 0) {\n        if (temp2 % 2 == 1)\n      \
    \    sumBinaryOfJ++;\n        temp2 /= 2;\n      }\n      if (sumBinaryOfI > sumBinaryOfJ)\
    \ {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n\
    \      } else if (sumBinaryOfI == sumBinaryOfJ) {\n        if (arr[i] > arr[j])\
    \ {\n          int temp = arr[i];\n          arr[i] = arr[j];\n          arr[j]\
    \ = temp;\n        }\n      }\n    }\n  }\n  return arr;", "  int numOnes;\n \
    \ std::vector<long> result;\n  // iterate through array, get number of ones, sort\
    \ in ascending order\n  for (int i = 0; i < arr.size(); i++) {\n    for (int j\
    \ = 0; j < arr.size(); j++) {\n      if (arr[i] < arr[j]) {\n        std::swap(arr[i],\
    \ arr[j]);\n      }\n    }\n  }\n  // instantiate a new vector to avoid mutating\
    \ original data\n  std::vector<long> sortedArr = arr;\n  // iterate through sorted\
    \ vector, add to result\n  for (int i = 0; i < sortedArr.size(); i++) {\n    numOnes\
    \ = std::bitset<64>(sortedArr[i]).count();\n    // if index + 1 exists, check\
    \ if number of ones are the same\n    if (i + 1 != sortedArr.size()) {\n     \
    \ if (std::bitset<64>(sortedArr[i + 1]).count() == numOnes) {\n        // if number\
    \ of ones are the same, swap them if the second is greater\n        if (sortedArr[i\
    \ + 1] > sortedArr[i]) {\n          std::swap(sortedArr[i + 1], sortedArr[i]);\n\
    \        }\n      }\n    }\n    result.push_back(sortedArr[i]);\n  }\n  return\
    \ result;", "\tstd::vector<long> answer(arr.size());\n\t// store pairs of {1s\
    \ in binary, corresponding number}\n\tstd::vector<std::pair<int,int>> a1(arr.size());\n\
    \tfor(auto i: arr) {\n\t\tint ones=__builtin_popcount(i);\n\t\tstd::pair<int,int>\
    \ p={ones,i};\n\t\ta1.push_back(p);\n\t}\n\t// sort based on ones\n\tstd::sort(a1.begin(),a1.end());\n\
    \t// fill answer with sorted pairs\n\tfor(int i=0;i<arr.size();i++) {\n\t\tanswer[i]=a1[i].second;\n\
    \t}\n\treturn answer;", "  std::vector<long> hola;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    hola.push_back(std::bitset<32>(arr[i]).count());\n  }\n  return\
    \ hola;", "  std::vector<std::pair<int, int>> ones_list;\n  for (int i = 0; i\
    \ < arr.size(); i++) {\n    std::string binary_representation = std::bitset<32>(arr[i]).to_string();\n\
    \    std::cout << binary_representation << std::endl;\n    int ones = 0;\n   \
    \ for (int j = 0; j < binary_representation.size(); j++) {\n      if (binary_representation[j]\
    \ == '1') ones++;\n    }\n    ones_list.push_back(std::make_pair(ones, arr[i]));\n\
    \  }\n  std::sort(ones_list.begin(), ones_list.end());\n  std::vector<long> ones_vec;\n\
    \  for (int i = 0; i < ones_list.size(); i++) {\n    ones_vec.push_back(ones_list[i].second);\n\
    \  }\n  return ones_vec;", "  sort(arr.begin(), arr.end(), [](long a, long b)\
    \ {\n    return std::bitset<32>(a).count() < std::bitset<32>(b).count();\n  });\n\
    \  return arr;", "  std::sort(arr.begin(), arr.end(), [](long lhs, long rhs) {\n\
    \    int lones = countOnes(lhs);\n    int rones = countOnes(rhs);\n    if (lones\
    \ == rones) {\n      return lhs < rhs;\n    }\n    return lones < rones;\n  });\n\
    \  return arr;", "    std::vector<long> r(arr.size());\n    std::vector<std::pair<int,\
    \ int>> v(arr.size());\n    for (int i = 0; i < arr.size(); i++) {\n        int\
    \ count = 0;\n        long x = arr[i];\n        while (x) {\n            if (x\
    \ & 1) count++;\n            x >>= 1;\n        }\n        v[i] = std::make_pair(count,\
    \ arr[i]);\n    }\n    std::sort(v.begin(), v.end());\n    for (int i = 0; i <\
    \ arr.size(); i++) r[i] = v[i].second;\n    return r;", "   std::vector<std::pair<int,\
    \ long>> ones_dec;\n   for (long i : arr) {\n     int num_ones = 0;\n     int\
    \ num = i;\n     while (num) {\n       num_ones += num%2;\n       num /= 2;\n\
    \     }\n     ones_dec.push_back(std::make_pair(num_ones, i));\n   }\n   sort(ones_dec.begin(),\
    \ ones_dec.end());\n   arr.clear();\n   for (auto p : ones_dec) {\n     arr.push_back(p.second);\n\
    \   }\n   return arr;", "\tstd::vector<long> one_zero_arr;\n\tfor (int i = 0;\
    \ i < arr.size(); i++) {\n\t\tint num = arr[i];\n\t\tstd::string binary = std::bitset<32>(num).to_string();\n\
    \t\tint ones = std::count(binary.begin(), binary.end(), '1');\n\t\tone_zero_arr.push_back(ones);\n\
    \t}\n\tstd::vector<int> sorted_one_zero_arr = one_zero_arr;\n\tstd::sort(sorted_one_zero_arr.begin(),\
    \ sorted_one_zero_arr.end());\n\tstd::vector<long> sorted_arr;\n\tfor (int i =\
    \ 0; i < sorted_one_zero_arr.size(); i++) {\n\t\tint ones = sorted_one_zero_arr[i];\n\
    \t\tfor (int j = 0; j < one_zero_arr.size(); j++) {\n\t\t\tif (ones == one_zero_arr[j])\
    \ {\n\t\t\t\tsorted_arr.push_back(arr[j]);\n\t\t\t\tarr[j] = INT_MAX;\n\t\t\t\t\
    one_zero_arr[j] = INT_MAX;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sorted_arr;",
  "    std::vector<std::pair<long,int>> bin_arr;\n    int cnt;\n    for(auto i:arr){\n\
    \        cnt=0;\n        while(i){\n            if(i&1)\n                cnt++;\n\
    \            i>>=1;\n        }\n        bin_arr.push_back(std::make_pair(cnt,arr.at(i)));\n\
    \    }\n    std::sort(bin_arr.begin(),bin_arr.end());\n    arr.clear();\n    for(auto\
    \ i:bin_arr){\n        arr.push_back(i.second);\n    }\n    return arr;", "  \
    \  std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        std::bitset<64>\
    \ s1(a);\n        std::bitset<64> s2(b);\n        return s1.count() < s2.count()\
    \ || (s1.count() == s2.count() && a < b);\n    });\n    return arr;", "  std::vector<long>\
    \ sorted = arr;\n  std::vector<int> mapping(arr.size());\n  std::iota(mapping.begin(),\
    \ mapping.end(), 0);\n  std::sort(mapping.begin(), mapping.end(),\n          \
    \  [&](int i, int j) {\n              std::bitset<sizeof(long) * 8> i_bits(sorted[i]);\n\
    \              std::bitset<sizeof(long) * 8> j_bits(sorted[j]);\n            \
    \  if (i_bits.count() == j_bits.count()) {\n                return sorted[i] <\
    \ sorted[j];\n              }\n              return i_bits.count() < j_bits.count();\n\
    \            });\n  std::transform(mapping.begin(), mapping.end(), sorted.begin(),\n\
    \                 [&](int i) { return arr[i]; });\n  return sorted;", "    for\
    \ (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size();\
    \ j++) {\n            if (__builtin_popcount(arr[i]) > __builtin_popcount(arr[j]))\
    \ {\n                std::swap(arr[i], arr[j]);\n            } else if (__builtin_popcount(arr[i])\
    \ == __builtin_popcount(arr[j])) {\n                if (arr[i] > arr[j]) {\n \
    \                   std::swap(arr[i], arr[j]);\n                }\n          \
    \  }\n        }\n    }\n    return arr;", "    std::map<int, std::vector<long>>\
    \ onesToDecimalMapper;\n    for (long decimalNumber : arr) {\n        int ones\
    \ = getNumberOfOnesInBinaryRepresentation(decimalNumber);\n        onesToDecimalMapper[ones].push_back(decimalNumber);\n\
    \    }\n    std::vector<long> result;\n    for (auto itr = onesToDecimalMapper.begin();\
    \ itr != onesToDecimalMapper.end(); itr++) {\n        for (long decimalNumber\
    \ : itr->second) {\n            result.push_back(decimalNumber);\n        }\n\
    \    }\n    return result;", "  for (long long i = 0; i < arr.size(); i++) {\n\
    \    long long y = arr[i];\n    long long count = 0;\n    while (y > 0) {\n  \
    \    if (y % 2 == 1) {\n        count++;\n      }\n      y = y / 2;\n    }\n \
    \   arr[i] = count * 1000000 + arr[i];\n  }\n  sort(arr.begin(), arr.end());\n\
    \  for (long long i = 0; i < arr.size(); i++) {\n    arr[i] = arr[i] % 1000000;\n\
    \  }\n  return arr;", "  std::vector<long> ones;\n  std::vector<long> zeros;\n\
    \  for (long i = 0; i < arr.size(); i++) {\n    int count = 0;\n    int num =\
    \ arr[i];\n    int rem = 0;\n    while (num > 0) {\n      rem = num % 2;\n   \
    \   if (rem == 1) {\n        count++;\n      }\n      num = num / 2;\n    }\n\
    \    if (count == 0) {\n      zeros.push_back(arr[i]);\n    } else {\n      ones.push_back(arr[i]);\n\
    \    }\n  }\n  // sort the ones vector\n  std::sort(ones.begin(), ones.end());\n\
    \  ones.insert(ones.end(), zeros.begin(), zeros.end());\n  return ones;", "  std::unordered_map<long,int>\
    \ mp;\n  int c =0;\n  std::vector<long> ans;\n  for(int i=0;i<arr.size();i++){\n\
    \    if(arr[i]<0){\n      mp[arr[i]]=-1;\n      c++;\n    }\n    else{\n     \
    \ long n = arr[i];\n      int count = 0;\n      while(n>0){\n        count +=\
    \ n&1;\n        n>>=1;\n      }\n      mp[arr[i]] = count;\n    }\n  }\n  sort(arr.begin(),arr.end());\n\
    \  std::vector<long> tmp;\n  for(int i=0;i<arr.size();i++){\n    if(mp[arr[i]]!=-1){\n\
    \      ans.push_back(arr[i]);\n    }\n    else{\n      tmp.push_back(arr[i]);\n\
    \    }\n  }\n  sort(ans.begin(),ans.end(),[mp](long a,long b){\n    return mp[a]>mp[b];\n\
    \  });\n  sort(tmp.begin(),tmp.end());\n  for(int i=0;i<tmp.size();i++){\n   \
    \ ans.push_back(tmp[i]);\n  }\n  return ans;", "  std::sort(arr.begin(), arr.end(),\
    \ [](int a, int b) {\n    return std::bitset<32>(a).count() < std::bitset<32>(b).count();\n\
    \  });\n  return arr;", "    // std::map<long,long> map;\n    // for(int i=0;i<arr.size();i++){\n\
    \    //     map[arr[i]] = __builtin_popcountl(arr[i]);\n    // }\n    // std::vector<long>\
    \ ans;\n    // for(auto it=map.begin();it!=map.end();it++){\n    //     ans.push_back(it->first);\n\
    \    // }\n    // for(int i=0;i<ans.size();i++){\n    //     for(int j=i+1;j<ans.size();j++){\n\
    \    //         if(map[ans[i]] > map[ans[j]]){\n    //             long temp =\
    \ ans[i];\n    //             ans[i] = ans[j];\n    //             ans[j] = temp;\n\
    \    //         }\n    //         else if(map[ans[i]] == map[ans[j]]){\n    //\
    \             if(ans[i] > ans[j]){\n    //                 long temp = ans[i];\n\
    \    //                 ans[i] = ans[j];\n    //                 ans[j] = temp;\n\
    \    //             }\n    //         }\n    //     }\n    // }\n    // return\
    \ ans;\n    for(int i=0;i<arr.size();i++){\n        for(int j=i+1;j<arr.size();j++){\n\
    \            if(__builtin_popcountl(arr[i])>__builtin_popcountl(arr[j])){\n  \
    \              long temp = arr[i];\n                arr[i] = arr[j];\n       \
    \         arr[j] = temp;\n            }\n            else if(__builtin_popcountl(arr[i])==__builtin_popcountl(arr[j])){\n\
    \                if(arr[i]>arr[j]){\n                    long temp = arr[i];\n\
    \                    arr[i] = arr[j];\n                    arr[j] = temp;\n  \
    \              }\n            }\n        }\n    }\n    return arr;", "  std::sort(arr.begin(),\
    \ arr.end(), [](long& a, long& b) {\n    unsigned c = 0, d = 0;\n    while (a\
    \ > 0) {\n      if (a % 2) c++;\n      a /= 2;\n    }\n    while (b > 0) {\n \
    \     if (b % 2) d++;\n      b /= 2;\n    }\n    return c < d || (c == d && a\
    \ < b);\n  });\n  return arr;", "  //convert to  vector<int>\n  std::vector<int>\
    \ onesCount;\n  for(auto const&i:arr){\n    int temp = i;\n    int count = 0;\n\
    \    if(temp == 0){\n      onesCount.push_back(0);\n      continue;\n    }\n \
    \   while(temp){\n      if(temp & 1){\n        count++;\n      }\n      temp >>=\
    \ 1;\n    }\n    onesCount.push_back(count);\n  }\n  //sort\n  std::vector<long>\
    \ sorted;\n  for(int i = 0; i < arr.size(); i++){\n    int smallest = INT_MAX;\n\
    \    int smallestIndex = -1;\n    for(int j = 0; j < arr.size(); j++){\n     \
    \ if(arr[j] > 0 && onesCount[j] < smallest){\n        smallest = onesCount[j];\n\
    \        smallestIndex = j;\n      }\n    }\n    sorted.push_back(arr[smallestIndex]);\n\
    \    arr[smallestIndex] = -1;\n  }\n  //greater than 1s\n  for(int i = 0; i <\
    \ arr.size(); i++){\n    int smallest = INT_MAX;\n    int smallestIndex = -1;\n\
    \    for(int j = 0; j < arr.size(); j++){\n      if(arr[j] > 0 && onesCount[j]\
    \ == 1 && arr[j] < smallest){\n        smallest = arr[j];\n        smallestIndex\
    \ = j;\n      }\n    }\n    sorted.push_back(arr[smallestIndex]);\n    arr[smallestIndex]\
    \ = -1;\n  }\n  // 0 ones\n  for(int i = 0; i < arr.size(); i++){\n    int smallest\
    \ = INT_MAX;\n    int smallestIndex = -1;\n    for(int j = 0; j < arr.size();\
    \ j++){\n      if(arr[j] > 0 && onesCount[j] == 0 && arr[j] < smallest){\n   \
    \     smallest = arr[j];\n        smallestIndex = j;\n      }\n    }\n    sorted.push_back(arr[smallest",
  "  std::vector<std::pair<long, int>> temp;\n  for (auto value : arr) {\n    int\
    \ count = 0;\n    while (value) {\n      count += value & 1;\n      value >>=\
    \ 1;\n    }\n    temp.push_back(std::make_pair(value, count));\n  }\n  std::sort(temp.begin(),\
    \ temp.end(),\n            [](std::pair<long, int> a, std::pair<long, int> b)\
    \ {\n              if (a.second != b.second) {\n                return a.second\
    \ < b.second;\n              } else {\n                return a.first < b.first;\n\
    \              }\n            });\n  for (int i = 0; i < temp.size(); i++) {\n\
    \    arr[i] = temp[i].first;\n  }\n  return arr;", "  int n = arr.size();\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = i+1; j < n; j++) {\n      int sb\
    \ = std::bitset<32>(arr[i]).count();\n      int sa = std::bitset<32>(arr[j]).count();\n\
    \      if (sb < sa) {\n        long temp = arr[i];\n        arr[i] = arr[j];\n\
    \        arr[j] = temp;\n      }\n      else if (sb == sa) {\n        if (arr[i]\
    \ < arr[j]) {\n          long temp = arr[i];\n          arr[i] = arr[j];\n   \
    \       arr[j] = temp;\n        }\n      }\n    }\n  }\n  return arr;", "  //\n\
    \  std::vector<std::pair<long, long>> num1s;\n  for (long i : arr) {\n    long\
    \ num_ones = 0;\n    for (; i > 0; i >>= 1) {\n      num_ones += i & 1;\n    }\n\
    \    num1s.push_back(std::make_pair(num_ones, i));\n  }\n  std::sort(num1s.begin(),\
    \ num1s.end());\n  std::vector<long> res;\n  for (auto& v : num1s) {\n    res.push_back(v.second);\n\
    \  }\n  return res;", "  std::vector<long> result;\n  result.reserve(arr.size());\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    result.push_back(0);\n  }\n  std::vector<int>\
    \ count(arr.size(), 0);\n  for (int i = 0; i < arr.size(); i++) {\n    int temp\
    \ = arr[i];\n    int bitCount = 0;\n    while (temp) {\n      bitCount += temp\
    \ & 1;\n      temp >>= 1;\n    }\n    count[i] = bitCount;\n  }\n  for (int i\
    \ = 0; i < arr.size(); i++) {\n    int i1;\n    for (i1 = 0; i1 < arr.size();\
    \ i1++) {\n      if (result[i1] == 0) {\n        break;\n      }\n    }\n    for\
    \ (int j = i1 + 1; j < arr.size(); j++) {\n      if (result[j] == 0) {\n     \
    \   if (count[i1] > count[j]) {\n          i1 = j;\n        } else if (count[i1]\
    \ == count[j]) {\n          if (arr[i1] > arr[j]) {\n            i1 = j;\n   \
    \       }\n        }\n      }\n    }\n    result[i1] = arr[i1];\n  }\n  return\
    \ result;", "  int size = arr.size();\n  int index = 0;\n  int i = 0;\n  int count\
    \ = 0;\n  long temp;\n  int zero = 0;\n  for (i = 0; i < size; i++) {\n    count\
    \ = 0;\n    temp = arr[i];\n    while (temp != 0) {\n      if (temp % 2 == 1)\
    \ {\n        count++;\n      }\n      temp = temp / 2;\n    }\n    if (count ==\
    \ 0) {\n      count = arr[i];\n      zero = 1;\n    }\n    arr[i] = count;\n \
    \ }\n  // if (zero == 1) {\n  //   for (i = 0; i < size; i++) {\n  //     if (arr[i]\
    \ != count) {\n  //       index = i;\n  //       break;\n  //     }\n  //   }\n\
    \  //   arr[index] = count;\n  //   arr[index + 1] = arr[index];\n  //   arr[index]\
    \ = temp;\n  // }\n  for (i = 0; i < size; i++) {\n    for (int j = i + 1; j <\
    \ size; j++) {\n      if (arr[i] > arr[j]) {\n        count = arr[i];\n      \
    \  arr[i] = arr[j];\n        arr[j] = count;\n      }\n    }\n  }\n  if (zero\
    \ == 1) {\n    arr[index] = temp;\n  }\n  for (i = 0; i < size; i++) {\n    std::cout\
    \ << arr[i] << std::endl;\n  }\n  return arr;", "    int n = arr.size();\n   \
    \ std::vector<int> ones_count(n);\n    int i = 0;\n    while(i < n) {\n      \
    \  int index = i;\n        int min_count = INT_MAX;\n        int min_index = i;\n\
    \        while(index < n) {\n            int count = 0;\n            long num\
    \ = arr[index];\n            while(num) {\n                if(num & 1) {\n   \
    \                 count++;\n                }\n                num = num >> 1;\n\
    \            }\n            if(count < min_count) {\n                min_count\
    \ = count;\n                min_index = index;\n            }\n            index++;\n\
    \        }\n        if(min_index != i) {\n            int temp = arr[i];\n   \
    \         arr[i] = arr[min_index];\n            arr[min_index] = temp;\n     \
    \   }\n        i++;\n    }\n    return arr;", "    // create array and store number\
    \ of 1's in each index of arr\n    int arr_size = arr.size();\n    std::vector<int>\
    \ arr_ones;\n    int temp_size = 0;\n    // find number of 1's in each element\
    \ of arr\n    for (int i = 0; i < arr_size; i++) {\n        int count = 0;\n \
    \       int temp = arr[i];\n        // check for negative number\n        if (temp\
    \ < 0) {\n            temp *= -1;\n        }\n        // count 1's in binary representation\
    \ of temp\n        while (temp > 0) {\n            if (temp % 2 == 1) {\n    \
    \            count++;\n            }\n            temp /= 2;\n        }\n    \
    \    // store count in array\n        arr_ones.push_back(count);\n    }\n    //\
    \ Create a map to hold pair of number of 1's and corresponding decimal value\n\
    \    std::map<int, std::vector<int>> map_ones;\n    //std::vector<int> temp_arr;\n\
    \    // Iterate through array and store number of 1's and decimal values in map\n\
    \    for (int i = 0; i < arr_size; i++) {\n        if (map_ones.find(arr_ones[i])\
    \ == map_ones.end()) {\n            std::vector<int> temp_arr;\n            temp_arr.push_back(arr[i]);\n\
    \            map_ones.insert(std::pair<int, std::vector<int>>(arr_ones[i], temp_arr));\n\
    \        } else {\n            map_ones[arr_ones[i]].push_back(arr[i]);\n    \
    \    }\n    }\n    // Sort each vector in map_ones by ascending order\n    for\
    \ (std::map<int, std::vector<int>>::iterator it = map_ones.begin(); it != map_ones.end();\
    \ it++) {\n        std::sort(it->second.begin(), it->second.end());\n    }\n \
    \   // Store sorted numbers in array\n    std::vector<long> sorted_arr;\n    int\
    \ index = 0;\n    for (std::map<int, std::vector<int>>::iterator it = map_ones.",
  "  sort(arr.begin(), arr.end(), [&](int i, int j) {\n    int x = __builtin_popcount(i);\n\
    \    int y = __builtin_popcount(j);\n    if (x != y) {\n      return x < y;\n\
    \    }\n    return i < j;\n  });\n  return arr;", "    int zeros = 0;\n    std::vector<long>\
    \ res;\n    for (auto i : arr) {\n        if (i == 0) {\n            zeros++;\n\
    \        }\n    }\n    while (zeros--) {\n        res.push_back(0);\n    }\n \
    \   std::sort(arr.begin(), arr.end(), [](int a, int b) {\n        return std::bitset<16>(a).count()\
    \ < std::bitset<16>(b).count();\n    });\n    for (auto i : arr) {\n        if\
    \ (i != 0) {\n            res.push_back(i);\n        }\n    }\n    return res;",
  "    //    std::sort(arr.begin(), arr.end(), cmp);\n    std::sort(arr.begin(), arr.end(),\n\
    \    [](const int & a, const int & b) -> bool {\n        int ones_a = __builtin_popcount(a);\n\
    \        int ones_b = __builtin_popcount(b);\n        if (ones_a == ones_b)\n\
    \            return a < b;\n        return ones_a < ones_b;\n    });\n    return\
    \ arr;", "  std::vector<std::pair<int, int>> tmp;\n  int n = arr.size();\n  for\
    \ (int i = 0; i < n; i++) {\n    int ones = 0;\n    int x = arr[i];\n    if (x\
    \ < 0)\n      x = -x;\n    while (x > 0) {\n      if (x % 2 == 1)\n        ones++;\n\
    \      x = x / 2;\n    }\n    tmp.push_back(std::make_pair(ones, arr[i]));\n \
    \ }\n  std::sort(tmp.begin(), tmp.end());\n  for (int i = 0; i < n; i++) {\n \
    \   arr[i] = tmp[i].second;\n  }\n  return arr;", "  // This is a program to count\
    \ the number of ones in a binary representation.\n  vector<int> count;\n  vector<long>\
    \ ans;\n  vector<long> ans2;\n  for (auto itr : arr) {\n    count.push_back(0);\n\
    \    int c = 0;\n    int temp = itr;\n    while (temp > 0) {\n      if (temp %\
    \ 2 == 1)\n        c++;\n      temp /= 2;\n    }\n    count.push_back(c);\n  }\n\
    \  sort(count.begin(), count.end());\n  return count;", "    //your code here\n\
    \    int n = arr.size();\n    std::vector<int> onesCount(n);\n    std::vector<int>\
    \ sorted(n);\n    std::vector<long> result(n);\n    for(int i = 0; i < n; i++)\
    \ {\n        int x = arr[i];\n        int count = 0;\n        while(x) {\n   \
    \         if(x & 1) count++;\n            x = x >> 1;\n        }\n        onesCount[i]\
    \ = count;\n        sorted[i] = i;\n    }\n    sort(sorted.begin(), sorted.end(),\
    \ [&](int a, int b) {\n        if(onesCount[a] == onesCount[b]) {\n          \
    \  return arr[a] < arr[b];\n        }\n        return onesCount[a] < onesCount[b];\n\
    \    });\n    for(int i = 0; i < n; i++) {\n        result[i] = arr[sorted[i]];\n\
    \    }\n    return result;", "  int n = arr.size();\n  std::vector<long> res(n);\n\
    \  std::map<int, std::vector<long>> mp;\n  for (auto i : arr) {\n    int cnt =\
    \ 0;\n    while (i) {\n      i /= 2;\n      cnt++;\n    }\n    mp[cnt].push_back(i);\n\
    \  }\n  int k = 0;\n  for (auto i : mp) {\n    for (auto j : i.second) {\n   \
    \   res[k++] = j;\n    }\n  }\n  return res;", "    std::vector<std::pair<long,\
    \ long>> v;\n    for (const auto& e : arr) {\n        std::bitset<32> bits(e);\n\
    \        long num_of_1 = bits.count();\n        v.push_back(std::make_pair(num_of_1,\
    \ e));\n    }\n    std::sort(v.begin(), v.end());\n    for (auto& e : arr) {\n\
    \        e = v.front().second;\n        v.erase(v.begin());\n    }\n    return\
    \ arr;", "  // sort the array by number of ones in their binary representation\n\
    \  std::sort(arr.begin(), arr.end(), [](long a, long b) {\n    std::string sa\
    \ = std::bitset<64>(a).to_string();\n    std::string sb = std::bitset<64>(b).to_string();\n\
    \    int c = 0;\n    for (int i = 0; i < 64; i++) {\n      if (sa[i] == '1') c++;\n\
    \    }\n    int d = 0;\n    for (int i = 0; i < 64; i++) {\n      if (sb[i] ==\
    \ '1') d++;\n    }\n    if (c == d) {\n      return a < b;\n    }\n    return\
    \ c < d;\n  });\n  return arr;", "  unsigned count=0;\n  std::vector<long> temp;\n\
    \  std::vector<long> temp2;\n  std::vector<long> result;\n  std::map<long, long>\
    \ m;\n  for(long i=0; i<arr.size(); i++){\n    long num = arr[i];\n    while(num!=0){\n\
    \      if(num%2==1){\n        count++;\n      }\n      num = num/2;\n    }\n \
    \   m[arr[i]] = count;\n    count = 0;\n  }\n  std::sort(arr.begin(), arr.end());\n\
    \  for(auto it=m.begin(); it!=m.end(); it++){\n    for(long i=0; i<arr.size();\
    \ i++){\n      if(it->first == arr[i]){\n        temp.push_back(arr[i]);\n   \
    \   }\n    }\n  }\n  for(auto it=m.begin(); it!=m.end(); it++){\n    for(long\
    \ i=0; i<temp.size(); i++){\n      if(it->first == temp[i]){\n        temp2.push_back(temp[i]);\n\
    \      }\n    }\n  }\n  for(long i=0; i<temp2.size(); i++){\n    for(long j=0;\
    \ j<temp.size(); j++){\n      if(temp2[i] == temp[j]){\n        result.push_back(temp[j]);\n\
    \      }\n    }\n  }\n  return result;", "  std::sort(arr.begin(), arr.end(),\n\
    \            [](const long &a, const long &b) {\n              int num_ones_a\
    \ = std::bitset<32>(a).count();\n              int num_ones_b = std::bitset<32>(b).count();\n\
    \              if (num_ones_a == num_ones_b) {\n                return a < b;\n\
    \              }\n              return num_ones_a < num_ones_b;\n            });\n\
    \  return arr;", "    std::multimap<int, long> mp;\n    std::vector<long> res;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        mp.insert(std::make_pair(__builtin_popcount(arr[i]),\
    \ arr[i]));\n    }\n    for (auto &p : mp) {\n        res.push_back(p.second);\n\
    \    }\n    return res;", "  // Write your code here\n  std::vector<std::pair<long,\
    \ int>> temp;\n  for (auto e : arr) {\n    int cnt = 0;\n    while (e > 0) {\n\
    \      cnt += e & 1;\n      e >>= 1;\n    }\n    temp.push_back(std::make_pair(e,\
    \ cnt));\n  }\n  std::sort(temp.begin(), temp.end(), [](auto a, auto b) {\n  \
    \  if (a.second == b.second)\n      return a.first < b.first;\n    return a.second\
    \ < b.second;\n  });\n  for (int i = 0; i < arr.size(); i++) {\n    arr[i] = temp[i].first;\n\
    \  }\n  return arr;", "  //your code here\n  // int n = arr.size();\n  // std::map<long,\
    \ int> m;\n  // std::vector<long> ans;\n  // for(int i = 0; i < n; i++) {\n  //\
    \   m[arr[i]] = __builtin_popcount(arr[i]);\n  // }\n  // sort(arr.begin(), arr.end(),\
    \ [&](int a, int b) {\n  //     if(m[a] != m[b]) {\n  //       return m[a] < m[b];\n\
    \  //     }\n  //     return a < b;\n  //   });\n  // return arr;\n  int n = arr.size();\n\
    \  for(int i = 0; i < n; i++) {\n    arr[i] *= -100;\n    arr[i] -= __builtin_popcount(arr[i]/-100);\n\
    \  }\n  sort(arr.begin(), arr.end());\n  for(int i = 0; i < n; i++) {\n    arr[i]\
    \ = arr[i]/-100;\n  }\n  return arr;", "  // your code\n  std::vector<long> sorted_arr(arr.size());\n\
    \  std::vector<int> binary_ones(arr.size());\n  std::vector<int> decimal_nums(arr.size());\n\
    \  for (long l : arr) {\n    int i = std::count(std::bitset<64>(l).to_string().begin(),\n\
    \                       std::bitset<64>(l).to_string().end(), '1');\n    binary_ones.push_back(i);\n\
    \    decimal_nums.push_back(l);\n  }\n  std::sort(binary_ones.begin(), binary_ones.end());\n\
    \  for (int i = 0; i < binary_ones.size(); i++) {\n    for (int j = 0; j < binary_ones.size();\
    \ j++) {\n      if (binary_ones[i] == std::count(std::bitset<64>(arr[j]).to_string().begin(),\n\
    \                       std::bitset<64>(arr[j]).to_string().end(), '1')) {\n \
    \       sorted_arr[i] = arr[j];\n        arr[j] = -1;\n        break;\n      }\n\
    \    }\n  }\n  return sorted_arr;", "    for (int i = 0; i < arr.size(); i++)\
    \ {\n        for (int j = i + 1; j < arr.size(); j++) {\n            int count1\
    \ = 0, count2 = 0;\n            int num1 = arr[i], num2 = arr[j];\n          \
    \  while (num1) {\n                count1 += num1 & 1;\n                num1 >>=\
    \ 1;\n            }\n            while (num2) {\n                count2 += num2\
    \ & 1;\n                num2 >>= 1;\n            }\n            if (count1 > count2)\n\
    \                std::swap(arr[i], arr[j]);\n            else if (count1 == count2)\
    \ {\n                if (arr[i] > arr[j])\n                    std::swap(arr[i],\
    \ arr[j]);\n            }\n        }\n    }\n    return arr;", "    int n = arr.size();\n\
    \    std::vector<int> binarr(n);\n    std::vector<long> ans(n);\n    for(int i\
    \ = 0; i < n; i++) {\n        long t = arr[i];\n        int count = 0;\n     \
    \   while(t) {\n            t = t & (t - 1);\n            count++;\n        }\n\
    \        binarr[i] = count;\n    }\n    std::vector<std::pair<int, long>> p;\n\
    \    for(int i = 0; i < n; i++) {\n        p.push_back(std::make_pair(binarr[i],\
    \ arr[i]));\n    }\n    std::sort(p.begin(), p.end());\n    for(int i = 0; i <\
    \ n; i++) {\n        ans[i] = p[i].second;\n    }\n    return ans;", "  //your\
    \ code here\n  std::map<int, std::vector<long>> m;\n  for (auto el : arr) {\n\
    \    int one_count = __builtin_popcount(el);\n    m[one_count].push_back(el);\n\
    \  }\n  std::vector<long> result;\n  for (auto kv : m) {\n    std::sort(kv.second.begin(),\
    \ kv.second.end());\n    result.insert(result.end(), kv.second.begin(), kv.second.end());\n\
    \  }\n  return result;", "    std::sort(arr.begin(), arr.end(),\n        [](long\
    \ a, long b) {\n            int abin = std::bitset<64>(a).count();\n         \
    \   int bbin = std::bitset<64>(b).count();\n            return abin < bbin ||\
    \ (abin == bbin && a < b);\n        });\n    return arr;", "  std::vector<long>\
    \ newarr = arr;\n  std::sort(newarr.begin(), newarr.end(), [](long a, long b)\
    \ {\n    int cnt1 = 0, cnt2 = 0;\n    int val1 = a, val2 = b;\n    for (; val1\
    \ > 0; val1 /= 2) {\n      cnt1 += val1 % 2;\n    }\n    for (; val2 > 0; val2\
    \ /= 2) {\n      cnt2 += val2 % 2;\n    }\n    if (cnt1 == cnt2) {\n      return\
    \ a < b;\n    }\n    return cnt1 < cnt2;\n  });\n  return newarr;", "  for (long\
    \ i=0; i<arr.size(); i++) {\n    for (long j=0; j<arr.size()-1; j++) {\n     \
    \ if (__builtin_popcountl(arr[j]) > __builtin_popcountl(arr[j+1])) {\n       \
    \ std::swap(arr[j], arr[j+1]);\n      } else if (__builtin_popcountl(arr[j]) ==\
    \ __builtin_popcountl(arr[j+1])) {\n        if (arr[j] > arr[j+1]) {\n       \
    \   std::swap(arr[j], arr[j+1]);\n        }\n      }\n    }\n  }\n  return arr;",
  "    int ones_count;\n    for (int i = 0; i < arr.size(); i++) {\n        for (int\
    \ j = i + 1; j < arr.size(); j++) {\n            ones_count = 0;\n           \
    \ for (int k = 0; k < 32; k++) {\n                if (arr[i] & (1 << k)) {\n \
    \                   ones_count++;\n                }\n            }\n        \
    \    int ones_count_j = 0;\n            for (int k = 0; k < 32; k++) {\n     \
    \           if (arr[j] & (1 << k)) {\n                    ones_count_j++;\n  \
    \              }\n            }\n            if (ones_count_j < ones_count) {\n\
    \                long temp = arr[i];\n                arr[i] = arr[j];\n     \
    \           arr[j] = temp;\n            } else if (ones_count_j == ones_count)\
    \ {\n                if (arr[j] < arr[i]) {\n                    long temp = arr[i];\n\
    \                    arr[i] = arr[j];\n                    arr[j] = temp;\n  \
    \              }\n            }\n        }\n    }\n    return arr;", "  std::vector<long>\
    \ result(arr.size());\n  std::map<long, std::vector<long>> mp;\n  for (long n\
    \ : arr) {\n    std::bitset<32> b(n);\n    if (mp.find(b.count()) == mp.end())\
    \ {\n      mp[b.count()] = std::vector<long>();\n    }\n    mp[b.count()].push_back(n);\n\
    \  }\n  int cnt = 0;\n  for (auto pr : mp) {\n    std::sort(pr.second.begin(),\
    \ pr.second.end());\n    for (long n : pr.second) {\n      result[cnt++] = n;\n\
    \    }\n  }\n  return result;", "  std::vector<long> sorted_array;\n  std::vector<long>\
    \ sorted_array_with_zeros;\n  for (size_t i = 0; i < arr.size(); i++) {\n    if\
    \ (arr[i] != 0) {\n      sorted_array.push_back(arr[i]);\n    } else {\n     \
    \ sorted_array_with_zeros.push_back(arr[i]);\n    }\n  }\n  int max_value = *std::max_element(sorted_array.begin(),\
    \ sorted_array.end());\n  // std::cout << max_value << std::endl;\n  std::vector<int>\
    \ frequencies(max_value, 0);\n  for (size_t i = 0; i < sorted_array.size(); i++)\
    \ {\n    frequencies[sorted_array[i] - 1]++;\n  }\n  std::vector<int> values;\n\
    \  for (size_t i = 0; i < frequencies.size(); i++) {\n    if (frequencies[i] !=\
    \ 0) {\n      values.push_back(i + 1);\n    }\n  }\n  std::vector<int> binary_values;\n\
    \  for (size_t i = 0; i < values.size(); i++) {\n    int value = values[i];\n\
    \    int number_of_ones = 0;\n    for (size_t j = 0; j < sizeof(value) * 8; j++)\
    \ {\n      if (value & 1) {\n        number_of_ones++;\n      }\n      value >>=\
    \ 1;\n    }\n    binary_values.push_back(number_of_ones);\n  }\n  std::vector<std::pair<int,\
    \ int>> pair_values;\n  for (size_t i = 0; i < values.size(); i++) {\n    std::pair<int,\
    \ int> pair(binary_values[i], values[i]);\n    pair_values.push_back(pair);\n\
    \  }\n  std::sort(pair_values.begin(), pair_values.end());\n  for (size_t i =\
    \ 0; i < sorted_array.size(); i++) {\n    for (size_", "    std::map<int, std::vector<long>>m;\n\
    \    for(long l : arr) {\n        int count = 0;\n        long temp = l;\n   \
    \     while(temp) {\n            if(temp & 1) {\n                count++;\n  \
    \          }\n            temp >>= 1;\n        }\n        m[count].push_back(l);\n\
    \    }\n    int index = 0;\n    for(std::pair<int, std::vector<long>> p : m) {\n\
    \        std::sort(p.second.begin(), p.second.end());\n        for(long l : p.second)\
    \ {\n            arr[index++] = l;\n        }\n    }\n    return arr;", "    //\
    \ your code here\n    std::vector<long>::iterator iter;\n    std::vector<long>\
    \ subarr[arr.size()];\n    std::vector<long> subsol;\n    // divide array\n  \
    \  for (iter = arr.begin(); iter != arr.end(); iter++) {\n        int cnt = 0;\n\
    \        long num = *iter;\n        while (num) {\n            cnt += (num & 1);\n\
    \            num >>= 1;\n        }\n        subarr[cnt].push_back(*iter);\n  \
    \  }\n    // sort subarr in ascending order\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        std::sort(subarr[i].begin(), subarr[i].end());\n    }\n    //\
    \ concatenate subarr to solution\n    for (int i = 0; i < arr.size(); i++) {\n\
    \        if (subarr[i].size() != 0) {\n            subsol.insert(subsol.end(),\
    \ subarr[i].begin(), subarr[i].end());\n        }\n    }\n    return subsol;",
  "  std::map<int, int>bitmap;\n  for(long n : arr) {\n    bitmap[count(std::bitset<32>(n).to_string().begin(),\
    \ std::bitset<32>(n).to_string().end(), '1')]++;\n  }\n  std::vector<long>res;\n\
    \  for(int i = 0; i < 32; i++) {\n    if(bitmap[i] > 0) {\n      std::vector<long>tmp;\n\
    \      for(long n : arr) {\n        if(count(std::bitset<32>(n).to_string().begin(),\
    \ std::bitset<32>(n).to_string().end(), '1') == i) {\n          tmp.push_back(n);\n\
    \        }\n      }\n      std::sort(tmp.begin(), tmp.end());\n      res.insert(res.end(),\
    \ tmp.begin(), tmp.end());\n    }\n  }\n  return res;", "  std::vector<long> ans;\n\
    \  std::map<long, long> map;\n  for (auto v : arr) {\n    long count = 0;\n  \
    \  while (v) {\n      v &= (v - 1);\n      count++;\n    }\n    if (map.find(count)\
    \ == map.end()) {\n      map[count] = v;\n    } else {\n      map[count] += v;\n\
    \    }\n  }\n  for (auto v : map) {\n    ans.push_back(v.second);\n  }\n  return\
    \ ans;", "  int n = arr.size();\n  std::vector<long> a(n);\n  std::vector<int>\
    \ b(n);\n  for (int i = 0; i < n; i++) {\n    a[i] = arr[i];\n    std::string\
    \ s = std::bitset<64>(arr[i]).to_string();\n    int cnt = 0;\n    for (int j =\
    \ 0; j < s.size(); j++) {\n      if (s[j] == '1') {\n        cnt++;\n      }\n\
    \    }\n    b[i] = cnt;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    for (int\
    \ j = 0; j < n - i - 1; j++) {\n      if (b[j] > b[j + 1]) {\n        std::swap(b[j],\
    \ b[j + 1]);\n        std::swap(a[j], a[j + 1]);\n      } else if (b[j] == b[j\
    \ + 1]) {\n        if (a[j] > a[j + 1]) {\n          std::swap(a[j], a[j + 1]);\n\
    \        }\n      }\n    }\n  }\n  return a;", "  std::map<int, std::vector<long>>\
    \ binaryMap;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] < 0)\n\
    \      arr[i] = -arr[i];\n    int count = 0;\n    while (arr[i] != 0) {\n    \
    \  count += arr[i] & 1;\n      arr[i] >>= 1;\n    }\n    binaryMap[count].push_back(arr[i]);\n\
    \  }\n  std::vector<long> res;\n  for (auto it = binaryMap.begin(); it != binaryMap.end();\
    \ it++) {\n    std::sort(it->second.begin(), it->second.end());\n    for (auto\
    \ i = it->second.begin(); i != it->second.end(); i++)\n      res.push_back(*i);\n\
    \  }\n  return res;", "    int N = arr.size();\n    std::vector<std::pair<int,\
    \ int>> a(N);\n    for (int i = 0; i < N; i++) {\n        int b = arr[i];\n  \
    \      int c = 0;\n        while (b > 0) {\n            b -= (b & -b);\n     \
    \       c++;\n        }\n        a[i] = std::make_pair(c, arr[i]);\n    }\n  \
    \  std::sort(a.begin(), a.end());\n    for (int i = 0; i < N; i++) {\n       \
    \ arr[i] = a[i].second;\n    }\n    return arr;", "    std::vector<long> result;\n\
    \    std::map<int, int> ones;\n    for (auto& item : arr) {\n        long num\
    \ = item;\n        int count = 0;\n        while (num) {\n            if (num\
    \ & 1) {\n                count++;\n            }\n            num = num >> 1;\n\
    \        }\n        ones[item] = count;\n    }\n    std::sort(arr.begin(), arr.end(),\
    \ [&ones](long a, long b) {\n        if (ones[a] == ones[b]) {\n            return\
    \ a < b;\n        }\n        return ones[a] < ones[b];\n    });\n    return arr;",
  "  std::vector<long> ones;\n  std::vector<long> zeros;\n  std::vector<long> result;\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    long temp = arr[i];\n    int counter\
    \ = 0;\n    while (temp != 0) {\n      if (temp % 2 == 1) {\n        counter++;\n\
    \      }\n      temp /= 2;\n    }\n    if (counter % 2 == 0) {\n      zeros.push_back(arr[i]);\n\
    \    } else {\n      ones.push_back(arr[i]);\n    }\n  }\n  std::sort(zeros.begin(),\
    \ zeros.end());\n  std::sort(ones.begin(), ones.end());\n  for (int i = 0; i <\
    \ zeros.size(); i++) {\n    result.push_back(zeros[i]);\n  }\n  for (int i = 0;\
    \ i < ones.size(); i++) {\n    result.push_back(ones[i]);\n  }\n  return result;",
  "  assert(std::all_of(arr.begin(), arr.end(), [](long n) {return n >= 0;}));\n \
    \ std::sort(arr.begin(), arr.end(),\n    [](long a, long b) {\n      int count_a\
    \ = std::bitset<sizeof(a) * 8>(a).count();\n      int count_b = std::bitset<sizeof(b)\
    \ * 8>(b).count();\n      return count_a == count_b ? a < b : count_a < count_b;\n\
    \    });\n  return arr;", "    std::vector<long> result = arr;\n    int size =\
    \ result.size();\n    for (int i = 0; i < size - 1; i++) {\n        for (int j\
    \ = 0; j < size - i - 1; j++) {\n            int one1 = __builtin_popcount(result[j]);\n\
    \            int one2 = __builtin_popcount(result[j + 1]);\n            if (one1\
    \ == one2) {\n                if (result[j] > result[j + 1]) {\n             \
    \       long t = result[j];\n                    result[j] = result[j + 1];\n\
    \                    result[j + 1] = t;\n                }\n            } else\
    \ if (one1 > one2) {\n                long t = result[j];\n                result[j]\
    \ = result[j + 1];\n                result[j + 1] = t;\n            }\n      \
    \  }\n    }\n    return result;", "    std::vector<long> ans;\n    std::vector<long>\
    \ index;\n    int ones = 0;\n    int index_ = 0;\n    int i = 0;\n    while(i\
    \ < arr.size()) {\n        index_ = 0;\n        index.clear();\n        ones =\
    \ 0;\n        while(index_ < arr.size()) {\n            if(__builtin_popcount(arr[index_])\
    \ == i) {\n                index.push_back(index_);\n            }\n         \
    \   index_++;\n        }\n        if(index.size() > 0) {\n            std::sort(index.begin(),\
    \ index.end(), [&arr](int a, int b) {\n                return arr[a] < arr[b];\n\
    \            });\n            for(auto it = index.begin(); it != index.end();\
    \ it++) {\n                ans.push_back(arr[*it]);\n            }\n        }\n\
    \        i++;\n    }\n    return ans;", "  \n  // make map\n  std::map<long, long>\
    \ map;\n  for (long i = 0; i < arr.size(); i++) {\n    long num = arr[i];\n  \
    \  long count = 0;\n    // get number of ones\n    for (long i = 0; i < 32; i++)\
    \ {\n      if (num & (1 << i)) {\n        count++;\n      }\n    }\n    if (map.find(count)\
    \ == map.end()) {\n      map[count] = arr[i];\n    } else {\n      if (map[count]\
    \ > arr[i]) {\n        map[count] = arr[i];\n      }\n    }\n  }\n  // make vector\n\
    \  std::vector<long> ans;\n  for (auto itr = map.begin(); itr != map.end(); itr++)\
    \ {\n    ans.push_back(itr->second);\n  }\n  return ans;", "\tstd::vector<long>\
    \ ret;\n\tstd::vector<std::vector<long>> map;\n\tstd::vector<long> temp;\n\tfor\
    \ (int i = 0; i < 32; i++) {\n\t\tmap.push_back(temp);\n\t}\n\tfor (int i = 0;\
    \ i < arr.size(); i++) {\n\t\tint count = 0;\n\t\tif (arr[i] < 0) {\n\t\t\tarr[i]\
    \ = -arr[i];\n\t\t}\n\t\tlong num = arr[i];\n\t\twhile (num) {\n\t\t\tif (num\
    \ & 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tnum = num >> 1;\n\t\t}\n\t\tmap[count].push_back(arr[i]);\n\
    \t}\n\tfor (int i = 0; i < 32; i++) {\n\t\tif (map[i].size() != 0) {\n\t\t\tstd::sort(map[i].begin(),\
    \ map[i].end());\n\t\t\tfor (int j = 0; j < map[i].size(); j++) {\n\t\t\t\tret.push_back(map[i][j]);\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn ret;", "    std::vector<long> temp;\n    int cnt;\n\
    \    for(auto c: arr){\n        if(c==0){\n            temp.push_back(c);\n  \
    \          continue;\n        }\n        cnt = 0;\n        for(auto i=1;i<=c;i<<=1){\n\
    \            if(c&i) cnt++;\n        }\n        temp.push_back(cnt<<15 | c);\n\
    \    }\n    std::sort(temp.begin(), temp.end());\n    for(auto& c: temp){\n  \
    \      c = c&32767;\n    }\n    return temp;", "  auto compare = [](const long\
    \ a, const long b) {\n    auto get_binary_ones = [](long a) {\n      std::bitset<sizeof(long)\
    \ * 8> binary(a);\n      return binary.count();\n    };\n    const auto a_ones\
    \ = get_binary_ones(a);\n    const auto b_ones = get_binary_ones(b);\n    return\
    \ a_ones < b_ones || (a_ones == b_ones && a < b);\n  };\n  std::sort(arr.begin(),\
    \ arr.end(), compare);\n  return arr;", "  int len = arr.size();\n  std::vector<std::vector<long>>\
    \ vec(len, std::vector<long>(2));\n  for (int i = 0; i < len; i++) {\n    vec[i][0]\
    \ = arr[i];\n    vec[i][1] = __builtin_popcount(arr[i]);\n  }\n  // std::cout\
    \ <<\"HERE\" << std::endl;\n  sort(vec.begin(), vec.end(), [](const std::vector<long>\
    \ &a, const std::vector<long> &b) {\n    if (a[1] == b[1]) {\n      return a[0]\
    \ < b[0];\n    }\n    return a[1] < b[1];\n  });\n  // std::cout <<\"HERE\" <<\
    \ std::endl;\n  std::vector<long> res(len);\n  for (int i = 0; i < len; i++) {\n\
    \    res[i] = vec[i][0];\n  }\n  return res;", "    for (size_t i = 0; i < arr.size();\
    \ i++) {\n        for (size_t j = i + 1; j < arr.size(); j++) {\n            if\
    \ (num_of_ones(arr[i]) > num_of_ones(arr[j])) {\n                std::swap(arr[i],\
    \ arr[j]);\n            } else if (num_of_ones(arr[i]) == num_of_ones(arr[j]))\
    \ {\n                if (arr[i] > arr[j]) {\n                    std::swap(arr[i],\
    \ arr[j]);\n                }\n            }\n        }\n    }\n    return arr;",
  "    std::sort(arr.begin(), arr.end(), [](int a, int b) {\n        int a_count =\
    \ std::bitset<32>(a).count();\n        int b_count = std::bitset<32>(b).count();\n\
    \        if (a_count == b_count) {\n            return a < b;\n        }\n   \
    \     return a_count < b_count;\n    });\n    return arr;", "  std::vector<long>\
    \ to_return;\n  // get an array of the binary represntation of each number\n \
    \ std::vector<std::string> binary_reps;\n  // get the binary rep of each number\n\
    \  for (auto num : arr) {\n    binary_reps.push_back(std::bitset<64>(num).to_string());\n\
    \  }\n  // get an array of the binary represntation of each number\n  std::vector<std::string>\
    \ sorted_binary_reps;\n  // get the binary rep of each number\n  for (auto binary_rep\
    \ : binary_reps) {\n    std::string binary_rep_sorted;\n    std::sort(binary_rep.begin(),\
    \ binary_rep.end());\n    for (auto bit : binary_rep) {\n      binary_rep_sorted\
    \ += std::to_string(bit - '0');\n    }\n    sorted_binary_reps.push_back(binary_rep_sorted);\n\
    \  }\n  std::vector<std::pair<int, int>> num_ones_and_decimal_values;\n  // get\
    \ the number of ones in the binary rep and its decimal value\n  for (int i = 0;\
    \ i < arr.size(); i++) {\n    num_ones_and_decimal_values.push_back(std::make_pair(std::stoi(sorted_binary_reps[i]),\
    \ arr[i]));\n  }\n  // sort by number of ones and then by decimal value\n  std::sort(num_ones_and_decimal_values.begin(),\
    \ num_ones_and_decimal_values.end());\n  // return only the decimal values\n \
    \ for (auto pair : num_ones_and_decimal_values) {\n    to_return.push_back(pair.second);\n\
    \  }\n  return to_return;", "  std::vector<std::pair<int,int>> tmp;\n  std::vector<long>\
    \ answer;\n  for(int i = 0; i < arr.size(); i++) {\n    int count = 0;\n    int\
    \ number = arr[i];\n    if(number >= 0) {\n      for(int j = 0; j < 32; j++) {\n\
    \        if(number % 2 == 1) {\n          count++;\n        }\n        number\
    \ /= 2;\n      }\n      tmp.push_back(std::make_pair(count, arr[i]));\n    } else\
    \ {\n      number = abs(number);\n      for(int j = 0; j < 32; j++) {\n      \
    \  if(number % 2 == 1) {\n          count++;\n        }\n        number /= 2;\n\
    \      }\n      tmp.push_back(std::make_pair(count, -arr[i]));\n    }\n  }\n \
    \ std::sort(tmp.begin(), tmp.end());\n  for(int i = 0; i < tmp.size(); i++) {\n\
    \    answer.push_back(tmp[i].second);\n  }\n  return answer;", "  if (arr.size()\
    \ <= 1) return arr;\n  std::vector<long> sorted;\n  std::vector<long> onecount;\n\
    \  int n = arr.size();\n  for (int i = 0; i < n; i++) {\n    long count = 0;\n\
    \    int t = arr[i];\n    while (t > 0) {\n      if (t & 1) count++;\n      t\
    \ >>= 1;\n    }\n    onecount.push_back(count);\n  }\n  std::vector<long> tmp\
    \ = arr;\n  for (int i = 0; i < n; i++) {\n    int idx = 0;\n    for (int j =\
    \ 0; j < n; j++) {\n      if (tmp[j] != -1 && onecount[j] < onecount[idx]) idx\
    \ = j;\n      else if (tmp[j] != -1 && onecount[j] == onecount[idx] && tmp[j]\
    \ < tmp[idx]) idx = j;\n    }\n    sorted.push_back(tmp[idx]);\n    tmp[idx] =\
    \ -1;\n  }\n  return sorted;", "    // TODO\n    vector<pair<int,int>>temp(arr.size());\n\
    \    for(int i=0;i<arr.size();i++){\n        int a=arr[i];\n        int count=0;\n\
    \        while(a){\n            count+=a&1;\n            a>>=1;\n        }\n \
    \       temp[i]=make_pair(count,arr[i]);\n    }\n    sort(temp.begin(),temp.end());\n\
    \    for(int i=0;i<arr.size();i++){\n        arr[i]=temp[i].second;\n    }\n \
    \   return arr;", "  std::vector<long> vec(arr.size());\n  std::sort(arr.begin(),\
    \ arr.end(), [](const long a, const long b) {\n    int a_ones = std::bitset<64>(a).count();\n\
    \    int b_ones = std::bitset<64>(b).count();\n    if (a_ones == b_ones) {\n \
    \     return a < b;\n    }\n    return a_ones < b_ones;\n  });\n  return arr;",
  "    // std::cout << arr.size() << std::endl;\n    std::vector<long> output;\n \
    \   std::vector<long> binary_ones_count;\n    std::vector<long> decimal_value;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        long count = 0;\n      \
    \  if (arr[i] > 0) {\n            count = std::to_string(arr[i]).length();\n \
    \           count = count - std::to_string(arr[i]).find_first_of('1');\n     \
    \   }\n        binary_ones_count.push_back(count);\n        decimal_value.push_back(arr[i]);\n\
    \    }\n    // std::cout << binary_ones_count.size() << std::endl;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        long min_index = std::min_element(binary_ones_count.begin(),\
    \ binary_ones_count.end()) - binary_ones_count.begin();\n        if (binary_ones_count[min_index]\
    \ == 0) {\n            long min_index = std::min_element(decimal_value.begin(),\
    \ decimal_value.end()) - decimal_value.begin();\n            output.push_back(decimal_value[min_index]);\n\
    \            binary_ones_count.erase(binary_ones_count.begin() + min_index);\n\
    \            decimal_value.erase(decimal_value.begin() + min_index);\n       \
    \ } else {\n            output.push_back(decimal_value[min_index]);\n        \
    \    binary_ones_count.erase(binary_ones_count.begin() + min_index);\n       \
    \     decimal_value.erase(decimal_value.begin() + min_index);\n        }\n   \
    \ }\n    return output;", "  std::multimap<int, long> bucket;\n  std::for_each(arr.begin(),\
    \ arr.end(), [&](long num) {\n    int count = 0;\n    long tmp = num;\n    while\
    \ (tmp > 0) {\n      if (tmp & 1) count++;\n      tmp >>= 1;\n    }\n    bucket.insert(std::make_pair(count,\
    \ num));\n  });\n  std::vector<long> result;\n  for (auto entry : bucket) {\n\
    \    result.push_back(entry.second);\n  }\n  return result;", "  std::vector<long>\
    \ bin;\n  std::vector<long> dec;\n  std::vector<long> res;\n  // sort(arr.begin(),\
    \ arr.end());\n  // return arr;\n  std::string str;\n  std::unordered_map<long,\
    \ long> mp;\n  std::string::size_type sz;\n  for (auto x : arr) {\n    str = std::bitset<8>(x).to_string();\n\
    \    std::cout << str << std::endl;\n    long ones = std::count(str.begin(), str.end(),\
    \ '1');\n    // std::cout << ones << std::endl;\n    mp[ones] = x;\n    bin.push_back(ones);\n\
    \    dec.push_back(x);\n  }\n  std::sort(bin.begin(), bin.end());\n  std::sort(dec.begin(),\
    \ dec.end());\n  for (auto x : bin) {\n    for (auto y : dec) {\n      if (mp[x]\
    \ == y) {\n        res.push_back(y);\n        // std::cout << y << std::endl;\n\
    \      }\n    }\n  }\n  return res;", "  int binaryArr[arr.size()];\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    binaryArr[i] = 0;\n    int c = 0;\n    int\
    \ t = arr[i];\n    while (t > 0) {\n      int rem = t % 2;\n      if (rem == 1)\
    \ {\n        binaryArr[i]++;\n      }\n      t = t / 2;\n      c++;\n    }\n \
    \ }\n  int j, m;\n  for (int i = 0; i < arr.size(); i++) {\n    j = i;\n    while\
    \ (j > 0 && binaryArr[j - 1] > binaryArr[j]) {\n      m = binaryArr[j];\n    \
    \  binaryArr[j] = binaryArr[j - 1];\n      binaryArr[j - 1] = m;\n      m = arr[j];\n\
    \      arr[j] = arr[j - 1];\n      arr[j - 1] = m;\n      j--;\n    }\n  }\n \
    \ for (int i = 0; i < arr.size(); i++) {\n    j = i;\n    while (j > 0 && binaryArr[j\
    \ - 1] == binaryArr[j] && arr[j - 1] > arr[j]) {\n      m = binaryArr[j];\n  \
    \    binaryArr[j] = binaryArr[j - 1];\n      binaryArr[j - 1] = m;\n      m =\
    \ arr[j];\n      arr[j] = arr[j - 1];\n      arr[j - 1] = m;\n      j--;\n   \
    \ }\n  }\n  return arr;", "  int n = arr.size();\n  for (int i = 0; i < n; i++)\
    \ {\n    for (int j = i+1; j < n; j++) {\n      int bin1 = __builtin_popcount(arr[i]);\n\
    \      int bin2 = __builtin_popcount(arr[j]);\n      if (bin1 > bin2) {\n    \
    \    std::swap(arr[i], arr[j]);\n      } else if (bin1 == bin2) {\n        if\
    \ (arr[i] > arr[j]) {\n          std::swap(arr[i], arr[j]);\n        }\n     \
    \ }\n    }\n  }\n  return arr;", "  int nums = arr.size();\n  int cnt = 0;\n \
    \ for (int i = 0; i < nums; i++) {\n    cnt = 0;\n    long x = arr[i];\n    while\
    \ (x > 0) {\n      if (x & 1) {\n        cnt++;\n      }\n      x >>= 1;\n   \
    \ }\n    arr[i] = -(cnt * nums + arr[i]);\n  }\n  sort(arr.begin(), arr.end());\n\
    \  for (int i = 0; i < nums; i++) {\n    arr[i] = -arr[i];\n  }\n  return arr;",
  "    std::vector<long> sorted_arr;\n    std::map<long, std::vector<long>> mp;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        long count = 0;\n      \
    \  long temp = arr[i];\n        while (temp) {\n            count += temp & 1;\n\
    \            temp >>= 1;\n        }\n        mp[count].push_back(arr[i]);\n  \
    \  }\n    for (auto x : mp) {\n        std::sort(x.second.begin(), x.second.end());\n\
    \        for (auto y : x.second) {\n            sorted_arr.push_back(y);\n   \
    \     }\n    }\n    return sorted_arr;", "  std::map<int, vector<long>> ones_map;\n\
    \  for (auto it : arr) {\n    int ones = count_ones(it);\n    ones_map[ones].push_back(it);\n\
    \  }\n  vector<long> ret;\n  for (auto it : ones_map) {\n    std::sort(it.second.begin(),\
    \ it.second.end());\n    ret.insert(ret.end(), it.second.begin(), it.second.end());\n\
    \  }\n  return ret;", "  std::sort(arr.begin(), arr.end(),\n            [](const\
    \ long a, const long b) {\n              int count_a = std::bitset<64>(a).count();\n\
    \              int count_b = std::bitset<64>(b).count();\n              if (count_a\
    \ == count_b) {\n                return a < b;\n              }\n            \
    \  return count_a < count_b;\n            });\n  return arr;", "\tauto cmp = [&](long\
    \ lhs, long rhs) {\n\t\tif (count_bits(lhs) == count_bits(rhs))\n\t\t\treturn\
    \ lhs < rhs;\n\t\treturn count_bits(lhs) < count_bits(rhs);\n\t};\n\tstd::sort(arr.begin(),\
    \ arr.end(), cmp);\n\treturn arr;", "  // your code here\n  vector<long> copy;\n\
    \  vector<pair<int,int>> temp;\n  vector<long> final;\n  int count;\n  for(int\
    \ i=0;i<arr.size();i++){\n    int temp = arr[i];\n    count = 0;\n    while(temp\
    \ != 0){\n      count++;\n      temp = temp & (temp-1);\n    }\n    copy.push_back(count);\n\
    \  }\n  for(int i=0;i<arr.size();i++){\n    temp.push_back(make_pair(copy[i],arr[i]));\n\
    \  }\n  sort(temp.begin(),temp.end());\n  for(int i=0;i<arr.size();i++){\n   \
    \ final.push_back(temp[i].second);\n  }\n  return final;", "    // Your code here!\n\
    \    long t1,t2;\n    for(int i=0;i<arr.size();i++){\n        for(int j=i+1;j<arr.size();j++){\n\
    \            t1=__builtin_popcount(arr[i]);\n            t2=__builtin_popcount(arr[j]);\n\
    \            if(t1>t2){\n                std::swap(arr[i],arr[j]);\n         \
    \   }\n            else if(t1==t2 && arr[i]>arr[j]){\n                std::swap(arr[i],arr[j]);\n\
    \            }\n        }\n    }\n    return arr;", "  struct Comparator {\n \
    \   int operator()(long num) {\n      int result = 0;\n      while (num > 0) {\n\
    \        if (num % 2 == 1) {\n          result++;\n        }\n        num /= 2;\n\
    \      }\n      return result;\n    }\n  };\n  std::vector<std::pair<int, long>>\
    \ data;\n  for (long num : arr) {\n    data.push_back(std::make_pair(Comparator()(num),\
    \ num));\n  }\n  std::sort(data.begin(), data.end());\n  std::vector<long> result;\n\
    \  for (const auto& i : data) {\n    result.push_back(i.second);\n  }\n  return\
    \ result;", "  std::map<int, std::vector<long>> onesCounts;\n  for (const auto&\
    \ num : arr) {\n    int count = std::bitset<32>(num).count();\n    onesCounts[count].push_back(num);\n\
    \  }\n  for (auto& p : onesCounts) {\n    std::sort(p.second.begin(), p.second.end());\n\
    \  }\n  std::vector<long> result;\n  for (const auto& p : onesCounts) {\n    result.insert(result.end(),\
    \ p.second.begin(), p.second.end());\n  }\n  return result;", "    std::unordered_map<long,long>\
    \ um;\n    int n = arr.size();\n    for(int i=0;i<n;i++){\n        um[arr[i]]++;\n\
    \    }\n    for(auto &it:um){\n        it.second = count(bitset<64>(it.first).begin(),bitset<64>(it.first).end(),1);\n\
    \    }\n    sort(arr.begin(),arr.end(),[&](const long &lhs,const long &rhs){\n\
    \        if(um[lhs] == um[rhs])\n            return lhs<rhs;\n        return um[lhs]<um[rhs];\n\
    \    });\n    return arr;", "  std::map<int, long> arr_map;\n  std::vector<long>\
    \ result;\n  for (auto &i : arr) {\n    int count = 0;\n    while (i) {\n    \
    \  if (i & 1) {\n        count++;\n      }\n      i >>= 1;\n    }\n    arr_map[count]\
    \ = i;\n  }\n  std::copy(arr_map.begin(), arr_map.end(), result.begin());\n  return\
    \ result;", "  // sort based on 1s, then sort based on decimal value\n  std::sort(arr.begin(),\
    \ arr.end(), [](long a, long b) {\n    std::bitset<sizeof(long) * 8> ba(a);\n\
    \    std::bitset<sizeof(long) * 8> bb(b);\n    return ba.count() == bb.count()\
    \ ? a < b : ba.count() < bb.count();\n  });\n  return arr;", "  std::vector<long>\
    \ result;\n  std::map<long, std::vector<long>> ones_freq;\n  for (auto const &a\
    \ : arr) {\n    long num = a;\n    long sum = 0;\n    while (num) {\n      sum\
    \ += num % 2;\n      num /= 2;\n    }\n    ones_freq[sum].push_back(a);\n  }\n\
    \  std::map<long, std::vector<long>>::iterator itr;\n  for (itr = ones_freq.begin();\
    \ itr != ones_freq.end(); ++itr) {\n    std::sort(itr->second.begin(), itr->second.end());\n\
    \    result.insert(result.end(), itr->second.begin(), itr->second.end());\n  }\n\
    \  return result;", "  vector<pair<int, int>> v;\n  vector<long> res;\n  for (auto\
    \ &i : arr) {\n    int cnt = 0;\n    while (i > 0) {\n      cnt += i & 1;\n  \
    \    i >>= 1;\n    }\n    v.push_back({cnt, i});\n  }\n  sort(v.begin(), v.end());\n\
    \  for (auto &i : v) {\n    res.push_back(i.second);\n  }\n  return res;", " \
    \ int n = arr.size();\n  int one[n];\n  int zero[n];\n  int mx = INT_MIN;\n  std::vector<long>\
    \ new_vector;\n  for (int i = 0; i < n; i++) {\n    int count = 0;\n    while\
    \ (arr[i] > 0) {\n      count++;\n      arr[i] /= 2;\n    }\n    one[i] = count;\n\
    \    zero[i] = count;\n    mx = std::max(mx, count);\n  }\n  for (int i = 0; i\
    \ < n; i++) {\n    arr[i] = arr[i] * std::pow(2, mx - one[i]);\n  }\n  for (int\
    \ i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (arr[i]\
    \ > arr[j]) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j]\
    \ = temp;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    arr[i] =\
    \ arr[i] / std::pow(2, mx - zero[i]);\n  }\n  return arr;", "    std::sort(arr.begin(),\
    \ arr.end(), [](long a, long b) {\n        int num_a_ones = std::bitset<64>(a).count();\n\
    \        int num_b_ones = std::bitset<64>(b).count();\n        if (num_a_ones\
    \ < num_b_ones) {\n            return true;\n        } else if (num_a_ones > num_b_ones)\
    \ {\n            return false;\n        } else {\n            return a < b;\n\
    \        }\n    });\n    return arr;", "    std::vector<long> v;\n    std::map<long,long>\
    \ mp;\n    std::vector<long> v1;\n    for(int i=0;i<arr.size();i++)\n    {\n \
    \       long cnt=0;\n        long temp=arr[i];\n        while(temp>0)\n      \
    \  {\n            if(temp%2==1)\n            {\n                cnt++;\n     \
    \       }\n            temp=temp/2;\n        }\n        mp[cnt]++;\n        v.push_back(cnt);\n\
    \    }\n    std::sort(v.begin(),v.end());\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        if(mp[v[i]]==1)\n        {\n            v1.push_back(arr[i]);\n\
    \        }\n        else\n        {\n            v1.push_back(arr[i]);\n     \
    \       mp[v[i]]--;\n        }\n    }\n    return v1;", "  // Your code here\n\
    \  int size = arr.size();\n  // std::vector<long> res(size);\n  int ones[size];\n\
    \  // int b[size];\n  // int c[size];\n  int i, j, temp;\n  int k;\n  int max\
    \ = INT_MIN;\n  // int max1 = INT_MIN;\n  int n;\n  for (i = 0; i < size; i++)\
    \ {\n    n = arr[i];\n    ones[i] = 0;\n    while (n > 0) {\n      ones[i] +=\
    \ n & 1;\n      n >>= 1;\n    }\n    if (max < ones[i]) {\n      max = ones[i];\n\
    \    }\n  }\n  for (i = 0; i < size; i++) {\n    for (j = i + 1; j < size; j++)\
    \ {\n      if (ones[i] > ones[j]) {\n        temp = ones[i];\n        ones[i]\
    \ = ones[j];\n        ones[j] = temp;\n        temp = arr[i];\n        arr[i]\
    \ = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  while (max > 0) {\n\
    \    // max1 = INT_MIN;\n    k = 0;\n    for (i = 0; i < size; i++) {\n      if\
    \ (ones[i] == max) {\n        k++;\n      }\n    }\n    for (i = 0; i < k; i++)\
    \ {\n      for (j = i + 1; j < k; j++) {\n        if (arr[i] > arr[j]) {\n   \
    \       temp = arr[i];\n          arr[i] = arr[j];\n          arr[j] = temp;\n\
    \        }\n      }\n    }\n    max--;\n  }\n  // for (i = 0; i < size; i++) {\n\
    \  //   std::cout << arr[i] << \" \";\n  // }\n  return arr;", "  // Write your\
    \ code here\n  // static bool cmp(long a, long b) {\n  //   int ones_count_a =\
    \ 0;\n  //   int ones_count_b = 0;\n  //   for (int i = 0; i < 32; i++) {\n  //\
    \     ones_count_a += (1 << i) & a;\n  //     ones_count_b += (1 << i) & b;\n\
    \  //   }\n  //   if (ones_count_a == ones_count_b) {\n  //     return a < b;\n\
    \  //   }\n  //   return ones_count_a < ones_count_b;\n  // }\n  // std::sort(arr.begin(),\
    \ arr.end(), cmp);\n  // return arr;\n  std::sort(arr.begin(), arr.end(), [](long\
    \ a, long b) {\n    int ones_count_a = 0;\n    int ones_count_b = 0;\n    for\
    \ (int i = 0; i < 32; i++) {\n      ones_count_a += (1 << i) & a;\n      ones_count_b\
    \ += (1 << i) & b;\n    }\n    if (ones_count_a == ones_count_b) {\n      return\
    \ a < b;\n    }\n    return ones_count_a < ones_count_b;\n  });\n  return arr;",
  "    if (arr.size() < 2) {\n        return arr;\n    }\n    sort(arr.begin(), arr.end(),\n\
    \         [](long a, long b) {\n             return std::bitset<64>(a).count()\
    \ < std::bitset<64>(b).count();\n         });\n    return arr;", "    std::vector<long>\
    \ res;\n    std::map<int, long> count;\n    for (auto &&it : arr) {\n        count[std::bitset<64>(it).count()]\
    \ = it;\n    }\n    for (auto &&it : count) {\n        res.push_back(it.second);\n\
    \    }\n    return res;", "    int n = arr.size();\n    std::map<long,int>mp;\n\
    \    std::map<int,int>mp2;\n    std::vector<long>ans;\n    for(int i=0;i<n;i++){\n\
    \        int val = arr[i];\n        int cnt = __builtin_popcount(val);\n     \
    \   mp[val] = cnt;\n        mp2[cnt]++;\n    }\n    std::map<int,int>::iterator\
    \ it = mp2.begin();\n    while(it!=mp2.end()){\n        long cnt = it->first;\n\
    \        std::map<long,int>::iterator it2 = mp.begin();\n        while(it2!=mp.end()){\n\
    \            if(it2->second == cnt){\n                ans.push_back(it2->first);\n\
    \                mp.erase(it2);\n            }\n            it2++;\n        }\n\
    \        it++;\n    }\n    return ans;", "  std::vector<std::pair<int, long>>\
    \ a;\n  for (int i = 0; i < arr.size(); i++) {\n    int ones = 0;\n    int num\
    \ = arr[i];\n    while (num) {\n      ones += num & 1;\n      num >>= 1;\n   \
    \ }\n    a.push_back(std::make_pair(ones, arr[i]));\n  }\n  std::sort(a.begin(),\
    \ a.end());\n  for (int i = 0; i < arr.size(); i++) {\n    arr[i] = a[i].second;\n\
    \  }\n  return arr;", "    std::sort(arr.begin(), arr.end(), [](long i, long j)\
    \ {\n        int ones_i = __builtin_popcount(i);\n        int ones_j = __builtin_popcount(j);\n\
    \        if (ones_i == ones_j) {\n            return i < j;\n        }\n     \
    \   return ones_i < ones_j;\n    });\n    return arr;", "    vector<int> bitCount(arr.size());\n\
    \    vector<int> tmp(arr.size());\n    for(int i = 0; i < arr.size(); i++) {\n\
    \        int num = arr[i];\n        int count = 0;\n        while(num) {\n   \
    \         count += num&1;\n            num >>= 1;\n        }\n        bitCount[i]\
    \ = count;\n        tmp[i] = arr[i];\n    }\n    sort(tmp.begin(), tmp.end());\n\
    \    vector<int> res(arr.size());\n    for(int i = 0; i < arr.size(); i++) {\n\
    \        int num = tmp[i];\n        int count = 0;\n        while(num) {\n   \
    \         count += num&1;\n            num >>= 1;\n        }\n        if(count\
    \ != bitCount[i]) {\n            res[i] = arr[i];\n        } else {\n        \
    \    res[i] = tmp[i];\n        }\n    }\n    return res;", "  // . . .\n  std::sort(arr.begin(),\
    \ arr.end(), [](const int lhs, const int rhs) {\n    return lhs == rhs ? lhs <\
    \ rhs : std::bitset<8>(lhs).count() < std::bitset<8>(rhs).count();\n  });\n  return\
    \ arr;", "    std::sort(arr.begin(), arr.end(), [](int& a, int& b) {\n       \
    \ int i = __builtin_popcount(a);\n        int j = __builtin_popcount(b);\n   \
    \     if (i == j) {\n            return a < b;\n        }\n        return i <\
    \ j;\n    });\n    return arr;", "    std::vector<long> sorted;\n    std::vector<long>\
    \ sorted2;\n    std::vector<long> s;\n    int count1 = 0;\n    int count2 = 0;\n\
    \    int count3 = 0;\n    int count4 = 0;\n    int count5 = 0;\n    for (int i\
    \ = 0; i < arr.size(); i++) {\n        long a = arr[i];\n        int b = 0;\n\
    \        while (a) {\n            b += a & 1;\n            a >>= 1;\n        }\n\
    \        if (b == 1) {\n            sorted.push_back(arr[i]);\n            count1++;\n\
    \        }\n        if (b == 2) {\n            sorted2.push_back(arr[i]);\n  \
    \          count2++;\n        }\n        if (b == 3) {\n            count3++;\n\
    \        }\n        if (b == 4) {\n            count4++;\n        }\n        if\
    \ (b == 5) {\n            count5++;\n        }\n    }\n    // std::cout << \"\
    count1 = \" << count1 << std::endl;\n    // std::cout << \"count2 = \" << count2\
    \ << std::endl;\n    // std::cout << \"count3 = \" << count3 << std::endl;\n \
    \   // std::cout << \"count4 = \" << count4 << std::endl;\n    // std::cout <<\
    \ \"count5 = \" << count5 << std::endl;\n    std::sort(sorted.begin(), sorted.end());\n\
    \    for (int i = 0; i < sorted.size(); i++) {\n        s.push_back(sorted[i]);\n\
    \    }\n    std::sort(sorted2.begin(), sorted2.end());\n    for (int i = 0; i\
    \ < sorted2.size(); i++) {\n        s.push_back(sorted2[i]);\n    }\n    for (int\
    \ i = 0; i < count3; i++) {\n        s.push_back(3);\n    }\n    for (int i =\
    \ 0; i < count4; i++) {\n        s.push_back(4);", "    std::sort(arr.begin(),\
    \ arr.end(), [](long lhs, long rhs) {\n        long lhs_ones = __builtin_popcount(lhs);\n\
    \        long rhs_ones = __builtin_popcount(rhs);\n        if (lhs_ones == rhs_ones)\n\
    \            return lhs < rhs;\n        return lhs_ones < rhs_ones;\n    });\n\
    \    return arr;", "    std::vector<long> tmp;\n    for (auto it : arr) {\n  \
    \      tmp.push_back(it);\n    }\n    std::sort(tmp.begin(), tmp.end(), [](int\
    \ a, int b) {\n        return __builtin_popcount(a) == __builtin_popcount(b) ?\
    \ a < b : __builtin_popcount(a) < __builtin_popcount(b);\n    });\n    return\
    \ tmp;", "  std::vector<long> result;\n  std::map<int,std::vector<long>> m;\n\
    \  for(auto i:arr){\n    if(i<0) continue;\n    int count = 0;\n    int num =\
    \ i;\n    while(num!=0){\n      if(num%2==1) count++;\n      num/=2;\n    }\n\
    \    m[count].push_back(i);\n  }\n  for(auto it = m.begin();it!=m.end();it++){\n\
    \    auto current = it->second;\n    std::sort(current.begin(),current.end());\n\
    \    result.insert(result.end(),current.begin(),current.end());\n  }\n  return\
    \ result;", "  std::map<int, std::vector<long>> one_count;\n  std::vector<long>\
    \ result;\n  for (long a : arr) {\n    int one_count = 0;\n    while (a) {\n \
    \     one_count += a & 1;\n      a >>= 1;\n    }\n    one_count[one_count].push_back(a);\n\
    \  }\n  for (auto a : one_count) {\n    std::sort(a.second.begin(), a.second.end());\n\
    \    result.insert(result.end(), a.second.begin(), a.second.end());\n  }\n  return\
    \ result;", "    // your code here\n    std::vector<std::pair<long,int>> bin(arr.size());\n\
    \    for(int i=0;i<arr.size();i++){\n        bin[i]={arr[i],__builtin_popcount(arr[i])};\n\
    \    }\n    sort(bin.begin(),bin.end(),[](auto &a,auto &b){\n        if(a.second\
    \ == b.second){\n            return a.first < b.first;\n        }\n        return\
    \ a.second < b.second;\n    });\n    for(int i=0;i<arr.size();i++){\n        arr[i]=bin[i].first;\n\
    \    }\n    return arr;", "  if (arr.size() == 0) return arr;\n  std::map<int,\
    \ std::vector<long>> order;\n  std::vector<long> result;\n  for (auto n : arr)\
    \ {\n    int one_count = 0;\n    while (n) {\n      if (n % 2 == 1) {\n      \
    \  one_count++;\n      }\n      n = n / 2;\n    }\n    order[one_count].push_back(n);\n\
    \  }\n  for (auto it = order.begin(); it != order.end(); it++) {\n    for (auto\
    \ n : it->second) {\n      result.push_back(n);\n    }\n  }\n  return result;",
  "    std::sort(arr.begin(), arr.end(), [](long lhs, long rhs) {\n        long ones_lhs\
    \ = std::bitset<32>(lhs).count();\n        long ones_rhs = std::bitset<32>(rhs).count();\n\
    \        if (ones_lhs == ones_rhs) {\n            return lhs < rhs;\n        }\n\
    \        return ones_lhs < ones_rhs;\n    });\n    return arr;", "    // std::sort(arr.begin(),\
    \ arr.end(), [](const int& a, const int& b) {\n    //   return a > b;\n    //\
    \ });\n    // return arr;\n    std::sort(arr.begin(), arr.end(), [](const int&\
    \ a, const int& b) {\n        int cntA = 0, cntB = 0;\n        while (a != 0)\
    \ {\n            cntA += a % 2;\n            a /= 2;\n        }\n        while\
    \ (b != 0) {\n            cntB += b % 2;\n            b /= 2;\n        }\n   \
    \     return cntA < cntB;\n    });\n    return arr;", "  vector<int> v;\n  for(auto\
    \ i:arr)\n  {\n    int c = __builtin_popcount(i);\n    v.push_back(c);\n  }\n\
    \  sort(v.begin(),v.end());\n  map<int,long> m;\n  for(int i=0;i<v.size();i++)\n\
    \  {\n    m[v[i]]=arr[i];\n  }\n  arr.clear();\n  for(auto it:m)\n  {\n    arr.push_back(it.second);\n\
    \  }\n  return arr;", "  unsigned int i, j;\n  std::vector<long> r;\n  std::vector<std::pair<long,int>>\
    \ v;\n  std::vector<long> ret;\n  for(i = 0; i < arr.size(); i++) {\n    if(arr[i]\
    \ >= 0)\n      v.push_back(std::make_pair(arr[i], __builtin_popcount(arr[i])));\n\
    \    else\n      r.push_back(arr[i]);\n  }\n  std::sort(v.begin(), v.end(), [](std::pair<long,int>\
    \ a, std::pair<long,int> b) {\n    if(a.second == b.second)\n      return a.first\
    \ < b.first;\n    return a.second < b.second;\n  });\n  for(i = 0; i < v.size();\
    \ i++)\n    ret.push_back(v[i].first);\n  for(i = 0; i < r.size(); i++)\n    ret.push_back(r[i]);\n\
    \  return ret;", "  // sort based on number of ones\n  std::sort(arr.begin(),\
    \ arr.end(), [](const long& lhs, const long& rhs) {\n    return std::bitset<32>(lhs).count()\
    \ < std::bitset<32>(rhs).count();\n  });\n  // sort based on decimal value if\
    \ same number of ones\n  int startIndex = 0;\n  while (startIndex < arr.size())\
    \ {\n    int endIndex = startIndex + 1;\n    while (endIndex < arr.size() &&\n\
    \           std::bitset<32>(arr[startIndex]).count() ==\n               std::bitset<32>(arr[endIndex]).count())\
    \ {\n      endIndex++;\n    }\n    std::sort(arr.begin() + startIndex, arr.begin()\
    \ + endIndex);\n    startIndex = endIndex;\n  }\n  return arr;", "  std::vector<long>\
    \ ones;\n  std::vector<long> zero;\n  for (int i = 0; i < arr.size(); i++) {\n\
    \    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    std::string s = std::bitset<32>(arr[i]).to_string();\n\
    \    int count = 0;\n    for (int j = 0; j < s.size(); j++) {\n      if (s[j]\
    \ == '1') {\n        count++;\n      }\n    }\n    if (count > 0) {\n      ones.push_back(arr[i]);\n\
    \    } else {\n      zero.push_back(arr[i]);\n    }\n  }\n  std::sort(ones.begin(),\
    \ ones.end());\n  std::sort(zero.begin(), zero.end());\n  int index = 0;\n  for\
    \ (int i = 0; i < zero.size(); i++) {\n    arr[index] = zero[i];\n    index++;\n\
    \  }\n  for (int i = 0; i < ones.size(); i++) {\n    arr[index] = ones[i];\n \
    \   index++;\n  }\n  return arr;", "  std::vector<std::pair<long, int>> temp;\n\
    \  std::vector<long> res;\n  for (int i = 0; i < arr.size(); i++) {\n    int sum\
    \ = 0;\n    int n = arr[i];\n    while (n > 0) {\n      sum += n % 2;\n      n\
    \ /= 2;\n    }\n    temp.push_back(std::make_pair(arr[i], sum));\n  }\n  std::sort(temp.begin(),\
    \ temp.end(), [](std::pair<long, int> a, std::pair<long, int> b) {\n    if (a.second\
    \ == b.second) {\n      return a.first < b.first;\n    }\n    return a.second\
    \ < b.second;\n  });\n  for (int i = 0; i < temp.size(); i++) {\n    res.push_back(temp[i].first);\n\
    \  }\n  return res;", "  std::vector<long> res;\n  for (size_t i = 0; i < arr.size();\
    \ i++) {\n    std::bitset<64> x(arr[i]);\n    res.push_back(x.count());\n  }\n\
    \  for (size_t i = 0; i < arr.size(); i++) {\n    for (size_t j = i+1; j < arr.size();\
    \ j++) {\n      if (res[i] > res[j]) {\n        int temp = res[i];\n        res[i]\
    \ = res[j];\n        res[j] = temp;\n        temp = arr[i];\n        arr[i] =\
    \ arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  return arr;", "  std::sort(arr.begin(),\
    \ arr.end(),\n  [](const long& lhs, const long& rhs) {\n    return std::bitset<32>(lhs).count()\
    \ < std::bitset<32>(rhs).count();\n  });\n  return arr;", "    vector<long> dec,\
    \ bin;\n    for (long i = 0; i < arr.size(); i++) {\n        dec.push_back(arr[i]);\n\
    \        bin.push_back(__builtin_popcount(arr[i]));\n    }\n    for (long i =\
    \ 0; i < arr.size(); i++) {\n        for (long j = i; j < arr.size(); j++) {\n\
    \            if (bin[i] > bin[j]) {\n                bin[i] ^= bin[j];\n     \
    \           bin[j] ^= bin[i];\n                bin[i] ^= bin[j];\n           \
    \     dec[i] ^= dec[j];\n                dec[j] ^= dec[i];\n                dec[i]\
    \ ^= dec[j];\n            }\n            else if (bin[i] == bin[j]) {\n      \
    \          if (dec[i] > dec[j]) {\n                    bin[i] ^= bin[j];\n   \
    \                 bin[j] ^= bin[i];\n                    bin[i] ^= bin[j];\n \
    \                   dec[i] ^= dec[j];\n                    dec[j] ^= dec[i];\n\
    \                    dec[i] ^= dec[j];\n                }\n            }\n   \
    \     }\n    }\n    return dec;", "  std::vector<std::pair<int, int>> ones_and_nums;\n\
    \  for (long num : arr) {\n    int ones = 0;\n    for (int j = 0; j < 32; j++)\
    \ {\n      if (num & (1 << j)) {\n        ones++;\n      }\n    }\n    ones_and_nums.push_back(std::make_pair(ones,\
    \ num));\n  }\n  std::sort(ones_and_nums.begin(), ones_and_nums.end());\n  std::vector<long>\
    \ result;\n  for (std::pair<int, int> p : ones_and_nums) {\n    result.push_back(p.second);\n\
    \  }\n  return result;", "  int ones = 0;\n  int size = arr.size();\n  int sorted\
    \ = 0;\n  int i, j;\n  std::vector<long> arr2(size);\n  while (sorted < size)\
    \ {\n    for (i = 0; i < size; i++) {\n      ones = 0;\n      int n = arr[i];\n\
    \      while (n) {\n        ones += n & 1;\n        n >>= 1;\n      }\n      if\
    \ (ones > sorted) {\n        break;\n      }\n    }\n    for (j = i; j < size;\
    \ j++) {\n      ones = 0;\n      int n = arr[j];\n      while (n) {\n        ones\
    \ += n & 1;\n        n >>= 1;\n      }\n      if (ones != sorted) {\n        break;\n\
    \      }\n    }\n    for (i; i < j; i++) {\n      for (int k = i; k < j; k++)\
    \ {\n        if (arr[i] > arr[k]) {\n          int temp = arr[i];\n          arr[i]\
    \ = arr[k];\n          arr[k] = temp;\n        }\n      }\n    }\n    sorted++;\n\
    \  }\n  return arr;", "    std::vector<long> result;\n    std::unordered_map<long,\
    \ long> ones;\n    for (long i = 0; i < arr.size(); i++) {\n        long ones_count\
    \ = 0;\n        long num = arr[i];\n        while (num) {\n            if (num\
    \ & 1) {\n                ones_count++;\n            }\n            num >>= 1;\n\
    \        }\n        ones[arr[i]] = ones_count;\n    }\n    sort(arr.begin(), arr.end(),\
    \ [&](long n1, long n2) {\n        long ones_n1 = ones[n1];\n        long ones_n2\
    \ = ones[n2];\n        if (ones_n1 < ones_n2) {\n            return true;\n  \
    \      } else if (ones_n1 > ones_n2) {\n            return false;\n        } else\
    \ {\n            return n1 < n2;\n        }\n    });\n    return arr;", "  for\
    \ (int i = 0; i < arr.size(); i++) {\n    for (int j = i + 1; j < arr.size();\
    \ j++) {\n      if (bit(arr[i]) > bit(arr[j])) {\n        long temp = arr[i];\n\
    \        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  return\
    \ arr;", "  std::sort(arr.begin(), arr.end(), [&](long x, long y) {\n    int xc\
    \ = std::bitset<32>(x).count();\n    int yc = std::bitset<32>(y).count();\n  \
    \  return xc < yc || (xc == yc && x < y);\n  });\n  return arr;", "    std::vector<std::pair<long,\
    \ long>> tmp;\n    for (auto i : arr) {\n        long n(i), bit_count(0);\n  \
    \      while (n) {\n            bit_count += n & 1;\n            n >>= 1;\n  \
    \      }\n        tmp.push_back(std::make_pair(bit_count, i));\n    }\n    std::sort(tmp.begin(),\
    \ tmp.end());\n    std::vector<long> ans;\n    for (auto i : tmp) {\n        ans.push_back(i.second);\n\
    \    }\n    return ans;", "  int max_ones = 0;\n  for (long a : arr) {\n    int\
    \ ones = 0;\n    while (a > 0) {\n      if (a % 2 == 1) {\n        ones++;\n \
    \     }\n      a /= 2;\n    }\n    max_ones = std::max(max_ones, ones);\n  }\n\
    \  std::vector<std::vector<long>> buckets(max_ones + 1);\n  for (long a : arr)\
    \ {\n    int ones = 0;\n    while (a > 0) {\n      if (a % 2 == 1) {\n       \
    \ ones++;\n      }\n      a /= 2;\n    }\n    buckets[ones].push_back(a);\n  }\n\
    \  arr.clear();\n  for (int i = 0; i < buckets.size(); i++) {\n    std::sort(buckets[i].begin(),\
    \ buckets[i].end());\n    for (long l : buckets[i]) {\n      arr.push_back(l);\n\
    \    }\n  }\n  return arr;", "  std::vector<std::pair<int, int>> arr_ones;\n \
    \ for (int i = 0; i < arr.size(); i++) {\n    int j = arr[i];\n    int ones =\
    \ 0;\n    while (j > 0) {\n      if (j & 1) {\n        ones++;\n      }\n    \
    \  j >>= 1;\n    }\n    arr_ones.push_back(std::make_pair(ones, arr[i]));\n  }\n\
    \  std::sort(arr_ones.begin(), arr_ones.end());\n  std::vector<long> out;\n  for\
    \ (int i = 0; i < arr_ones.size(); i++) {\n    out.push_back(arr_ones[i].second);\n\
    \  }\n  return out;", "    std::sort(arr.begin(), arr.end(), [](long a, long b)\
    \ {\n        return std::bitset<32>(a).count() < std::bitset<32>(b).count();\n\
    \    });\n    return arr;", "  // Your code here\n  std::map<int, std::vector<long>>\
    \ map;\n  for (const auto &x : arr) {\n    int count = 0;\n    for (long i = x;\
    \ i > 0; i >>= 1) {\n      if (i & 1) {\n        count++;\n      }\n    }\n  \
    \  map[count].push_back(x);\n  }\n  arr.clear();\n  for (const auto &[k, v] :\
    \ map) {\n    std::sort(v.begin(), v.end());\n    arr.insert(arr.end(), v.begin(),\
    \ v.end());\n  }\n  return arr;", "    for (int i = 0; i < arr.size(); i++) {\n\
    \        for (int j = i + 1; j < arr.size(); j++) {\n            std::bitset<64>\
    \ x(arr[i]);\n            std::bitset<64> y(arr[j]);\n            if (x.count()\
    \ > y.count()) {\n                int temp = arr[i];\n                arr[i] =\
    \ arr[j];\n                arr[j] = temp;\n            } else if (x.count() ==\
    \ y.count()) {\n                if (arr[i] > arr[j]) {\n                    int\
    \ temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j]\
    \ = temp;\n                }\n            }\n        }\n    }\n    return arr;",
  "  std::vector<long> *result = new std::vector<long>();\n  std::map<int, std::vector<long>\
    \ > m;\n  for (int i = 0; i < arr.size(); i++) {\n    int one_count = 0;\n   \
    \ long current = arr[i];\n    while (current > 0) {\n      one_count += (current\
    \ % 2);\n      current /= 2;\n    }\n    m[one_count].push_back(arr[i]);\n  }\n\
    \  for (std::map<int, std::vector<long> >::iterator it = m.begin(); it != m.end();\
    \ it++) {\n    std::sort(it->second.begin(), it->second.end());\n    for (int\
    \ i = 0; i < it->second.size(); i++) {\n      result->push_back(it->second[i]);\n\
    \    }\n  }\n  return *result;", "  std::map<int, long> count;\n  for (auto i\
    \ : arr) {\n    std::bitset<32> b(i);\n    count[b.count()] = i;\n  }\n  std::vector<long>\
    \ ret;\n  for (auto i : count) {\n    ret.push_back(i.second);\n  }\n  return\
    \ ret;", "  if (arr.size() < 2) {\n    return arr;\n  }\n  std::vector<std::pair<long,\
    \ std::bitset<64>>> dec2binary;\n  // -- convert decimal to binary\n  for (auto\
    \ dec : arr) {\n    dec2binary.push_back(std::make_pair(dec, std::bitset<64>(dec)));\n\
    \  }\n  // -- sort\n  std::sort(dec2binary.begin(), dec2binary.end(), [](auto&\
    \ d1, auto& d2) {\n    size_t c1 = d1.second.count();\n    size_t c2 = d2.second.count();\n\
    \    return c1 != c2 ? c1 < c2 : d1.first < d2.first;\n  });\n  // -- convert\
    \ back to decimal\n  std::vector<long> res;\n  for (auto pair : dec2binary) {\n\
    \    res.push_back(pair.first);\n  }\n  return res;", "  std::sort(arr.begin(),\
    \ arr.end(),\n      [](long a, long b) {\n        unsigned int x = (unsigned int)\
    \ a;\n        unsigned int y = (unsigned int) b;\n        int x_ones = 0;\n  \
    \      int y_ones = 0;\n        while (x > 0) {\n          x_ones += x % 2;\n\
    \          x = x / 2;\n        }\n        while (y > 0) {\n          y_ones +=\
    \ y % 2;\n          y = y / 2;\n        }\n        if (x_ones == y_ones) {\n \
    \         return a < b;\n        }\n        return x_ones < y_ones;\n      });\n\
    \  return arr;", "    int n = arr.size();\n    std::sort(arr.begin(), arr.end(),\
    \ [](long a, long b) -> bool {\n        if (__builtin_popcount(a) == __builtin_popcount(b))\n\
    \            return a < b;\n        return __builtin_popcount(a) < __builtin_popcount(b);\n\
    \    });\n    return arr;", "  if (arr.size() == 0) return arr;\n  sort(arr.begin(),\
    \ arr.end(), [](const long & a, const long & b) -> bool {\n    return (std::bitset<64>(a).count()\
    \ != std::bitset<64>(b).count()) ?\n      std::bitset<64>(a).count() < std::bitset<64>(b).count()\
    \ : a < b;\n  });\n  return arr;", "    std::vector<std::pair<int, int>> sort_list;\n\
    \    std::vector<long> result;\n    for (auto item : arr) {\n        int ones\
    \ = 0;\n        int temp = item;\n        while (temp > 0) {\n            ones\
    \ += temp % 2;\n            temp /= 2;\n        }\n        sort_list.push_back(std::make_pair(ones,\
    \ item));\n    }\n    std::sort(sort_list.begin(), sort_list.end());\n    for\
    \ (auto item : sort_list) {\n        result.push_back(item.second);\n    }\n \
    \   return result;", "    for (int i = 0; i < arr.size(); i++) {\n        for\
    \ (int j = i + 1; j < arr.size(); j++) {\n            long countBitsI = std::__pop_count(arr[i]);\n\
    \            long countBitsJ = std::__pop_count(arr[j]);\n            if (countBitsI\
    \ > countBitsJ) {\n                std::swap(arr[i], arr[j]);\n            } else\
    \ if (countBitsI == countBitsJ) {\n                if (arr[i] > arr[j]) {\n  \
    \                  std::swap(arr[i], arr[j]);\n                }\n           \
    \ }\n        }\n    }\n    return arr;", "    // TODO\n    //your code here\n\
    \    std::vector<long> new_arr;\n    int count;\n    std::vector<int> num1_vector;\n\
    \    for(int i = 0; i < arr.size(); i++){\n        count = 0;\n        while(arr[i]\
    \ != 0){\n            if((arr[i] & 1) == 1){\n                count++;\n     \
    \       }\n            arr[i] >>= 1;\n        }\n        num1_vector.push_back(count);\n\
    \    }\n    std::vector<long> temp = arr;\n    sort(temp.begin(), temp.end());\n\
    \    int val;\n    int p;\n    while(arr.size() != 0){\n        val = *max_element(num1_vector.begin(),\
    \ num1_vector.end());\n        for(int i = 0; i < arr.size(); i++){\n        \
    \    if(num1_vector[i] == val){\n                p = i;\n                break;\n\
    \            }\n        }\n        new_arr.push_back(arr[p]);\n        arr.erase(arr.begin()\
    \ + p);\n        num1_vector.erase(num1_vector.begin() + p);\n    }\n    return\
    \ new_arr;", "  std::unordered_map<long, std::vector<long>> my_map;\n  for (auto\
    \ i : arr) {\n    long ones = 0;\n    for (auto j = i; j > 0; j /= 2) {\n    \
    \  if (j % 2 == 1) {\n        ones++;\n      }\n    }\n    my_map[ones].push_back(i);\n\
    \  }\n  std::vector<long> ans;\n  for (auto it = my_map.begin(); it != my_map.end();\
    \ it++) {\n    std::sort(it->second.begin(), it->second.end());\n    for (auto\
    \ j : it->second) {\n      ans.push_back(j);\n    }\n  }\n  return ans;", "  \
    \  std::vector<long> res = arr;\n    std::sort(res.begin(), res.end(), [](long\
    \ a, long b) {\n        int countA = 0, countB = 0;\n        int x = a, y = b;\n\
    \        while (x > 0) {\n            countA += x % 2;\n            x /= 2;\n\
    \        }\n        while (y > 0) {\n            countB += y % 2;\n          \
    \  y /= 2;\n        }\n        if (countA == countB) {\n            return a <\
    \ b;\n        }\n        return countA < countB;\n    });\n    return res;", " \
    \ std::vector<long> bin;\n  long count;\n  for (long i = 0; i < arr.size(); i++)\
    \ {\n    count = 0;\n    while (arr[i] != 0) {\n      if (arr[i] % 2 == 1) {\n\
    \        count++;\n      }\n      arr[i] /= 2;\n    }\n    bin.push_back(count);\n\
    \  }\n  for (long i = 0; i < arr.size(); i++) {\n    for (long j = i + 1; j <\
    \ arr.size(); j++) {\n      if (bin[i] > bin[j]) {\n        long temp = bin[i];\n\
    \        bin[i] = bin[j];\n        bin[j] = temp;\n        temp = arr[i];\n  \
    \      arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  return\
    \ arr;", "  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int bitsA\
    \ = 0;\n    int bitsB = 0;\n    while (a != 0) {\n      bitsA += a & 1;\n    \
    \  a >>= 1;\n    }\n    while (b != 0) {\n      bitsB += b & 1;\n      b >>= 1;\n\
    \    }\n    if (bitsA == bitsB)\n      return a < b;\n    return bitsA < bitsB;\n\
    \  });\n  return arr;", "  std::vector<long> sorted_arr(arr.size());\n  std::vector<std::pair<long,\
    \ int>> num_ones;\n  for (auto n : arr) {\n    long n_copy = n;\n    int ones\
    \ = 0;\n    while (n_copy) {\n      ones += n_copy & 1;\n      n_copy >>= 1;\n\
    \    }\n    num_ones.push_back(std::make_pair(n, ones));\n  }\n  std::sort(num_ones.begin(),\
    \ num_ones.end(),\n            [](const std::pair<long, int>& lhs, const std::pair<long,\
    \ int>& rhs) {\n              if (lhs.second == rhs.second) {\n              \
    \  return lhs.first < rhs.first;\n              }\n              return lhs.second\
    \ < rhs.second;\n            });\n  for (int i = 0; i < arr.size(); ++i) {\n \
    \   sorted_arr[i] = num_ones[i].first;\n  }\n  return sorted_arr;", "    long\
    \ temp_count_bin, temp_count_dec;\n    bool done=false;\n    while(!done){\n \
    \       done=true;\n        for(int i=0; i<arr.size()-1; i++){\n            temp_count_bin=0;\n\
    \            temp_count_dec=0;\n            if(arr[i]>0){\n                temp_count_dec=arr[i];\n\
    \                while(temp_count_dec>0){\n                    temp_count_bin+=(temp_count_dec%2);\n\
    \                    temp_count_dec/=2;\n                }\n            }\n  \
    \          else{\n                temp_count_dec=-arr[i];\n                while(temp_count_dec>0){\n\
    \                    temp_count_bin+=(temp_count_dec%2);\n                   \
    \ temp_count_dec/=2;\n                }\n            }\n            long temp_count_bin2=0;\n\
    \            long temp_count_dec2=0;\n            if(arr[i+1]>0){\n          \
    \      temp_count_dec2=arr[i+1];\n                while(temp_count_dec2>0){\n\
    \                    temp_count_bin2+=(temp_count_dec2%2);\n                 \
    \   temp_count_dec2/=2;\n                }\n            }\n            else{\n\
    \                temp_count_dec2=-arr[i+1];\n                while(temp_count_dec2>0){\n\
    \                    temp_count_bin2+=(temp_count_dec2%2);\n                 \
    \   temp_count_dec2/=2;\n                }\n            }\n            if(temp_count_bin>temp_count_bin2){\n\
    \                done=false;\n                temp_count_dec=arr[i];\n       \
    \         arr[i]=arr[i+1];\n                arr[i+1]=temp_count_dec;\n       \
    \     }\n            else if(temp_count_bin==temp_count_bin2){\n             \
    \   if(arr[i]>arr[i+1]){\n                    done=false;\n                  \
    \  temp_count_dec=arr[i];\n                    arr[i]=arr[i+1];\n            \
    \        arr[i+", "    struct num {\n        int n;\n        int ones;\n    };\n\
    \    std::vector<num> nums;\n    for (int i = 0; i < arr.size(); i++) {\n    \
    \    nums.push_back({arr[i], __builtin_popcount(arr[i])});\n    }\n    std::sort(nums.begin(),\
    \ nums.end(), [](num a, num b) {\n        if (a.ones != b.ones) {\n          \
    \  return a.ones < b.ones;\n        } else {\n            return a.n < b.n;\n\
    \        }\n    });\n    std::vector<long> result;\n    for (int i = 0; i < nums.size();\
    \ i++) {\n        result.push_back(nums[i].n);\n    }\n    return result;", " \
    \ // sort(arr.begin(), arr.end(), [](long &a, long &b) {\n  //   // return countOnes(a)\
    \ == countOnes(b) ? a < b : countOnes(a) < countOnes(b);\n  //   return a < b;\n\
    \  // });\n  // return arr;\n  if (arr.size() < 2) {\n    return arr;\n  }\n \
    \ std::vector<long> left;\n  std::vector<long> right;\n  int mid = arr.size()\
    \ / 2;\n  for (int i = 0; i < mid; i++) {\n    left.push_back(arr[i]);\n  }\n\
    \  for (int i = mid; i < arr.size(); i++) {\n    right.push_back(arr[i]);\n  }\n\
    \  left = sort_array(left);\n  right = sort_array(right);\n  return merge(left,\
    \ right);", "  std::sort(arr.begin(), arr.end(),\n            [](long left, long\
    \ right) {\n              int leftBits = std::bitset<32>(left).count();\n    \
    \          int rightBits = std::bitset<32>(right).count();\n              if (leftBits\
    \ == rightBits) {\n                return left < right;\n              }\n   \
    \           return leftBits < rightBits;\n            });\n  return arr;", " \
    \   std::map<int, std::vector<long>> mymap;\n    int n = arr.size();\n    for\
    \ (auto i : arr) {\n        int cnt = 0;\n        while (i > 0) {\n          \
    \  cnt += i % 2;\n            i /= 2;\n        }\n        mymap[cnt].push_back(i);\n\
    \    }\n    for (auto x : mymap) {\n        for (auto y : x.second) {\n      \
    \      std::cout << y << \" \";\n        }\n        std::cout << std::endl;\n\
    \    }\n    return arr;", "  // Implement me\n  long size = arr.size();\n  for(long\
    \ i = 0; i < size; i++) {\n    long binaryOnes = 0;\n    long decimal = arr[i];\n\
    \    while(decimal) {\n      binaryOnes += decimal % 2;\n      decimal /= 2;\n\
    \    }\n    arr[i] = (binaryOnes << 32) | arr[i];\n  }\n  std::sort(arr.begin(),\
    \ arr.end());\n  for(long i = 0; i < size; i++) {\n    arr[i] = arr[i] & 0x00000000FFFFFFFF;\n\
    \  }\n  return arr;", "  std::map<int, std::vector<long>> ones;\n  for (auto&\
    \ num : arr) {\n    auto cnt = std::bitset<sizeof(num) * 8>(num).count();\n  \
    \  if (ones.find(cnt) == ones.end()) {\n      ones[cnt] = std::vector<long>{num};\n\
    \    } else {\n      ones[cnt].push_back(num);\n    }\n  }\n  for (auto& kv :\
    \ ones) {\n    std::sort(kv.second.begin(), kv.second.end());\n  }\n  arr.clear();\n\
    \  for (auto& kv : ones) {\n    for (auto& v : kv.second) {\n      arr.push_back(v);\n\
    \    }\n  }\n  return arr;", "    std::vector<long> sorted_arr;\n    std::vector<long>\
    \ ones_count;\n    for (auto num : arr) {\n        int count = 0;\n        while\
    \ (num) {\n            if (num % 2)\n                count++;\n            num\
    \ /= 2;\n        }\n        ones_count.push_back(count);\n    }\n    std::sort(ones_count.begin(),\
    \ ones_count.end());\n    std::map<long, long> arr_map;\n    std::map<long, long>\
    \ ones_count_map;\n    for (size_t i = 0; i < arr.size(); i++) {\n        arr_map[arr[i]]\
    \ = ones_count[i];\n        ones_count_map[ones_count[i]] = arr[i];\n    }\n \
    \   auto it = arr_map.begin();\n    for (size_t i = 0; i < arr.size(); i++) {\n\
    \        sorted_arr.push_back(it->first);\n        ++it;\n    }\n    return sorted_arr;",
  "  std::vector<long> sorted_vec;\n  std::map<int, std::vector<long>> ones_to_value;\n\
    \  for (auto a : arr) {\n    int count = 0;\n    int num = a;\n    while (num)\
    \ {\n      if (num & 1) {\n        count++;\n      }\n      num = num >> 1;\n\
    \    }\n    if (ones_to_value.find(count) == ones_to_value.end()) {\n      ones_to_value[count]\
    \ = std::vector<long>();\n    }\n    ones_to_value[count].push_back(a);\n  }\n\
    \  for (auto it = ones_to_value.begin(); it != ones_to_value.end(); it++) {\n\
    \    std::sort(it->second.begin(), it->second.end());\n    sorted_vec.insert(sorted_vec.end(),\
    \ it->second.begin(), it->second.end());\n  }\n  return sorted_vec;", "    std::vector<long>\
    \ re;\n    int count;\n    while(arr.size()>0){\n        int min = pow(2,30);\n\
    \        int min_count = pow(2,30);\n        for(int i=0;i<arr.size();i++){\n\
    \            count = 0;\n            int x = arr[i];\n            while(x>0){\n\
    \                count++;\n                x = x & (x-1);\n            }\n   \
    \         if(count<min_count){\n                min_count = count;\n         \
    \       min = arr[i];\n            }\n            else if(count==min_count){\n\
    \                if(arr[i]<min){\n                    min = arr[i];\n        \
    \        }\n            }\n        }\n        re.push_back(min);\n        arr.erase(std::remove(arr.begin(),\
    \ arr.end(), min), arr.end());\n    }\n    return re;", "    std::vector<long>\
    \ result;\n    int count_zeros = 0;\n    int count_ones = 0;\n    for (size_t\
    \ i = 0; i < arr.size(); i++) {\n        // std::cout << arr[i] << \" <-> \";\n\
    \        if (arr[i] > 0) {\n            long value = arr[i];\n            while\
    \ (value != 0) {\n                if (value % 2 == 0) {\n                    count_zeros++;\n\
    \                } else {\n                    count_ones++;\n               \
    \ }\n                value /= 2;\n            }\n            // std::cout << count_ones\
    \ << std::endl;\n            result.push_back(count_ones);\n            count_zeros\
    \ = 0;\n            count_ones = 0;\n        } else {\n            result.push_back(arr[i]);\n\
    \        }\n    }\n    return result;", "    int n = arr.size();\n    vector<pair<int,int>>\
    \ v;\n    vector<long> ans;\n    for(int i=0;i<n;i++){\n        int count = 0;\n\
    \        long x = arr[i];\n        while(x!=0){\n            count++;\n      \
    \      x = x&(x-1);\n        }\n        v.push_back({count,arr[i]});\n    }\n\
    \    sort(v.begin(),v.end());\n    for(int i=0;i<n;i++){\n        ans.push_back(v[i].second);\n\
    \    }\n    return ans;", "    sort(arr.begin(), arr.end(), [](long i, long j)\
    \ {\n        int ones_i = bitset<32>(i).count();\n        int ones_j = bitset<32>(j).count();\n\
    \        if (ones_i == ones_j)\n            return i < j;\n        return ones_i\
    \ < ones_j;\n    });\n    return arr;"]
stop_tokens:
- "\n}"
