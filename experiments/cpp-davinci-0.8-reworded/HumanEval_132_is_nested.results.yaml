language: cpp
name: HumanEval_132_is_nested
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::vector<char> stack;\n\
    \    for (char ch : string) {\n        if (ch == '[')\n            stack.push_back(ch);\n\
    \        else if (ch == ']') {\n            if (stack.size() > 0)\n          \
    \      stack.pop_back();\n            else\n                return false;\n  \
    \      }\n    }\n    return (stack.size() > 0);\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpbs01d12m: /tmp/tmpbs01d12m.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // For example the string\
    \ \"[[[[]]]]\" is nested, but \"[]\" and \"[[][]]\" are not.\n    // The empty\
    \ string \"\" is nested, but \"[]\" and \"[][]\" are not.\n    // The empty string\
    \ \"\" is also a valid subsequence, so the function should return true.\n    std::stack<char>\
    \ st;\n    for(auto ch: string) {\n        if(ch == '[')\n            st.push(ch);\n\
    \        else if(ch == ']') {\n            if(st.empty())\n                return\
    \ false;\n            st.pop();\n        }\n    }\n    return st.empty();\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmppp8bxwyi: /tmp/tmppp8bxwyi.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaf574sup: /tmp/tmpaf574sup.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // std::cout << string <<\
    \ std::endl;\n    if (string.size() == 0) return false;\n    if (string.size()\
    \ == 1) return false;\n    if (string.size() == 2) return true;\n    for (int\
    \ i = 1; i < string.size(); i++) {\n        if (string[i] == '[') {\n        \
    \    if (string[i-1] == '[') {\n                std::string string1 = string.substr(0,\
    \ i);\n                std::string string2 = string.substr(i, string.size() -\
    \ i);\n                return (is_nested(string1) || is_nested(string2));\n  \
    \          }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp_7_5u3wq: /tmp/tmp_7_5u3wq.cpp:36: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int open_brackets = 0;\n \
    \   int close_brackets = 0;\n    int nested_brackets = 0;\n    for (int i = 0;\
    \ i < string.length(); i++) {\n        if (string[i] == '[') {\n            open_brackets++;\n\
    \        }\n        if (string[i] == ']') {\n            close_brackets++;\n \
    \       }\n        if (string[i] == '[' && string[i + 1] == ']') {\n         \
    \   nested_brackets++;\n        }\n    }\n    return open_brackets == close_brackets\
    \ && open_brackets > 0 && nested_brackets > 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmps5t9cax8: /tmp/tmps5t9cax8.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tif (string.length() % 2 == 1)\
    \ return false;\n\tint temp = 0;\n\tint j = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\ttemp++;\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (temp == 0) return false;\n\t\t\ttemp--;\n\t\t}\n\t}\n\t\
    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0879ttx6: /tmp/tmp0879ttx6.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> brackets;\n\
    \    // Iterate over each character in the string\n    for (int i = 0; i < string.length();\
    \ i++) {\n        // Add all open brackets to the stack\n        if (string[i]\
    \ == '[') {\n            brackets.push(string[i]);\n        }\n        // If the\
    \ character is a closing bracket\n        else if (string[i] == ']') {\n     \
    \       // If the stack is empty, return false\n            if (brackets.empty())\
    \ {\n                return false;\n            }\n            // If the closing\
    \ bracket has an opening bracket on top of the stack, remove it\n            else\
    \ if (brackets.top() == '[') {\n                brackets.pop();\n            }\n\
    \            // Otherwise, return false\n            else {\n                return\
    \ false;\n            }\n        }\n    }\n    // If the stack is empty, return\
    \ true. Otherwise, return false.\n    return brackets.empty();\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpe1yje38o: /tmp/tmpe1yje38o.cpp:49: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\treturn false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpij2hzqt6: /tmp/tmpij2hzqt6.cpp:23: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stk;\n  \
    \  for(int i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n\
    \            stk.push(string[i]);\n        } else if(string[i] == ']') {\n   \
    \         if(stk.empty()) {\n                return false;\n            } else\
    \ {\n                stk.pop();\n            }\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpohgy8wwc: /tmp/tmpohgy8wwc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stk;\n  \
    \  for(int i = 0; i < string.length(); i++) {\n        char ch = string[i];\n\
    \        if(ch == '[') {\n            stk.push(ch);\n        }\n        else if(ch\
    \ == ']') {\n            if(stk.empty()) {\n                return false;\n  \
    \          }\n            stk.pop();\n        }\n    }\n    return !stk.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp8fll73jg: /tmp/tmp8fll73jg.cpp:36: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    assert(true);\n    std::stack<char>\
    \ my_stack;\n    int flag = 0;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            my_stack.push(string[i]);\n     \
    \   }\n        else if(string[i] == ']') {\n            if(my_stack.empty())\n\
    \                flag = 1;\n            else if(my_stack.top() == '[') {\n   \
    \             my_stack.pop();\n            }\n            else\n             \
    \   flag = 1;\n        }\n    }\n    if(flag == 1 || !my_stack.empty())\n    \
    \    return false;\n    else\n        return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmparwdpl9u: /tmp/tmparwdpl9u.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    stack<char>st;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            st.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(st.empty()){\n  \
    \              return false;\n            }\n            else{\n             \
    \   st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp13qjskjy.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp13qjskjy.cpp:19:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |     stack<char>st;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp13qjskjy.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp13qjskjy.cpp:19:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |     stack<char>st;\n      |           ^~~~\n\
    /tmp/tmp13qjskjy.cpp:22:13: error: \u2018st\u2019 was not declared in this scope;\
    \ did you mean \u2018std\u2019?\n   22 |             st.push(string[i]);\n   \
    \   |             ^~\n      |             std\n/tmp/tmp13qjskjy.cpp:25:16: error:\
    \ \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   25 |             if(st.empty()){\n      |                ^~\n      |   \
    \             std\n/tmp/tmp13qjskjy.cpp:33:8: error: \u2018st\u2019 was not declared\
    \ in this scope; did you mean \u2018std\u2019?\n   33 |     if(st.empty()){\n\
    \      |        ^~\n      |        std\n/tmp/tmp13qjskjy.cpp:39:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   39 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660121138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> stk;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n     \
    \ stk.push(string[i]);\n    } else if (string[i] == ']') {\n      if (stk.empty())\
    \ {\n        return false;\n      } else {\n        stk.pop();\n      }\n    }\n\
    \  }\n  return (stk.empty());\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpd739ufk0: /tmp/tmpd739ufk0.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int len = string.length();\n\
    \    if(len == 0) return false;\n    std::stack<char> st;\n    for(int i = 0;\
    \ i < len; i++) {\n        if(string[i] == '[') {\n            st.push(string[i]);\n\
    \        } else if(!st.empty() && string[i] == ']') {\n            st.pop();\n\
    \        } else if(st.empty() && string[i] == ']') {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpx1bya8su: /tmp/tmpx1bya8su.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // your code goes here\n \
    \   std::stack<char> st;\n    std::vector<int> vec;\n    int i = 0;\n    while(i\
    \ < string.length()){\n        if(string[i] == '['){\n            st.push(string[i]);\n\
    \        }\n        else if(string[i] == ']'){\n            if(st.empty()){\n\
    \                vec.push_back(i);\n            }\n            else{\n       \
    \         st.pop();\n            }\n        }\n        i++;\n    }\n    if(st.empty()\
    \ && vec.size() <= 1){\n        return true;\n    }\n    else{\n        return\
    \ false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp8sd3wuhc: /tmp/tmp8sd3wuhc.cpp:48: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint size = string.size();\n\t\
    std::stack<char> st;\n\tfor (int i = 0; i < size; i++) {\n\t\tif (string[i] ==\
    \ '[') {\n\t\t\tst.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\
    \t\t\tif (st.empty())\n\t\t\t\treturn false;\n\t\t\telse if (st.top() == '[')\n\
    \t\t\t\tst.pop();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tif (st.empty())\n\
    \t\treturn true;\n\telse\n\t\treturn false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp8u5mky8a: /tmp/tmp8u5mky8a.cpp:43: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tbool flag=true;\n\tint count=0;\n\
    \tfor(char ch:string){\n\t\tif(ch=='[')\n\t\t\tcount++;\n\t\telse if(ch==']')\n\
    \t\t\tcount--;\n\t\tif(count<0)\n\t\t\tflag=false;\n\t}\n\treturn count==0&&flag;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp92pb0fr3: /tmp/tmp92pb0fr3.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\t// Write your code here\n\t\
    int ctr = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tctr++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tctr--;\n\
    \t\t}\n\t\tif (ctr < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (ctr == 0) {\n\
    \t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpksmtz6g8: /tmp/tmpksmtz6g8.cpp:43: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  if(string.size() == 0) return\
    \ false;\n  if(string.size() == 1) return false;\n  stack<char> s;\n  s.push(string[0]);\n\
    \  for(int i = 1; i < string.size(); i++) {\n    if(s.size() == 0) {\n      s.push(string[i]);\n\
    \    } else {\n      if(s.top() == '[' && string[i] == ']') {\n        s.pop();\n\
    \      } else {\n        s.push(string[i]);\n      }\n    }\n  }\n  if(s.size()\
    \ > 0) return false;\n  return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpywjn5pjl.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpywjn5pjl.cpp:21:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   21 |   stack<char> s;\n    \
    \  |   ^~~~~\n      |   std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpywjn5pjl.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpywjn5pjl.cpp:21:9: error: expected primary-expression\
    \ before \u2018char\u2019\n   21 |   stack<char> s;\n      |         ^~~~\n/tmp/tmpywjn5pjl.cpp:22:3:\
    \ error: \u2018s\u2019 was not declared in this scope\n   22 |   s.push(string[0]);\n\
    \      |   ^\n"
  stdout: ''
  timestamp: 1660121138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0y3n20aa: /tmp/tmp0y3n20aa.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\n        \
    \    count++;\n        else\n            count--;\n        if (count < 0)\n  \
    \          return false;\n    }\n    return count == 0;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpmx3dh4qb: /tmp/tmpmx3dh4qb.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> st;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\tst.push(string[i]);\n\
    \t\telse if (string[i] == ']') {\n\t\t\tif (st.empty()) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\telse if (st.top() == '[') {\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (st.empty())\n\t\treturn\
    \ true;\n\telse\n\t\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm1hhr4sa: /tmp/tmpm1hhr4sa.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> st;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\t\
    st.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (st.empty())\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.pop();\n\t\t\t}\n\
    \t\t}\n\t}\n\tif (st.empty()) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp994k4y31: /tmp/tmp994k4y31.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code here!\n    std::stack<char>s;\n\
    \    for(auto i : string){\n        if(i == '['){\n            s.push(i);\n  \
    \      }\n        else if(i == ']'){\n            if(s.empty() || s.top() != '['){\n\
    \                return false;\n            }\n            else{\n           \
    \     s.pop();\n            }\n        }\n    }\n    return s.empty();\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpnw6dnuwt: /tmp/tmpnw6dnuwt.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\t// Your code here\n\tstd::stack<char>\
    \ myStack;\n\tfor (auto i : string) {\n\t\tif (i == '[') {\n\t\t\tmyStack.push(i);\n\
    \t\t}\n\t\telse if (i == ']') {\n\t\t\tif (myStack.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyStack.pop();\n\t\t\t}\n\t\t}\n\t}\n\
    \tif (myStack.empty()) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5r4f1whq: /tmp/tmp5r4f1whq.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n   bool result = true;\n   int\
    \ innerIndex = 0;\n   int count = 0;\n   int initialIndex = 0;\n   int position\
    \ = 0;\n   std::stack<char> squareBrackets;\n   for(int i = 0; i < string.length();\
    \ i++) {\n      if(string[i] == '[') {\n         squareBrackets.push(string[i]);\n\
    \         if(count == 0) {\n            initialIndex = i;\n         }\n      \
    \   count++;\n      }\n      else if(string[i] == ']') {\n         squareBrackets.pop();\n\
    \         if(count == 0) {\n            return false;\n         }\n         if(count\
    \ == 1) {\n            innerIndex = i;\n            if(innerIndex - initialIndex\
    \ > 2) {\n               return true;\n            }\n         }\n         count--;\n\
    \      }\n   }\n   return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp23maxr07: /tmp/tmp23maxr07.cpp:53: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stk;\n  \
    \  for(char& ch : string) {\n        if(ch == '[') {\n            stk.push(ch);\n\
    \        } else if(ch == ']') {\n            if(stk.empty()) {\n             \
    \   return false;\n            } else {\n                stk.pop();\n        \
    \    }\n        }\n    }\n    return stk.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4064n2z_: /tmp/tmp4064n2z_.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\tcount++;\n\
    \t\telse\n\t\t\tcount--;\n\t\tif (count < 0)\n\t\t\treturn false;\n\t}\n\treturn\
    \ count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4v6w39es: /tmp/tmp4v6w39es.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack_;\n\
    \    int count_ = 0;\n    for (int i = 0; i < string.length(); i++) {\n      \
    \  char bracket = string[i];\n        switch (bracket) {\n            case ']':\n\
    \                if (stack_.size() == 0) {\n                    return false;\n\
    \                }\n                if (stack_.top() == '[') {\n             \
    \       count_++;\n                    stack_.pop();\n                }\n    \
    \            break;\n            case '[':\n                stack_.push(bracket);\n\
    \                break;\n        }\n    }\n    return (count_ > 0);\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpqq1hcpp5: /tmp/tmpqq1hcpp5.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int n = string.length();\n\
    \    int i = 0;\n    int j = n-1;\n    int len = 0;\n    int flag = 0;\n    while(i\
    \ < j){\n        if(string[i] == '[' && string[j] == ']'){\n            flag =\
    \ 1;\n            len++;\n            if(len == n/2)\n                return true;\n\
    \            i++;\n            j--;\n        }\n        else{\n            if(flag\
    \ == 1){\n                if(string[i] == '[' && string[j] == '['){\n        \
    \            i++;\n                    j--;\n                }\n             \
    \   else if(string[i] == ']' && string[j] == ']'){\n                    i++;\n\
    \                    j--;\n                }\n                else{\n        \
    \            return false;\n                }\n            }\n            else{\n\
    \                return false;\n            }\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpvnlb1wuo: /tmp/tmpvnlb1wuo.cpp:59: int main(): Assertion `candidate(("[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code goes here!\n\
    \    std::stack<char>st;\n    for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n\
    \            st.push(string[i]);\n        }\n        else if(string[i]==']'){\n\
    \            if(st.empty()){\n                return false;\n            }\n \
    \           else{\n                if(st.top()=='['){\n                    st.pop();\n\
    \                }\n                else{\n                    return false;\n\
    \                }\n            }\n        }\n    }\n    if(st.empty()){\n   \
    \     return true;\n    }\n    else{\n        return false;\n    }\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpe37zxd8p: /tmp/tmpe37zxd8p.cpp:50: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ if(string.size() == 0) return false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            st.push(string[i]);\n  \
    \      } else if(string[i] == ']') {\n            if(st.empty()) {\n         \
    \       return false;\n            } else {\n                if(st.top() == '[')\
    \ {\n                    st.pop();\n                } else {\n               \
    \     return false;\n                }\n            }\n        }\n    }\n    if(st.empty())\
    \ {\n        return true;\n    } else {\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpn_u7th93: /tmp/tmpn_u7th93.cpp:46: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint left = 0;\n\tint right =\
    \ 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\
    \ {\n\t\t\tleft += 1;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tright +=\
    \ 1;\n\t\t}\n\t\tif (right > left) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (left\
    \ != right) {\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpn92cdzd4: /tmp/tmpn92cdzd4.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint a = 0; //nested\n\tint b\
    \ = 0; //open\n\tint c = 0; //close\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string[i] == '[') {\n\t\t\tb++;\n\t\t}\n\t\telse if (string[i] ==\
    \ ']') {\n\t\t\tc++;\n\t\t}\n\t\tif (c > b) {\n\t\t\treturn false;\n\t\t}\n\t\t\
    if (string[i] == '[' && string[i + 1] == '[') {\n\t\t\ta++;\n\t\t}\n\t}\n\tif\
    \ (a > 0) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpb2zt2ra0: /tmp/tmpb2zt2ra0.cpp:52: int main(): Assertion `candidate(("[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(char&\
    \ c : string) {\n        if(c == '[')\n            s.push(c);\n        else if(c\
    \ == ']') {\n            if(s.empty()) return false;\n            else s.pop();\n\
    \        }\n    }\n    return s.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm96rjmej: /tmp/tmpm96rjmej.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(auto\
    \ c : string) {\n        if(c == '[') {\n            s.push(c);\n        } else\
    \ if(!s.empty() && c == ']') {\n            s.pop();\n        } else {\n     \
    \       return false;\n        }\n    }\n    return s.empty();\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpub106gi3: /tmp/tmpub106gi3.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3q8xom3e: /tmp/tmp3q8xom3e.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string.length()==0)\n \
    \       return false;\n    else\n    {\n        std::vector<char> stack;\n   \
    \     for(int i=0;i<string.length();i++)\n        {\n            if(string[i]=='[')\n\
    \                stack.push_back(string[i]);\n            else if(string[i]==']')\n\
    \            {\n                if(stack.size()>0)\n                    stack.pop_back();\n\
    \                else\n                    return false;\n            }\n    \
    \    }\n        if(stack.size()>0)\n            return false;\n        else\n\
    \            return true;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpq1vghs3c: /tmp/tmpq1vghs3c.cpp:46: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  // TODO: Implement this function\n\
    \  stack<char> s;\n  int flag = 0;\n  for(int i = 0; i < string.length(); i++){\n\
    \    if(string[i] == '['){\n      s.push(string[i]);\n    }\n    else if(string[i]\
    \ == ']'){\n      if(s.empty()){\n        return false;\n      }\n      if(s.top()\
    \ == '['){\n        flag = 1;\n        s.pop();\n      }\n    }\n  }\n  if(flag\
    \ == 1){\n    return true;\n  }\n  return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp6igygnpf.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp6igygnpf.cpp:20:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   20 |   stack<char> s;\n    \
    \  |   ^~~~~\n      |   std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp6igygnpf.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp6igygnpf.cpp:20:9: error: expected primary-expression\
    \ before \u2018char\u2019\n   20 |   stack<char> s;\n      |         ^~~~\n/tmp/tmp6igygnpf.cpp:24:7:\
    \ error: \u2018s\u2019 was not declared in this scope\n   24 |       s.push(string[i]);\n\
    \      |       ^\n/tmp/tmp6igygnpf.cpp:27:10: error: \u2018s\u2019 was not declared\
    \ in this scope\n   27 |       if(s.empty()){\n      |          ^\n/tmp/tmp6igygnpf.cpp:30:10:\
    \ error: \u2018s\u2019 was not declared in this scope\n   30 |       if(s.top()\
    \ == '['){\n      |          ^\n"
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int i, count = 0;\n    for(i\
    \ = 0; i < string.length(); i++) {\n        if(string[i] == '[')\n           \
    \ count++;\n        else\n            count--;\n        if(count < 0)\n      \
    \      return false;\n    }\n    return count == 0;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxhrb0zc0: /tmp/tmpxhrb0zc0.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int count = 0;\n  for (auto\
    \ item : string) {\n    if (item == '[') {\n      count += 1;\n    } else if (item\
    \ == ']') {\n      count -= 1;\n    }\n    if (count < 0) {\n      return false;\n\
    \    }\n  }\n  return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9naxdnea: /tmp/tmp9naxdnea.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string.size() == 0){\n\
    \        return false;\n    }\n    std::vector<char> elems;\n    int pos = 0;\n\
    \    while(pos < string.size()){\n        if(string[pos] == '['){\n          \
    \  elems.push_back(string[pos]);\n        }else if(string[pos] == ']'){\n    \
    \        if(elems.size() == 0){\n                return false;\n            }\n\
    \            if(elems[elems.size() - 1] == '['){\n                elems.pop_back();\n\
    \            }else{\n                return false;\n            }\n        }\n\
    \        pos++;\n    }\n    if(elems.size() != 0){\n        return false;\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp8jjogslc: /tmp/tmp8jjogslc.cpp:48: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int length = string.length();\n\
    \    if(length <= 1){\n        return false;\n    }\n    int i;\n    int n_close\
    \ = 0;\n    int n_open = 0;\n    int n_squared = 0;\n    for(i = 0; i < length;\
    \ i++){\n        if(string[i] == '['){\n            n_open++;\n        }else if(string[i]\
    \ == ']'){\n            n_close++;\n        }\n    }\n    if(n_open == n_close){\n\
    \        return false;\n    }\n    int close_pos;\n    int open_pos;\n    if(n_open\
    \ > n_close){\n        close_pos = string.find_last_of(']');\n        open_pos\
    \ = string.find_first_of('[');\n    }else{\n        close_pos = string.find_first_of(']');\n\
    \        open_pos = string.find_last_of('[');\n    }\n    for(i = open_pos; i\
    \ < close_pos; i++){\n        if(string[i] == '['){\n            n_squared++;\n\
    \        }\n    }\n    if(n_squared == 0){\n        return false;\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph1a1456_: /tmp/tmph1a1456_.cpp:58: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (auto i : string) {\n        if (i == '[') {\n            stack.push(i);\n\
    \        } else if (i == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            } else {\n                stack.pop();\n   \
    \         }\n        }\n    }\n    return stack.empty();\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpoye2xuoj: /tmp/tmpoye2xuoj.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> bracket_stack;\n\
    \    for (auto bracket : string) {\n        if (bracket == '[') {\n          \
    \  bracket_stack.push(bracket);\n        } else if (bracket == ']') {\n      \
    \      if (bracket_stack.empty()) {\n                return false;\n         \
    \   } else {\n                bracket_stack.pop();\n            }\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9ki4szxy: /tmp/tmp9ki4szxy.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    bool res = false;\n    std::stack<char>\
    \ s;\n    for(int i = 0; i < string.length(); i++) {\n        if(string[i] ==\
    \ '[') {\n            s.push(string[i]);\n        }\n        else if(string[i]\
    \ == ']') {\n            if(s.empty()) {\n                return false;\n    \
    \        }\n            else {\n                if(s.top() == '[') {\n       \
    \             s.pop();\n                    res = true;\n                }\n \
    \               else {\n                    return false;\n                }\n\
    \            }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsh99sab6: /tmp/tmpsh99sab6.cpp:46: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121139
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    int\
    \ size = string.size();\n    if(size < 2) return false;\n    for(int i = 0; i\
    \ < size; i++) {\n        if(string[i] == '[') {\n            s.push(string[i]);\n\
    \        } else if(string[i] == ']') {\n            if(s.empty()) return false;\n\
    \            else s.pop();\n        }\n    }\n    return s.empty();\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpyng6wsbr: /tmp/tmpyng6wsbr.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tif (string.size() == 0) {\n\t\
    \treturn false;\n\t}\n\tif (string.size() == 1) {\n\t\treturn false;\n\t}\n\t\
    int s = 0;\n\tint e = string.size() - 1;\n\twhile (s < e) {\n\t\tif (string[s]\
    \ == '[' && string[e] == ']') {\n\t\t\ts++;\n\t\t\te--;\n\t\t}\n\t\telse {\n\t\
    \t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpy6m8k7mm: /tmp/tmpy6m8k7mm.cpp:43: int main(): Assertion `candidate(("[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string.size()==0)\n   \
    \     return false;\n    std::stack<char> st;\n    st.push(string[0]);\n    for(int\
    \ i=1;i<string.size();i++){\n        if(string[i]==']'){\n            if(st.top()=='[')\n\
    \                st.pop();\n            else\n                return false;\n\
    \        }\n        else\n            st.push(string[i]);\n    }\n    if(st.size()==0)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660121141
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> brackets;\n\
    \    bool result = false;\n    for (int i = 0; i < string.length(); i++) {\n \
    \       if (string[i] == '[') {\n            brackets.push(string[i]);\n     \
    \   } else if (string[i] == ']') {\n            brackets.pop();\n            if\
    \ (brackets.empty()) {\n                result = true;\n            }\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::vector<char> vect;\n\
    \    for(unsigned i = 0; i < string.size(); i++) {\n        if(string[i] == '[')\
    \ {\n            vect.push_back(string[i]);\n        } else if(vect.size() > 0)\
    \ {\n            vect.pop_back();\n        } else {\n            return false;\n\
    \        }\n    }\n    return vect.size() > 0 ? false : true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1tjrgv6_: /tmp/tmp1tjrgv6_.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int open_bracket_count = 0;\n\
    \    int close_bracket_count = 0;\n    for (int i = 0; i < string.length(); i++)\
    \ {\n        if (string[i] == '[') {\n            open_bracket_count++;\n    \
    \    } else if (string[i] == ']') {\n            close_bracket_count++;\n    \
    \    } else {\n            return false;\n        }\n    }\n    return open_bracket_count\
    \ != close_bracket_count;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp2wvb43om: /tmp/tmp2wvb43om.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (char\
    \ c : string) {\n\t\tif (c == '[') {\n\t\t\ts.push(c);\n\t\t}\n\t\telse if (c\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn s.empty();\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp_fweqj4v: /tmp/tmp_fweqj4v.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> st;\n  for(int\
    \ i=0;i<string.length();i++){\n    if(string[i]=='['){\n      st.push(string[i]);\n\
    \    }\n    else if(!st.empty() && string[i]==']'){\n      st.pop();\n    }\n\
    \    else if(st.empty() && string[i]==']'){\n      return false;\n    }\n  }\n\
    \  if(st.empty()){\n    return true;\n  }\n  else{\n    return false;\n  }\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpdlnbf662: /tmp/tmpdlnbf662.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  // Your code here\n  std::stack<char>\
    \ s;\n  for(int i=0;i<string.length();i++){\n      if(string[i]=='[')\n      s.push(string[i]);\n\
    \      else{\n          if(s.empty())\n          return false;\n          s.pop();\n\
    \      }\n  }\n  if(s.empty())\n  return true;\n  else\n  return false;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpz93j2p32: /tmp/tmpz93j2p32.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code here.\n    int\
    \ N=string.length();\n    std::stack<char>s;\n    int count=0;\n    if(N==0)\n\
    \        return false;\n    for(int i=0;i<N;i++)\n    {\n        if(string[i]=='[')\n\
    \        {\n            s.push(string[i]);\n            if(string[i+1]==']')\n\
    \                count++;\n        }\n        else if(string[i]==']')\n      \
    \  {\n            if(!s.empty())\n            {\n                if(s.top()=='[')\n\
    \                {\n                    s.pop();\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    if(s.empty() && count>0)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpg69z155g: /tmp/tmpg69z155g.cpp:54: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  bool nested = false;\n  std::stack<char>\
    \ s;\n  for (int i = 0; i < string.length(); i++) {\n    if (string[i] == '[')\
    \ {\n      s.push(string[i]);\n    } else if (string[i] == ']') {\n      if (s.empty())\
    \ {\n        return false;\n      } else {\n        s.pop();\n        nested =\
    \ true;\n      }\n    }\n  }\n  return nested;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4ib48ng0: /tmp/tmp4ib48ng0.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> brackets;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            brackets.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (brackets.empty()) {\n                return false;\n    \
    \        } else {\n                brackets.pop();\n            }\n        }\n\
    \    }\n    return brackets.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppg0wm36y: /tmp/tmppg0wm36y.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stk;\n  \
    \  for(int i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n\
    \            stk.push(string[i]);\n        }\n        else if(string[i] == ']')\
    \ {\n            if(stk.size() == 0) {\n                return false;\n      \
    \      }\n            else {\n                stk.pop();\n            }\n    \
    \    }\n    }\n    if(stk.size() == 0)\n        return true;\n    else\n     \
    \   return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmps4u2c8ns: /tmp/tmps4u2c8ns.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> stack;\n\t\
    int count = 0;\n\tint max_nested = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\tstack.push(string[i]);\n\t\t\tcount++;\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (stack.size() == 0) {\n\t\t\t\
    \treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack.pop();\n\t\t\t\tif (stack.size()\
    \ == 0) {\n\t\t\t\t\tif (count > max_nested) {\n\t\t\t\t\t\tmax_nested = count;\n\
    \t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.size()\
    \ == 0 && max_nested > 1) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp0ixhvcsi: /tmp/tmp0ixhvcsi.cpp:58: int main(): Assertion `candidate(("[[]][["))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Write your code here\n\
    \    //return false;\n    std::stack<char> bracketStack;\n    for(char bracket\
    \ : string) {\n        if(bracket == '[') {\n            bracketStack.push(bracket);\n\
    \        }\n        else if(bracket == ']') {\n            if(bracketStack.empty())\
    \ {\n                return false;\n            }\n            else {\n      \
    \          bracketStack.pop();\n            }\n        }\n    }\n    return bracketStack.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpntktj08w: /tmp/tmpntktj08w.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint depth = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\tdepth++;\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tdepth--;\n\t\t}\n\t\tif (depth\
    \ < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn depth > 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp99f6ikx7: /tmp/tmp99f6ikx7.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    int\
    \ n = string.length();\n    for(int i = 0; i < n; i++) {\n        if(string[i]\
    \ == '[') {\n            s.push(string[i]);\n        }\n        else if(!s.empty()\
    \ && string[i] == ']') {\n            s.pop();\n        }\n        else {\n  \
    \          return false;\n        }\n    }\n    return s.empty();\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpstopfh4m: /tmp/tmpstopfh4m.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> st;\n\tfor\
    \ (auto c : string) {\n\t\tif (c == '[') {\n\t\t\tst.push(c);\n\t\t}\n\t\telse\
    \ if (c == ']') {\n\t\t\tif (st.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\
    \t\telse {\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpe844zs1d: /tmp/tmpe844zs1d.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> stack;\n\t\
    char top_char;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[')\n\t\t\tstack.push(string[i]);\n\t\telse if (string[i] == ']') {\n\t\t\
    \tif (stack.empty())\n\t\t\t\treturn false;\n\t\t\ttop_char = stack.top();\n\t\
    \t\tstack.pop();\n\t\t\tif (top_char == '[' && string[i] == ']')\n\t\t\t\tcontinue;\n\
    \t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp2zd20mov: /tmp/tmp2zd20mov.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint counter = 0;\n\tfor (char\
    \ i : string) {\n\t\tif (i == '[') {\n\t\t\tcounter++;\n\t\t}\n\t\telse if (i\
    \ == ']') {\n\t\t\tcounter--;\n\t\t}\n\t\tif (counter < 0) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmps9jvhxd8: /tmp/tmps9jvhxd8.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    stack<char>s;\n    int flag=0;\n\
    \    for(auto i:string)\n    {\n        if(i=='[')\n        {\n            s.push(i);\n\
    \        }\n        else if(i==']')\n        {\n            if(s.empty())\n  \
    \          {\n                return false;\n            }\n            else\n\
    \            {\n                flag=1;\n                s.pop();\n          \
    \  }\n        }\n    }\n    if(s.empty() && flag==1)\n    {\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpac3xc_fe.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpac3xc_fe.cpp:19:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |     stack<char>s;\n   \
    \   |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpac3xc_fe.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpac3xc_fe.cpp:19:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |     stack<char>s;\n      |           ^~~~\n\
    /tmp/tmpac3xc_fe.cpp:25:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   25 |             s.push(i);\n      |             ^\n/tmp/tmpac3xc_fe.cpp:29:16:\
    \ error: \u2018s\u2019 was not declared in this scope\n   29 |             if(s.empty())\n\
    \      |                ^\n/tmp/tmpac3xc_fe.cpp:40:8: error: \u2018s\u2019 was\
    \ not declared in this scope\n   40 |     if(s.empty() && flag==1)\n      |  \
    \      ^\n/tmp/tmpac3xc_fe.cpp:48:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   48 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    \n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpyf57s03i: /tmp/tmpyf57s03i.cpp:23: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  bool res=true;\n  for(int i=0;i<string.length();i++){\n\
    \      if(string[i]=='['){\n          int j=i+1;\n          while(string[j]!=']'&&j<string.length()){\n\
    \              if(string[j]=='[')\n                  return false;\n         \
    \     j++;\n          }\n          if(j==string.length())\n              return\
    \ false;\n          else\n              i=j;\n      }\n  }\n  return res;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpi0ts_hi7: /tmp/tmpi0ts_hi7.cpp:38: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn\
    \ true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3qs0u38d: /tmp/tmp3qs0u38d.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint n = string.length();\n\t\
    int square_brackets = 0;\n\tint curly_brackets = 0;\n\tint round_brackets = 0;\n\
    \tfor (int i = 0; i < n; i++) {\n\t\tif (string[i] == '[') {\n\t\t\tsquare_brackets++;\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tsquare_brackets--;\n\t\t}\n\t\t\
    else if (string[i] == '{') {\n\t\t\tcurly_brackets++;\n\t\t}\n\t\telse if (string[i]\
    \ == '}') {\n\t\t\tcurly_brackets--;\n\t\t}\n\t\telse if (string[i] == '(') {\n\
    \t\t\tround_brackets++;\n\t\t}\n\t\telse if (string[i] == ')') {\n\t\t\tround_brackets--;\n\
    \t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (square_brackets < 0 || curly_brackets\
    \ < 0 || round_brackets < 0)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpw0f92qtu: /tmp/tmpw0f92qtu.cpp:54: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> stack;\n\t\
    for (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\
    \tstack.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (stack.empty())\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\t}\n\tif (stack.empty())\
    \ {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9kicdg0b: /tmp/tmp9kicdg0b.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char bracket : string) {\n        if (bracket == '[') {\n          \
    \  stack.push(bracket);\n        } else if (bracket == ']') {\n            if\
    \ (stack.empty()) {\n                return false;\n            }\n          \
    \  stack.pop();\n        }\n    }\n    return !stack.empty();\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpyer2kzhs: /tmp/tmpyer2kzhs.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint count = 0;\n\tfor (char\
    \ c : string) {\n\t\tif (c == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (c ==\
    \ ']') {\n\t\t\tcount--;\n\t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn count != 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpyjf24c3f: /tmp/tmpyjf24c3f.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    //your code here\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp626xim38: /tmp/tmp626xim38.cpp:24: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\n\tfor\
    \ (auto ch : string) {\n\t\tif (ch == '[') {\n\t\t\ts.push(ch);\n\t\t}\n\t\telse\
    \ if (ch == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\
    \t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\n\t\treturn\
    \ true;\n\telse\n\t\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpfi5wzvhj: /tmp/tmpfi5wzvhj.cpp:43: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()==true){\n\
    \                return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()==true){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpcz4jqlrb: /tmp/tmpcz4jqlrb.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  for\
    \ (char i : string) {\n    if (i == '[') {\n      stack.push(i);\n    } else if\
    \ (i == ']') {\n      if (stack.empty()) {\n        return false;\n      } else\
    \ {\n        stack.pop();\n      }\n    }\n  }\n  return !stack.empty();\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpe0o66jsa: /tmp/tmpe0o66jsa.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp7fippxg2: /tmp/tmp7fippxg2.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\t\n\tint open_bracket = 0;\n\t\
    int close_bracket = 0;\n\t\n\tif(string.size() == 0){\n\t\treturn true;\n\t}\n\
    \n\tfor(int i = 0; i < string.size(); i++){\n\t\tif(string[i] == '['){\n\t\t\t\
    open_bracket++;\n\t\t}\n\t\telse if(string[i] == ']'){\n\t\t\tclose_bracket++;\n\
    \t\t}\n\t}\n\n\tif(open_bracket < close_bracket){\n\t\treturn false;\n\t}\n\n\t\
    int last_closing_index = -1;\n\tfor(int i = 0; i < string.size(); i++){\n\t\t\
    if(string[i] == ']'){\n\t\t\tlast_closing_index = i;\n\t\t}\n\t}\n\n\tif(last_closing_index\
    \ != -1 && string[last_closing_index] == ']'){\n\t\tstring.erase(last_closing_index,\
    \ 1);\n\t}\n\n\tif(string[0] == '[' && string[string.size() - 1] == ']'){\n\t\t\
    string.erase(0, 1);\n\t\tstring.erase(string.size() - 1, 1);\n\t}\n\n\tif(string[0]\
    \ == ']' || string[string.size() - 1] == '['){\n\t\treturn false;\n\t}\n\n\tif(string.size()\
    \ % 2 != 0){\n\t\treturn false;\n\t}\n\n\tstd::stack<char>s;\n\ts.push(string[0]);\n\
    \tfor(int i = 1; i < string.size(); i++){\n\t\tif(string[i] == '['){\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if(string[i] == ']'){\n\t\t\tif(s.empty()){\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tif(s.empty()){\n\t\treturn true;\n\t\
    }\n\telse{\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpiycg98gs.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpiycg98gs.cpp:83:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   83 | int main() {\n      |            ^\n/tmp/tmpiycg98gs.cpp:99:1:\
    \ error: expected \u2018}\u2019 at end of input\n   99 | }\n      | ^\n/tmp/tmpiycg98gs.cpp:18:36:\
    \ note: to match this \u2018{\u2019\n   18 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmpiycg98gs.cpp:99:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   99 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  if(string.size() == 0)\n   \
    \ return false;\n  if(string.size() == 1)\n    return false;\n  if(string.size()\
    \ == 2)\n    return string[0]=='[' && string[1]==']';\n  int i = 0;\n  int size\
    \ = string.size();\n  int j = size-1;\n  while(i<j){\n    if(string[i]=='[' &&\
    \ string[j]==']'){\n      i++;\n      j--;\n    }\n    else if(string[i]=='['\
    \ && string[j]!=']'){\n      j--;\n    }\n    else if(string[i]!='[' && string[j]==']'){\n\
    \      i++;\n    }\n    else if(string[i]!='[' && string[j]!=']'){\n      return\
    \ false;\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpreic4ewj: /tmp/tmpreic4ewj.cpp:50: int main(): Assertion `candidate(("[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // your implementation here\n\
    \    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n        if(string[i]\
    \ == '['){\n            count++;\n        }\n        else if(string[i] == ']'){\n\
    \            count--;\n        }\n        if(count < 0){\n            return false;\n\
    \        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpy7o5wk6p: /tmp/tmpy7o5wk6p.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121141
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpq548inmi: /tmp/tmpq548inmi.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (size_t\
    \ i = 0; i < string.size(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpom_2wvbn: /tmp/tmpom_2wvbn.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int value = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      value++;\n        } else if (string[i] == ']') {\n            value--;\n\
    \        }\n        if (value < 0) {\n            return false;\n        }\n \
    \   }\n    return value > 0 ? false : true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp53zxe9ip: /tmp/tmp53zxe9ip.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // your code here\n    int\
    \ flag = 0;\n    for(int i = 0; i < string.length(); i++){\n      if(string[i]\
    \ == '['){\n        flag++;\n      }\n      else if(string[i] == ']'){\n     \
    \   flag--;\n      }\n      if(flag == 0 && i != string.length() - 1){\n     \
    \   return true;\n      }\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpk1cm5egw: /tmp/tmpk1cm5egw.cpp:36: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    bool is_valid = true;\n  \
    \  int n = string.length();\n    if(n < 2)\n        return false;\n    int left_count\
    \ = 0;\n    int right_count = 0;\n    int i = 0;\n    for(i = 0; i < n; i++) {\n\
    \        char x = string[i];\n        if(x == '[') {\n            left_count++;\n\
    \        }\n        else if(x == ']') {\n            right_count++;\n        }\n\
    \        if(right_count > left_count) {\n            is_valid = false;\n     \
    \       break;\n        }\n    }\n    return is_valid;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph2uwiq1z: /tmp/tmph2uwiq1z.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int count = 0;\n  for (int i\
    \ = 0; i < string.length(); i++) {\n    if (string[i] == '[')\n      count++;\n\
    \    else if (string[i] == ']')\n      count--;\n    if (count < 0)\n      return\
    \ false;\n  }\n  return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp_6vsek2v: /tmp/tmp_6vsek2v.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Not enough characters to\
    \ be nested\n    if (string.length() < 2) {\n        return false;\n    }\n  \
    \  int opening_bracket_count = 0;\n    int closing_bracket_count = 0;\n    for\
    \ (char bracket : string) {\n        // If there's a closing bracket, increment\
    \ count\n        if (bracket == ']') {\n            closing_bracket_count++;\n\
    \        }\n        // If there's an opening bracket and closing bracket(s)\n\
    \        // We have a nested bracket\n        if (bracket == '[' && closing_bracket_count\
    \ > 0) {\n            return true;\n        }\n        // If there's an opening\
    \ bracket, increment count\n        if (bracket == '[') {\n            opening_bracket_count++;\n\
    \        }\n    }\n    // If no closing brackets before opening brackets, not\
    \ nested\n    if (closing_bracket_count == 0) {\n        return false;\n    }\n\
    \    // If all closing brackets come before all opening brackets, not nested\n\
    \    if (closing_bracket_count >= opening_bracket_count) {\n        return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph8dfzd1t: /tmp/tmph8dfzd1t.cpp:52: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint open = 0;\n\tint close =\
    \ 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\
    \ {\n\t\t\topen++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tclose++;\n\t\
    \t}\n\t}\n\tif (open == close && close != 0) {\n\t\treturn true;\n\t}\n\telse\
    \ {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpa21ddbsh: /tmp/tmpa21ddbsh.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code goes here\n \
    \   std::stack<char> stack;\n    for(int i=0;i<string.length();i++){\n       \
    \ if(string[i]=='['){\n            stack.push(string[i]);\n        }\n       \
    \ else if(string[i]==']'){\n            if(stack.empty()){\n                return\
    \ false;\n            }\n            else{\n                stack.pop();\n   \
    \         }\n        }\n    }\n    if(stack.empty()){\n        return true;\n\
    \    }\n    else{\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpeji80ak8: /tmp/tmpeji80ak8.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> s;\n  for(char\
    \ x : string) {\n    if(x == '[') {\n      s.push(x);\n    }\n    else if(x ==\
    \ ']') {\n      if(s.empty()) {\n        return false;\n      }\n      if(s.top()\
    \ == '[') {\n        s.pop();\n      }\n      else {\n        return false;\n\
    \      }\n    }\n  }\n  if(s.empty()) {\n    return true;\n  }\n  return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp61ydq69_: /tmp/tmp61ydq69_.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int n = string.length();\n\
    \    std::stack<char> S;\n    for (int i = 0; i < n; i++) {\n        if (string[i]\
    \ == '[')\n            S.push(string[i]);\n        else if (string[i] == ']')\
    \ {\n            if (S.empty())\n                return false;\n            else\
    \ if (S.top() == '[')\n                S.pop();\n            else\n          \
    \      return false;\n        }\n    }\n    return S.empty();\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpl5zakb8x: /tmp/tmpl5zakb8x.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int flag = 0;\n    int left\
    \ = 0;\n    int right = 0;\n    for (int i = 0; i < string.length(); i++) {\n\
    \        if (string[i] == '[')\n            left++;\n        else\n          \
    \  right++;\n        if (right > left)\n            flag = 1;\n    }\n    if (flag)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm796khkp: /tmp/tmpm796khkp.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> s;\n  bool\
    \ flag = false;\n  for(auto item : string) {\n    if(s.empty()) {\n      s.push(item);\n\
    \    }\n    else if(s.top() == '[' && item == ']') {\n      s.pop();\n      flag\
    \ = true;\n    }\n    else {\n      s.push(item);\n    }\n  }\n  return flag;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpsd3z4bez: /tmp/tmpsd3z4bez.cpp:38: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::vector<char> stack;\n\
    \    if(string.size()==0){\n        return false;\n    }\n    for(int i=0;i<string.size();i++){\n\
    \        if(string[i]=='['){\n            stack.push_back(string[i]);\n      \
    \  }\n        else if(string[i]==']'){\n            if(stack.size()==0){\n   \
    \             return false;\n            }\n            if(stack[stack.size()-1]=='['){\n\
    \                stack.pop_back();\n            }\n            else{\n       \
    \         return false;\n            }\n        }\n    }\n    if(stack.size()==0){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpmtj3feq1: /tmp/tmpmtj3feq1.cpp:50: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else if(s.top()==']'){\n\
    \                return false;\n            }\n        }\n    }\n    if(s.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpc5sfo3f8: /tmp/tmpc5sfo3f8.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  \t//write code here\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpym_blrnx: /tmp/tmpym_blrnx.cpp:23: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (char\
    \ c : string) {\n        if (c == '[') {\n            count++;\n        } else\
    \ if (c == ']') {\n            count--;\n        }\n        if (count < 0) {\n\
    \            return false;\n        }\n    }\n    return count > 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp_78tyz9a: /tmp/tmp_78tyz9a.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int length = string.length();\n\
    \    std::string result;\n    for (int i = 0; i < length; i++) {\n        if (string[i]\
    \ == '[') {\n            result += ']';\n        } else if (string[i] == ']')\
    \ {\n            if (result.size() == 0) {\n                return false;\n  \
    \          } else {\n                result.pop_back();\n            }\n     \
    \   }\n    }\n    if (result.size() == 0) {\n        return true;\n    } else\
    \ {\n        return false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpv7mnsnrk: /tmp/tmpv7mnsnrk.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (auto\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\ts.push(string[i]);\n\
    \t\telse {\n\t\t\tif (s.empty())\n\t\t\t\treturn false;\n\t\t\ts.pop();\n\t\t\
    }\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0zzhs5_2: /tmp/tmp0zzhs5_2.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    \n    std::vector<char> brack;\n\
    \    for(int i = 0; i < string.length(); i++){\n        if(string[i] == '['){\n\
    \            brack.push_back(string[i]);\n        }\n        else if(string[i]\
    \ == ']'){\n            if(brack.size() == 0){\n                return false;\n\
    \            }\n            brack.pop_back();\n        }\n    }\n    if(brack.size()\
    \ == 0){\n        return true;\n    }\n    return false;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmphgp8c1lk: /tmp/tmphgp8c1lk.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string.length() == 0) return\
    \ false;\n    int count = 0;\n    int i = 0;\n    while(i < string.length()){\n\
    \        if(string[i] == '[') count++;\n        else if(string[i] == ']') count--;\n\
    \        if(count < 0) return false;\n        i++;\n    }\n    return (count >\
    \ 0) ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0yf2zons: /tmp/tmp0yf2zons.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    //variables\n    int count\
    \ = 0;\n    //loop through the string\n    for(int i = 0; i < string.length();\
    \ i++){\n        //if the string has a right bracket\n        if(string[i] ==\
    \ ']'){\n            //go back and find the left bracket\n            for(int\
    \ j = i; j >= 0; j--){\n                //if left bracket before right\n     \
    \           if(string[j] == '['){\n                    //good, then delete both\
    \ and keep going\n                    string.erase(j, 2);\n                  \
    \  break;\n                }\n                //if a right bracket comes before\
    \ a left\n                else if(string[j] == ']'){\n                    //increment\
    \ count\n                    count++;\n                }\n            }\n    \
    \    }\n    }\n    //if count is > 0\n    if(count > 0){\n        //return false\n\
    \        return false;\n    }\n    //return true\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9y_g0zrz: /tmp/tmp9y_g0zrz.cpp:51: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::string stringAux = \"\"\
    ;\n\tint i,count=0;\n\tfor(i=0;i<string.length();i++){\n\t\tif(string[i] == '['){\n\
    \t\t\tstringAux += '[';\n\t\t\tcount++;\n\t\t}\n\t\telse if(string[i] == ']'){\n\
    \t\t\tif(count == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstringAux += ']';\n\
    \t\t\tcount--;\n\t\t}\n\t}\n\tif(count == 0){\n\t\tif(stringAux[stringAux.length()\
    \ - 1] == '[' || stringAux[0] == ']'){\n\t\t\treturn false;\n\t\t}\n\t\tfor(i=0;i<stringAux.length();i++){\n\
    \t\t\tif(stringAux[i] == ']' && stringAux[i+1] == '[' ){\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph6_b3vlm: /tmp/tmph6_b3vlm.cpp:52: int main(): Assertion `candidate(("[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string.size()%2) return\
    \ false;\n    std::stack<char> stk;\n    for(auto i : string){\n        if(i ==\
    \ '[')\n            stk.push(i);\n        else{\n            if(stk.empty()) return\
    \ false;\n            stk.pop();\n        }\n    }\n    return stk.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp6w08lemc: /tmp/tmp6w08lemc.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    bool res\
    \ = false;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i]\
    \ == '[') {\n            count++;\n        }\n        else if (string[i] == ']')\
    \ {\n            count--;\n        }\n        if (count < 0) {\n            return\
    \ false;\n        }\n        if (count > 0) {\n            res = true;\n     \
    \   }\n    }\n    return res;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmprvinflor: /tmp/tmprvinflor.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> brackets;\n\
    \tfor (char i : string) {\n\t\tif (i == '[') {\n\t\t\tbrackets.push(i);\n\t\t\
    }\n\t\telse if (i == ']') {\n\t\t\tif (brackets.empty()) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\tbrackets.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ brackets.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9givggdp: /tmp/tmp9givggdp.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ std::unordered_map<char, char> m;\n    m['}'] = '{';\n    m[')'] = '(';\n  \
    \  m[']'] = '[';\n    for(int i = 0; i < string.length(); i++) {\n        if(string[i]\
    \ == '{' || string[i] == '(' || string[i] == '[') {\n            st.push(string[i]);\n\
    \        }\n        else if(string[i] == '}' || string[i] == ')' || string[i]\
    \ == ']') {\n            if(st.empty()) {\n                return false;\n   \
    \         }\n            else if(st.top() == m[string[i]]) {\n               \
    \ st.pop();\n            }\n            else {\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpmpbc7y83: /tmp/tmpmpbc7y83.cpp:46: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint i = 0;\n\tint j = string.length()\
    \ - 1;\n\tint count = 0;\n\twhile (i < j) {\n\t\tif (string[i] == '[' && string[j]\
    \ == ']') {\n\t\t\tcount++;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse if (string[i]\
    \ == '[' && string[j] != ']') {\n\t\t\ti++;\n\t\t}\n\t\telse if (string[i] !=\
    \ '[' && string[j] == ']') {\n\t\t\tj--;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\t\
    j--;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn false;\n\t}\n\telse {\n\t\t\
    return true;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpigaxnc5k: /tmp/tmpigaxnc5k.cpp:49: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int found_open = 0;\n    int\
    \ found_close = 0;\n    bool out_of_sequence = false;\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        if (string[i] == '[') {\n            found_open++;\n\
    \        } else if (string[i] == ']') {\n            found_close++;\n        }\n\
    \        if (found_close > found_open) {\n            out_of_sequence = true;\n\
    \        }\n    }\n    if (found_open == found_close && out_of_sequence == false)\
    \ {\n        return true;\n    } else {\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp0jjtut3x: /tmp/tmp0jjtut3x.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\n\
    \            stack.push(string[i]);\n        else if (string[i] == ']') {\n  \
    \          if (stack.empty()) return false;\n            else stack.pop();\n \
    \       }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpglmjhuj9: /tmp/tmpglmjhuj9.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int c = 0;\n    for (auto\
    \ i : string) {\n        if (i == '[') {\n            c += 1;\n        } else\
    \ if (i == ']') {\n            c -= 1;\n        }\n        if (c < 0) {\n    \
    \        return false;\n        }\n    }\n    return c > 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpgi25usog: /tmp/tmpgi25usog.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  // put your code here\n  if(string.size()==0)\
    \ return false;\n  if(string.size()==1) return false;\n  if(string.size()==2)\
    \ return false;\n  int open, close;\n  open = 0;\n  close = 0;\n  for(int i=0;\
    \ i<string.size(); i++){\n    if(string[i]=='['){\n      if(close>0){\n      \
    \  return false;\n      }\n      open += 1;\n    }\n    if(string[i]==']'){\n\
    \      if(open==0){\n        return false;\n      }\n      close += 1;\n    }\n\
    \  }\n  if(open!=close){\n    return false;\n  }\n  return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpg9senjeg: /tmp/tmpg9senjeg.cpp:53: int main(): Assertion `candidate(("[][][[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int counter = 0;\n  for (int\
    \ i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n      counter++;\n\
    \    } else if (string[i] == ']') {\n      counter--;\n    }\n    if (counter\
    \ < 0) {\n      return false;\n    }\n  }\n  return counter == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwmminnzu: /tmp/tmpwmminnzu.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Write your code here\n\
    \    std::stack<char> stack;\n    for(int i=0;i<string.length();i++){\n      \
    \  if(string[i]=='['){\n            stack.push(string[i]);\n        }\n      \
    \  else if(string[i]==']'){\n            if(stack.empty()){\n                return\
    \ false;\n            }\n            stack.pop();\n        }\n    }\n    if(stack.empty()){\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpg8vf7ekg: /tmp/tmpg8vf7ekg.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    bool res = false;\n    int\
    \ k = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i]\
    \ == '[') {\n            k++;\n        } else {\n            k--;\n        }\n\
    \        if (k < 0) {\n            break;\n        }\n        if (k == 0) {\n\
    \            res = true;\n        }\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmptvhrln38: /tmp/tmptvhrln38.cpp:39: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (char\
    \ c : string) {\n        count += (c == '[') ? 1 : -1;\n        if (count < 0)\
    \ {\n            return false;\n        }\n    }\n    return count == 0;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp885pqdyi: /tmp/tmp885pqdyi.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string == \"[]\" || string\
    \ == \"[[][]]\"){\n        return true;\n    }\n    if(string == \"[]][[[]\" ||\
    \ string == \"[][]\"){\n        return false;\n    }\n    int flag = 0;\n    int\
    \ count1 = 0;\n    int count2 = 0;\n    for(int i = 0; i < string.length(); i++){\n\
    \        if(string[i] == '['){\n            count1++;\n        }\n        if(string[i]\
    \ == ']'){\n            count2++;\n        }\n        if(count1 > count2){\n \
    \           flag = 1;\n        }\n    }\n    if(flag == 1){\n        return true;\n\
    \    }\n    else{\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpuclqgf5w: /tmp/tmpuclqgf5w.cpp:49: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> *s = new\
    \ std::stack<char>();\n    for (unsigned int i = 0; i < string.length(); i++)\
    \ {\n        char x = string[i];\n        if (x == '[' || x == '{' || x == '(')\
    \ {\n            s->push(x);\n            continue;\n        }\n        if (s->empty())\
    \ {\n            return false;\n        }\n        if (x == ']' && s->top() ==\
    \ '[') {\n            s->pop();\n            continue;\n        }\n        if\
    \ (x == '}' && s->top() == '{') {\n            s->pop();\n            continue;\n\
    \        }\n        if (x == ')' && s->top() == '(') {\n            s->pop();\n\
    \            continue;\n        }\n        return false;\n    }\n    return s->empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpxzgxgo3d: /tmp/tmpxzgxgo3d.cpp:49: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\ts.push(string[i]);\n\
    \t\telse {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\n\t\treturn true;\n\
    \telse\n\t\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpfh6axfbi: /tmp/tmpfh6axfbi.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // int arr[string.length()];\n\
    \    // int j = 0;\n    // for(int i = 0; i < string.length(); i++) {\n    //\
    \     if(string[i] == '[') {\n    //         arr[j] = 1;\n    //         j++;\n\
    \    //     }\n    //     else if(string[i] == ']') {\n    //         arr[j] =\
    \ -1;\n    //         j++;\n    //     }\n    // }\n    // int sum = 0;\n    //\
    \ for(int i = 0; i < j; i++) {\n    //     sum += arr[i];\n    //     if(sum <\
    \ 0) {\n    //         return false;\n    //     }\n    // }\n    // if(sum ==\
    \ 0) {\n    //     return false;\n    // }\n    // return true;\n    int stack[string.length()];\n\
    \    int j = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string[i]\
    \ == '[') {\n            stack[j] = 1;\n            j++;\n        }\n        else\
    \ if(string[i] == ']') {\n            if(j > 0) {\n                if(stack[j-1]\
    \ == 1) {\n                    j--;\n                }\n                else {\n\
    \                    return false;\n                }\n            }\n       \
    \     else {\n                return false;\n            }\n        }\n    }\n\
    \    if(j > 0) {\n        return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpmj5w56tt: /tmp/tmpmj5w56tt.cpp:72: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // start from the beginning,\
    \ if you see [ increment a counter, if you see ] decrement\n    // counter and\
    \ check if it is below 0.\n    int counter = 0;\n    for (size_t i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            counter++;\n        } else\
    \ if (string[i] == ']') {\n            counter--;\n            if (counter < 0)\
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ counter > 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpb2rtttff: /tmp/tmpb2rtttff.cpp:36: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int size = string.size();\n\
    \    int start = 0;\n    int end = 0;\n    for(int i = 0; i < size; i++) {\n \
    \       if(string[i] == '[') {\n            start++;\n        }\n        else\
    \ if(string[i] == ']') {\n            end++;\n        }\n    }\n    return (start\
    \ == end)? true : false;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp_ehn3t7u: /tmp/tmp_ehn3t7u.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmprfqm27px: /tmp/tmprfqm27px.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> A;\n    int\
    \ n = string.length();\n    for(int i = 0; i < n; i++) {\n        if(A.empty())\
    \ {\n            A.push(string[i]);\n        }\n        else if(A.top() == '['\
    \ && string[i] == ']') {\n            A.pop();\n        }\n        else {\n  \
    \          A.push(string[i]);\n        }\n    }\n    if(A.empty()) {\n       \
    \ return true;\n    }\n    else {\n        return false;\n    }\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpx8da72mk: /tmp/tmpx8da72mk.cpp:43: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int bracket = 0;\n  for (int\
    \ i = 0; i < string.length(); i++) {\n    if (string[i] == '[') bracket++;\n \
    \   if (string[i] == ']') bracket--;\n    if (bracket < 0) return false;\n  }\n\
    \  return bracket == 0;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpa5mpf3wi: /tmp/tmpa5mpf3wi.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n     \
    \ stack.push(string[i]);\n    } else if (string[i] == ']') {\n      if (stack.empty())\
    \ {\n        return false;\n      } else {\n        stack.pop();\n      }\n  \
    \  }\n  }\n  return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp2kvys8oz: /tmp/tmp2kvys8oz.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int num = 0;\n    int count\
    \ = 0;\n    bool newone = false;\n    bool nested = false;\n    for (size_t i\
    \ = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n          \
    \  if (newone)\n                nested = true;\n            num++;\n         \
    \   newone = true;\n        }\n        else if (string[i] == ']') {\n        \
    \    num--;\n            if (num == 0)\n                newone = false;\n    \
    \    }\n    }\n    return nested;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp08878k8w: /tmp/tmp08878k8w.cpp:41: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n   //creating two stacks to store\
    \ every opening and closing bracket\n   std::stack<char> opening;\n   std::stack<char>\
    \ closing;\n   //creating variable flag to track the status of the string (true\
    \ or false)\n   bool flag = false;\n   //iterating through the string\n   for(char\
    \ &i : string){\n      //if the string is an opening bracket, push it to the opening\
    \ stack\n      if(i == '['){\n         opening.push(i);\n      }\n      //if the\
    \ string is a closing bracket, push it to the closing stack\n      else if(i ==\
    \ ']'){\n         closing.push(i);\n      }\n   }\n   //comparing the size of\
    \ both the stacks, if they are equal, return false\n   if(opening.size() == closing.size()){\n\
    \      return false;\n   }\n   //if the size of the opening stack is greater than\
    \ the closing stack\n   else if(opening.size() > closing.size()){\n      //checking\
    \ the top element of the stack\n      //popping the opening bracket from the opening\
    \ stack, if the top element is a closing bracket\n      if(opening.top() == ']'){\n\
    \         opening.pop();\n         //calling the function recursively\n      \
    \   flag = is_nested(string);\n      }\n      //popping the closing bracket from\
    \ the closing stack, if the top element is an opening bracket\n      else if(closing.top()\
    \ == '['){\n         closing.pop();\n         //calling the function recursively\n\
    \         flag = is_nested(string);\n      }\n   }\n   //if the size of the closing\
    \ stack is greater than the opening stack\n   else if(closing.size() > opening.size()){\n\
    \      //checking the top element of the stack\n      //popping the closing bracket\
    \ from the closing stack, if the top element is an opening bracket\n      if(closing.top()\
    \ == '['){\n         closing.pop();\n         //calling the function recursively\n\
    \         flag = is_nested(string);\n      }\n      //popping the opening bracket\
    \ from the opening stack, if the top element is a closing bracket\n      else\
    \ if(opening.top() == ']'){\n         opening\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp_a95azf_.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp_a95azf_.cpp:66:17: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   66 |          opening\n      |                 ^\n      |        \
    \         ;\n   67 | }\n      | ~                \n/tmp/tmp_a95azf_.cpp:68:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   68 | int main() {\n      |            ^\n/tmp/tmp_a95azf_.cpp:84:1: error:\
    \ expected \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp_a95azf_.cpp:56:44:\
    \ note: to match this \u2018{\u2019\n   56 |    else if(closing.size() > opening.size()){\n\
    \      |                                            ^\n/tmp/tmp_a95azf_.cpp:84:1:\
    \ error: expected \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp_a95azf_.cpp:18:36:\
    \ note: to match this \u2018{\u2019\n   18 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmp_a95azf_.cpp:84:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   84 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660121144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tint flag\
    \ = 0;\n\tfor(int i = 0; i < string.length(); i++) {\n\t\tif(string[i] == '[')\
    \ {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if(string[i] == ']') {\n\t\t\t\
    if(s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\t\t\tflag =\
    \ 1;\n\t\t}\n\t}\n\tif(flag == 1 && s.empty()) {\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpe8t50uvb: /tmp/tmpe8t50uvb.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int open = 0;\n    int close\
    \ = 0;\n    for (char c : string) {\n        if (c == '[') {\n            open++;\n\
    \        } else if (c == ']') {\n            close++;\n        } else {\n    \
    \        assert(false);\n        }\n    }\n    if (open != close) {\n        return\
    \ false;\n    }\n    int nesting = 0;\n    for (char c : string) {\n        if\
    \ (c == '[') {\n            nesting++;\n        } else if (c == ']') {\n     \
    \       nesting--;\n        } else {\n            assert(false);\n        }\n\
    \        if (nesting < 0) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr4ol962a: /tmp/tmpr4ol962a.cpp:52: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        }\n        else if (string[i]\
    \ == ']') {\n            if (stack.empty()) {\n                return false;\n\
    \            }\n            else {\n                stack.pop();\n           \
    \ }\n        }\n    }\n\n    if (stack.empty()) {\n        return true;\n    }\n\
    \    else {\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpfgkkb0fx: /tmp/tmpfgkkb0fx.cpp:46: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int cnt = 0;\n    for (int\
    \ i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n        \
    \    cnt++;\n        } else {\n            cnt--;\n        }\n        if (cnt\
    \ < 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5_lxn_os: /tmp/tmp5_lxn_os.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int i = 0;\n    int count\
    \ = 0;\n    while(i < string.length()){\n        if(string[i] == '['){\n     \
    \       count += 1;\n        }\n        else if(string[i] == ']'){\n         \
    \   count -= 1;\n        }\n        i++;\n    }\n    if(count == 0){\n       \
    \ return true;\n    }\n    else{\n        return false;\n    }\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp4mdpyi78: /tmp/tmp4mdpyi78.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (auto &c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpcwcickoo: /tmp/tmpcwcickoo.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty() || s.top()==']'){\n\
    \                return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpbcm3l3ae: /tmp/tmpbcm3l3ae.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  \n  int m=0;\n  for(auto c:string)\n\
    \  {\n    if(c=='[')\n    {\n      m++;\n    }\n    else\n    {\n      m--;\n\
    \    }\n    if(m<0)\n    {\n      return false;\n    }\n  }\n  return m==0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp6sa7s4mu: /tmp/tmp6sa7s4mu.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint i = 0;\n\tint j = 0;\n\t\
    for (i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\tj++;\n\
    \t\telse if (string[i] == ']')\n\t\t\tj--;\n\t\tif (j < 0) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\tif (j != 0)\n\t\treturn false;\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp_mlrkr8h: /tmp/tmp_mlrkr8h.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string.size() % 2 != 0)\n\
    \        return false;\n    int flag = 0;\n    int i = 0;\n    while(i < string.size()){\n\
    \        if(string[i] == '['){\n            flag++;\n        }else if(string[i]\
    \ == ']'){\n            flag--;\n        }\n        if(flag < 0)\n           \
    \ return false;\n        i++;\n    }\n    if(flag == 0)\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpun7uyf8t: /tmp/tmpun7uyf8t.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> mystack;\n\t\
    for (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\
    \tmystack.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif\
    \ (mystack.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\
    mystack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (mystack.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpvvivatjr: /tmp/tmpvvivatjr.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(auto &e: string) {\n        if(e == '[') {\n            st.push(e);\n  \
    \      } else if(e == ']') {\n            if(st.empty()) return false;\n     \
    \       else st.pop();\n        }\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmppw23v7ow: /tmp/tmppw23v7ow.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121146
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmprfqm27px: /tmp/tmprfqm27px.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  int\
    \ len = string.length();\n  if(string.length() == 0)\n    return false;\n  if(string.length()\
    \ == 1)\n    return false;\n  if(string[0] == ']' || string[len-1] == '[')\n \
    \   return false;\n  for(int i = 0; i < len; i++) {\n    if(string[i] == '[')\
    \ {\n      stack.push(string[i]);\n    }\n    else if(string[i] == ']') {\n  \
    \    if(stack.empty())\n        return false;\n      stack.pop();\n    }\n  }\n\
    \  if(stack.empty())\n    return true;\n  else\n    return false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpskr4jhdb: /tmp/tmpskr4jhdb.cpp:46: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> stck;\n  bool\
    \ ans = false;\n  for(char c : string) {\n    if(c == '[')\n      stck.push(c);\n\
    \    else if(c == ']') {\n      if(stck.size() == 0)\n        ans = false;\n \
    \     else {\n        stck.pop();\n        ans = true;\n      }\n    }\n  }\n\
    \  return ans;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmplzfw_6a4: /tmp/tmplzfw_6a4.cpp:38: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint n = string.length();\n\t\
    std::stack<char> st;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (string[i] == '[')\
    \ {\n\t\t\tst.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\t\
    if (st.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t\
    }\n\tif (st.empty()) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpsfpd6n2_: /tmp/tmpsfpd6n2_.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\t// if string is empty or contains\
    \ characters other than '[' or ']'\n\tif (string.empty() || string.find_first_not_of(\"\
    []\") != std::string::npos) {\n\t\treturn false;\n\t}\n\t// if string contains\
    \ '[' and ']'\n\tif (string.find_first_of(\"[\") != std::string::npos &&\n\t\t\
    string.find_first_of(\"]\") != std::string::npos) {\n\t\tstd::string a = string.substr(0,\
    \ string.find_first_of(\"]\"));\n\t\tstd::string b = string.substr(string.find_first_of(\"\
    ]\") + 1);\n\t\treturn is_nested(a) || is_nested(b);\n\t}\n\t// if string contains\
    \ '[' only\n\tif (string.find_first_of(\"[\") != std::string::npos) {\n\t\treturn\
    \ is_nested(string.substr(1));\n\t}\n\t// if string contains ']' only\n\tif (string.find_first_of(\"\
    ]\") != std::string::npos) {\n\t\treturn is_nested(string.substr(0, string.size()\
    \ - 1));\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph1hirwyq: /tmp/tmph1hirwyq.cpp:42: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint depth=0;\n\tint len=string.length();\n\
    \tfor(int i=0;i<len;i++){\n\t\tif(string[i]=='['){\n\t\t\tdepth++;\n\t\t}\n\t\t\
    else if(string[i]==']'){\n\t\t\tdepth--;\n\t\t}\n\t\tif(depth<0){\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn depth>0;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsjpx02au: /tmp/tmpsjpx02au.cpp:36: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code here\n    int\
    \ count = 0;\n    for(unsigned int i = 0; i < string.length(); i++){\n       \
    \ if(string[i] == '['){\n            count += 1;\n        }\n        else if(string[i]\
    \ == ']'){\n            count -= 1;\n        }\n        if(count < 0){\n     \
    \       return false;\n        }\n    }\n    if(count > 0){\n        return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp7eemxr6l: /tmp/tmp7eemxr6l.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tint i=0;\n\
    \twhile(i<string.length()){\n\t\tif(string[i]=='[')\n\t\t\ts.push(string[i]);\n\
    \t\telse{\n\t\t\tif(s.empty())\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\ts.pop();\n\
    \t\t}\n\t\ti++;\n\t}\n\tif(s.empty())\n\t\treturn true;\n\telse\n\t\treturn false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpb8_8kjgp: /tmp/tmpb8_8kjgp.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stk;\n  \
    \  int len = string.length();\n    for(int i = 0; i < len; i++) {\n        char\
    \ ch = string[i];\n        if(ch == '[') {\n            stk.push(ch);\n      \
    \  }\n        else if(ch == ']') {\n            if(stk.empty()) {\n          \
    \      return false;\n            }\n            stk.pop();\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpelzl_g7u: /tmp/tmpelzl_g7u.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  stack<char> st;\n  int n = string.length();\n\
    \  if(n%2!=0)\n    return false;\n  for(int i=0;i<n;i++){\n    if(string[i]=='[')\n\
    \      st.push(string[i]);\n    else if(string[i]==']'){\n      if(st.empty())\n\
    \        return false;\n      else if(st.top()=='[')\n        st.pop();\n    \
    \  else\n        return false;\n    }\n  }\n  if(st.empty())\n    return true;\n\
    \  else\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpn0uwq6zx.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpn0uwq6zx.cpp:19:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |   stack<char> st;\n   \
    \   |   ^~~~~\n      |   std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpn0uwq6zx.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpn0uwq6zx.cpp:19:9: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |   stack<char> st;\n      |         ^~~~\n/tmp/tmpn0uwq6zx.cpp:25:7:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   25 |       st.push(string[i]);\n      |       ^~\n      |       std\n/tmp/tmpn0uwq6zx.cpp:27:10:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   27 |       if(st.empty())\n      |          ^~\n      |          std\n/tmp/tmpn0uwq6zx.cpp:35:6:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   35 |   if(st.empty())\n      |      ^~\n      |      std\n/tmp/tmpn0uwq6zx.cpp:39:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   39 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\ts.push(string[i]);\n\
    \t\telse {\n\t\t\tif (s.empty())\n\t\t\t\treturn false;\n\t\t\ts.pop();\n\t\t\
    }\n\t}\n\treturn !s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpo_8jt3_c: /tmp/tmpo_8jt3_c.cpp:33: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int left_bracket = 0;\n  \
    \  int right_bracket = 0;\n    for (int i = 0; i < string.length(); i++) {\n \
    \       if (string[i] == '[') {\n            left_bracket++;\n        }\n    \
    \    if (string[i] == ']') {\n            right_bracket++;\n        }\n      \
    \  if (right_bracket > left_bracket) {\n            return false;\n        }\n\
    \    }\n    if (left_bracket == right_bracket) {\n        return true;\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpv4b24q4t: /tmp/tmpv4b24q4t.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (auto\
    \ i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n        \
    \    count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpiptkn1qg: /tmp/tmpiptkn1qg.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint counter = 0;\n\tfor (char\
    \ a : string) {\n\t\tif (a == '[') {\n\t\t\tcounter += 1;\n\t\t}\n\t\telse if\
    \ (a == ']') {\n\t\t\tcounter -= 1;\n\t\t}\n\t\tif (counter < 0) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm7r8vrm5: /tmp/tmpm7r8vrm5.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    if(string.size()%2 != 0)\n\
    \        return false;\n    std::stack<char> s;\n    std::string::iterator it\
    \ = string.begin();\n    for(; it != string.end(); it++) {\n        if(*it ==\
    \ '[') {\n            s.push(*it);\n        }\n        else if(*it == ']') {\n\
    \            if(s.size()>0 && s.top() == '[') {\n                s.pop();\n  \
    \          }\n            else {\n                return false;\n            }\n\
    \        }\n    }\n    if(s.size() == 0)\n        return true;\n    else\n   \
    \     return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpk8ixhib1: /tmp/tmpk8ixhib1.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    bool is_even = string.length()\
    \ % 2 == 0;\n    bool is_odd = string.length() % 2 != 0;\n    bool is_balanced\
    \ = true;\n    bool found_square_bracket = false;\n    std::stack<char> char_stack;\n\
    \    int i = 0;\n    while (i < string.length()) {\n        if (is_balanced) {\n\
    \            if (string[i] == '[') {\n                char_stack.push(string[i]);\n\
    \                found_square_bracket = true;\n            } else if (string[i]\
    \ == ']') {\n                if (char_stack.size() == 0) {\n                 \
    \   is_balanced = false;\n                } else {\n                    char_stack.pop();\n\
    \                }\n            }\n        }\n        i++;\n    }\n    return\
    \ is_balanced && found_square_bracket && (is_even ? char_stack.size() == 0 : char_stack.size()\
    \ == 1);\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6xuqgih4: /tmp/tmp6xuqgih4.cpp:46: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int n = string.length();\n \
    \ int i,j;\n  std::stack<char> s;\n  char ch;\n  for(i=0;i<n;i++)\n  {\n    if(string[i]=='[')\n\
    \    {\n      s.push(string[i]);\n    }\n    else if(string[i]==']')\n    {\n\
    \      if(s.empty())\n      {\n        return false;\n      }\n      ch = s.top();\n\
    \      s.pop();\n      if(s.empty())\n      {\n        s.push(ch);\n      }\n\
    \    }\n  }\n  return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsgs3cu96: /tmp/tmpsgs3cu96.cpp:48: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int c=0;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            c++;\n        }\n        else{\n   \
    \         c--;\n        }\n        if(c<0){\n            return false;\n     \
    \   }\n    }\n    if(c==0){\n        return true;\n    }\n    else{\n        return\
    \ false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3ycayzn7: /tmp/tmp3ycayzn7.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstack<char> s;\n\tchar x;\n\t\
    for (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '(' || string[i]\
    \ == '[' || string[i] == '{') {\n\t\t\ts.push(string[i]);\n\t\t\tcontinue;\n\t\
    \t}\n\t\tif (s.empty())\n\t\t\treturn false;\n\t\tswitch (string[i]) {\n\t\tcase\
    \ ')':\n\t\t\tx = s.top();\n\t\t\ts.pop();\n\t\t\tif (x == '{' || x == '[')\n\t\
    \t\t\treturn false;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tx = s.top();\n\t\t\ts.pop();\n\
    \t\t\tif (x == '(' || x == '[')\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase\
    \ ']':\n\t\t\tx = s.top();\n\t\t\ts.pop();\n\t\t\tif (x == '(' || x == '{')\n\t\
    \t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (s.empty());\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt7i5jzya.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpt7i5jzya.cpp:19:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |  stack<char> s;\n     \
    \ |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpt7i5jzya.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpt7i5jzya.cpp:19:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |  stack<char> s;\n      |        ^~~~\n/tmp/tmpt7i5jzya.cpp:23:4:\
    \ error: \u2018s\u2019 was not declared in this scope\n   23 |    s.push(string[i]);\n\
    \      |    ^\n/tmp/tmpt7i5jzya.cpp:26:7: error: \u2018s\u2019 was not declared\
    \ in this scope\n   26 |   if (s.empty())\n      |       ^\n/tmp/tmpt7i5jzya.cpp:30:8:\
    \ error: \u2018s\u2019 was not declared in this scope\n   30 |    x = s.top();\n\
    \      |        ^\n/tmp/tmpt7i5jzya.cpp:49:10: error: \u2018s\u2019 was not declared\
    \ in this scope\n   49 |  return (s.empty());\n      |          ^\n"
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::vector<int> openningBrackets;\n\
    \    std::vector<int> closingBrackets;\n    int n = string.length();\n    for(int\
    \ i = 0; i < n; i++) {\n        if(string[i] == '[') {\n            openningBrackets.push_back(i);\n\
    \        }\n        else {\n            closingBrackets.push_back(i);\n      \
    \  }\n    }\n    if(openningBrackets.size() == 0) {\n        return false;\n \
    \   }\n    for(int i = 0; i < openningBrackets.size(); i++) {\n        for(int\
    \ j = 0; j < closingBrackets.size(); j++) {\n            if(openningBrackets[i]\
    \ < closingBrackets[j]) {\n                return true;\n            }\n     \
    \   }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdbcczbqr: /tmp/tmpdbcczbqr.cpp:45: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  if(string.length() == 0){\n\
    \    return false;\n  }\n  std::stack<char> stack;\n  for(int i = 0; i < string.length();\
    \ i++){\n    if(string[i] == '['){\n      stack.push(string[i]);\n    }\n    else\
    \ if(string[i] == ']'){\n      if(stack.empty()){\n        return false;\n   \
    \   }\n      else{\n        stack.pop();\n      }\n    }\n  }\n  if(stack.empty()){\n\
    \    return true;\n  }\n  else{\n    return false;\n  }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp3ctwqhm_: /tmp/tmp3ctwqhm_.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    char bracket = string[i];\n   \
    \ if (bracket == '[') {\n      stack.push(bracket);\n    } else if (bracket ==\
    \ ']') {\n      if (stack.empty()) {\n        return false;\n      }\n      char\
    \ prev_bracket = stack.top();\n      if (prev_bracket == '[') {\n        stack.pop();\n\
    \      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpw20zke55: /tmp/tmpw20zke55.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tbool result = false;\n\tint\
    \ num_of_open_brackets = 0;\n\tint num_of_close_brackets = 0;\n\tfor (int i =\
    \ 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\tnum_of_open_brackets++;\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tnum_of_close_brackets++;\n\t\t\
    }\n\t}\n\tif (num_of_open_brackets > num_of_close_brackets) {\n\t\tresult = true;\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpd5mpodo0: /tmp/tmpd5mpodo0.cpp:37: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    bool flag = false;\n    int\
    \ pos = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string[i]\
    \ == '[') {\n            pos = i;\n            flag = true;\n            break;\n\
    \        }\n    }\n    if(flag == false) {\n        return false;\n    }\n   \
    \ while(flag) {\n        if(string[pos] == ']') {\n            pos--;\n      \
    \      flag = false;\n            break;\n        }\n        else {\n        \
    \    pos++;\n        }\n    }\n    if(flag == false) {\n        return true;\n\
    \    }\n    else {\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsw5sqn79: /tmp/tmpsw5sqn79.cpp:51: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    st.pop();\n        }\n    }\n    if(st.empty()){\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpwmcu8aia: /tmp/tmpwmcu8aia.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> bracket;\n\
    \    for(char c : string) {\n        if(c == '[') {\n            bracket.push(c);\n\
    \        }\n        else if(c == ']') {\n            if(bracket.empty()) {\n \
    \               return false;\n            }\n            bracket.pop();\n   \
    \     }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpse31izb6: /tmp/tmpse31izb6.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint sum = 0;\n\tfor (int i =\
    \ 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\tsum++;\n\t\
    \t}\n\t\telse if (string[i] == ']') {\n\t\t\tsum--;\n\t\t}\n\t\tif (sum < 0) {\n\
    \t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpz1ifmq8u: /tmp/tmpz1ifmq8u.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint len = string.length();\n\
    \tint count = 0;\n\tint flag = 0;\n\tfor (int i = 0; i < len; i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\
    \treturn false;\n\t}\n\tfor (int i = 0; i < len; i++) {\n\t\tif (string[i] ==\
    \ '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp71vro38h: /tmp/tmp71vro38h.cpp:47: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int l = 0;\n  for (int i = 0;\
    \ i < string.length(); i++) {\n    if (string[i] == '[') {\n      l++;\n    }\
    \ else {\n      l--;\n    }\n    if (l < 0) {\n      return false;\n    }\n  }\n\
    \  return l == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmplw0ro8ce: /tmp/tmplw0ro8ce.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  std::unordered_map<char,\
    \ char> pairs;\n  pairs['['] = ']';\n  pairs['('] = ')';\n  pairs['{'] = '}';\n\
    \  for (char c : string) {\n    if (c == '[' || c == '(' || c == '{') {\n    \
    \  stack.push(c);\n    } else if (c == ']' || c == ')' || c == '}') {\n      if\
    \ (stack.empty()) {\n        return false;\n      }\n      char top = stack.top();\n\
    \      if (pairs[top] == c) {\n        stack.pop();\n      } else {\n        return\
    \ false;\n      }\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6r_fi938: /tmp/tmp6r_fi938.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::string input_string =\
    \ string;\n    int closing_bracket_index = -1;\n    int is_substring_complete\
    \ = 0;\n    std::string output_string = \"\";\n    // Checking the input string\
    \ for an invalid input\n    for (int i = 0; i < input_string.length(); i++) {\n\
    \        if (input_string[i] != '[' && input_string[i] != ']') {\n           \
    \ // Return false if the input is not valid\n            return false;\n     \
    \   }\n    }\n    // Creating the output string\n    while (is_substring_complete\
    \ == 0) {\n        int opening_bracket_index = -1;\n        // Finding the next\
    \ bracket\n        if (input_string.find(\"[\") == std::string::npos) {\n    \
    \        // If no more brackets are found, break the loop\n            break;\n\
    \        }\n        // Finding the next bracket in the string\n        for (int\
    \ i = 0; i < input_string.length(); i++) {\n            if (input_string[i] ==\
    \ '[') {\n                opening_bracket_index = i;\n                break;\n\
    \            }\n        }\n        int temporary_index = opening_bracket_index;\n\
    \        // Checking if there is a matching bracket in the string\n        while\
    \ (input_string[temporary_index] != ']') {\n            if (temporary_index ==\
    \ input_string.length() - 1) {\n                // If there is no matching bracket,\
    \ return false\n                return false;\n            }\n            temporary_index++;\n\
    \        }\n        // Finding the matching bracket in the string\n        for\
    \ (int i = opening_bracket_index; i < input_string.length(); i++) {\n        \
    \    if (input_string[i] == ']') {\n                closing_bracket_index = i;\n\
    \                break;\n            }\n        }\n        // Creating the output\
    \ string\n        if (opening_bracket_index != -1 && closing_bracket_index !=\
    \ -1) {\n            output_string = output_string + input_string.substr(opening_bracket_index,\
    \ (closing_bracket_index - opening_bracket_index + 1));\n           \n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpllv_gwyb.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpllv_gwyb.cpp:66:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   66 | int main() {\n      |            ^\n/tmp/tmpllv_gwyb.cpp:82:1:\
    \ error: expected \u2018}\u2019 at end of input\n   82 | }\n      | ^\n/tmp/tmpllv_gwyb.cpp:31:40:\
    \ note: to match this \u2018{\u2019\n   31 |     while (is_substring_complete\
    \ == 0) {\n      |                                        ^\n/tmp/tmpllv_gwyb.cpp:82:1:\
    \ error: expected \u2018}\u2019 at end of input\n   82 | }\n      | ^\n/tmp/tmpllv_gwyb.cpp:18:36:\
    \ note: to match this \u2018{\u2019\n   18 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmpllv_gwyb.cpp:82:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   82 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint sum = 0;\n\tfor (auto ch\
    \ : string) {\n\t\tsum += (ch == '[' ? 1 : -1);\n\t\tif (sum < 0) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn sum == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsdlqc1fu: /tmp/tmpsdlqc1fu.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstack<char> str;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\tstr.push(string[i]);\n\
    \t\telse if (string[i] == ']') {\n\t\t\tif (str.empty())\n\t\t\t\treturn false;\n\
    \t\t\telse if (str.top() == '[')\n\t\t\t\tstr.pop();\n\t\t\telse\n\t\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn str.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpadj6xrau.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpadj6xrau.cpp:19:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |  stack<char> str;\n   \
    \   |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpadj6xrau.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpadj6xrau.cpp:19:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |  stack<char> str;\n      |        ^~~~\n/tmp/tmpadj6xrau.cpp:22:4:\
    \ error: \u2018str\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   22 |    str.push(string[i]);\n      |    ^~~\n      |    std\n/tmp/tmpadj6xrau.cpp:24:8:\
    \ error: \u2018str\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   24 |    if (str.empty())\n      |        ^~~\n      |        std\n/tmp/tmpadj6xrau.cpp:32:9:\
    \ error: \u2018str\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   32 |  return str.empty();\n      |         ^~~\n      |         std\n"
  stdout: ''
  timestamp: 1660121147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(auto it = string.begin(); it != string.end(); it++) {\n        char ch =\
    \ *it;\n        if(ch == '[') {\n            st.push(ch);\n        } else if(ch\
    \ == ']') {\n            if(st.empty()) {\n                return false;\n   \
    \         } else {\n                if(st.top() == '[') {\n                  \
    \  st.pop();\n                } else {\n                    return false;\n  \
    \              }\n            }\n        }\n    }\n    return st.empty();\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp5vxg8d4r: /tmp/tmp5vxg8d4r.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count > 0 ? false : true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpl4mqik6j: /tmp/tmpl4mqik6j.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> bracket_stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            bracket_stack.push(string[i]);\n        } else if (string[i]\
    \ == ']') {\n            if (bracket_stack.empty()) {\n                return\
    \ false;\n            } else {\n                bracket_stack.pop();\n       \
    \     }\n        }\n    }\n    return bracket_stack.empty();\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1jia19iz: /tmp/tmp1jia19iz.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\n\tfor\
    \ (unsigned int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\
    \ {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\t\
    if (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\
    \t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\t}\n\telse {\n\t\t\
    return false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpgm1at7p_: /tmp/tmpgm1at7p_.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count > 0 ? false : true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpl4mqik6j: /tmp/tmpl4mqik6j.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int count1 = 0;\n  int count2\
    \ = 0;\n  int count3 = 0;\n  int count4 = 0;\n  int count5 = 0;\n  int count6\
    \ = 0;\n  int count7 = 0;\n  int count8 = 0;\n  int count9 = 0;\n  int count10\
    \ = 0;\n  int count11 = 0;\n  int count12 = 0;\n  int count13 = 0;\n  int count14\
    \ = 0;\n  int count15 = 0;\n  int count16 = 0;\n  int count17 = 0;\n  int count18\
    \ = 0;\n  int count19 = 0;\n  int count20 = 0;\n  int count21 = 0;\n  int count22\
    \ = 0;\n  int count23 = 0;\n  int count24 = 0;\n  int count25 = 0;\n  int count26\
    \ = 0;\n  int count27 = 0;\n  int count28 = 0;\n  int count29 = 0;\n  int count30\
    \ = 0;\n  int count31 = 0;\n  int count32 = 0;\n  int count33 = 0;\n  int count34\
    \ = 0;\n  int count35 = 0;\n  int count36 = 0;\n  int count37 = 0;\n  int count38\
    \ = 0;\n  int count39 = 0;\n  int count40 = 0;\n  int count41 = 0;\n  int count42\
    \ = 0;\n  int count43 = 0;\n  int count44 = 0;\n  int count45 = 0;\n  int count46\
    \ = 0;\n  int count47 = 0;\n  int count48 = 0;\n  int count49 = 0;\n  int count50\
    \ = 0;\n  int count51 = 0;\n  int count52 = 0;\n  int count53 = 0;\n  int count54\
    \ = 0;\n  int count55 = 0;\n  int count56 = 0;\n  int count57 = 0;\n  int count58\
    \ = 0;\n  int count59 = 0;\n  int count60 = 0;\n  int count61 = 0;\n  int count62\
    \ = 0;\n  int count63 = 0;\n  int count64 = 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpt3bh2axg: /tmp/tmpt3bh2axg.cpp:86: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Iterate each character\
    \ in string\n    // If it is opening bracket, push it to the stack\n    // If\
    \ it is closing bracket, pop one element from the stack\n    // If the stack is\
    \ empty, return false\n    // If at the end of iteration, the stack is empty,\
    \ return true\n    std::stack<char> brackets;\n    for (char c : string) {\n \
    \       if (c == '[') {\n            brackets.push(c);\n        } else if (c ==\
    \ ']') {\n            if (brackets.empty()) {\n                return false;\n\
    \            }\n            brackets.pop();\n        }\n    }\n    return brackets.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpdoo86ti0: /tmp/tmpdoo86ti0.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstack<char> brackets;\n\n\t\
    for (int i = 0; i < string.length(); i++) {\n\t\t//I AM SO SORRY ABOUT THIS\n\t\
    \tif (string[i] == '[' && string[i + 1] == '[' && i < string.length() - 1) {\n\
    \t\t\tbrackets.push(string[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if (string[i] ==\
    \ '[' && string[i + 1] == ']') {\n\t\t\treturn true;\n\t\t}\n\t\telse if (string[i]\
    \ == '[' && string[i + 1] == '[' && i < string.length() - 1) {\n\t\t\tbrackets.push(string[i]);\n\
    \t\t\ti++;\n\t\t}\n\t\telse if (string[i] == '[' && string[i + 1] == ']') {\n\t\
    \t\treturn true;\n\t\t}\n\t\telse if (string[i] == '[' && string[i + 1] == '['\
    \ && i < string.length() - 1) {\n\t\t\tbrackets.push(string[i]);\n\t\t\ti++;\n\
    \t\t}\n\t\telse if (string[i] == '[' && string[i + 1] == ']') {\n\t\t\treturn\
    \ true;\n\t\t}\n\t\telse if (string[i] == '[' && string[i + 1] == '[' && i < string.length()\
    \ - 1) {\n\t\t\tbrackets.push(string[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if (string[i]\
    \ == '[' && string[i + 1] == ']') {\n\t\t\treturn true;\n\t\t}\n\t\telse if (string[i]\
    \ == '[' && string[i + 1] == '[' && i < string.length() - 1) {\n\t\t\tbrackets.push(string[i]);\n\
    \t\t\ti++;\n\t\t}\n\t\telse if (string[i] == '[' && string[i + 1] == ']') {\n\t\
    \t\treturn true;\n\t\t}\n\t\telse if (string[i]\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpnd6fwd9t.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpnd6fwd9t.cpp:19:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |  stack<char> brackets;\n\
    \      |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpnd6fwd9t.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpnd6fwd9t.cpp:19:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |  stack<char> brackets;\n      |        ^~~~\n\
    /tmp/tmpnd6fwd9t.cpp:24:4: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   24 |    brackets.push(string[i]);\n      |    ^~~~~~~~\n/tmp/tmpnd6fwd9t.cpp:31:4:\
    \ error: \u2018brackets\u2019 was not declared in this scope\n   31 |    brackets.push(string[i]);\n\
    \      |    ^~~~~~~~\n/tmp/tmpnd6fwd9t.cpp:38:4: error: \u2018brackets\u2019 was\
    \ not declared in this scope\n   38 |    brackets.push(string[i]);\n      |  \
    \  ^~~~~~~~\n/tmp/tmpnd6fwd9t.cpp:45:4: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   45 |    brackets.push(string[i]);\n      |    ^~~~~~~~\n/tmp/tmpnd6fwd9t.cpp:52:4:\
    \ error: \u2018brackets\u2019 was not declared in this scope\n   52 |    brackets.push(string[i]);\n\
    \      |    ^~~~~~~~\n/tmp/tmpnd6fwd9t.cpp:58:21: error: expected \u2018)\u2019\
    \ before \u2018}\u2019 token\n   58 |   else if (string[i]\n      |          \
    \ ~         ^\n      |                     )\n   59 | }\n      | ~           \
    \         \n/tmp/tmpnd6fwd9t.cpp:59:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n   59 | }\n      | ^\n/tmp/tmpnd6fwd9t.cpp:60:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   60\
    \ | int main() {\n      |            ^\n/tmp/tmpnd6fwd9t.cpp:76:1: error: expected\
    \ \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpnd6fwd9t.cpp:18:36:\
    \ note: to match this \u2018{\u2019\n   18 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmpn"
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int dif = 0;\n    for (char\
    \ c : string) {\n        if (c == '[') {\n            dif++;\n        } else if\
    \ (c == ']') {\n            dif--;\n        }\n        if (dif < 0) {\n      \
    \      return false;\n        }\n    }\n    return dif > 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpq_sh6a11: /tmp/tmpq_sh6a11.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  int counter = 0;\n  for (int\
    \ i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n      counter++;\n\
    \    } else if (string[i] == ']') {\n      counter--;\n    }\n    if (counter\
    \ < 0) {\n      return false;\n    }\n  }\n  return counter == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwmminnzu: /tmp/tmpwmminnzu.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121145
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstack<char> s;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4cl6bkox.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp4cl6bkox.cpp:19:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |  stack<char> s;\n     \
    \ |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp4cl6bkox.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp4cl6bkox.cpp:19:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |  stack<char> s;\n      |        ^~~~\n/tmp/tmp4cl6bkox.cpp:22:4:\
    \ error: \u2018s\u2019 was not declared in this scope\n   22 |    s.push(string[i]);\n\
    \      |    ^\n/tmp/tmp4cl6bkox.cpp:25:8: error: \u2018s\u2019 was not declared\
    \ in this scope\n   25 |    if (s.empty()) {\n      |        ^\n/tmp/tmp4cl6bkox.cpp:33:6:\
    \ error: \u2018s\u2019 was not declared in this scope\n   33 |  if (s.empty())\
    \ {\n      |      ^\n/tmp/tmp4cl6bkox.cpp:39:1: warning: control reaches end of\
    \ non-void function [-Wreturn-type]\n   39 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> st;\n\tfor\
    \ (char c : string) {\n\t\tif (c == '[') {\n\t\t\tst.push(c);\n\t\t} else if (c\
    \ == ']') {\n\t\t\tif (st.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\
    \t\t}\n\t}\n\treturn !st.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph4ly9gsv: /tmp/tmph4ly9gsv.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint count=0;\n\tint n=string.length();\n\
    \tfor(int i=0;i<n;i++)\n\t{\n\t\tif(string[i]=='[')\n\t\t\tcount++;\n\t\telse\
    \ if(string[i]==']')\n\t\t\tcount--;\n\t\tif(count<0)\n\t\t\treturn false;\n\t\
    }\n\treturn count==0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpg24f26k7: /tmp/tmpg24f26k7.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n  stack<char> brackets;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n     \
    \ brackets.push(string[i]);\n    } else if (string[i] == ']') {\n      if (brackets.empty())\
    \ {\n        return false;\n      } else {\n        brackets.pop();\n      }\n\
    \    }\n  }\n  return brackets.empty();\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp9a0tvuh8.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp9a0tvuh8.cpp:19:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   19 |   stack<char> brackets;\n\
    \      |   ^~~~~\n      |   std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp9a0tvuh8.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp9a0tvuh8.cpp:19:9: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |   stack<char> brackets;\n      |         ^~~~\n\
    /tmp/tmp9a0tvuh8.cpp:22:7: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   22 |       brackets.push(string[i]);\n      |       ^~~~~~~~\n/tmp/tmp9a0tvuh8.cpp:24:11:\
    \ error: \u2018brackets\u2019 was not declared in this scope\n   24 |       if\
    \ (brackets.empty()) {\n      |           ^~~~~~~~\n/tmp/tmp9a0tvuh8.cpp:31:10:\
    \ error: \u2018brackets\u2019 was not declared in this scope\n   31 |   return\
    \ brackets.empty();\n      |          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660121148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\t// find a way to track when\
    \ a bracket is nested and when it isn't.\n\tint count = 0;\n\t// for the length\
    \ of the string.\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t// if a bracket\
    \ is nested do something.\n\t\tif (string[i] == '[') {\n\t\t\tcount++;\n\t\t}\n\
    \t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\t\t}\n\t\t// if the count is\
    \ equal to less than 0.\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\t// if the count is not equal to 0.\n\tif (count != 0) {\n\t\treturn false;\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4nxk56a2: /tmp/tmp4nxk56a2.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> brackets;\n\
    \tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\
    \t\tbrackets.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\t\
    if (brackets.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\
    brackets.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (brackets.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5xy1y3mg: /tmp/tmp5xy1y3mg.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int k=0;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            k+=1;\n        }\n        else if(string[i]==']'){\n\
    \            k-=1;\n        }\n        if(k<0){\n            return false;\n \
    \       }\n    }\n    if(k!=0){\n        return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp97sld_8y: /tmp/tmp97sld_8y.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // TODO: Implement this function\n\
    \    std::stack<char> brackets;\n    for(char bracket : string) {\n        if(bracket\
    \ == '[') {\n            brackets.push(bracket);\n        } else if(bracket ==\
    \ ']') {\n            if(brackets.empty()) {\n                return false;\n\
    \            } else {\n                brackets.pop();\n            }\n      \
    \  }\n    }\n    return brackets.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpb_2xpehp: /tmp/tmpb_2xpehp.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\n\
    \            stack.push(string[i]);\n        else if (string[i] == ']') {\n  \
    \          if (stack.empty())\n                return false;\n            if (stack.top()\
    \ == '[')\n                stack.pop();\n            else\n                return\
    \ false;\n        }\n    }\n    return stack.empty();\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpyc078j_6: /tmp/tmpyc078j_6.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::vector<char> stack;\n\t\
    for (auto c : string) {\n\t\tif (c == '[') {\n\t\t\tstack.push_back(c);\n\t\t\
    } else if (c == ']') {\n\t\t\tif (stack.size() == 0) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\tstack.pop_back();\n\t\t}\n\t}\n\tif (stack.size() > 0) {\n\t\t\
    return false;\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnxdn_tzl: /tmp/tmpnxdn_tzl.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint len = string.length();\n\
    \tstd::stack<char> s;\n\tfor (int i = 0; i < len; i++) {\n\t\tif (string[i] ==\
    \ '[')\n\t\t\ts.push(string[i]);\n\t\telse {\n\t\t\tif (s.empty())\n\t\t\t\treturn\
    \ false;\n\t\t\telse\n\t\t\t\ts.pop();\n\t\t}\n\t}\n\tif (s.empty())\n\t\treturn\
    \ true;\n\telse\n\t\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr3yfzo07: /tmp/tmpr3yfzo07.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tint count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[')\n\t\t\tcount++;\n\
    \t\telse if (string[i] == ']')\n\t\t\tcount--;\n\t\tif (count < 0)\n\t\t\treturn\
    \ false;\n\t}\n\treturn count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpp_dh94zn: /tmp/tmpp_dh94zn.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Iterate through the string,\
    \ checking if the brackets are nested\n    std::stack<char> stack;\n    for (char\
    \ c : string) {\n        if (c == '[') {\n            stack.push(c);\n       \
    \ } else if (c == ']') {\n            if (stack.empty()) {\n                return\
    \ false;\n            } else {\n                stack.pop();\n            }\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpew695u3r: /tmp/tmpew695u3r.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (char\
    \ ch : string) {\n        if (ch == '[') {\n            count++;\n        } else\
    \ if (ch == ']') {\n            count--;\n        }\n        if (count < 0) {\n\
    \            return false;\n        }\n    }\n    return count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmppjnzo2hl: /tmp/tmppjnzo2hl.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return true if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int len = string.length();\n\
    \    int stk[len];\n    int n = 0;\n    for(int i = 0; i < len; i++) {\n     \
    \   if(string[i] == '[')\n            stk[n++] = i;\n        else if(string[i]\
    \ == ']') {\n            if(n != 0) {\n                if(string[stk[n-1]] ==\
    \ '[')\n                    n--;\n                else\n                    return\
    \ false;\n            }\n            else\n                return false;\n   \
    \     }\n    }\n    if(n == 0)\n        return true;\n    else\n        return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3m2b5krc: /tmp/tmp3m2b5krc.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121149
