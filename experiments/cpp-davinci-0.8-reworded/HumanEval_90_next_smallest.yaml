name: HumanEval_90_next_smallest
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of\
  \ integers.\n// Write a function next_smallest() that returns the 2nd smallest element\
  \ of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5,\
  \ (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n\
  // std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n\
  // std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n"
tests: "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5,\
  \ (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>()))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1})))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
  \ (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35,\
  \ (long)34, (long)12, (long)-45}))) == -35);\n}\n"
completions: ["\tif (lst.size() == 0)\n\t\treturn std::nullopt;\n\tstd::sort(lst.begin(),\
    \ lst.end());\n\tfor (int i = 0; i < lst.size() - 1; i++) {\n\t\tif (lst[i] !=\
    \ lst[i + 1])\n\t\t\treturn lst[i + 1];\n\t}\n\treturn std::nullopt;", "    std::sort(lst.begin(),\
    \ lst.end());\n    long prev = lst[0];\n    for (long i=1; i<lst.size(); i++)\
    \ {\n        if (lst[i] == prev) continue;\n        return std::optional<long>(lst[i]);\n\
    \    }\n    return std::nullopt;", "    if (lst.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    std::sort(lst.begin(), lst.end());\n    auto last\
    \ = std::unique(lst.begin(), lst.end());\n    lst.erase(last, lst.end());\n  \
    \  if (lst.size() < 2) {\n        return std::nullopt;\n    }\n    return lst[1];",
  "    if (lst.size() < 2) return std::nullopt;\n    std::vector<long> v;\n    long\
    \ min = lst[0];\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i]\
    \ < min) min = lst[i];\n    }\n    for (int i = 0; i < lst.size(); i++) {\n  \
    \      if (lst[i] > min) v.push_back(lst[i]);\n    }\n    if (v.size() == 0) return\
    \ std::nullopt;\n    long second_min = v[0];\n    for (int i = 0; i < v.size();\
    \ i++) {\n        if (v[i] < second_min) second_min = v[i];\n    }\n    return\
    \ second_min;", "    std::optional<long> ans = std::nullopt;\n    long n = lst.size();\n\
    \    if (n == 0) {\n        return ans;\n    }\n    else if (n == 1) {\n     \
    \   return ans;\n    }\n    else if (n == 2) {\n        if (lst[0] != lst[1])\
    \ {\n            if (lst[0] < lst[1]) {\n                ans = lst[1];\n     \
    \       }\n            else {\n                ans = lst[0];\n            }\n\
    \        }\n        return ans;\n    }\n    else {\n        std::vector<long>\
    \ tmp;\n        for (int i = 0; i < n; i++) {\n            tmp.push_back(lst[i]);\n\
    \        }\n        std::sort(tmp.begin(), tmp.end());\n        for (int i = 0;\
    \ i < n; i++) {\n            lst[i] = tmp[i];\n        }\n        for (int i =\
    \ 0; i < n; i++) {\n            if (lst[i] != lst[i + 1]) {\n                ans\
    \ = lst[i + 1];\n                break;\n            }\n        }\n        return\
    \ ans;\n    }", "    long ret_value=0;\n    long n = lst.size();\n    if(n==0)\
    \ return std::nullopt;\n    std::vector<long> temp_lst(lst);\n    // Implement\
    \ your solution below.\n    sort(temp_lst.begin(), temp_lst.end());\n    if(temp_lst[0]==temp_lst[n-1])\
    \ return std::nullopt;\n    else ret_value = temp_lst[1];\n    return ret_value;",
  "    std::sort(lst.begin(), lst.end());\n    std::vector<long>::iterator u = std::unique(lst.begin(),\
    \ lst.end());\n    lst.resize(std::distance(lst.begin(), u));\n    if (lst.size()\
    \ >= 2) {\n        return lst[1];\n    }\n    return std::nullopt;", "    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    std::sort(lst.begin(), lst.end());\n\
    \    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    if (lst.size()\
    \ == 2) {\n        if (lst[0] == lst[1]) {\n            return std::nullopt;\n\
    \        }\n        return lst[1];\n    }\n    for (long i = 1; i < lst.size();\
    \ i++) {\n        if (lst[i - 1] != lst[i]) {\n            return lst[i];\n  \
    \      }\n    }\n    return std::nullopt;", "\tint x,y;\n\tstd::optional<long>\
    \ var;\n\tif(lst.size()==0)\n\t{\n\t\treturn var;\n\t}\n\tx=*min_element(lst.begin(),lst.end());\n\
    \tstd::remove(lst.begin(),lst.end(),x);\n\tif(lst.size()==0)\n\t{\n\t\treturn\
    \ var;\n\t}\n\ty=*min_element(lst.begin(),lst.end());\n\tvar=y;\n\treturn var;",
  "\tif (lst.size() < 2) {\n\t\treturn std::nullopt;\n\t}\n\tstd::vector<long>::iterator\
    \ it = lst.begin();\n\tlong smallest = *it;\n\tlong next_smallest = *(it + 1);\n\
    \tit++;\n\twhile (it != lst.end()) {\n\t\tif (smallest == next_smallest) {\n\t\
    \t\tnext_smallest = *it;\n\t\t}\n\t\tif (*it < smallest) {\n\t\t\tnext_smallest\
    \ = smallest;\n\t\t\tsmallest = *it;\n\t\t}\n\t\telse if (*it < next_smallest)\
    \ {\n\t\t\tnext_smallest = *it;\n\t\t}\n\t\tit++;\n\t}\n\tif (smallest == next_smallest)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\treturn next_smallest;", "    if (lst.size()\
    \ < 2) return std::nullopt;\n    long min1 = std::numeric_limits<long>::max();\n\
    \    long min2 = std::numeric_limits<long>::max();\n    for (auto i : lst) {\n\
    \        if (i <= min1) {\n            min2 = min1;\n            min1 = i;\n \
    \       } else if (i < min2) {\n            min2 = i;\n        }\n    }\n    if\
    \ (min2 == std::numeric_limits<long>::max()) return std::nullopt;\n    return\
    \ min2;", "    std::sort(lst.begin(), lst.end());\n    return std::unique(lst.begin(),\
    \ lst.end()) == lst.end() ? std::optional<long>(lst[1]) : std::nullopt;", "  \
    \  std::optional<long> next_smallest = 0;\n    if (lst.size() < 2) {\n       \
    \ return next_smallest;\n    }\n    std::sort(lst.begin(), lst.end());\n    for\
    \ (int i = 0; i < lst.size() - 1; i++) {\n        if (lst[i + 1] != lst[i]) {\n\
    \            next_smallest = lst[i + 1];\n            break;\n        }\n    }\n\
    \    return next_smallest;", "    int n = lst.size();\n    int min = INT_MAX;\n\
    \    int secondMin = INT_MAX;\n    if(n < 2)\n        return std::nullopt;\n \
    \   if(n == 2)\n        return lst[1];\n    for(int i = 0; i < n; i++) {\n   \
    \     if(lst[i] < min) {\n            secondMin = min;\n            min = lst[i];\n\
    \        }\n        else if(lst[i] < secondMin && lst[i] != min)\n           \
    \ secondMin = lst[i];\n    }\n    if(secondMin == INT_MAX)\n        return std::nullopt;\n\
    \    return secondMin;", "\tlst.push_back(10000000);\n\tstd::sort(lst.begin(),\
    \ lst.end());\n\tfor (auto i = 0; i < lst.size() - 1; i++) {\n\t\tif (lst[i] ==\
    \ lst[i + 1]) continue;\n\t\tif (lst[i + 1] != lst[i] + 1) return lst[i + 1];\n\
    \t}\n\treturn std::nullopt;", "  // your code here\n  std::sort(lst.begin(), lst.end());\n\
    \  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  long next = lst[0];\n\
    \  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > next) {\n      return\
    \ next;\n    }\n    next = lst[i];\n  }\n  return std::nullopt;", "    // TODO:\
    \ Implement this function\n    // return std::nullopt;\n    std::sort(lst.begin(),\
    \ lst.end());\n    std::optional<long> none_num = std::nullopt;\n    if (lst.size()\
    \ == 0)\n        return none_num;\n    else if (lst.size() == 1)\n        return\
    \ none_num;\n    else if (lst.size() == 2) {\n        if (lst[0] == lst[1])\n\
    \            return none_num;\n        else\n            return lst[1];\n    }\n\
    \    else {\n        int min_index = 0;\n        int min_num = lst[0];\n     \
    \   int next_min_index = 0;\n        int next_min_num = lst[0];\n        for (int\
    \ i = 0; i < lst.size(); i++) {\n            if (lst[i] < min_num) {\n       \
    \         min_num = lst[i];\n                min_index = i;\n            }\n \
    \       }\n        for (int i = 0; i < lst.size(); i++) {\n            if (i ==\
    \ min_index)\n                continue;\n            if (lst[i] < next_min_num)\
    \ {\n                next_min_num = lst[i];\n                next_min_index =\
    \ i;\n            }\n        }\n        return next_min_num;\n    }", "    if\
    \ (lst.size() < 2) {\n        return std::nullopt;\n    }\n    std::sort(lst.begin(),\
    \ lst.end());\n    if (lst[0] == lst[1]) {\n        return std::nullopt;\n   \
    \ }\n    return lst[1];", "  // your code here\n  std::optional<long> result;\n\
    \  std::vector<long> newList;\n  std::sort(lst.begin(), lst.end());\n  for (int\
    \ i = 0; i < lst.size(); i++) {\n    if (lst[i] == lst[i+1]) {\n      continue;\n\
    \    }\n    else {\n      newList.push_back(lst[i]);\n    }\n  }\n  if (newList.size()\
    \ < 2) {\n    return result;\n  }\n  result = newList[1];\n  return result;",
  "    // Your code here.\n    // For printing, use std::cout << \"text\" << std::endl;\n\
    \    long n = lst.size();\n    if(n==0)\n        return {};\n    if(n==1)\n  \
    \      return {};\n    long ans = LONG_MAX;\n    std::sort(lst.begin(),lst.end());\n\
    \    for(long i=1;i<n;i++)\n    {\n        if(lst[i]!=lst[i-1])\n        {\n \
    \           ans = lst[i];\n            break;\n        }\n    }\n    if(ans==LONG_MAX)\n\
    \        return {};\n    return ans;", "\tstd::optional<long> result;\n\tif(lst.size()\
    \ == 0) return result;\n\tstd::set<long> slst(lst.begin(), lst.end());\n\tif(slst.size()\
    \ == 1) return result;\n\tstd::vector<long> v(slst.begin(), slst.end());\n\tresult\
    \ = v[1];\n\treturn result;", '    return 0;', "    if (lst.size() == 0) {\n \
    \       return std::nullopt;\n    } else if (lst.size() == 1) {\n        return\
    \ std::nullopt;\n    } else {\n        std::sort(lst.begin(), lst.end());\n  \
    \      auto itr = std::unique(lst.begin(), lst.end());\n        lst.resize(std::distance(lst.begin(),\
    \ itr));\n        if (lst.size() == 1) {\n            return std::nullopt;\n \
    \       } else {\n            return lst[1];\n        }\n    }", "\t// sort the\
    \ list\n\t// return the second element\n\t// if not found return nullopt\n\tif\
    \ (lst.size() <= 1) {\n\t\treturn std::nullopt;\n\t}\n\tsort(lst.begin(), lst.end());\n\
    \tif (lst[0] != lst[1]) {\n\t\treturn lst[1];\n\t}\n\telse {\n\t\tfor (int i =\
    \ 1; i < lst.size() - 1; i++) {\n\t\t\tif (lst[i] != lst[i + 1]) {\n\t\t\t\treturn\
    \ lst[i + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn std::nullopt;", "  long min_value\
    \ = std::numeric_limits<long>::max();\n  long min_value_2 = std::numeric_limits<long>::max();\n\
    \  for (long elem : lst) {\n    if (elem < min_value) {\n      min_value_2 = min_value;\n\
    \      min_value = elem;\n    } else if (elem < min_value_2) {\n      min_value_2\
    \ = elem;\n    }\n  }\n  if (min_value_2 == std::numeric_limits<long>::max())\
    \ {\n    return std::nullopt;\n  }\n  return min_value_2;", "\tif (lst.size()\
    \ < 2) {\n\t\treturn std::nullopt;\n\t}\n\tif (lst.size() == 2) {\n\t\tif (lst[0]\
    \ != lst[1]) {\n\t\t\treturn lst[1];\n\t\t}\n\t\treturn std::nullopt;\n\t}\n\t\
    std::sort(lst.begin(), lst.end());\n\tstd::vector<long> unique_sorted_list;\n\t\
    unique_sorted_list.push_back(lst[0]);\n\tfor (int i = 1; i < lst.size(); i++)\
    \ {\n\t\tif (lst[i] != lst[i - 1]) {\n\t\t\tunique_sorted_list.push_back(lst[i]);\n\
    \t\t}\n\t}\n\tif (unique_sorted_list.size() == 1) {\n\t\treturn std::nullopt;\n\
    \t}\n\treturn unique_sorted_list[1];", "    if (lst.size() == 0)\n        return\
    \ std::nullopt;\n    else if (lst.size() == 1)\n        return std::nullopt;\n\
    \    else {\n        long min = lst[0];\n        long min2 = lst[1];\n       \
    \ for (long i = 0; i < lst.size(); i++) {\n            if (lst[i] < min) {\n \
    \               min2 = min;\n                min = lst[i];\n            }\n  \
    \          else if (lst[i] < min2 && lst[i] != min) {\n                min2 =\
    \ lst[i];\n            }\n        }\n        if (min2 == min)\n            return\
    \ std::nullopt;\n        else\n            return min2;\n    }", "    std::optional<long>\
    \ first=std::nullopt;\n    if(lst.size()<=1) return first;\n    std::sort(lst.begin(),lst.end());\n\
    \    for(int i=0;i<lst.size()-1;i++){\n        if(lst[i]!=lst[i+1]){\n       \
    \     first=lst[i+1];\n            break;\n        }\n    }\n    return first;",
  "    auto sort_desc = [](auto a, auto b) {\n        return a > b;\n    };\n    std::sort(lst.begin(),\
    \ lst.end(), sort_desc);\n    if (lst.size() <= 1) {\n        return std::nullopt;\n\
    \    }\n    return *(++lst.begin());", "    if (lst.size()==0){\n        return\
    \ std::nullopt;\n    }\n    if (lst.size()==1){\n        return std::nullopt;\n\
    \    }\n    long min=lst[0];\n    long min2=lst[1];\n    for (int i=1;i<lst.size();i++){\n\
    \        if (lst[i]<min){\n            min2=min;\n            min=lst[i];\n  \
    \      }\n        else if (lst[i]<min2){\n            min2=lst[i];\n        }\n\
    \    }\n    if (min==min2){\n        return std::nullopt;\n    }\n    return min2;",
  "    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n    std::sort(lst.begin(),\
    \ lst.end());\n    long prev = lst[0];\n    for (auto el: lst) {\n        if (el\
    \ > prev) {\n            return el;\n        }\n        prev = el;\n    }\n  \
    \  return std::nullopt;", "    if (lst.size() < 2) return std::nullopt;\n    int\
    \ min1 = INT_MAX, min2 = INT_MAX;\n    for (auto i : lst) {\n        if (i < min1)\
    \ {\n            min2 = min1;\n            min1 = i;\n        } else if (i < min2\
    \ && i != min1) {\n            min2 = i;\n        }\n    }\n    if (min2 == INT_MAX)\
    \ return std::nullopt;\n    return min2;", "    std::sort(lst.begin(), lst.end());\n\
    \    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    if (lst.size()\
    \ == 1) {\n        return std::nullopt;\n    }\n    for (int i = 0; i < lst.size()\
    \ - 1; i++) {\n        if (lst[i] != lst[i + 1]) {\n            return lst[i +\
    \ 1];\n        }\n    }\n    return std::nullopt;", "\t// Insert your code here.\n\
    \    std::sort(lst.begin(), lst.end());\n    int arr[lst.size()], flag[lst.size()];\n\
    \    std::fill_n(flag, lst.size(), 1);\n    for(int i = 0; i < lst.size(); i++)\
    \ {\n        arr[i] = lst[i];\n    }\n    for(int i = 0; i < lst.size(); i++)\
    \ {\n        for(int j = i + 1; j < lst.size(); j++) {\n            if(arr[i]\
    \ == arr[j]) {\n                flag[i] = 0;\n                flag[j] = 0;\n \
    \           }\n        }\n    }\n    for(int i = 0; i < lst.size(); i++) {\n \
    \       if(flag[i] == 1) {\n            return arr[i];\n        }\n    }\n   \
    \ return std::nullopt;", "    if (lst.size() <= 1) return std::nullopt;\n    std::sort(lst.begin(),\
    \ lst.end());\n    for (auto i = lst.begin() + 1; i != lst.end(); i++) {\n   \
    \     if (*i > *(i - 1)) return *i;\n    }\n    return std::nullopt;", "    int\
    \ v1 = lst[0];\n    int v2 = lst[1];\n    if (v1 < v2)\n        std::swap(v1,\
    \ v2);\n    for (size_t i = 2; i < lst.size(); i++) {\n        long x = lst[i];\n\
    \        if (x < v1) {\n            v2 = v1;\n            v1 = x;\n        } else\
    \ if (x < v2) {\n            v2 = x;\n        }\n    }\n    if (v1 == v2)\n  \
    \      return std::nullopt;\n    return v2;", "  // TODO: implement this function\n\
    \  long second_smallest;\n  if(lst.size()==0)\n  {\n      return std::nullopt;\n\
    \  }\n  if(lst.size()==1)\n  {\n      return std::nullopt;\n  }\n  sort(lst.begin(),lst.end());\n\
    \  if(lst[0]==lst[1])\n  {\n      return std::nullopt;\n  }\n  second_smallest=lst[1];\n\
    \  return second_smallest;", "    if (lst.size() < 2) {\n        return std::nullopt;\n\
    \    }\n    std::sort(lst.begin(), lst.end());\n    if (lst[0] != lst[1]) {\n\
    \        return lst[1];\n    }\n    for (long i = 2; i < lst.size(); i++) {\n\
    \        if (lst[i] != lst[i - 1]) {\n            return lst[i];\n        }\n\
    \    }\n    return std::nullopt;", "    if (lst.size()==0) return std::nullopt;\n\
    \    std::sort(lst.begin(), lst.end());\n    long smallest = lst[0];\n    long\
    \ next_smallest = smallest;\n    bool flag = false;\n    for (int i=1; i<lst.size();\
    \ i++) {\n        if (lst[i]>smallest) {\n            next_smallest = lst[i];\n\
    \            flag = true;\n            break;\n        }\n    }\n    if (flag)\
    \ return next_smallest;\n    else return std::nullopt;", "    std::optional<long>\
    \ result = {};\n    if (lst.size() == 0) {\n        return result;\n    }\n  \
    \  std::optional<long> smallest = {lst[0]};\n    for (long& i : lst) {\n     \
    \   if (i < *smallest) {\n            smallest = i;\n        }\n    }\n    for\
    \ (long& i : lst) {\n        if (i < *smallest && i != *smallest) {\n        \
    \    if (result == std::nullopt) {\n                result = i;\n            }\
    \ else if (i < *result) {\n                result = i;\n            }\n      \
    \  }\n    }\n    return result;", "    std::sort(lst.begin(), lst.end());\n  \
    \  int n = lst.size();\n    for(int i = 1; i < n; i++) {\n        if(lst[i] !=\
    \ lst[i-1])\n            return lst[i];\n    }\n    return std::nullopt;", " \
    \   if (lst.size()==0) {\n        return std::nullopt;\n    }\n    long min=lst[0];\n\
    \    long next_min=lst[0];\n    for (int i=0; i<lst.size(); i++) {\n        if\
    \ (lst[i]<min) {\n            next_min=min;\n            min=lst[i];\n       \
    \ }\n        else if (lst[i]<next_min) {\n            next_min=lst[i];\n     \
    \   }\n    }\n    if (next_min==min) {\n        return std::nullopt;\n    }\n\
    \    return next_min;", "  // your code here\n  return {};", "\tint n = lst.size();\n\
    \tlong min = *min_element(lst.begin(), lst.end());\n\tlong t = min;\n\tlong secondMin\
    \ = min;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (lst[i] > min && lst[i] < secondMin)\
    \ {\n\t\t\tsecondMin = lst[i];\n\t\t}\n\t}\n\tif (secondMin == min) {\n\t\treturn\
    \ {};\n\t}\n\treturn secondMin;", "    std::optional<long> ret;\n    std::sort(lst.begin(),\
    \ lst.end());\n    int i = 1;\n    for (std::vector<long>::iterator it = lst.begin();\
    \ it != lst.end(); ++it) {\n        if (*it == *(it + 1))\n            i++;\n\
    \        else {\n            if (i == 2) {\n                ret = *it;\n     \
    \           break;\n            }\n            i = 1;\n        }\n    }\n    return\
    \ ret;", "    int n = lst.size();\n    if(n < 2) return std::nullopt;\n    std::sort(lst.begin(),\
    \ lst.end());\n    for(int i = 1; i < n; i++) {\n        if(lst[i] != lst[i-1])\
    \ return lst[i];\n    }\n    return std::nullopt;", "    if (lst.size() < 2) {\n\
    \        return std::nullopt;\n    }\n\n    std::sort(lst.begin(), lst.end());\n\
    \    long smallest = lst[0];\n    long smallest_diff = std::numeric_limits<long>::max();\n\
    \    long current_diff = std::numeric_limits<long>::max();\n    long prev = lst[0];\n\
    \    for (int i = 1; i < lst.size(); i++) {\n        current_diff = lst[i] - prev;\n\
    \        if (current_diff < smallest_diff) {\n            smallest_diff = current_diff;\n\
    \        }\n        prev = lst[i];\n    }\n\n    return smallest + smallest_diff;",
  "  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  long smallest = lst[0];\n\
    \  long next_smallest = lst[1];\n  if (smallest > next_smallest) {\n    smallest\
    \ = lst[1];\n    next_smallest = lst[0];\n  }\n  for (size_t i = 2; i < lst.size();\
    \ i++) {\n    if (lst[i] < smallest) {\n      next_smallest = smallest;\n    \
    \  smallest = lst[i];\n    } else if (lst[i] < next_smallest) {\n      next_smallest\
    \ = lst[i];\n    }\n  }\n  return next_smallest;", "    int n = lst.size();\n\
    \    if(n<=1) return std::nullopt;\n    std::sort(lst.begin(), lst.end());\n \
    \   int a = lst[0];\n    int b = INT_MAX;\n    for(int i=1; i<n; i++){\n     \
    \   if(lst[i] > a && lst[i] < b){\n            b = lst[i];\n        }\n    }\n\
    \    if(b == INT_MAX) return std::nullopt;\n    return b;", "  // Your code here\n\
    \    int min1 = INT_MAX, min2 = INT_MAX; \n  for (int i = 0; i < lst.size(); i++)\
    \ \n  { \n    // If found new smaller number \n    if (lst[i] < min1) \n    {\
    \ \n      min2 = min1; \n      min1 = lst[i]; \n    } \n  \n    // If current\
    \ element is smaller than max2, and \n    // greater than min1 \n    else if (lst[i]\
    \ < min2 && lst[i] != min1) \n      min2 = lst[i]; \n  } \n  if (min2 == INT_MAX)\
    \ \n    return std::nullopt; \n  else\n    return min2; ", "\tstd::sort(lst.begin(),\
    \ lst.end());\n\tfor (size_t i = 0; i < lst.size() - 1; i++) {\n\t\tif (lst[i]\
    \ != lst[i + 1]) {\n\t\t\treturn lst[i + 1];\n\t\t}\n\t}\n\treturn std::nullopt;",
  "    std::sort(lst.begin(), lst.end());\n    int size = lst.size();\n    int i =\
    \ 0;\n    while(i < size - 1) {\n        if(lst[i] == lst[i + 1]) {\n        \
    \    i++;\n        } else {\n            return lst[i + 1];\n        }\n    }\n\
    \    return std::nullopt;", "  // Your solution goes here.\n  long smallest =\
    \ lst[0];\n  long second_smallest = smallest;\n  int flag = 0;\n  for(int i =\
    \ 0; i < lst.size(); i++){\n    if(lst[i] < smallest){\n      second_smallest\
    \ = smallest;\n      smallest = lst[i];\n      flag = 1;\n    }\n    else if(lst[i]\
    \ < second_smallest && lst[i] != smallest){\n      second_smallest = lst[i];\n\
    \      flag = 1;\n    }\n  }\n  if(flag == 0){\n    return std::nullopt;\n  }\n\
    \  return second_smallest;", "    // Write your code here\n    // To print results\
    \ to the standard output you can use print\n    // Example: print \"Hello world!\"\
    \n    long n = lst.size();\n    if(n == 0) return std::nullopt;\n    std::sort(lst.begin(),\
    \ lst.end());\n    long curr_max = lst[0];\n    long second_min = INT_MAX;\n \
    \   bool second_min_found = false;\n    for(int i = 1; i < n; i++) {\n       \
    \ if(lst[i] > curr_max) {\n            second_min = lst[i];\n            second_min_found\
    \ = true;\n            break;\n        }\n    }\n    if(second_min_found) {\n\
    \        return second_min;\n    }\n    return std::nullopt;", "  if (lst.size()\
    \ == 0) {\n    return std::nullopt;\n  }\n  if (lst.size() == 1) {\n    return\
    \ std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  int prev = lst[0];\n\
    \  for (auto i = lst.begin() + 1; i != lst.end(); i++) {\n    if (*i != prev)\
    \ {\n      return *i;\n    }\n    prev = *i;\n  }\n  return std::nullopt;", " \
    \ // Write your code here\n  // To print results to the standard output you can\
    \ use std::cout\n  // Example: std::cout << \"Hello world!\";\n  std::optional<long>\
    \ min1 = std::nullopt;\n  std::optional<long> min2 = std::nullopt;\n  int n =\
    \ lst.size();\n  for(int i = 0; i < n; i++) {\n      if (min1 == std::nullopt\
    \ || lst[i] < *min1) {\n          min2 = min1;\n          min1 = lst[i];\n   \
    \   } else if (min2 == std::nullopt || lst[i] < *min2) {\n          min2 = lst[i];\n\
    \      }\n  }\n  return min2;", "  if (lst.size() == 0) return std::nullopt;\n\
    \  if (lst.size() == 1) return std::nullopt;\n  std::sort(lst.begin(), lst.end());\n\
    \  for (int i = 0; i < lst.size() - 1; i++) {\n    if (lst[i] < lst[i + 1]) {\n\
    \      return lst[i + 1];\n    }\n  }\n  return std::nullopt;", "    if (lst.size()\
    \ < 2) {\n        return std::nullopt;\n    }\n    long smallest = lst[0];\n \
    \   long smallest_next = lst[1];\n    for (long i = 1; i < lst.size(); i++) {\n\
    \        if (lst[i] < smallest) {\n            smallest_next = smallest;\n   \
    \         smallest = lst[i];\n        } else if (lst[i] < smallest_next) {\n \
    \           smallest_next = lst[i];\n        }\n    }\n    if (smallest_next ==\
    \ smallest) {\n        return std::nullopt;\n    }\n    return smallest_next;",
  "\t// write the body of your function here\n\tstd::sort(lst.begin(), lst.end());\n\
    \tlong check=0;\n\tfor(int i=0;i<lst.size();i++){\n\t\tif(lst[i]!=lst[i+1]){\n\
    \t\t\tcheck++;\n\t\t}\n\t\tif(check==2){\n\t\t\treturn lst[i+1];\n\t\t}\n\t}\n\
    \treturn {};", "    std::sort(lst.begin(), lst.end());\n    long prev = lst[0];\n\
    \    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] != prev) {\n \
    \           return lst[i];\n        }\n        prev = lst[i];\n    }\n    return\
    \ std::nullopt;", "  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  //write\
    \ your code here\n  return std::nullopt;", "    assert(lst.size() > 1);\n    //\
    \ Write your code here\n    // To print results to the standard output you can\
    \ use \n    std::sort(lst.begin(), lst.end());\n    std::set<long> set;\n    for(auto\
    \ i: lst)\n    {\n        set.insert(i);\n    }\n    if(set.size()==1)\n    {\n\
    \        return {};\n    }\n    else if(set.size()==2)\n    {\n        return\
    \ *(set.begin()+1);\n    }\n    else\n    {\n        long min, min2;\n       \
    \ min = *(set.begin());\n        min2 = *(set.begin()+1);\n        for(auto i:\
    \ set)\n        {\n            if(i > min && i < min2)\n            {\n      \
    \          min2 = i;\n            }\n        }\n        return min2;\n    }",
  "    // TODO\n    if(lst.size() == 0) return std::nullopt;\n    long min1 = lst[0];\n\
    \    long min2 = LONG_MAX;\n    for(long i = 1; i < lst.size(); i++){\n      \
    \  if(lst[i] < min1){\n            min2 = min1;\n            min1 = lst[i];\n\
    \        }else if(lst[i] < min2){\n            min2 = lst[i];\n        }\n   \
    \ }\n    if(min2 == LONG_MAX) return std::nullopt;\n    return min2;", "  std::vector<long>::iterator\
    \ itr = lst.begin();\n  std::optional<long> result;\n  if(lst.size() == 0) {\n\
    \    return result;\n  }\n  if(lst.size() == 1) {\n    return result;\n  }\n \
    \ std::sort(lst.begin(), lst.end());\n  itr = std::unique(lst.begin(), lst.end());\n\
    \  lst.resize(std::distance(lst.begin(), itr));\n  if(lst.size() == 1) {\n   \
    \ return result;\n  }\n  else {\n    result = lst[1];\n    return result;\n  }",
  "  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(),\
    \ lst.end());\n  return lst[1];", "  int count = 0;\n  long smallest = lst[0];\n\
    \  long second_smallest = lst[0];\n  for (int i = 0; i < lst.size(); i++) {\n\
    \    if (lst[i] < smallest) {\n      second_smallest = smallest;\n      smallest\
    \ = lst[i];\n      count++;\n    }\n    else if (lst[i] < second_smallest && lst[i]\
    \ != smallest) {\n      second_smallest = lst[i];\n      count++;\n    }\n  }\n\
    \  if (count < 2) {\n    return std::nullopt;\n  }\n  else {\n    return second_smallest;\n\
    \  }", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    int\
    \ i = 0;\n    int secondSmallestIdx = 0;\n    int smallestIdx = 0;\n    for (int\
    \ j = 0; j < lst.size(); j++) {\n        if (lst[j] < lst[smallestIdx]) {\n  \
    \          secondSmallestIdx = smallestIdx;\n            smallestIdx = j;\n  \
    \      } else if (lst[j] < lst[secondSmallestIdx]) {\n            secondSmallestIdx\
    \ = j;\n        }\n    }\n    if (lst[secondSmallestIdx] == lst[smallestIdx])\
    \ {\n        return std::nullopt;\n    }\n    return lst[secondSmallestIdx];",
  "\t// Note: I'm using longs because the test is using longs, but it's overkill\n\
    \t// in terms of space and time complexity.\n\tint n = lst.size();\n\tlong m1\
    \ = -1, m2 = -1;\n\tfor (long &i : lst) {\n\t\tif (i <= m1) m1 = i;\n\t\telse\
    \ if (i <= m2) m2 = i;\n\t}\n\treturn m2 == -1 ? std::nullopt : std::optional<long>(m2);",
  "  // your code here\n  long min = INT_MAX;\n  long min2 = INT_MAX;\n  bool duplicate\
    \ = false;\n  for(int i = 0; i < lst.size(); i++){\n    if(lst[i] < min){\n  \
    \    min2 = min;\n      min = lst[i];\n    }\n    else if(lst[i] == min){\n  \
    \    duplicate = true;\n    }\n    else if(lst[i] < min2){\n      min2 = lst[i];\n\
    \    }\n  }\n  if(min2 == INT_MAX || duplicate) return std::nullopt;\n  return\
    \ min2;", "  std::vector<long> lst1;\n  lst1.reserve(lst.size());\n  std::copy(lst.begin(),\
    \ lst.end(), std::back_inserter(lst1));\n  std::sort(lst1.begin(), lst1.end());\n\
    \  auto it = std::unique(lst1.begin(), lst1.end());\n  lst1.resize(std::distance(lst1.begin(),\
    \ it));\n  return (lst1.size() > 1) ? std::optional<long>(lst1[1]) : std::nullopt;",
  "\tif (lst.size()<2) return std::nullopt;\n\tlong min = lst[0];\n\tlong minIdx =\
    \ 0;\n\tfor (int i = 1; i < lst.size(); i++) {\n\t\tif (lst[i] < min) {\n\t\t\t\
    min = lst[i];\n\t\t\tminIdx = i;\n\t\t}\n\t}\n\tlong min2 = lst[(minIdx + 1) %\
    \ lst.size()];\n\tfor (int i = 1; i < lst.size(); i++) {\n\t\tif (i == minIdx)\
    \ continue;\n\t\tif (lst[i] < min2) {\n\t\t\tmin2 = lst[i];\n\t\t}\n\t}\n\treturn\
    \ min2;", "\tif (lst.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\tstd::optional<long>\
    \ min = lst[0];\n\tstd::optional<long> second_min = std::nullopt;\n\tfor (auto\
    \ e : lst) {\n\t\tif (!min.has_value() || (e < min.value())) {\n\t\t\tsecond_min\
    \ = min;\n\t\t\tmin = e;\n\t\t}\n\t\telse if ((!second_min.has_value() || (e <\
    \ second_min.value())) && (e != min.value())) {\n\t\t\tsecond_min = e;\n\t\t}\n\
    \t}\n\treturn second_min;", "  if (lst.size() == 0) return std::nullopt;\n  long\
    \ min1 = std::numeric_limits<long>::max();\n  long min2 = std::numeric_limits<long>::max();\n\
    \  for (auto x : lst) {\n    if (x < min1) {\n      min2 = min1;\n      min1 =\
    \ x;\n    } else if (x < min2 && x != min1) {\n      min2 = x;\n    }\n  }\n \
    \ if (min2 == std::numeric_limits<long>::max()) return std::nullopt;\n  return\
    \ min2;", "    std::sort(lst.begin(), lst.end());\n    for (int i = 0; i < lst.size()\
    \ - 1; i++) {\n        if (lst[i] != lst[i + 1]) {\n            return lst[i +\
    \ 1];\n        }\n    }\n    return std::nullopt;", "  std::sort(lst.begin(),\
    \ lst.end());\n  long prev = lst[0];\n  for (int i = 1; i < lst.size(); i++) {\n\
    \    if (lst[i] != prev) {\n      return lst[i];\n    }\n    prev = lst[i];\n\
    \  }\n  return std::nullopt;", "    // Your code here!\n    std::sort(lst.begin(),\
    \ lst.end());\n    long f = lst[0];\n    long s = INT_MAX;\n    int flag = 0;\n\
    \    for(long n : lst){\n        if(n != f && n != s){\n            s = n;\n \
    \           flag = 1;\n            break;\n        }\n    }\n    if(flag) return\
    \ s;\n    else return std::nullopt;", "  long len = lst.size();\n  if (len <=\
    \ 1) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n\
    \  long prev = lst[0];\n  long curr = lst[1];\n  for (long i = 2; i < len; i++)\
    \ {\n    if (prev != curr) {\n      return curr;\n    }\n    prev = curr;\n  \
    \  curr = lst[i];\n  }\n  return std::nullopt;", "  // replace with your code\n\
    \  std::sort(lst.begin(), lst.end());\n  for (int i = 0; i < lst.size() - 1; i++)\
    \ {\n    if (lst[i] != lst[i + 1]) {\n      return lst[i + 1];\n    }\n  }\n \
    \ return std::nullopt;", "    long min1 = INT_MAX;\n    long min2 = INT_MAX;\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < min1) {\n  \
    \          min2 = min1;\n            min1 = lst[i];\n        } else if (lst[i]\
    \ < min2 && lst[i] != min1) {\n            min2 = lst[i];\n        }\n    }\n\
    \    return min2 == INT_MAX ? std::nullopt : std::optional<long>(min2);", "  std::sort(lst.begin(),\
    \ lst.end());\n  if (lst.size() >= 2) {\n    for (int i = 1; i < lst.size(); i++)\
    \ {\n      if (lst[i] > lst[0]) {\n        return lst[i];\n      }\n    }\n  }\n\
    \  return std::nullopt;", "    std::optional<long> ret;\n    long min, sec;\n\
    \    min = sec = LONG_MAX;\n    for (auto i : lst) {\n        if (i < min) {\n\
    \            sec = min;\n            min = i;\n        } else if (i < sec && i\
    \ != min) {\n            sec = i;\n        }\n    }\n    if (sec != LONG_MAX)\
    \ {\n        ret = sec;\n    }\n    return ret;", "  std::sort(lst.begin(), lst.end());\n\
    \  auto lst2 = std::unique(lst.begin(), lst.end());\n  lst.erase(lst2, lst.end());\n\
    \  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  return lst[1];", " \
    \   long smallest = *std::min_element(lst.begin(), lst.end());\n    lst.erase(std::remove(lst.begin(),\
    \ lst.end(), smallest), lst.end());\n    if (lst.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    return *std::min_element(lst.begin(), lst.end());",
  "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    // find the\
    \ minimum value\n    auto min_it = std::min_element(lst.begin(), lst.end());\n\
    \    // get it's index\n    int min_idx = std::distance(lst.begin(), min_it);\n\
    \    // remove it from the list\n    lst.erase(min_it);\n    // find the next\
    \ smallest element and return it\n    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    auto min_it2 = std::min_element(lst.begin(), lst.end());\n    int\
    \ min_idx2 = std::distance(lst.begin(), min_it2);\n    if (min_idx == min_idx2)\
    \ {\n        return std::nullopt;\n    }\n    return *min_it2;", "    if (lst.size()\
    \ <= 1) {\n        return std::nullopt;\n    }\n    long min = std::numeric_limits<long>::max();\n\
    \    long next_min = std::numeric_limits<long>::max();\n    for (auto i: lst)\
    \ {\n        if (i < min) {\n            next_min = min;\n            min = i;\n\
    \        } else if (i < next_min) {\n            next_min = i;\n        }\n  \
    \  }\n    if (next_min == std::numeric_limits<long>::max()) {\n        return\
    \ std::nullopt;\n    }\n    return next_min;", "    if (lst.size() == 0) {\n \
    \       return std::nullopt;\n    }\n    if (lst.size() == 1) {\n        return\
    \ std::nullopt;\n    }\n    if (lst.size() == 2) {\n        if (lst[0] != lst[1])\
    \ {\n            return lst[1];\n        }\n        return std::nullopt;\n   \
    \ }\n    long smallest = lst[0];\n    long nextSmallest = lst[1];\n    long temp\
    \ = smallest;\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i]\
    \ < smallest) {\n            nextSmallest = smallest;\n            smallest =\
    \ lst[i];\n        }\n        if (lst[i] < nextSmallest && lst[i] != smallest)\
    \ {\n            nextSmallest = lst[i];\n        }\n    }\n    if (nextSmallest\
    \ == temp) {\n        return std::nullopt;\n    }\n    return nextSmallest;",
  "\tif (lst.size() < 2) {\n\t\treturn std::nullopt;\n\t}\n\tlong min = *std::min_element(lst.begin(),\
    \ lst.end());\n\tfor (long el : lst) {\n\t\tif (el > min) {\n\t\t\treturn el;\n\
    \t\t}\n\t}\n\treturn std::nullopt;", "\tint small;\n\tint nsmall;\n\tint smallcount\
    \ = 0;\n\tint nsmallcount = 0;\n\tif (lst.size() == 0) {\n\t\treturn {};\n\t}\n\
    \tif (lst.size() == 1) {\n\t\treturn {};\n\t}\n\tsmall = lst[0];\n\tnsmall = lst[1];\n\
    \tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] == small) {\n\t\t\tsmallcount++;\n\
    \t\t}\n\t\tif (lst[i] == nsmall) {\n\t\t\tnsmallcount++;\n\t\t}\n\t\tif (lst[i]\
    \ < small) {\n\t\t\tnsmall = small;\n\t\t\tsmall = lst[i];\n\t\t}\n\t\tif (lst[i]\
    \ < nsmall && lst[i] != small) {\n\t\t\tnsmall = lst[i];\n\t\t}\n\t}\n\tif (smallcount\
    \ == lst.size()) {\n\t\treturn {};\n\t}\n\tif (nsmallcount == lst.size()) {\n\t\
    \treturn {};\n\t}\n\treturn nsmall;", "    if (lst.size() <= 1) {\n        return\
    \ std::nullopt;\n    }\n    if (lst.size() == 2) {\n        if (lst[0] != lst[1])\
    \ {\n            return std::min(lst[0], lst[1]);\n        } else {\n        \
    \    return std::nullopt;\n        }\n    }\n    std::sort(lst.begin(), lst.end());\n\
    \    int prev = lst[0];\n    for (int i = 1; i < lst.size(); i++) {\n        if\
    \ (lst[i] != prev) {\n            return lst[i];\n        }\n        prev = lst[i];\n\
    \    }\n    return std::nullopt;", "    int size = lst.size();\n    int i;\n \
    \   long min = INT_MAX;\n    long min2 = INT_MAX;\n    for(i=0;i<size;i++){\n\
    \        if(lst[i]<min){\n            min2 = min;\n            min = lst[i];\n\
    \        }\n        else if(lst[i]<min2 && lst[i]>min){\n            min2 = lst[i];\n\
    \        }\n    }\n    if(min2==INT_MAX){\n        return std::nullopt;\n    }\n\
    \    return min2;", "\tint c = 0;\n\tif (lst.size() <= 1) {\n\t\treturn {};\n\t\
    }\n\tstd::sort(lst.begin(), lst.end());\n\tfor (int i = 0; i < lst.size() - 1;\
    \ i++) {\n\t\tif (lst[i] != lst[i + 1]) {\n\t\t\treturn lst[i + 1];\n\t\t}\n\t\
    }\n\treturn {};", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    else if (lst.size() == 1) {\n        return std::nullopt;\n    }\n\
    \    else if (lst.size() == 2) {\n        if (lst[0] == lst[1]) {\n          \
    \  return std::nullopt;\n        }\n        else {\n            std::sort(lst.begin(),\
    \ lst.end());\n            return lst[1];\n        }\n    }\n    else {\n    \
    \    std::sort(lst.begin(), lst.end());\n        for (auto i = 0; i < lst.size()\
    \ - 1; i++) {\n            if (lst[i] != lst[i + 1]) {\n                return\
    \ lst[i + 1];\n            }\n        }\n        return std::nullopt;\n    }",
  "  if (lst.size() <= 1) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(),\
    \ lst.end());\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] != lst[i\
    \ - 1]) {\n      return lst[i];\n    }\n  }\n  return std::nullopt;", "\tauto\
    \ n = lst.size();\n\tif (n == 0) return std::nullopt;\n\tif (n == 1) return std::nullopt;\n\
    \tlong min = lst[0];\n\tlong second_min = lst[1];\n\tfor (int i = 1; i < n; i++)\
    \ {\n\t\tif (lst[i] < min) {\n\t\t\tsecond_min = min;\n\t\t\tmin = lst[i];\n\t\
    \t}\n\t\telse if (lst[i] < second_min && lst[i] != min) {\n\t\t\tsecond_min =\
    \ lst[i];\n\t\t}\n\t}\n\tif (second_min == min) return std::nullopt;\n\treturn\
    \ second_min;", "    if (lst.size() == 0) {\n        return std::nullopt;\n  \
    \  }\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    if\
    \ (lst.size() == 2) {\n        if (lst[0] == lst[1]) {\n            return std::nullopt;\n\
    \        }\n    }\n    long cur_min = lst[0];\n    long cur_min_idx = 0;\n   \
    \ for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] < cur_min) {\n  \
    \          cur_min = lst[i];\n            cur_min_idx = i;\n        }\n    }\n\
    \    std::vector<long> new_lst;\n    for (int i = 0; i < lst.size(); i++) {\n\
    \        if (i != cur_min_idx) {\n            new_lst.push_back(lst[i]);\n   \
    \     }\n    }\n    return next_smallest(new_lst);", "    // I would probably\
    \ just use a priority queue but this is a bit more fun.\n    std::vector<long>\
    \ res;\n    if (lst.size() == 0) {\n        return {};\n    }\n    if (lst.size()\
    \ == 1) {\n        return {};\n    }\n    // Assuming the values of the list are\
    \ unique for now.\n\n    for (int i = 0; i < lst.size(); i++) {\n        // Then\
    \ I would probably use the fact that binary search works for sorted arrays.\n\
    \        for (int j = 0; j < lst.size(); j++) {\n            if (i != j) {\n \
    \               if (lst[i] > lst[j]) {\n                    res.push_back(lst[i]);\n\
    \                }\n            }\n        }\n    }\n    if (res.size() > 0) {\n\
    \        std::sort(res.begin(), res.end());\n        return res[0];\n    }\n \
    \   return {};", "  int count = lst.size();\n  if (count == 0) {\n    return std::nullopt;\n\
    \  }\n  std::sort(lst.begin(), lst.end());\n  for (int i = 0; i < count - 1; i++)\
    \ {\n    if (lst[i] != lst[i + 1]) {\n      return lst[i + 1];\n    }\n  }\n \
    \ return std::nullopt;", "\tassert(lst.size() >= 2);\n\tstd::sort(lst.begin(),\
    \ lst.end());\n\tstd::set<long> uniq(lst.begin(), lst.end());\n\tif (uniq.size()\
    \ == 1)\n\t\treturn std::nullopt;\n\tauto it = uniq.begin();\n\tit++;\n\treturn\
    \ *it;", "\tif (lst.size()<2) return std::nullopt;\n\tlong m = lst[0];\n\tlong\
    \ s = m;\n\tfor (int i = 1; i < lst.size(); i++) {\n\t\tif (lst[i] < m) {\n\t\t\
    \ts = m;\n\t\t\tm = lst[i];\n\t\t}\n\t\telse if (lst[i] < s && lst[i] != m) {\n\
    \t\t\ts = lst[i];\n\t\t}\n\t}\n\tif (s == m) return std::nullopt;\n\treturn s;",
  "  std::sort(lst.begin(), lst.end());\n  for (int i = 0; i < lst.size() - 1; i++)\
    \ {\n    if (lst[i] != lst[i + 1])\n      return lst[i + 1];\n  }\n  return std::nullopt;",
  "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    if (lst.size()\
    \ == 1) {\n        return std::nullopt;\n    }\n    if (lst.size() == 2) {\n \
    \       if (lst[0] == lst[1]) {\n            return std::nullopt;\n        }\n\
    \    }\n    std::sort(lst.begin(), lst.end());\n    std::vector<long> unique(lst.size());\n\
    \    auto it = std::unique_copy(lst.begin(), lst.end(), unique.begin());\n   \
    \ unique.resize(std::distance(unique.begin(), it));\n    std::vector<long> unique_lst\
    \ = unique;\n    // std::cout << \"unique_lst.size() \" << unique_lst.size() <<\
    \ std::endl;\n    for (int i = 0; i < unique_lst.size(); i++) {\n        // std::cout\
    \ << unique_lst[i] << \" \";\n    }\n    // std::cout << std::endl;\n    if (unique_lst.size()\
    \ == 1) {\n        return std::nullopt;\n    }\n    if (unique_lst.size() == 2)\
    \ {\n        return unique_lst[1];\n    }\n    if (unique_lst.size() == 3) {\n\
    \        if (unique_lst[0] == unique_lst[1]) {\n            return unique_lst[2];\n\
    \        }\n        if (unique_lst[1] == unique_lst[2]) {\n            return\
    \ unique_lst[0];\n        }\n        if (unique_lst[0] != unique_lst[1] && unique_lst[1]\
    \ != unique_lst[2]) {\n            return unique_lst[1];\n        }\n    }\n \
    \   if (unique_lst.size() == 4) {\n        if (unique_lst[0] == unique_lst[1])\
    \ {\n            if (unique_lst[2] == unique_lst[3]) {\n                return\
    \ std", "\treturn std::nullopt;", "\tstd::optional<long> ret;\n\t// assert (lst.size()\
    \ > 1);\n\tif (lst.size() < 2) {\n\t\treturn ret;\n\t}\n\tstd::sort(lst.begin(),\
    \ lst.end());\n\tlong last = lst[0];\n\tfor (int i = 1; i < lst.size(); i++) {\n\
    \t\tif (lst[i] != last) {\n\t\t\tret = lst[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn\
    \ ret;", "    std::vector<long>::iterator it; \n    it = std::unique(lst.begin(),\
    \ lst.end()); \n    lst.resize(std::distance(lst.begin(), it)); \n    std::sort(lst.begin(),\
    \ lst.end());\n    if(lst.size() > 1){\n        return lst[1];\n    }\n    else{\n\
    \        return std::nullopt;\n    }", '  return (std::optional<long>() );', " \
    \ if (lst.size() == 0) {\n    return std::nullopt;\n  } else if (lst.size() ==\
    \ 1) {\n    return std::nullopt;\n  } else {\n    long min = lst[0];\n    long\
    \ smallest = lst[0];\n    for (auto i = 0; i < lst.size(); i++) {\n      if (lst[i]\
    \ < min) {\n        min = lst[i];\n      }\n    }\n    for (auto i = 0; i < lst.size();\
    \ i++) {\n      if (lst[i] > min) {\n        if (lst[i] < smallest) {\n      \
    \    smallest = lst[i];\n        }\n      }\n    }\n    if (smallest == lst[0])\
    \ {\n      return std::nullopt;\n    } else {\n      return smallest;\n    }\n\
    \  }", "    std::vector<long>::iterator it, first, second;\n    for (it = lst.begin();\
    \ it != lst.end(); it++) {\n        if (*it < 0) {\n            std::cout << *it\
    \ << std::endl;\n            return std::nullopt;\n        }\n    }\n    for (it\
    \ = lst.begin(); it != lst.end(); it++) {\n        if (it == lst.begin()) {\n\
    \            first = it;\n        } else if (it == lst.begin() + 1) {\n      \
    \      second = it;\n        } else {\n            if (*first > *it) {\n     \
    \           first = it;\n            } else if (*first < *it && *second > *it)\
    \ {\n                second = it;\n            }\n        }\n    }\n    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    } else if (lst.size() == 1) {\n \
    \       return std::nullopt;\n    } else if (lst.size() == 2) {\n        if (*first\
    \ == *second) {\n            return std::nullopt;\n        } else {\n        \
    \    return *second;\n        }\n    } else {\n        return *second;\n    }",
  "\tif (lst.size() <= 1) {\n\t\treturn std::nullopt;\n\t}\n\tstd::sort(lst.begin(),\
    \ lst.end());\n\tlong ret = lst[0];\n\tfor (long i = 1; i < lst.size(); i++) {\n\
    \t\tif (lst[i] > ret) {\n\t\t\treturn lst[i];\n\t\t}\n\t}\n\treturn std::nullopt;",
  "  if (lst.size() == 0) {\n    return std::nullopt;\n  }\n  if (lst.size() == 1)\
    \ {\n    return std::nullopt;\n  }\n  if (lst.size() == 2) {\n    if (lst[0] ==\
    \ lst[1]) {\n      return std::nullopt;\n    }\n  }\n  long min = lst[0];\n  long\
    \ second_min = lst[1];\n  if (second_min < min) {\n    long temp = min;\n    min\
    \ = second_min;\n    second_min = temp;\n  }\n  for (long i = 2; i < lst.size();\
    \ i++) {\n    if (lst[i] < min) {\n      second_min = min;\n      min = lst[i];\n\
    \    } else if (lst[i] < second_min) {\n      second_min = lst[i];\n    }\n  }\n\
    \  if (second_min == min) {\n    return std::nullopt;\n  }\n  return second_min;",
  "  // your code here\n  long min = *std::min_element(lst.begin(), lst.end());\n\
    \  auto myiterator = std::find(lst.begin(), lst.end(), min);\n  if (myiterator\
    \ != lst.end())\n    lst.erase(myiterator);\n  if (lst.size() > 0)\n    return\
    \ *std::min_element(lst.begin(), lst.end());\n  else\n    return std::nullopt;",
  "  if (lst.size() == 0) {\n    return std::nullopt;\n  }\n  auto copy(lst);\n  auto\
    \ it = std::adjacent_find(copy.begin(), copy.end(), [](long a, long b) {\n   \
    \ return a != b;\n  });\n  if (it == copy.end()) {\n    return std::nullopt;\n\
    \  }\n  std::sort(copy.begin(), copy.end());\n  return *(it + 1);", "\tint sz\
    \ = lst.size();\n\tif (sz < 2) return std::nullopt;\n\tlong min, min2;\n\tmin\
    \ = min2 = lst[0];\n\tfor (int i = 1; i < sz; i++) {\n\t\tif (lst[i] < min) {\n\
    \t\t\tmin2 = min;\n\t\t\tmin = lst[i];\n\t\t}\n\t\telse if (lst[i] < min2) {\n\
    \t\t\tmin2 = lst[i];\n\t\t}\n\t}\n\tif (min == min2) return std::nullopt;\n\t\
    return min2;", "  long min = INT_MAX;\n  long second_min = INT_MAX;\n  for (auto\
    \ num : lst) {\n    if (num < min) {\n      second_min = min;\n      min = num;\n\
    \    } else if (num < second_min && num != min) {\n      second_min = num;\n \
    \   }\n  }\n  if (second_min == INT_MAX) {\n    return std::nullopt;\n  }\n  return\
    \ second_min;", "    std::optional<long> ret;\n    if(lst.size()<2) return ret;\n\
    \    std::sort(lst.begin(), lst.end());\n    long mn = lst[0];\n    for(long i\
    \ = 1; i < lst.size(); i++){\n        if(lst[i] == mn) continue;\n        return\
    \ lst[i];\n    }\n    return ret;", "    // TODO: Write your code here\n    if(lst.size()\
    \ == 0)\n      return std::nullopt;\n    if(lst.size() == 1)\n      return std::nullopt;\n\
    \    long min = INT_MAX;\n    long secondMin = INT_MAX;\n    for(int i=0; i<lst.size();\
    \ i++){\n      if(lst[i] < min){\n        secondMin = min;\n        min = lst[i];\n\
    \      }\n      else if(lst[i] < secondMin){\n        secondMin = lst[i];\n  \
    \    }\n    }\n    if(secondMin == INT_MAX)\n      return std::nullopt;\n    return\
    \ secondMin;", "    if (lst.size() == 0) {\n        return std::nullopt;\n   \
    \ }\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    if (lst.size()\
    \ == 2) {\n        if (lst[0] == lst[1]) {\n            return std::nullopt;\n\
    \        }\n    }\n    long min_elem_1 = lst[0];\n    long min_elem_2 = lst[1];\n\
    \    for (auto i = 2; i < lst.size(); i++) {\n        if (lst[i] < min_elem_1)\
    \ {\n            min_elem_2 = min_elem_1;\n            min_elem_1 = lst[i];\n\
    \        }\n        else if (lst[i] < min_elem_2) {\n            min_elem_2 =\
    \ lst[i];\n        }\n    }\n    if (min_elem_1 == min_elem_2) {\n        return\
    \ std::nullopt;\n    }\n    return min_elem_2;", "    std::optional<long> result;\n\
    \    long min = lst[0];\n    long min2 = lst[0];\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < min) {\n            min2 = min;\n            min\
    \ = lst[i];\n        }\n        else if (lst[i] == min) {\n            min2 =\
    \ min;\n        }\n        else if (lst[i] < min2) {\n            min2 = lst[i];\n\
    \        }\n    }\n    if (min == min2) {\n        return result;\n    }\n   \
    \ else {\n        result = min2;\n        return result;\n    }", "  if (lst.size()<=1)\
    \ return std::nullopt;\n  int minIndex = 0;\n  int secondMinIndex = 0;\n  for\
    \ (int i = 1; i < lst.size(); i++) {\n    if (lst[i] < lst[minIndex]) {\n    \
    \  secondMinIndex = minIndex;\n      minIndex = i;\n    } else if (lst[i] < lst[secondMinIndex])\
    \ {\n      secondMinIndex = i;\n    }\n  }\n  if (lst[secondMinIndex] == lst[minIndex])\
    \ return std::nullopt;\n  return lst[secondMinIndex];", "\t// Start implementation\n\
    \tif (lst.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\tlong min_ = lst[0];\n\
    \tlong sec_min = lst[0];\n\tfor (long i = 0; i < lst.size(); i++) {\n\t\tif (lst[i]\
    \ < min_) {\n\t\t\tsec_min = min_;\n\t\t\tmin_ = lst[i];\n\t\t}\n\t\telse if (lst[i]\
    \ < sec_min && lst[i] != min_) {\n\t\t\tsec_min = lst[i];\n\t\t}\n\t}\n\tif (sec_min\
    \ == min_) {\n\t\treturn std::nullopt;\n\t}\n\treturn sec_min;\n\t// End implementation",
  "    // Your code here\n    if(lst.size() < 2)\n        return std::nullopt;\n \
    \   std::vector<long>::iterator it = lst.begin();\n    long a = *it;\n    long\
    \ b = a;\n    it++;\n    for(; it != lst.end(); it++)\n    {\n        if(*it <\
    \ a)\n        {\n            b = a;\n            a = *it;\n        }\n       \
    \ else if(a < *it && *it < b)\n        {\n            b = *it;\n        }\n  \
    \  }\n    if(a == b)\n        return std::nullopt;\n    return b;", "    int count\
    \ = 0;\n    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    if\
    \ (lst.size() == 1) {\n        return std::nullopt;\n    }\n    if (lst.size()\
    \ == 2) {\n        if (lst[0] == lst[1]) {\n            return std::nullopt;\n\
    \        }\n    }\n    std::sort(lst.begin(), lst.end());\n    for (int i = 0;\
    \ i < lst.size() - 1; i++) {\n        if (lst[i] != lst[i + 1]) {\n          \
    \  count++;\n        }\n        if (count == 2) {\n            return lst[i +\
    \ 1];\n        }\n    }\n    return std::nullopt;", "  auto it = std::min_element(lst.begin(),\
    \ lst.end());\n  if (it == lst.end()) {\n    return std::nullopt;\n  }\n  lst.erase(it);\n\
    \  it = std::min_element(lst.begin(), lst.end());\n  if (it == lst.end()) {\n\
    \    return std::nullopt;\n  }\n  return *it;", "  // your code here\n  std::vector<long>s;\n\
    \  std::sort(lst.begin(),lst.end());\n  for(auto &i:lst)\n  {\n      s.push_back(i);\n\
    \  }\n  std::vector<long>::iterator ip; \n  ip = std::unique(s.begin(), s.end());\n\
    \  s.resize(std::distance(s.begin(), ip));\n  if(s.size()<2)\n  {\n      return\
    \ std::nullopt;\n  }\n  else\n  {\n      return s[1];\n  }\n  ", "    std::sort(lst.begin(),\
    \ lst.end());\n    int counter = 0;\n    int first = lst[0];\n    int second =\
    \ lst[1];\n    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n \
    \   if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    for (int\
    \ i = 0; i < lst.size(); i++) {\n        if (lst[i] == first) {\n            counter++;\n\
    \        }\n    }\n    if (counter == lst.size()) {\n        return std::nullopt;\n\
    \    }\n    if (second == first) {\n        return next_smallest(std::vector<long>(lst.begin()\
    \ + 1, lst.end()));\n    }\n    return second;", "  // No elements: no next smallest\
    \ element\n  if (lst.size() == 0) {\n    return std::nullopt;\n  }\n  // Single\
    \ element: no next smallest element\n  if (lst.size() == 1) {\n    return std::nullopt;\n\
    \  }\n  // Two elements: 2nd element if 2nd is smaller than 1st\n  if (lst.size()\
    \ == 2) {\n    if (lst[1] < lst[0]) {\n      return lst[1];\n    } else {\n  \
    \    return std::nullopt;\n    }\n  }\n  // More than two elements: linear search\
    \ O(n)\n  long min = lst[0];\n  long second_min = lst[1];\n  for (int i = 1; i\
    \ < lst.size(); i++) {\n    if (lst[i] < min) {\n      second_min = min;\n   \
    \   min = lst[i];\n    } else if (lst[i] < second_min) {\n      second_min = lst[i];\n\
    \    }\n  }\n  if (second_min == min) {\n    return std::nullopt;\n  } else {\n\
    \    return second_min;\n  }", "    long smallest,second_smallest;\n    int i;\n\
    \    if(lst.size()==0) {\n        return {};\n    }\n    else if(lst.size()==1)\
    \ {\n        return {};\n    }\n    else {\n        smallest=lst[0];\n       \
    \ second_smallest=lst[1];\n        for(i=0;i<lst.size();i++) {\n            if(lst[i]<smallest)\
    \ {\n                second_smallest=smallest;\n                smallest=lst[i];\n\
    \            }\n            else if(lst[i]<second_smallest && lst[i]!=smallest)\
    \ {\n                second_smallest=lst[i];\n            }\n        }\n     \
    \   if(second_smallest==smallest) {\n            return {};\n        }\n     \
    \   else {\n            return second_smallest;\n        }\n    }", "    if (lst.size()==0)\
    \ return std::nullopt;\n    std::sort(lst.begin(), lst.end());\n    auto it =\
    \ std::unique(lst.begin(), lst.end());\n    lst.resize(std::distance(lst.begin(),\
    \ it));\n    if (lst.size()==1) return std::nullopt;\n    return lst[1];", "\t\
    if (lst.size() < 2) return std::nullopt;\n\tauto result = std::min_element(lst.begin(),\
    \ lst.end());\n\tauto start = *result;\n\tlst.erase(result);\n\tresult = std::min_element(lst.begin(),\
    \ lst.end());\n\twhile (*result == start) {\n\t\tlst.erase(result);\n\t\tif (lst.size()\
    \ == 0) return std::nullopt;\n\t\tresult = std::min_element(lst.begin(), lst.end());\n\
    \t}\n\treturn *result;", "  std::sort(lst.begin(), lst.end());\n  long previous\
    \ = lst[0];\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] != previous)\
    \ {\n      return lst[i];\n    }\n    previous = lst[i];\n  }\n  return std::nullopt;",
  "\t// Your code here!\n  std::set<long> s;\n  for(long i : lst)\n    s.insert(i);\n\
    \  if(s.size()<2)\n    return std::nullopt;\n  return *std::next(s.begin());",
  "\tlong min1, min2;\n\tmin1 = min2 = lst[0];\n\tfor (auto i : lst) {\n\t\tif (i\
    \ < min1) {\n\t\t\tmin2 = min1;\n\t\t\tmin1 = i;\n\t\t}\n\t\telse if (i < min2\
    \ && i != min1)\n\t\t\tmin2 = i;\n\t}\n\tif (min1 == min2)\n\t\treturn std::nullopt;\n\
    \treturn min2;", "\tlong min1 = (long)1000000000000000000;\n\tlong min2 = (long)1000000000000000000;\n\
    \tif (lst.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\tfor (int i = 0; i <\
    \ lst.size(); i++) {\n\t\tif (lst[i] < min1) {\n\t\t\tmin2 = min1;\n\t\t\tmin1\
    \ = lst[i];\n\t\t}\n\t\telse if (lst[i] < min2 && lst[i] != min1) {\n\t\t\tmin2\
    \ = lst[i];\n\t\t}\n\t}\n\tif (min2 == (long)1000000000000000000) {\n\t\treturn\
    \ std::nullopt;\n\t}\n\treturn min2;", "\t\n\tif(lst.size() == 0) {\n\t\treturn\
    \ std::nullopt;\n\t}\n\n\t// if all elements in array are same, return null\n\t\
    int firstVal = lst[0];\n\tfor(int i = 1; i < lst.size(); i++) {\n\t\tif(lst[i]\
    \ != firstVal) {\n\t\t\tbreak;\n\t\t}\n\t\tif(i == lst.size() - 1) {\n\t\t\treturn\
    \ std::nullopt;\n\t\t}\n\t}\n\n\t// sort\n\tsort(lst.begin(), lst.end());\n\n\t\
    // find second smallest\n\tint secondSmallest = lst[0];\n\tfor(int i = 1; i <\
    \ lst.size(); i++) {\n\t\tif(lst[i] != secondSmallest) {\n\t\t\tsecondSmallest\
    \ = lst[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn secondSmallest;", "  /*\n  if\
    \ len(lst) <= 1:\n        return None\n  if len(lst) == 2:\n    if lst[0] != lst[1]:\n\
    \      return lst[1]\n    else:\n      return None\n  if len(lst) == 3:\n    if\
    \ lst[0] != lst[1] and lst[1] != lst[2]:\n      return lst[1]\n    elif lst[0]\
    \ != lst[1] and lst[1] == lst[2]:\n      return lst[2]\n    elif lst[0] == lst[1]\
    \ and lst[1] != lst[2]:\n      return lst[2]\n    else:\n      return None\n \
    \ */\n  // if len(lst) <= 1:\n  //   return None\n  if (lst.size() <= 1) {\n \
    \   return std::nullopt;\n  }\n  if (lst.size() == 2) {\n    if (lst[0] != lst[1])\
    \ {\n      return lst[1];\n    } else {\n      return std::nullopt;\n    }\n \
    \ }\n  if (lst.size() == 3) {\n    if (lst[0] != lst[1] && lst[1] != lst[2]) {\n\
    \      return lst[1];\n    } else if (lst[0] != lst[1] && lst[1] == lst[2]) {\n\
    \      return lst[2];\n    } else if (lst[0] == lst[1] && lst[1] != lst[2]) {\n\
    \      return lst[2];\n    } else {\n      return std::nullopt;\n    }\n  }\n\
    \  // return std::nullopt;\n  std::vector<long> tmp_lst;\n  for (long i = 0; i\
    \ < lst.size(); i++) {\n    tmp_lst.push_back(lst[i]);\n  }\n  std::sort(tmp_lst.begin(),\
    \ tmp_lst.end());\n  for (long", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    std::sort(lst.begin(),\
    \ lst.end());\n    return lst[1];", "    if (lst.size() <= 1) {\n        return\
    \ std::nullopt;\n    }\n    long mn = *std::min_element(lst.begin(), lst.end());\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] == mn) {\n   \
    \         lst.erase(lst.begin() + i);\n            i--;\n        }\n    }\n  \
    \  if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    return *std::min_element(lst.begin(),\
    \ lst.end());", "    if (lst.size() == 0) {\n        return std::nullopt;\n  \
    \  }\n    else if (lst.size() == 1) {\n        return std::nullopt;\n    }\n \
    \   std::sort(lst.begin(), lst.end());\n    return lst[1];", "\tif (lst.size()\
    \ < 2) {\n\t\treturn std::nullopt;\n\t}\n\tstd::sort(lst.begin(), lst.end());\n\
    \tfor (int i = 1; i < lst.size(); i++) {\n\t\tif (lst[i] != lst[i - 1]) {\n\t\t\
    \treturn lst[i];\n\t\t}\n\t}\n\treturn std::nullopt;", "  std::sort(lst.begin(),\
    \ lst.end());\n  if (lst.size() > 1) {\n    for (size_t i = 1; i < lst.size();\
    \ i++) {\n      if (lst[i] > lst[0])\n        return lst[i];\n    }\n  }\n  return\
    \ std::nullopt;", "    if (lst.size() <= 1) {\n        return std::nullopt;\n\
    \    }\n    auto temp1 = lst[0];\n    auto temp2 = lst[1];\n    if (temp1 > temp2)\
    \ {\n        std::swap(temp1, temp2);\n    }\n    for (int i = 2; i < lst.size();\
    \ i++) {\n        if (lst[i] < temp1) {\n            temp2 = temp1;\n        \
    \    temp1 = lst[i];\n        } else if (lst[i] < temp2) {\n            temp2\
    \ = lst[i];\n        }\n    }\n    if (temp1 == temp2) {\n        return std::nullopt;\n\
    \    }\n    return temp2;", "    std::vector<long> distinct;\n    for (long i\
    \ : lst) {\n        if (std::find(distinct.begin(), distinct.end(), i) == distinct.end())\
    \ {\n            distinct.push_back(i);\n        }\n    }\n    std::sort(distinct.begin(),\
    \ distinct.end());\n    if (distinct.size() < 2) {\n        return std::nullopt;\n\
    \    }\n    return distinct[1];", "\t// your code goes here\n\tlong num_lst =\
    \ lst.size();\n\tif (num_lst == 0) {\n\t\treturn std::nullopt;\n\t}\n\telse if\
    \ (num_lst == 1) {\n\t\treturn std::nullopt;\n\t}\n\telse if (num_lst == 2) {\n\
    \t\tif (lst[0] != lst[1]) {\n\t\t\treturn lst[1];\n\t\t}\n\t\telse {\n\t\t\treturn\
    \ std::nullopt;\n\t\t}\n\t}\n\telse {\n\t\tstd::sort(lst.begin(), lst.end());\n\
    \t\tlong count = 0;\n\t\tfor (long i = 0; i < num_lst - 1; i++) {\n\t\t\tif (lst[i]\
    \ != lst[i + 1]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count == 2) {\n\t\t\t\
    \treturn lst[i + 1];\n\t\t\t}\n\t\t}\n\t\treturn std::nullopt;\n\t}", "    //\
    \ TODO: write your code here.\n    if(lst.size()==0){\n      return std::nullopt;\n\
    \    }\n    std::vector<long> sorted=lst;\n    std::sort(sorted.begin(),sorted.end());\n\
    \    int smallest=sorted[0];\n    int counter=0;\n    for(int i=0;i<sorted.size();i++){\n\
    \      if(sorted[i]==smallest){\n        counter++;\n      }\n    }\n    if(counter==sorted.size()){\n\
    \      return std::nullopt;\n    }\n    return sorted[counter];", "  // Write\
    \ your code here\n  if(lst.size() == 0){\n    return std::nullopt;\n  }\n  if(lst.size()\
    \ == 1){\n    return std::nullopt;\n  }\n  if(lst.size() == 2){\n    if(lst[0]\
    \ == lst[1]){\n      return std::nullopt;\n    }\n  }\n  long min = lst[0];\n\
    \  long second_min = INT_MAX;\n  for(int i = 0; i < lst.size(); i++){\n    if(lst[i]\
    \ < min){\n      second_min = min;\n      min = lst[i];\n    }\n    else if(lst[i]\
    \ < second_min && lst[i] != min){\n      second_min = lst[i];\n    }\n  }\n  if(second_min\
    \ == INT_MAX){\n    return std::nullopt;\n  }\n  return second_min;", "\tstd::sort(lst.begin(),\
    \ lst.end());\n\tauto length = lst.size();\n\tfor (auto i = 0; i < length; i++)\
    \ {\n\t\tif (lst[i] != lst[i + 1]) {\n\t\t\treturn lst[i + 1];\n\t\t}\n\t}\n\t\
    return std::nullopt;", "    // return the 2nd smallest element of the vector\n\
    \tif(lst.size()<2) return {};\n\tlong min=INT_MAX,secmin=INT_MAX;\n\tfor(auto\
    \ i:lst){\n\t\tif(i<min){\n\t\t\tsecmin=min;\n\t\t\tmin=i;\n\t\t}\n\t\telse if(i<secmin\
    \ && i!=min){\n\t\t\tsecmin=i;\n\t\t}\n\t}\n\treturn secmin;", "    long min =\
    \ lst[0];\n    long min2 = lst[0];\n    for (long elem : lst) {\n        if (elem\
    \ < min) {\n            min2 = min;\n            min = elem;\n        } else if\
    \ (elem < min2) {\n            min2 = elem;\n        }\n    }\n    if (min2 ==\
    \ min) {\n        return std::nullopt;\n    }\n    return min2;", "  long len\
    \ = lst.size();\n  if (len == 0) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(),\
    \ lst.end());\n  if (len == 1) {\n    return std::nullopt;\n  }\n  if (lst[0]\
    \ == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];", "    // first\
    \ sort\n    std::sort(lst.begin(), lst.end());\n    if (lst.size() < 2) {\n  \
    \      return std::nullopt;\n    }\n    if (lst[0] == lst[1]) {\n        return\
    \ std::nullopt;\n    }\n    return lst[1];", "    // your code here\n    if(lst.size()<2)\
    \ return std::nullopt;\n    long min1=lst[0],min2=lst[1];\n    bool found=false;\n\
    \    for(int i=1;i<lst.size();i++){\n        if(lst[i]<min1){\n            min2=min1;\n\
    \            min1=lst[i];\n            found=true;\n        }\n        else if(lst[i]>min1\
    \ && lst[i]<min2){\n            min2=lst[i];\n            found=true;\n      \
    \  }\n    }\n    if(found)\n        return min2;\n    else\n        return std::nullopt;",
  "\tif (lst.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\tlong s = *min_element(lst.begin(),\
    \ lst.end());\n\tif (count(lst.begin(), lst.end(), s) == lst.size()) {\n\t\treturn\
    \ std::nullopt;\n\t}\n\tsort(lst.begin(), lst.end());\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] != s) {\n\t\t\treturn lst[i];\n\t\t}\n\t}\n\tassert(false);",
  "    std::vector<long> all_elements;\n    if(lst.size() < 2) {\n        return std::nullopt;\n\
    \    }\n    if(lst.size() == 2) {\n        if(lst[0] != lst[1]) {\n          \
    \  all_elements.push_back(lst[0]);\n            all_elements.push_back(lst[1]);\n\
    \        }\n        else {\n            return std::nullopt;\n        }\n    }\n\
    \    else {\n        for(int i = 0; i < lst.size(); i++) {\n            bool check\
    \ = false;\n            for(int j = 0; j < all_elements.size(); j++) {\n     \
    \           if(lst[i] == all_elements[j]) {\n                    check = true;\n\
    \                    break;\n                }\n            }\n            if(!check)\
    \ {\n                all_elements.push_back(lst[i]);\n            }\n        }\n\
    \    }\n    if(all_elements.size() < 2) {\n        return std::nullopt;\n    }\n\
    \    sort(all_elements.begin(), all_elements.end());\n    return all_elements[1];",
  "    std::cout << std::endl;\n    int i = 0;\n    int j = 1;\n    while(j<lst.size()){\n\
    \        if(lst[i]==lst[j]){\n            lst.erase(lst.begin()+j);\n        }else{\n\
    \            i++;\n            j++;\n        }\n    }\n    if(lst.size()<2){\n\
    \        return std::nullopt;\n    }\n    long smallest_val = lst[0];\n    long\
    \ next_smallest_val = lst[1];\n    for(int i=1;i<lst.size();i++){\n        if(lst[i]<smallest_val){\n\
    \            next_smallest_val = smallest_val;\n            smallest_val = lst[i];\n\
    \        }else if(lst[i]<next_smallest_val){\n            next_smallest_val =\
    \ lst[i];\n        }\n    }\n    return next_smallest_val;", "    auto len = lst.size();\n\
    \    if (len <= 1) {\n        return std::nullopt;\n    }\n    std::sort(lst.begin(),\
    \ lst.end());\n    int min = lst[0];\n    int min_idx = 0;\n    for (int i = 1;\
    \ i < len; i++) {\n        if (lst[i] == min) {\n            min_idx = i;\n  \
    \      } else {\n            break;\n        }\n    }\n    if (min_idx == len\
    \ - 1) {\n        return std::nullopt;\n    }\n    return lst[min_idx + 1];",
  "\t\tstd::sort(lst.begin(), lst.end());\n    int size = lst.size();\n    int count\
    \ = 1;\n    for(int i = 0; i < size; i++){\n        if(count < 2){\n         \
    \   if(lst[i] != lst[i+1])\n                count++;\n        }\n        else{\n\
    \            return lst[i+1];\n        }\n    }\n    return std::nullopt;", " \
    \   if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    if (lst.size()\
    \ == 1) {\n        return std::nullopt;\n    }\n    if (lst.size() == 2) {\n \
    \       if (lst[0] == lst[1]) {\n            return std::nullopt;\n        }\n\
    \    }\n    std::sort(lst.begin(), lst.end());\n    for (int i = 1; i < lst.size();\
    \ i++) {\n        if (lst[i - 1] != lst[i]) {\n            return lst[i];\n  \
    \      }\n    }\n    return std::nullopt;", "  std::sort(lst.begin(), lst.end());\n\
    \  long count = 1;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] ==\
    \ lst[i + 1]) {\n      continue;\n    } else {\n      count++;\n    }\n    if\
    \ (count == 2) {\n      return lst[i + 1];\n    }\n  }\n  return std::nullopt;",
  "  //  std::sort(lst.begin(), lst.end());\n  //  return lst[1];\n  long min = 1000000001;\n\
    \  long second = 1000000001;\n  bool flag = false;\n  if (lst.size() < 2) {\n\
    \    return std::nullopt;\n  }\n  for (int i = 0; i < lst.size(); i++) {\n   \
    \ if (lst[i] < min) {\n      second = min;\n      min = lst[i];\n      flag =\
    \ true;\n    } else if (lst[i] < second && lst[i] != min) {\n      second = lst[i];\n\
    \      flag = true;\n    }\n  }\n  if (flag) {\n    return second;\n  } else {\n\
    \    return std::nullopt;\n  }", "    if (lst.size()==0) {return std::nullopt;}\n\
    \    int min = INT_MAX;\n    for (int i=0; i<lst.size(); i++) {\n        if (lst[i]\
    \ < min) {\n            min = lst[i];\n        }\n    }\n    int min2 = INT_MAX;\n\
    \    for (int i=0; i<lst.size(); i++) {\n        if (lst[i] < min2 && lst[i] >\
    \ min) {\n            min2 = lst[i];\n        }\n    }\n    if (min2==INT_MAX)\
    \ {return std::nullopt;}\n    return min2;", "  // Your code goes here\n  if(lst.size()<2)\n\
    \    return std::nullopt;\n  int i;\n  std::vector<long> t;\n  for(int i=0;i<lst.size();i++)\n\
    \  {\n    if(t.size()==0){\n      t.push_back(lst[i]);\n    }\n    else if(t.size()==1){\n\
    \      if(t[0]>lst[i]){\n        t.push_back(t[0]);\n        t[0]=lst[i];\n  \
    \    }\n      else if(t[0]==lst[i]){\n        return std::nullopt;\n      }\n\
    \      else\n        t.push_back(lst[i]);\n    }\n    else{\n      if(t[0]>lst[i]){\n\
    \        t[1]=t[0];\n        t[0]=lst[i];\n      }\n      else if(t[1]>lst[i]){\n\
    \        t[1]=lst[i];\n      }\n      else if(t[0]==lst[i] || t[1]==lst[i]){\n\
    \        return std::nullopt;\n      }\n    }\n  }\n  return t[1];", "    long\
    \ small;\n    long nextSmall;\n    if(lst.size() <= 1)\n        return std::nullopt;\n\
    \    else{\n        small = lst[0];\n        nextSmall = lst[1];\n        for(long\
    \ i = 0; i < lst.size(); i++){\n            if(lst[i] < small){\n            \
    \    nextSmall = small;\n                small = lst[i];\n            }\n    \
    \        else if(lst[i] > small && lst[i] < nextSmall){\n                nextSmall\
    \ = lst[i];\n            }\n        }\n        if(small == nextSmall)\n      \
    \      return std::nullopt;\n        else\n            return nextSmall;\n   \
    \ }", "    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n    long\
    \ min = lst[0];\n    long nmin = lst[1];\n    for (auto i : lst) {\n        if\
    \ (i < min) {\n            nmin = min;\n            min = i;\n        } else if\
    \ (i < nmin) {\n            nmin = i;\n        }\n    }\n    if (nmin == min)\
    \ {\n        return std::nullopt;\n    }\n    return nmin;", "  std::sort(lst.begin(),\
    \ lst.end());\n  auto it = std::unique(lst.begin(), lst.end());\n  if(it == lst.end())\
    \ {\n    return std::nullopt;\n  }\n  ++it;\n  if(it == lst.end()) {\n    return\
    \ std::nullopt;\n  }\n  return *it;", "    if (lst.size() <= 1) {\n        return\
    \ std::nullopt;\n    }\n    std::sort(lst.begin(), lst.end());\n    int prev =\
    \ lst[0];\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] != prev)\
    \ {\n            return lst[i];\n        }\n        prev = lst[i];\n    }\n  \
    \  return std::nullopt;", "    std::vector<long> sorted_lst;\n    std::sort(lst.begin(),\
    \ lst.end());\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\
    \    if (lst[0] == lst[1]) {\n        return std::nullopt;\n    }\n    return\
    \ lst[1];", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n\
    \    long min = INT_MAX;\n    long second_min = INT_MAX;\n    for (int i = 0;\
    \ i < lst.size(); i++) {\n        if (lst[i] < min) {\n            second_min\
    \ = min;\n            min = lst[i];\n        } else if (lst[i] < second_min &&\
    \ lst[i] != min) {\n            second_min = lst[i];\n        }\n    }\n    if\
    \ (second_min == INT_MAX) {\n        return std::nullopt;\n    }\n    return second_min;",
  "  int i,n;\n  n=lst.size();\n  if(n==0){\n    return std::nullopt;\n  }\n  if(n==1){\n\
    \    return std::nullopt;\n  }\n  long first,second;\n  first=lst[0];\n  for(i=1;i<n;i++){\n\
    \    if(lst[i]<first){\n      second=first;\n      first=lst[i];\n    }\n    else\
    \ if(lst[i]<second && lst[i]!=first){\n      second=lst[i];\n    }\n  }\n  if(second==first){\n\
    \    return std::nullopt;\n  }\n  return second;", "    if (lst.size() == 0)\n\
    \        return std::nullopt;\n    long small = lst[0];\n    long second_small\
    \ = INT_MAX;\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] <\
    \ small) {\n            second_small = small;\n            small = lst[i];\n \
    \       } else if (lst[i] < second_small && lst[i] != small) {\n            second_small\
    \ = lst[i];\n        }\n    }\n    if (second_small == INT_MAX)\n        return\
    \ std::nullopt;\n    return second_small;", "    if (lst.size() < 2) {\n     \
    \   return std::nullopt;\n    }\n    std::vector<long> new_lst = lst;\n    sort(new_lst.begin(),\
    \ new_lst.end());\n    if (new_lst[0] == new_lst[1]) {\n        return std::nullopt;\n\
    \    }\n    return new_lst[1];", "\tlong ans = lst[0];\n\tint count = 0;\n\tfor\
    \ (long i : lst) {\n\t\tans = std::min(ans, i);\n\t}\n\tfor (long i : lst) {\n\
    \t\tif (i == ans) {\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (count == lst.size()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tstd::sort(lst.begin(), lst.end());\n\tlong prev\
    \ = 0;\n\tfor (long i : lst) {\n\t\tif (i == ans) {\n\t\t\tcontinue;\n\t\t}\n\t\
    \tprev = i;\n\t\tbreak;\n\t}\n\treturn prev;", "    if (lst.size()<2) return std::nullopt;\n\
    \    long small = lst[0];\n    long next = lst[1];\n    if (small > next) std::swap(small,\
    \ next);\n    for (int i = 2; i < lst.size(); i++) {\n        if (lst[i] < small)\
    \ {\n            next = small;\n            small = lst[i];\n        } else if\
    \ (lst[i] < next) {\n            next = lst[i];\n        }\n    }\n    return\
    \ next;", "    if (lst.size()==0) return std::nullopt;\n    std::vector<long>::iterator\
    \ it;\n    it = std::unique(lst.begin(), lst.end());\n    lst.resize(std::distance(lst.begin(),\
    \ it));\n    std::sort(lst.begin(), lst.end());\n    if (lst.size()<2) return\
    \ std::nullopt;\n    return lst[1];", "    std::sort(lst.begin(), lst.end());\n\
    \    return lst.size() >= 2 ? lst[1] : std::nullopt;", "  std::vector<long> result(lst);\n\
    \  long min_value = 0;\n  long min_value2 = 0;\n  std::sort(result.begin(), result.end());\n\
    \  std::vector<long>::iterator it;\n  it = std::unique(result.begin(), result.end());\n\
    \  result.resize(std::distance(result.begin(), it));\n  if (result.size() < 2)\
    \ {\n    return std::nullopt;\n  }\n  min_value = result[0];\n  int i = 0;\n \
    \ while (i < result.size()) {\n    if (result[i] == min_value) {\n      i++;\n\
    \    } else {\n      min_value2 = result[i];\n      break;\n    }\n  }\n  return\
    \ min_value2;", "    if (lst.size() < 2) return std::nullopt;\n    std::sort(lst.begin(),\
    \ lst.end());\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i]\
    \ != lst[i-1]) return lst[i];\n    }\n    return std::nullopt;", "  long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n  lst.erase(std::remove(lst.begin(),\
    \ lst.end(), smallest), lst.end());\n  if (lst.size() < 1)\n    return std::nullopt;\n\
    \  else\n    return *std::min_element(lst.begin(), lst.end());", "  if (lst.size()\
    \ < 2) {\n    return std::nullopt;\n  }\n  long min_num = lst[0];\n  long second_min_num\
    \ = std::numeric_limits<long>::max();\n  for (size_t i = 1; i < lst.size(); i++)\
    \ {\n    if (lst[i] > min_num && lst[i] < second_min_num) {\n      second_min_num\
    \ = lst[i];\n    }\n    if (lst[i] < min_num) {\n      second_min_num = min_num;\n\
    \      min_num = lst[i];\n    }\n  }\n  if (second_min_num == std::numeric_limits<long>::max())\
    \ {\n    return std::nullopt;\n  }\n  return second_min_num;", "    // Your implementation\
    \ goes here.\n    int size = lst.size();\n    if(size==0)\n        return {};\n\
    \    long min = INT_MAX;\n    int i;\n    for(i=0;i<size;i++)\n    {\n       \
    \ if(lst[i]<min)\n            min = lst[i];\n    }\n    long min2 = INT_MAX;\n\
    \    for(i=0;i<size;i++)\n    {\n        if(lst[i]<min2 && lst[i]>min)\n     \
    \       min2 = lst[i];\n    }\n    if(min2 == INT_MAX)\n        return {};\n \
    \   return min2;", "  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n \
    \ std::sort(lst.begin(), lst.end());\n  for (int i = 1; i < lst.size(); i++) {\n\
    \    if (lst[i - 1] != lst[i]) {\n      return lst[i];\n    }\n  }\n  return std::nullopt;",
  "  if (lst.size()==0){\n    return std::nullopt;\n  }\n  else if (lst.size()==1){\n\
    \    return std::nullopt;\n  }\n  else if (lst.size()==2){\n    if (lst[0]==lst[1]){\n\
    \      return std::nullopt;\n    }\n    else{\n      return std::nullopt;\n  \
    \  }\n  }\n  else{\n    std::sort(lst.begin(), lst.end());\n    for (int i=0;\
    \ i<lst.size()-1; i++){\n      if (lst[i]!=lst[i+1]){\n        return lst[i+1];\n\
    \      }\n    }\n    return std::nullopt;\n  }", "    std::sort(lst.begin(), lst.end());\n\
    \    auto smallest = *std::next(lst.begin(), 1);\n    if(smallest==lst[0]){\n\
    \        return std::nullopt;\n    }\n    return smallest;", "\tif (lst.size()\
    \ < 2) {\n\t\treturn std::nullopt;\n\t}\n\tstd::sort(lst.begin(), lst.end());\n\
    \tint second_min = lst[0];\n\tint last_num = lst[0];\n\tfor (int i = 1; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] != last_num) {\n\t\t\tsecond_min = lst[i];\n\t\t\tlast_num\
    \ = lst[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (second_min == lst[0]) {\n\t\treturn\
    \ std::nullopt;\n\t}\n\treturn second_min;", "\tif (lst.size() < 2) {\n\t\treturn\
    \ std::nullopt;\n\t}\n\tlong min = lst[0];\n\tlong min2 = lst[1];\n\tif (min2\
    \ < min) {\n\t\tstd::swap(min, min2);\n\t}\n\tfor (int i = 2; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] < min) {\n\t\t\tmin2 = min;\n\t\t\tmin = lst[i];\n\t\t\
    }\n\t\telse if (lst[i] < min2) {\n\t\t\tmin2 = lst[i];\n\t\t}\n\t}\n\tif (min2\
    \ == min) {\n\t\treturn std::nullopt;\n\t}\n\treturn min2;", "  if (lst.size()\
    \ < 3) return std::nullopt;\n  std::sort(lst.begin(), lst.end());\n  return lst[1];",
  "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    if (lst.size()\
    \ == 1) {\n        return std::nullopt;\n    }\n    if (lst.size() == 2) {\n \
    \       if (lst[0] == lst[1]) {\n            return std::nullopt;\n        }\n\
    \    }\n    std::sort(lst.begin(), lst.end());\n    for (int i = 1; i < lst.size();\
    \ i++) {\n        if (lst[i] != lst[i - 1]) {\n            return lst[i];\n  \
    \      }\n    }\n    return std::nullopt;", "\tint min = INT_MAX;\n\tint min2\
    \ = INT_MAX;\n\tfor (auto l : lst) {\n\t\tif (l < min) {\n\t\t\tmin2 = min;\n\t\
    \t\tmin = l;\n\t\t}\n\t\telse if (l > min && l < min2)\n\t\t\tmin2 = l;\n\t}\n\
    \tif (min2 == INT_MAX)\n\t\treturn std::nullopt;\n\treturn min2;", "  if (lst.size()\
    \ <= 1) {\n    return std::nullopt;\n  }\n  auto smallest = std::min_element(lst.begin(),\
    \ lst.end());\n  auto second_smallest = smallest;\n  std::advance(second_smallest,\
    \ 1);\n  std::for_each(second_smallest, lst.end(), [&](auto &&i) {\n    if (i\
    \ < *smallest) {\n      smallest = second_smallest;\n    }\n    ++second_smallest;\n\
    \  });\n  if (*smallest == lst.back()) {\n    return std::nullopt;\n  }\n  return\
    \ *smallest;", "  std::sort(lst.begin(), lst.end());\n  std::set<long> lst_set(lst.begin(),\
    \ lst.end());\n  std::vector<long> lst_unique(lst_set.begin(), lst_set.end());\n\
    \  if (lst_unique.size() < 2) {\n    return std::nullopt;\n  }\n  long second_smallest\
    \ = lst_unique[1];\n  return second_smallest;", "  std::sort(lst.begin(), lst.end());\n\
    \  auto u = std::unique(lst.begin(), lst.end());\n  if(u == lst.end()) return\
    \ std::nullopt;\n  if(++u == lst.end()) return std::nullopt;\n  return *u;", " \
    \ // Type your solution here\n  int arr[lst.size()];\n  for(int i=0;i<lst.size();i++){\n\
    \      arr[i]=lst[i];\n  }\n  int n=sizeof(arr)/sizeof(arr[0]);\n  std::sort(arr,arr+n);\n\
    \  // for(int i=0;i<n;i++){\n  //     cout<<arr[i]<<\" \";\n  // }\n  int count\
    \ = 1;\n  for(int i=0;i<n;i++){\n      if(arr[i]==arr[i+1]){\n          count++;\n\
    \      }\n      else{\n          break;\n      }\n  }\n  if(count==n){\n     \
    \ return std::nullopt;\n  }\n  return arr[count];", "    // Your solution\n  \
    \  std::sort(lst.begin(), lst.end());\n    std::optional<long> ans;\n    if (lst.size()\
    \ > 1) {\n        ans = *(lst.begin() + 1);\n    }\n    return ans;", "  if (lst.size()\
    \ < 2) {\n    return std::nullopt;\n  }\n  long min = lst[0];\n  long smin = lst[1];\n\
    \  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] < min) {\n      smin\
    \ = min;\n      min = lst[i];\n    } else if (lst[i] < smin) {\n      smin = lst[i];\n\
    \    }\n  }\n  if (smin == min) {\n    return std::nullopt;\n  }\n  return smin;",
  "    std::sort(lst.begin(), lst.end());\n    if (lst.size() <= 1) {\n        return\
    \ std::nullopt;\n    }\n    else {\n        long v = lst[0];\n        for (int\
    \ i = 1; i < lst.size(); i++) {\n            if (lst[i] > v) {\n             \
    \   return lst[i];\n            }\n        }\n        return std::nullopt;\n \
    \   }", "    if (lst.size() < 2) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    std::iter_swap(it, lst.begin());\n    auto it2 = std::min_element(lst.begin()\
    \ + 1, lst.end());\n    if (*it < *it2) return *it2;\n    return std::nullopt;",
  "    std::sort(lst.begin(), lst.end());\n    int n = lst.size();\n    if (n < 2)\n\
    \        return std::nullopt;\n    for (int i = 1; i < n; i++) {\n        if (lst[i]\
    \ != lst[i - 1])\n            return lst[i];\n    }\n    return std::nullopt;",
  "  std::vector<long> tmp;\n  std::sort(lst.begin(), lst.end());\n  for (auto& it\
    \ : lst) {\n    if (it != lst[0]) {\n      tmp.push_back(it);\n    }\n  }\n  if\
    \ (tmp.size() == 0) {\n    return std::nullopt;\n  }\n  auto result = tmp[0];\n\
    \  for (auto& it : tmp) {\n    if (it != result) {\n      return result;\n   \
    \ }\n  }\n  return std::nullopt;", "    std::optional<long> ans;\n    std::sort(lst.begin(),\
    \ lst.end());\n    auto it = std::unique(lst.begin(), lst.end());\n    lst.resize(std::distance(lst.begin(),\
    \ it));\n    if (lst.size() > 1) {\n        ans = lst[1];\n    }\n    return ans;",
  '    // YOUR CODE HERE', "  // Your code here...\n    if(lst.size()==0)\n      \
    \  return std::nullopt;\n    long min1=lst[0];\n    long min2=lst[0];\n    for(int\
    \ i=0;i<lst.size();i++)\n    {\n        if(lst[i]<min1)\n        {\n         \
    \   min2=min1;\n            min1=lst[i];\n        }\n        else if(lst[i]<min2)\n\
    \        {\n            min2=lst[i];\n        }\n    }\n    if(min1==min2)\n \
    \       return std::nullopt;\n    return min2;", "  long min1 = INT_MAX;\n  long\
    \ min2 = INT_MAX;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] <\
    \ min1) {\n      min2 = min1;\n      min1 = lst[i];\n    } else if (lst[i] < min2\
    \ && lst[i] != min1) {\n      min2 = lst[i];\n    }\n  }\n  if (min2 == INT_MAX)\
    \ {\n    return std::nullopt;\n  }\n  return min2;"]
stop_tokens:
- "\n}"
