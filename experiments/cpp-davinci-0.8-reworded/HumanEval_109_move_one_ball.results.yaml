language: cpp
name: HumanEval_109_move_one_ball
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  std::vector<int> t(arr.size());\n\
    \  std::sort(arr.begin(), arr.end());\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    t[i] = arr[i];\n  }\n  for (int i = 0; i < arr.size(); i++) {\n    if\
    \ (arr[i] != t[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp50fuyl6f: /tmp/tmp50fuyl6f.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\t\treturn true;\n\
    \tstd::stack<long> s;\n\tint i;\n\tfor (i = 0; i < arr.size(); i++) {\n\t\tif\
    \ (s.empty())\n\t\t\ts.push(arr[i]);\n\t\telse {\n\t\t\tif (s.top() < arr[i])\n\
    \t\t\t\ts.push(arr[i]);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile (i <\
    \ arr.size()) {\n\t\tif (s.top() <= arr[i])\n\t\t\treturn false;\n\t\ts.pop();\n\
    \t\ti++;\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660111301
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\t\treturn true;\n\
    \tstd::vector<long> copy(arr);\n\tstd::sort(copy.begin(), copy.end());\n\tint\
    \ n = arr.size();\n\tstd::vector<int> pos(n);\n\tfor (int i = 0; i < n; i++) {\n\
    \t\tpos[arr[i]] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint curr = pos[copy[i]];\n\
    \t\tif (curr != i) {\n\t\t\tif (pos[copy[curr]] == i) {\n\t\t\t\tswap(arr[curr],\
    \ arr[i]);\n\t\t\t\tswap(pos[copy[curr]], pos[copy[i]]);\n\t\t\t}\n\t\t\telse\n\
    \t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplklrv3wz.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmplklrv3wz.cpp:38:5: error: \u2018swap\u2019 was not declared\
    \ in this scope\n   38 |     swap(arr[curr], arr[i]);\n      |     ^~~~\n/tmp/tmplklrv3wz.cpp:38:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplklrv3wz.cpp:2:\n/usr/include/c++/9/bits/regex.h:2029:5:\
    \ note:   \u2018std::__cxx11::swap\u2019\n 2029 |     swap(match_results<_Bi_iter,\
    \ _Alloc>& __lhs,\n      |     ^~~~\nIn file included from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmplklrv3wz.cpp:2:\n/usr/include/c++/9/bits/move.h:182:5:\
    \ note:   \u2018std::swap\u2019\n  182 |     swap(_Tp& __a, _Tp& __b)\n      |\
    \     ^~~~\n/usr/include/c++/9/bits/move.h:182:5: note:   \u2018std::swap\u2019\
    \nIn file included from /usr/include/c++/9/exception:143,\n                 from\
    \ /usr/include/c++/9/ios:39,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmplklrv3wz.cpp:2:\n/usr/include/c++/9/bits/exception_ptr.h:166:5: note:\
    \   \u2018std::__exception_ptr::swap\u2019\n  166 |     swap(exception_ptr& __lhs,\
    \ exception_ptr& __rhs)\n      |     ^~~~\nIn file included from /usr/include/c++/9/filesystem:37,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmplklrv3wz.cpp:2:\n/usr/include/c++/9/bits/fs_path.h:611:15:\
    \ note:   \u2018std::filesystem::__cxx11::swap\u2019\n  611 |   inline void swap(path&\
    \ __lhs, path& "
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tlong min=arr[0];\n\tlong max = arr[0];\n\
    \tint count1=0;\n\tint count2=0;\n\tint count3=0;\n\tfor(int i=0;i<arr.size();i++)\n\
    \t{\n\t\tif(arr[i]>max)\n\t\t{\n\t\t\tmax=arr[i];\n\t\t\tcount1++;\n\t\t}\n\t\t\
    if(arr[i]<min)\n\t\t{\n\t\t\tmin=arr[i];\n\t\t\tcount2++;\n\t\t}\n\t\tif(arr[i]==max)\n\
    \t\t{\n\t\t\tcount3++;\n\t\t}\n\t}\n\tif(count1==1&&count2==1&&count3==1)\n\t\
    {\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmqmf8or5: /tmp/tmpmqmf8or5.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    assert(arr.size() >= 0);\n    if\
    \ (arr.size() == 0) {\n        return true;\n    }\n    for (int i = 0; i < arr.size()\
    \ - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            std::rotate(arr.begin(),\
    \ arr.begin() + arr.size() - 1, arr.end());\n            for (int i = 0; i < arr.size()\
    \ - 1; i++) {\n                if (arr[i] > arr[i + 1]) {\n                  \
    \  return false;\n                }\n            }\n            return true;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy0f98x6b: /tmp/tmpy0f98x6b.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0){\n        return\
    \ true;\n    }\n    auto it = std::min_element(arr.begin(), arr.end());\n    int\
    \ min_index = std::distance(arr.begin(), it);\n    for(int i = 0; i < arr.size();\
    \ i++){\n        if(arr[i] != arr[min_index]){\n            if(i == min_index\
    \ && arr[i] > arr[i+1]){\n                return false;\n            }\n     \
    \       if(i != min_index && arr[i] > arr[i+1]){\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvatrelnj: /tmp/tmpvatrelnj.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\
    \ {\n\t\treturn true;\n\t}\n\tlong min = arr[0];\n\tint min_index = 0;\n\tfor\
    \ (int i = 1; i < n; i++) {\n\t\tif (arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\
    \tmin_index = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i]\
    \ < min) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzs5cdrts: /tmp/tmpzs5cdrts.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0)\n        return\
    \ true;\n    for(int i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n \
    \           return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpuj9h120k: /tmp/tmpuj9h120k.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() == 0) {\n    return\
    \ true;\n  }\n  int l = 0;\n  while (l < arr.size() - 1) {\n    if (arr[l] > arr[l\
    \ + 1]) {\n      break;\n    }\n    l++;\n  }\n  int r = arr.size() - 1;\n  while\
    \ (r > 0) {\n    if (arr[r] < arr[r - 1]) {\n      break;\n    }\n    r--;\n \
    \ }\n  if (l == arr.size() - 1 || r == 0) {\n    return true;\n  }\n  int min\
    \ = arr[l];\n  int max = arr[r];\n  for (int i = l + 1; i <= r; i++) {\n    if\
    \ (arr[i] < min) {\n      min = arr[i];\n    }\n    if (arr[i] > max) {\n    \
    \  max = arr[i];\n    }\n  }\n  return (min > arr[0] && max < arr[arr.size() -\
    \ 1]);\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9o53sby0: /tmp/tmp9o53sby0.cpp:59: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    if(arr.size() == 1) return true;\n    int s = 0;\n    int e = arr.size()\
    \ - 1;\n    while(s < e) {\n        if(arr[s] > arr[s+1]) {\n            arr.erase(arr.begin()\
    \ + s);\n            s--;\n            e--;\n        }\n        s++;\n    }\n\
    \    s = 0;\n    while(s < e) {\n        if(arr[s] > arr[s+1]) return false;\n\
    \        s++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxckkfghj: /tmp/tmpxckkfghj.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    long n = arr.size();\n    if(n <\
    \ 2)\n        return true;\n    std::vector<long> left(n, 0);\n    std::vector<long>\
    \ right(n, 0);\n    left[0] = arr[0];\n    for(long i = 1; i < n; i++)\n     \
    \   left[i] = std::max(left[i-1], arr[i]);\n    right[n-1] = arr[n-1];\n    for(long\
    \ i = n-2; i >= 0; i--)\n        right[i] = std::min(right[i+1], arr[i]);\n  \
    \  for(long i = 0; i < n; i++)\n        if(left[i] <= right[i])\n            return\
    \ true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdqjnse2e: /tmp/tmpdqjnse2e.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code goes here\n    int\
    \ length = arr.size();\n    if(length == 0) return true;\n    int n = arr.size()\
    \ - 1;\n    int m = n - 1;\n    while(m >= 0) {\n        if(arr[m] < arr[n]) {\n\
    \            int i = n;\n            while(arr[i] > arr[m]) {\n              \
    \  --i;\n            }\n            if(i == m) return false;\n            while(arr[i\
    \ + 1] > arr[m]) {\n                arr[i] = arr[i + 1];\n                ++i;\n\
    \            }\n            arr[i] = arr[m];\n            --m;\n            --n;\n\
    \        } else {\n            --m;\n        }\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpm_5b35_9: /tmp/tmpm_5b35_9.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    long minimum = arr[0];\n    for(long i = 1; i < arr.size(); i++) {\n    \
    \    if(arr[i] >= minimum) minimum = arr[i];\n        else return false;\n   \
    \ }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwz3mthj5: /tmp/tmpwz3mthj5.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the method printf()\n  \
    \  // For example:\n    // printf(\"%s\", \"Hello world!\");\n\tassert(arr.size()>0);\n\
    \tbool is_sorted=false;\n\tstd::vector<long> v;\n\tv=arr;\n\tstd::sort(v.begin(),v.end());\n\
    \twhile(!is_sorted)\n\t{\n\t\tstd::rotate(arr.begin(),arr.begin()+1,arr.end());\n\
    \t\tis_sorted=true;\n\t\tfor(long i=0;i<arr.size();i++)\n\t\t{\n\t\t\tif(arr[i]!=v[i])\n\
    \t\t\t{\n\t\t\t\tis_sorted=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ is_sorted;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // Write your code here\n  std::vector<long>\
    \ arr1(arr.size());\n  for(int i=0;i<arr.size();i++)\n    arr1[i]=arr[i];\n  std::sort(arr1.begin(),arr1.end());\n\
    \  int len=arr.size();\n  int count=0;\n  for(int i=0;i<len;i++)\n  {\n    if(arr[i]==arr1[count])\n\
    \      count++;\n  }\n  if(count==len)\n    return true;\n  else\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpgnqf12lf: /tmp/tmpgnqf12lf.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> sorted = arr;\n\
    \    std::sort(sorted.begin(), sorted.end());\n    int n = arr.size();\n    int\
    \ count = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != sorted[i])\
    \ {\n            count++;\n        }\n    }\n    return count <= 2;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcymr51aq: /tmp/tmpcymr51aq.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() == 0) return true;\n\
    \  // TODO: Add code here\n  return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpgv_060hq: /tmp/tmpgv_060hq.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ Do not write input/output statements.\n    // Do not write input/output statements.\n\
    \    // Do not use scanf or printf statements.\n    // Do not use other functions\n\
    \    if(arr.size()==0)\n        return true;\n    if(arr.size()==1)\n        return\
    \ true;\n    int c=0;\n    int l=arr.size();\n    for(int i=0;i<l;i++)\n    {\n\
    \        for(int j=0;j<l-1;j++)\n        {\n            if(arr[j]>arr[j+1])\n\
    \            {\n                std::swap(arr[j],arr[j+1]);\n                c++;\n\
    \            }\n        }\n    }\n    //check if(arr[j]>arr[j+1]) then swap and\
    \ increment c by 1\n    // else do nothing\n    // for(int i=0;i<l;i++)\n    //\
    \ {\n    //     if(arr[i]>arr[i+1])\n    //     {\n    //         if(i==l-1)\n\
    \    //         {\n    //             break;\n    //         }\n    //       \
    \  else\n    //         {\n    //             std::swap(arr[i],arr[i+1]);\n  \
    \  //             c++;\n    //         }\n    //     }\n    // }\n    if(c==0)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnyvlysdy: /tmp/tmpnyvlysdy.cpp:70: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tstd::sort(arr.begin(), arr.end());\n\
    \tint len = arr.size();\n\tfor (int i = 0; i < len; i++) {\n\t\tif (arr[i] !=\
    \ i + 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjbope9bg: /tmp/tmpjbope9bg.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\t// To print\
    \ results to the standard output you can use the cout stream\n\t// Example: cout\
    \ << \"Hello world!\";\n\tint size = arr.size();\n\t//cout << size;\n\tif (size\
    \ == 0)\n\t\treturn true;\n\telse if (size == 1)\n\t\treturn true;\n\telse {\n\
    \t\tfor (int i = 0; i < size - 1; i++) {\n\t\t\tif (arr[i] > arr[i + 1])\n\t\t\
    \t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb1rj6m_v: /tmp/tmpb1rj6m_v.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\t// To print\
    \ results to the standard output you can use the cout stream\n\t// Example: cout\
    \ << \"Hello world!\";\n\tint count = 0;\n\tfor (int i = 0; i < arr.size(); i++)\
    \ {\n\t\tcount++;\n\t\tint j = i + 1;\n\t\twhile (arr[i] > arr[j]) {\n\t\t\tj++;\n\
    \t\t}\n\t\ti = j - 1;\n\t}\n\tif (count <= arr.size()) {\n\t\treturn true;\n\t\
    }\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp21o3165x: /tmp/tmp21o3165x.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // write your solution here\n  \
    \  int n = arr.size();\n    if(n==0)\n        return true;\n    int count =0;\n\
    \    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n\
    \    }\n    return count>1?false:true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() <= 1) {\n\t\treturn\
    \ true;\n\t}\n\t// TODO\n\tfor (int i = 0; i < arr.size() - 1; i++) {\n\t\tif\
    \ (arr[i] > arr[i + 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkx6c6lsg: /tmp/tmpkx6c6lsg.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  bool flag = true;\n  for(int i = 0;\
    \ i < arr.size() - 1; i++) {\n    if(arr[i] > arr[i + 1]) {\n      flag = false;\n\
    \      break;\n    }\n  }\n  return flag;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkaqqnyv1: /tmp/tmpkaqqnyv1.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// This function returns true if it\
    \ is possible to get a vector sorted in\n\t// non-decreasing order by performing\
    \ the following operation on the given\n\t// vector:\n\t// You are allowed to\
    \ perform right shift operation any number of times.\n\t// One right shift operation\
    \ means shifting all elements of the vector by one\n\t// position in the right\
    \ direction. The last element of the vector will be moved to\n\t// the starting\
    \ position in the vector i.e. 0th index.\n\tint n = arr.size();\n\tif (n == 0)\n\
    \t\treturn true;\n\t// Check the element at the 0th position if it is less than\
    \ the last element\n\t// then return false as it is not possible to get non-decreasing\
    \ order for\n\t// the given vector by performing any number of right shift operations.\n\
    \tif (arr[0] < arr[n - 1])\n\t\treturn false;\n\t// Return true if vector arr\
    \ is sorted in non-decreasing order.\n\tfor (int i = 0; i < n - 1; i++) {\n\t\t\
    if (arr[i] > arr[i + 1])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5q2xyehv: /tmp/tmp5q2xyehv.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0)\n    {\n     \
    \   return true;\n    }\n    long ele =arr[0];\n    bool flag=false;\n    long\
    \ min=ele;\n    for(long x:arr)\n    {\n        if(x>=ele)\n        {\n      \
    \      ele=x;\n        }\n        else\n        {\n            if(flag==false)\n\
    \            {\n                flag=true;\n            }\n            else\n\
    \            {\n                return false;\n            }\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpf2syme4w: /tmp/tmpf2syme4w.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  bool ret = true;\n  int len = arr.size();\n\
    \  if (len == 0) return true;\n  std::vector<long> arr1(arr);\n  std::sort(arr1.begin(),\
    \ arr1.end());\n  for (int i = 0; i < len; i++) {\n    if (arr[i] != arr1[i])\
    \ {\n      ret = false;\n      break;\n    }\n  }\n  for (int i = 1; i < len;\
    \ i++) {\n    if (arr[i] < arr[i - 1]) {\n      ret = false;\n      break;\n \
    \   }\n  }\n  return ret;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6pd16333: /tmp/tmp6pd16333.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    //get sorted list of array\n   \
    \ std::vector<long> arr1 = arr;\n    std::sort(arr1.begin(), arr1.end());\n  \
    \  //get the position of smallest element in the arr1\n    int pos = std::distance(arr1.begin(),\
    \ std::min_element(arr1.begin(), arr1.end()));\n    //Using cyclic permutation,\
    \ we get the expected ordering\n    //get the position of smallest element in\
    \ the arr\n    int pos1 = std::distance(arr.begin(), std::min_element(arr.begin(),\
    \ arr.end()));\n    //check if the ordering is possible using the above shifts\n\
    \    if((pos - pos1) % arr.size() == 0){\n        return true;\n    }else{\n \
    \       return false;\n    }\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3bxg4sm8: /tmp/tmp3bxg4sm8.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() == 0) return true;\n\
    \  std::vector<long> arr_temp(arr.size());\n  //copy the given vector into temp\
    \ vector.\n  for (int i = 0; i < arr.size(); i++) {\n    arr_temp[i] = arr[i];\n\
    \  }\n  //sort the temp vector.\n  std::sort(arr_temp.begin(), arr_temp.end());\n\
    \  int num_right_shifts = 0;\n  //the elements that are to be placed at their\
    \ respective positions.\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i]\
    \ == arr_temp[i]) {\n      num_right_shifts++;\n    }\n  }\n  if (num_right_shifts\
    \ == arr.size()) {\n    return true;\n  }\n  else {\n    return false;\n  }\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmps94g9f41: /tmp/tmps94g9f41.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\
    \ return true;\n\tstd::vector<bool> visited(n, false);\n\tlong pos = arr[0];\n\
    \tvisited[0] = true;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (pos < arr[i]) {\n\
    \t\t\treturn false;\n\t\t}\n\t\tif (pos > arr[i]) {\n\t\t\tint temp = arr[i];\n\
    \t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (temp < arr[j] && visited[j]\
    \ == false) {\n\t\t\t\t\tpos = arr[j];\n\t\t\t\t\tvisited[j] = true;\n\t\t\t\t\
    \tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplo73vxj1: /tmp/tmplo73vxj1.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> m(arr.size());\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        m[arr[i] - 1] = i;\n    }\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        long pos = m[i];\n       \
    \ if(pos > i) {\n            int flag = 0;\n            for(int j = pos; j > i;\
    \ j--) {\n                if(arr[j] < arr[j - 1]) {\n                    flag\
    \ = 1;\n                    break;\n                }\n            }\n       \
    \     if(flag == 0) {\n                return true;\n            }\n        }\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzuvmldkd: /tmp/tmpzuvmldkd.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> temp(arr.size());\n    temp[0] = 0;\n    for(int\
    \ i = 1; i < arr.size(); i++) {\n        if(arr[i] < arr[i-1]) {\n           \
    \ temp[i] = 1;\n        }\n        else {\n            temp[i] = 0;\n        }\n\
    \    }\n    if(std::accumulate(temp.begin(), temp.end(), 0) <= 1)\n        return\
    \ true;\n    else\n        return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> arr_copy(arr);\n\
    \    std::sort(arr_copy.begin(), arr_copy.end());\n    long sorted_array_sum=0;\n\
    \    long actual_array_sum=0;\n    for(long i=0;i<arr.size();i++){\n        sorted_array_sum+=arr_copy[i];\n\
    \        actual_array_sum+=arr[i];\n    }\n    return sorted_array_sum==actual_array_sum;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5q8e71pr: /tmp/tmp5q8e71pr.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n < 2)\
    \ return true;\n\t// bool sorted = false;\n\t// bool prevSorted = false;\n\tfor\
    \ (int i = 0; i < n; i++) {\n\t\tif (arr[i] < arr[i+1])\n\t\t\treturn true;\n\t\
    }\n\treturn false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpphbsqs5l: /tmp/tmpphbsqs5l.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0)\n        return true;\n    std::stack<long> s;\n    long max = -1;\n    for(int\
    \ i = 0; i < n; i++) {\n        long ele = arr[i];\n        if(ele > max) {\n\
    \            while(!s.empty() && ele > s.top()) {\n                max = s.top();\n\
    \                s.pop();\n            }\n            s.push(ele);\n        }\n\
    \        else {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5focpg9d: /tmp/tmp5focpg9d.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tbool flag = true;\n\tif (arr.size()\
    \ == 0)\n\t\treturn true;\n\tstd::vector<long> v;\n\tstd::vector<long> v1;\n\t\
    std::vector<long> v2;\n\tlong x = arr[0];\n\tv.push_back(x);\n\tfor (int i = 1;\
    \ i < arr.size(); i++) {\n\t\tif (x < arr[i]) {\n\t\t\tv.push_back(arr[i]);\n\t\
    \t\tx = arr[i];\n\t\t}\n\t\telse {\n\t\t\tv1.push_back(arr[i]);\n\t\t}\n\t}\n\t\
    if (v1.size() > 0) {\n\t\tlong temp = v1[0];\n\t\tv2.push_back(temp);\n\t\tfor\
    \ (int i = 1; i < v1.size(); i++) {\n\t\t\tif (temp < v1[i]) {\n\t\t\t\tflag =\
    \ false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv2.push_back(v1[i]);\n\
    \t\t\t\ttemp = v1[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 0;\
    \ i < v.size(); i++) {\n\t\t\tif (i == v.size() - 1) {\n\t\t\t\tif (v[i] > v2[0])\
    \ {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\tif (v[i] > v[i + 1]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkoq10v26: /tmp/tmpkoq10v26.cpp:76: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    int\
    \ N = arr.size();\n    if(N==0)\n        return true;\n    int count_sort[N+1]={0};\n\
    \    for(int i=0;i<N;i++)\n        count_sort[arr[i]]++;\n    for(int i=1;i<=N;i++)\n\
    \        if(count_sort[i]>1)\n            return false;\n    for(int i=0;i<N;i++)\n\
    \        if(count_sort[i]==0)\n            return false;\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp56r7gza7: /tmp/tmp56r7gza7.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint len = arr.size();\n\tif (len ==\
    \ 0)\n\t\treturn true;\n\tint max_pos = 0;\n\tfor (int i = 1; i < len; i++) {\n\
    \t\tif (arr[i] > arr[max_pos])\n\t\t\tmax_pos = i;\n\t}\n\tif (max_pos == len\
    \ - 1)\n\t\treturn true;\n\tif (max_pos == 0)\n\t\treturn false;\n\tfor (int i\
    \ = 0; i < max_pos; i++) {\n\t\tif (arr[i] > arr[i + 1])\n\t\t\treturn false;\n\
    \t}\n\tfor (int i = max_pos + 1; i < len; i++) {\n\t\tif (arr[i] < arr[i - 1])\n\
    \t\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu_19na4u: /tmp/tmpu_19na4u.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // your code here\n    int temp;\n\
    \    int count = 0;\n    bool geeks = false;\n    bool flag = false;\n    for(int\
    \ i = 0; i < arr.size(); i++){\n        geeks = false;\n        temp = arr[i];\n\
    \        for(int j = i+1; j < arr.size(); j++){\n            if(arr[j] < temp){\n\
    \                geeks = true;\n                break;\n            }\n      \
    \  }\n        if(geeks == false){\n            count++;\n        }\n    }\n  \
    \  if(count == arr.size()){\n        flag = true;\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8ovcv8y4: /tmp/tmp8ovcv8y4.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> sorted(arr);\n\
    \    std::sort(sorted.begin(), sorted.end());\n    int count = 0;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] != sorted[i]) {\n        \
    \    count++;\n        }\n    }\n    if (count > 1) {\n        return false;\n\
    \    }\n    else {\n        return true;\n    }\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0wrp8yjt: /tmp/tmp0wrp8yjt.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // TODO: Write - Your - Code\n \
    \   if(arr.size()==0){\n        return true;\n    }\n    std::vector<long> unsorted;\n\
    \    long temp =arr[0];\n    for(int i=1;i<arr.size();i++){\n        if(arr[i]<temp){\n\
    \            unsorted.push_back(arr[i]);\n        }\n        else{\n         \
    \   temp = arr[i];\n        }\n    }\n    return unsorted.size()<=1;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8h55xswt: /tmp/tmp8h55xswt.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int size = arr.size();\n    int\
    \ *minPos = new int[size];\n    int *visited = new int[size];\n    std::fill(visited,\
    \ visited + size, 0);\n    // 1: can move\n    // 0: can't move\n    // -1: visited\n\
    \    for (int i = 0; i < size; i++) {\n        if (visited[i] == -1) {\n     \
    \       continue;\n        }\n        int j = i;\n        long min = arr[i];\n\
    \        int curMinPos = i;\n        int curMinPosOld = i;\n        while (true)\
    \ {\n            int cur = arr[j];\n            if (cur < min) {\n           \
    \     min = cur;\n                curMinPos = j;\n            }\n            int\
    \ pos = (j + 1) % size;\n            if (arr[pos] > cur) {\n                j\
    \ = pos;\n            } else {\n                break;\n            }\n      \
    \  }\n        minPos[i] = curMinPos;\n        visited[i] = 1;\n        if (curMinPos\
    \ == i) {\n            continue;\n        }\n        j = i;\n        while (true)\
    \ {\n            if (visited[j] == -1) {\n                break;\n           \
    \ }\n            int pos = (j + 1) % size;\n            int cur = arr[pos];\n\
    \            visited[j] = -1;\n            if (cur < min) {\n                min\
    \ = cur;\n                curMinPos = pos;\n            }\n            if (pos\
    \ == curMinPosOld) {\n                break;\n            }\n            j = pos;\n\
    \        }\n        minPos[i] = curMinPos;\n        if (curMinPos != curMinPosOld)\
    \ {\n            visited[i] = 0;\n        }\n    }\n    bool can = true;\n   \
    \ for (int i = 0; i < size; i++) {\n        if (visited[i] == 0) {\n         \
    \   can = false;\n            break;\n        }\n    }\n    delete[] minPos;\n\
    \    delete[] visited;\n    return can;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpiibq67_5: /tmp/tmpiibq67_5.cpp:95: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111300
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> sort_arr = arr;\n\
    \    int n = arr.size();\n    if(n==0){\n        return true;\n    }\n    int\
    \ min_index = 0;\n    sort(sort_arr.begin(), sort_arr.end());\n    // we find\
    \ the element in the array which is the smallest\n    // and then check the value\
    \ at that index in the sorted array \n    // if the value is equal to the value\
    \ at that index in the sorted array \n    // then no right shift is required \n\
    \    // we can just see if the the following elements are in increasing order\
    \ or not\n    for(int i=0;i<n;i++){\n        if(arr[i]==sort_arr[0]){\n      \
    \      min_index = i;\n            break;\n        }\n    }\n    if(arr[min_index]!=sort_arr[min_index]){\n\
    \        return false;\n    }\n    for(int i=min_index+1;i<n;i++){\n        if(arr[i]<arr[i-1]){\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpegc3jegm: /tmp/tmpegc3jegm.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\t\treturn true;\n\
    \tstd::map<long,long> mymap;\n\tlong max = 0;\n\tlong min = INT_MAX;\n\tfor (auto\
    \ i : arr) {\n\t\tif (i > max)\n\t\t\tmax = i;\n\t\tif (i < min)\n\t\t\tmin =\
    \ i;\n\t\tmymap[i]++;\n\t}\n\treturn (mymap.size() == max - min + 1);\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp15a43wa5: /tmp/tmp15a43wa5.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    std::vector<long> nge(arr.size());\n\
    \    std::stack<long> st;\n    for(int i=arr.size()-1;i>=0;i--){\n        while(!st.empty()\
    \ && arr[i] > arr[st.top()])\n            st.pop();\n        if(st.empty())\n\
    \            nge[i] = -1;\n        else\n            nge[i] = st.top();\n    \
    \    st.push(i);\n    }\n    int max_right = -1;\n    for(int i=0;i<arr.size();i++){\n\
    \        if(max_right <= nge[i])\n            max_right = nge[i];\n        else\
    \ if(max_right > i)\n            return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5npi4sc4: /tmp/tmp5npi4sc4.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // TODO: Write your code here\n\
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpa1m2d8bu: /tmp/tmpa1m2d8bu.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111301
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int count = 0;\n    while (count\
    \ < arr.size()) {\n        if (arr[count] <= arr[count - 1]) {\n            return\
    \ false;\n        }\n        count++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpp7om423q: /tmp/tmpp7om423q.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111302
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    if(arr.size() <= 1) return true;\n    int *count;\n\
    \    count = new int[arr.size()+1];\n    for(int i = 0; i <= arr.size(); i++)\
    \ count[i] = 0;\n    for(int i = 0; i < arr.size(); i++) count[arr[i]]++;\n  \
    \  for(int i = 1; i <= arr.size(); i++) {\n        if(count[i] > 1) return false;\n\
    \    }\n    long high = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < high) return false;\n        high = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyee5gjha: /tmp/tmpyee5gjha.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()==0)\n\
    \        return true;\n    if(arr.size()==1)\n        return true;\n    std::vector<long>\
    \ temp(arr.size());\n    std::copy(arr.begin(),arr.end(),temp.begin());\n    std::sort(temp.begin(),temp.end());\n\
    \    std::vector<int> pos(arr.size());\n    for(int i=0;i<arr.size();i++)\n  \
    \  {\n        pos[i]=std::find(temp.begin(),temp.end(),arr[i])-temp.begin();\n\
    \    }\n    int flag=0;\n    int index=-1;\n    for(int i=0;i<pos.size();i++)\n\
    \    {\n        if(pos[i]!=i)\n        {\n            flag=1;\n            index=i;\n\
    \            break;\n        }\n    }\n    if(flag==0)\n        return true;\n\
    \    for(int i=index;i<pos.size();i++)\n    {\n        if(pos[i]==index)\n   \
    \     {\n            flag=0;\n            break;\n        }\n    }\n    if(flag==0)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpd29b9gbu: /tmp/tmpd29b9gbu.cpp:68: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111302
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n    {\n   \
    \     return true;\n    }\n    int N = arr.size();\n    int count = 0;\n    int\
    \ expected_count = N - 1;\n    for(int i = 0; i < N - 1; i++)\n    {\n       \
    \ if(arr[i] < arr[i + 1])\n        {\n            count++;\n        }\n    }\n\
    \    if(count == expected_count)\n    {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxgq01tis: /tmp/tmpxgq01tis.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    int\
    \ i;\n    for(i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n  \
    \      {\n            break;\n        }\n    }\n    for(int j=i+1;j<arr.size();j++)\n\
    \    {\n        if(arr[j]<arr[i])\n        {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_9mtptz5: /tmp/tmp_9mtptz5.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  int n = arr.size();\n  if(arr.size()\
    \ == 0)\n    return true;\n  std::vector<long> max(n);\n  std::vector<long> min(n);\n\
    \  max[0] = arr[0];\n  min[n-1] = arr[n-1];\n  for(int i = 1; i < n; i++)\n  \
    \  max[i] = std::max(max[i-1], arr[i]);\n  for(int i = n-2; i >= 0; i--)\n   \
    \ min[i] = std::min(min[i+1], arr[i]);\n  for(int i = 0; i < n; i++)\n    if(max[i]\
    \ <= min[i])\n      return true;\n  return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfuxzi3ix: /tmp/tmpfuxzi3ix.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() <= 1) {\n\t\treturn\
    \ true;\n\t}\n\telse {\n\t\tstd::vector<long> temp = arr;\n\t\tstd::sort(temp.begin(),\
    \ temp.end());\n\t\tif (arr[0] == temp[temp.size() - 1]) {\n\t\t\tint last_position\
    \ = 0;\n\t\t\tfor (int i = 0; i < arr.size(); i++) {\n\t\t\t\tif (arr[i] == temp[temp.size()\
    \ - 1]) {\n\t\t\t\t\tlast_position = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i\
    \ = 0; i < arr.size(); i++) {\n\t\t\t\tif (arr[i] != temp[i + last_position])\
    \ {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\
    \telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxk49t_b3: /tmp/tmpxk49t_b3.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  int n = arr.size();\n  if(n == 0)\n\
    \    return true;\n  int index_max = 0;\n  long max = arr[0];\n  for(int i = 1;\
    \ i < n; i++) {\n    if(arr[i] > max) {\n      max = arr[i];\n      index_max\
    \ = i;\n    }\n  }\n  if(index_max == n - 1)\n    return true;\n  for(int i =\
    \ index_max; i < n - 1; i++) {\n    if(arr[i + 1] < arr[i])\n      return false;\n\
    \  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb77zd69x: /tmp/tmpb77zd69x.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\t\treturn true;\n\
    \tint n = arr.size();\n\tint min_index = 0;\n\tfor (int i = 0; i < n; i++) {\n\
    \t\tif (arr[i] < arr[min_index])\n\t\t\tmin_index = i;\n\t}\n\tint count = 0;\n\
    \tint index = min_index;\n\tdo {\n\t\tindex = (index + 1) % n;\n\t\tcount++;\n\
    \t} while (index != min_index);\n\tif (count == n)\n\t\treturn true;\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2ky0mb34: /tmp/tmp2ky0mb34.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // your code goes here\n    std::sort(arr.begin(),\
    \ arr.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] !=\
    \ i + 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphrcisdiy: /tmp/tmphrcisdiy.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplho5y97z: /tmp/tmplho5y97z.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // Implement your solution here.\n\
    \  long i,j,k,count=0;\n  for(i=0;i<arr.size();i++)\n  {\n      for(j=0;j<arr.size()-1;j++)\n\
    \      {\n          if(arr[j]>arr[j+1])\n          {\n              k=arr[j];\n\
    \              arr[j]=arr[j+1];\n              arr[j+1]=k;\n              count++;\n\
    \          }\n      }\n  }\n  if(count<=1)\n  {\n      return true;\n  }\n  else\n\
    \  {\n      return false;\n  }\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6lk1pv3x: /tmp/tmp6lk1pv3x.cpp:51: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    //Your code goes here\n    if(arr.size()\
    \ == 0)\n        return true;\n    int count[arr.size()];\n    memset(count, 0,\
    \ sizeof(count));\n    for(int i = 0; i < arr.size(); i++)\n    {\n        for(int\
    \ j = 0; j < arr.size(); j++)\n        {\n            if(arr[i] < arr[j])\n  \
    \              count[i]++;\n        }\n    }\n    bool flag = false;\n    for(int\
    \ i = 0; i < arr.size(); i++)\n    {\n        if(count[i] == arr.size() - 1)\n\
    \        {\n            flag = true;\n            break;\n        }\n    }\n \
    \   return flag;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxytix_i3: /tmp/tmpxytix_i3.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    for(int i = 0; i < arr.size() - 1; i++) {\n        if(arr[i] > arr[i\
    \ + 1])\n            return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphgay9sj5: /tmp/tmphgay9sj5.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0){\n        return true;\n    }\n    if(n == 1){\n        return true;\n  \
    \  }\n    int idx = 0;\n    for(int i = 1; i < n; i++){\n        if(arr[i] < arr[i-1]){\n\
    \            idx = i;\n            break;\n        }\n    }\n    if(idx == 0){\n\
    \        return true;\n    }\n    int min_so_far = arr[idx];\n    for(int i =\
    \ idx+1; i < n; i++){\n        if(arr[i] < min_so_far){\n            return false;\n\
    \        }\n    }\n    if(arr[0] < min_so_far){\n        return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111303
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    for(int\
    \ i = 1; i < n; i++) {\n        if(arr[i-1] > arr[i]) {\n            int j = i;\n\
    \            while(j > 0 && arr[j-1] > arr[j]) {\n                swap(arr[j-1],\
    \ arr[j]);\n                j--;\n            }\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprzk14nff.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmprzk14nff.cpp:30:17: error: \u2018swap\u2019 was not declared\
    \ in this scope\n   30 |                 swap(arr[j-1], arr[j]);\n      |    \
    \             ^~~~\n/tmp/tmprzk14nff.cpp:30:17: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprzk14nff.cpp:2:\n/usr/include/c++/9/bits/regex.h:2029:5:\
    \ note:   \u2018std::__cxx11::swap\u2019\n 2029 |     swap(match_results<_Bi_iter,\
    \ _Alloc>& __lhs,\n      |     ^~~~\nIn file included from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmprzk14nff.cpp:2:\n/usr/include/c++/9/bits/move.h:182:5:\
    \ note:   \u2018std::swap\u2019\n  182 |     swap(_Tp& __a, _Tp& __b)\n      |\
    \     ^~~~\n/usr/include/c++/9/bits/move.h:182:5: note:   \u2018std::swap\u2019\
    \nIn file included from /usr/include/c++/9/exception:143,\n                 from\
    \ /usr/include/c++/9/ios:39,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmprzk14nff.cpp:2:\n/usr/include/c++/9/bits/exception_ptr.h:166:5: note:\
    \   \u2018std::__exception_ptr::swap\u2019\n  166 |     swap(exception_ptr& __lhs,\
    \ exception_ptr& __rhs)\n      |     ^~~~\nIn file included from /usr/include/c++/9/filesystem:37,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmprzk14nff.cpp:2:\n/usr/include/c++/9/bits/fs_path.h:611:15:\
    \ note:   \u2018std::filesystem::__cxx11::swap\u2019\n  611 |   inline void"
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // your code goes here\n  if(arr.size()\
    \ == 0)\n      return true;\n  std::vector<long> temp(arr.size());\n  for(int\
    \ i = 0; i < arr.size(); i++)\n  {\n      temp[i] = arr[i];\n  }\n  sort(temp.begin(),\
    \ temp.end());\n  int i = 0;\n  long next = temp[i];\n  while(i != temp.size())\n\
    \  {\n      if(arr[i] == next)\n      {\n          i++;\n          next = temp[i];\n\
    \      }\n      else if(arr[i] == temp[temp.size() - 1])\n      {\n          long\
    \ last = arr[i];\n          arr.erase(arr.begin() + i);\n          arr.insert(arr.begin(),\
    \ last);\n      }\n      else\n      {\n          return false;\n      }\n  }\n\
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpr7746y7p: /tmp/tmpr7746y7p.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // TO DO: Please implement the function\
    \ here.\n  int ln = arr.size();\n  if(ln == 0) return true;\n  if(ln == 1) return\
    \ true;\n  int k = 0;\n  for(int i = 1; i < ln; i++)\n    if(arr[i] > arr[i-1])\n\
    \      k++;\n  if(k == ln - 1) return true;\n  else return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2cnguqt9: /tmp/tmp2cnguqt9.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int arr_size = arr.size();\n   \
    \ if (arr_size == 0) {\n        return true;\n    }\n    std::vector<long> arr_copy(arr_size);\n\
    \    for (long i = 0; i < arr_size; i++) {\n        arr_copy[i] = arr[i];\n  \
    \  }\n    std::sort(arr_copy.begin(), arr_copy.end());\n    for (long i = 0; i\
    \ < arr_size; i++) {\n        if (arr[i] != arr_copy[i]) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy0zj5n2s: /tmp/tmpy0zj5n2s.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int count = 0;\n    for(int i =\
    \ 0; i < arr.size(); i++) {\n        for(int j = i+1; j < arr.size(); j++) {\n\
    \            if(arr[i] > arr[j]) {\n                count++;\n            }\n\
    \        }\n    }\n    if(count == 0) {\n        return true;\n    } else if(count\
    \ == 1) {\n        return true;\n    } else {\n        return false;\n    }\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpsff0w3rm: /tmp/tmpsff0w3rm.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0)\n        return\
    \ true;\n    std::vector<long> unique_arr;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        std::vector<long>::iterator it = find(unique_arr.begin(),unique_arr.end(),arr[i]);\n\
    \        if(it==unique_arr.end())\n            unique_arr.push_back(arr[i]);\n\
    \    }\n    if(unique_arr.size()==1)\n        return true;\n    std::sort(unique_arr.begin(),unique_arr.end());\n\
    \    int count = 0;\n    long min_pos = std::min_element(arr.begin(),arr.end())-arr.begin();\n\
    \    for(int i=0;i<unique_arr.size();i++)\n    {\n        std::vector<long>::iterator\
    \ it = find(arr.begin(),arr.end(),unique_arr[i]);\n        if(it==arr.end())\n\
    \            return false;\n        if(it-arr.begin()==min_pos)\n            count++;\n\
    \    }\n    return (count<=1);\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmps6awfhv7: /tmp/tmps6awfhv7.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tstd::vector<long>::size_type N = arr.size();\n\
    \t// Check if size is empty\n\tif (N == 0) {\n\t\treturn true;\n\t}\n\t// Loop\
    \ through the vector to find the smallest item\n\tlong minNum = arr[0];\n\tstd::vector<long>::size_type\
    \ minPos = 0;\n\tfor (std::vector<long>::size_type i = 1; i < N; i++) {\n\t\t\
    if (arr[i] < minNum) {\n\t\t\tminNum = arr[i];\n\t\t\tminPos = i;\n\t\t}\n\t}\n\
    \t// Check if the minimum is in position 0, otherwise return false\n\tif (minPos\
    \ != 0) {\n\t\treturn false;\n\t}\n\t// Loop through the vector\n\tfor (std::vector<long>::size_type\
    \ i = 1; i < N; i++) {\n\t\t// If a number is smaller than the previous number,\
    \ return false\n\t\tif (arr[i] < arr[i - 1]) {\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\t// Otherwise, return true\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp15p7c8c7: /tmp/tmp15p7c8c7.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    for(int i = 0; i < arr.size() - 1; i++) {\n        if(arr[i] > arr[i\
    \ + 1])\n            return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphgay9sj5: /tmp/tmphgay9sj5.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n    {\n   \
    \     return true;\n    }\n    long prev = arr[0];\n    long initial_pos = 0;\n\
    \    for(long i = 1; i < arr.size(); i++)\n    {\n        if(arr[i] > prev)\n\
    \        {\n            prev = arr[i];\n        }\n        else\n        {\n \
    \           initial_pos = i;\n            break;\n        }\n    }\n    for(long\
    \ i = initial_pos; i < arr.size(); i++)\n    {\n        if(arr[i] < prev)\n  \
    \      {\n            return false;\n        }\n        prev = arr[i];\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpe28xfkff: /tmp/tmpe28xfkff.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // Write your code here.\n  if(arr.size()\
    \ == 0) return true;\n  if(arr.size() == 1) return true;\n  long maximum = 0;\n\
    \  long maximumIndex = 0;\n  for(int i = 0; i < arr.size(); i++){\n    if(arr[i]\
    \ > maximum){\n      maximum = arr[i];\n      maximumIndex = i;\n    }\n  }\n\
    \  if(maximumIndex == 0) return true;\n  for(int i = maximumIndex; i < arr.size();\
    \ i++){\n    if(arr[i] >= maximum) return false;\n  }\n  for(int i = 0; i < maximumIndex;\
    \ i++){\n    if(arr[i] >= maximum) return false;\n  }\n  return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppb_nvt_t: /tmp/tmppb_nvt_t.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() == 0) {\n    return\
    \ true;\n  }\n  long i;\n  std::vector<long> v(arr.size());\n  std::vector<long>::iterator\
    \ it;\n  long n = arr.size();\n  std::copy(arr.begin(), arr.end(), v.begin());\n\
    \  std::sort(v.begin(), v.end());\n  for (i = 0; i < n; i++) {\n    if (arr[i]\
    \ == v[0]) {\n      break;\n    }\n  }\n  std::rotate(arr.begin(), arr.begin()\
    \ + i, arr.end());\n  for (i = 0; i < n; i++) {\n    if (arr[i] != v[i]) {\n \
    \     return false;\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\
    \ {\n\t\treturn true;\n\t}\n\tlong min = arr[0];\n\tfor (int i = 1; i < n; i++)\
    \ {\n\t\tif (arr[i] < min) {\n\t\t\treturn false;\n\t\t}\n\t\tmin = arr[i];\n\t\
    }\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpa2olg3fs: /tmp/tmpa2olg3fs.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    // If you want to return an integer, use 'return'\n\
    \    // Example: return 42;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpo7apvmdq: /tmp/tmpo7apvmdq.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    for(int i=0;i<arr.size();i++){\n\
    \        int count=0;\n        for(int j=0;j<arr.size();j++){\n            if(arr[i]<arr[j])\n\
    \                count++;\n        }\n        if(count>arr.size()-i)\n       \
    \     return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp73x6ycnq: /tmp/tmp73x6ycnq.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0)return true;\n\
    \    std::vector<int> dp(arr.size(),-1);\n    int mx=arr[0];\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<mx)continue;\n        if(arr[i]==mx){\n            mx=arr[i];\n\
    \            dp[i]=1;\n        }\n        if(arr[i]>mx){\n            dp[i]=mx+1;\n\
    \            mx=arr[i];\n        }\n    }\n    return dp[arr.size()-1]!=-1;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpts0cwxzy: /tmp/tmpts0cwxzy.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()\
    \ == 0)\n        return true;\n    if(arr.size() == 1)\n        return true;\n\
    \    long min = INT_MAX;\n    long max = INT_MIN;\n    for(long i = 0; i < arr.size();\
    \ i++){\n        if(arr[i] > max)\n            max = arr[i];\n        if(arr[i]\
    \ < min)\n            min = arr[i];\n    }\n    std::cout << \"min: \" << min\
    \ << \" max: \" << max << std::endl;\n    if(min > 1)\n        return false;\n\
    \    if(max != arr.size())\n        return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpooc0v2r5: /tmp/tmpooc0v2r5.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: 'min: 1 max: 5

    min: 1 max: 10

    '
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0) return true;\n\
    \    long n = arr.size();\n    long i=0;\n    while(i<n){\n        long curr =\
    \ arr[i];\n        if(i+1<n && arr[i+1]<curr){\n            break;\n        }\n\
    \        ++i;\n    }\n    if(i==n) return true;\n    while(i>0){\n        --i;\n\
    \        if(arr[i]>arr[i+1]){\n            return false;\n        }\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpr2k2dx6u: /tmp/tmpr2k2dx6u.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() == 0) return true;\n\
    \  // Delete the next four lines and add your own code here.\n  // The next line\
    \ is only here so that this skeleton code compiles.\n  std::string question =\
    \ \"\";\n  std::getline(std::cin, question);\n  std::stringstream ss(question);\n\
    \  std::string item;\n  std::vector<std::string> tokens;\n  while (std::getline(ss,\
    \ item, ' ')) {\n    tokens.push_back(item);\n  }\n  if (tokens.size() != arr.size())\
    \ return false;\n  std::vector<long> sorted(arr.size());\n  std::sort(arr.begin(),\
    \ arr.end());\n  std::copy(arr.begin(), arr.end(), sorted.begin());\n  for (auto\
    \ i = 0; i < arr.size(); i++) {\n    if (tokens[i] != std::to_string(arr[i]))\
    \ return false;\n  }\n  std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n\
    \  for (auto i = 0; i < arr.size(); i++) {\n    if (arr[i] != sorted[i]) return\
    \ false;\n  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660111308
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tfor (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i\
    \ + 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7xmkgq19: /tmp/tmp7xmkgq19.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n==0){\n\
    \        return true;\n    }\n    if(n==1){\n        return true;\n    }\n   \
    \ for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1]){\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqvf4_b0l: /tmp/tmpqvf4_b0l.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// write your code here\n\tif (arr.size()\
    \ <= 1) {\n\t\treturn true;\n\t}\n\tlong i = 0;\n\twhile (i < arr.size() - 1)\
    \ {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif\
    \ (i == arr.size() - 1) {\n\t\treturn true;\n\t}\n\telse {\n\t\tlong j = i + 1;\n\
    \t\twhile (j < arr.size() - 1) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (arr[arr.size() - 1] < arr[0]) {\n\
    \t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoh34sphc: /tmp/tmpoh34sphc.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\t// Itereate\
    \ through the vector to find the out of place element\n\t// Cannot Shift it to\
    \ any position to make the array non-decreasing\n\t// Sort the array, iterate\
    \ through the sorted array and the input array\n\t// if sorted[i] != arr[i]\n\t\
    // return false\n\t// return true\n\t// return true if arr.size() == 0\n\tint\
    \ out_of_place = -1;\n\tfor (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i]\
    \ > arr[i + 1]) {\n\t\t\tout_of_place = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (out_of_place\
    \ == -1) {\n\t\treturn true;\n\t}\n\telse {\n\t\tstd::vector<long> sorted_arr\
    \ = arr;\n\t\tstd::sort(sorted_arr.begin(), sorted_arr.end());\n\t\tfor (int i\
    \ = 0; i < arr.size(); i++) {\n\t\t\tif (sorted_arr[i] != arr[i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptdkbu4oa: /tmp/tmptdkbu4oa.cpp:56: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end());\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] != i + 1) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpg_9w307p: /tmp/tmpg_9w307p.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111303
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // TODO: Write code here\n  bool res\
    \ = true;\n  if(arr.size() == 0) {\n      return res;\n  }\n  auto it = arr.begin();\n\
    \  while(it < arr.end()-1) {\n      auto next = it+1;\n      if(*it > *next) {\n\
    \          res = false;\n          break;\n      }\n      it++;\n  }\n  return\
    \ res;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpobs_7hsr: /tmp/tmpobs_7hsr.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() == 0) {\n    return\
    \ true;\n  }\n  else {\n    std::sort(arr.begin(), arr.end());\n    int index\
    \ = arr.size() - 1;\n    for (int i = 0; i < arr.size(); i++) {\n      if (arr[i]\
    \ == arr[index]) {\n        index--;\n      }\n      else {\n        return false;\n\
    \      }\n    }\n    return true;\n  }\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7kfa93by: /tmp/tmp7kfa93by.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    else if(arr.size() == 1)\n        return true;\n    else if(arr.size()\
    \ == 2)\n        return arr[0] <= arr[1];\n    else if(arr.size() == 3)\n    \
    \    return arr[0] <= arr[1] && arr[1] <= arr[2];\n    std::vector<long> sorted_arr\
    \ = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n    long count\
    \ = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] != sorted_arr[i])\n\
    \            count++;\n    }\n    if(count > 2)\n        return false;\n    else\
    \ if(count == 2) {\n        if(arr[0] == sorted_arr[1] && arr[1] == sorted_arr[0])\n\
    \            return true;\n        if(arr[0] == sorted_arr[arr.size() - 1] &&\
    \ arr[arr.size() - 1] == sorted_arr[0])\n            return true;\n        if(arr[arr.size()\
    \ - 1] == sorted_arr[arr.size() - 2] && arr[arr.size() - 2] == sorted_arr[arr.size()\
    \ - 1])\n            return true;\n        if(arr[arr.size() - 1] == sorted_arr[0]\
    \ && arr[0] == sorted_arr[arr.size() - 1])\n            return true;\n       \
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppnxjnsr9: /tmp/tmppnxjnsr9.cpp:57: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    else if(arr.size() == 1)\n        return true;\n    else if(arr.size()\
    \ == 2)\n        return true;\n    else{\n        std::vector<long> new_arr(arr.size());\n\
    \        new_arr[0] = arr[arr.size()-1];\n        for(int i = 1; i < arr.size();\
    \ i++)\n            new_arr[i] = arr[i-1];\n        bool check = true;\n     \
    \   for(int i = 0; i < arr.size()-1; i++){\n            if(new_arr[i] > new_arr[i+1]){\n\
    \                check = false;\n                break;\n            }\n     \
    \   }\n        if(check)\n            return true;\n        else\n           \
    \ return move_one_ball(new_arr);\n    }\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here.\n    std::vector<long>\
    \ sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n  \
    \  if (arr.size() < 2) {\n        return true;\n    }\n    int size = arr.size();\n\
    \    long min = arr[0];\n    long max = arr[0];\n    for (int i = 0; i < size;\
    \ i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n\
    \        if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n  \
    \  if (min < max) {\n        return false;\n    }\n    int min_index = 0;\n  \
    \  for (int i = 0; i < size; i++) {\n        if (arr[i] == min) {\n          \
    \  min_index = i;\n            break;\n        }\n    }\n    for (int i = 0; i\
    \ < size; i++) {\n        if (arr[(min_index + i) % size] != sorted_arr[i]) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphvuzsn4m: /tmp/tmphvuzsn4m.cpp:61: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sortedArr(arr);\n    std::sort(sortedArr.begin(),\
    \ sortedArr.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != sortedArr[i])\n            return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpgbjawzqa: /tmp/tmpgbjawzqa.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111304
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\t// To print\
    \ results to the standard output you can use cout\n\t// Example: cout << \"Hello\
    \ world!\";\n\tlong n = arr.size();\n\tif (n == 0)\n\t\treturn true;\n\tlong smin\
    \ = arr[0];\n\tstd::vector<long> dp(n);\n\tfor (long i = 1; i < n; i++) {\n\t\t\
    if (arr[i] < smin) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tdp[i] = max(dp[i\
    \ - 1], arr[i] - smin);\n\t\t\tsmin = min(smin, arr[i]);\n\t\t}\n\t}\n\tfor (long\
    \ i = 0; i < n; i++) {\n\t\tif (dp[i] > i)\n\t\t\treturn false;\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjtbjlj35.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpjtbjlj35.cpp:38:12: error: \u2018max\u2019 was not declared\
    \ in this scope; did you mean \u2018std::max\u2019?\n   38 |    dp[i] = max(dp[i\
    \ - 1], arr[i] - smin);\n      |            ^~~\n      |            std::max\n\
    In file included from /usr/include/c++/9/algorithm:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpjtbjlj35.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note: \u2018\
    std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp> __l, _Compare\
    \ __comp)\n      |     ^~~\n/tmp/tmpjtbjlj35.cpp:39:11: error: \u2018min\u2019\
    \ was not declared in this scope; did you mean \u2018std::min\u2019?\n   39 |\
    \    smin = min(smin, arr[i]);\n      |           ^~~\n      |           std::min\n\
    In file included from /usr/include/c++/9/algorithm:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpjtbjlj35.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3456:5: note: \u2018\
    std::min\u2019 declared here\n 3456 |     min(initializer_list<_Tp> __l, _Compare\
    \ __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660111304
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> temp = arr;\n\
    \    std::sort(temp.begin(), temp.end());\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] != temp[i]) {\n            long val = arr[i];\n \
    \           arr.erase(arr.begin() + i);\n            arr.insert(arr.begin(), val);\n\
    \            i = -1;\n        }\n    }\n    bool result = true;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] != temp[i]) {\n          \
    \  result = false;\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    std::vector<long>\
    \ count(arr.size()+1,0);\n    for(int i=0;i<arr.size();i++)\n    {\n        count[arr[i]]++;\n\
    \    }\n    int j=0;\n    for(int i=1;i<=arr.size();i++)\n    {\n        while(count[i]!=0)\n\
    \        {\n            if(arr[j]!=i)\n            {\n                return false;\n\
    \            }\n            j++;\n            count[i]--;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp350awgt2: /tmp/tmp350awgt2.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111305
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n    {\n   \
    \     return true;\n    }\n    long i = 0;\n    long n = arr.size();\n    long\
    \ maxVal = arr[0];\n    for(i = 1; i < n; i++)\n    {\n        if(arr[i] > maxVal)\n\
    \        {\n            maxVal = arr[i];\n        }\n        else if(arr[i] <\
    \ maxVal)\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvdyv540u: /tmp/tmpvdyv540u.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111305
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    int flag = 0;\n    int max = arr[0];\n    int flag2 = 0;\n    for(int i =\
    \ 1; i < arr.size(); i++) {\n        if(arr[i] < max) flag2 = 1;\n        if(flag2\
    \ == 1) {\n            if(arr[i] < max) flag = 1;\n            if(arr[i] > max)\
    \ flag2 = 0;\n        }\n        max = std::max(max, arr[i]);\n    }\n    if(flag\
    \ == 1) return false;\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpueza_kwm.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpueza_kwm.cpp:35:35: error: no matching function for call\
    \ to \u2018max(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   35 |         max = std::max(max, arr[i]);\n   \
    \   |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpueza_kwm.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpueza_kwm.cpp:35:35: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   35 |         max = std::max(max, arr[i]);\n\
    \      |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpueza_kwm.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpueza_kwm.cpp:35:35:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   35 |         max = std::max(max, arr[i]);\n\
    \      |                        "
  stdout: ''
  timestamp: 1660111305
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    // Return true if possible to sort the array, else\
    \ return false\n    if(arr.size() <= 1)\n    {\n        return true;\n    }\n\
    \    else\n    {\n        std::vector<long> temp_arr;\n        temp_arr = arr;\n\
    \        std::sort(temp_arr.begin(), temp_arr.end());\n        if(temp_arr ==\
    \ arr)\n        {\n            return true;\n        }\n        else\n       \
    \ {\n            return false;\n        }\n    }\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcemphx0u: /tmp/tmpcemphx0u.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111305
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    bool flag\
    \ = true;\n    int i = 0;\n    int temp;\n    if(arr.size() == 0)\n    {\n   \
    \     return true;\n    }\n    if(arr.size() == 1)\n    {\n        return true;\n\
    \    }\n    for(i = 0; i < arr.size() - 1; i++)\n    {\n        if(arr[i] > arr[i+1])\n\
    \        {\n            flag = false;\n            break;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnr72bw1k: /tmp/tmpnr72bw1k.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0) return true;\n\
    \    if(arr.size()==1) return true;\n    std::vector<long> array(arr.size());\n\
    \    for(int i=0;i<arr.size();i++){\n        array[i]=i+1;\n    }\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(array[i]!=arr[i]){\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcgo7zk3f: /tmp/tmpcgo7zk3f.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() <= 0) {\n\t\treturn\
    \ true;\n\t}\n\tfor (int i = 0; i < arr.size() - 1; i++) {\n\t\tif (arr[i] > arr[i\
    \ + 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0q_jh23s: /tmp/tmp0q_jh23s.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() < 2) {\n    return\
    \ true;\n  }\n  long shift_count = 0;\n  for (int i = 0; i < arr.size() - 1; i++)\
    \ {\n    if (arr[i] > arr[i + 1]) {\n      shift_count++;\n    }\n  }\n  if (shift_count\
    \ > 1) {\n    return false;\n  }\n  if (shift_count == 1) {\n    long current_min\
    \ = LONG_MAX;\n    long index_of_min = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n      if (arr[i] < current_min) {\n        current_min = arr[i];\n \
    \       index_of_min = i;\n      }\n    }\n    if (index_of_min != 0) {\n    \
    \  return false;\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjyqkkhy8: /tmp/tmpjyqkkhy8.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n// Write your code here\n\tlong count\
    \ = 0;\n\tfor(int i = 0; i < arr.size(); i++)\n\t{\n\t\tif(arr[i] > arr[i+1])\n\
    \t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(count == 1)\n\t{\n\t\treturn true;\n\t\
    }\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp33b0xmsu: /tmp/tmp33b0xmsu.cpp:49: int main(): Assertion `candidate((std::vector<long>()))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111305
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()\
    \ == 0){\n        return true;\n    }\n    vector<long> v = arr;\n    sort(v.begin(),\
    \ v.end());\n    if(arr == v){\n        return true;\n    }\n    int i = 0;\n\
    \    while(i < arr.size()){\n        if(arr[i] != v[i]){\n            break;\n\
    \        }\n        i++;\n    }\n    if(i == arr.size()){\n        return false;\n\
    \    }\n    int j = i;\n    while(j < arr.size()){\n        if(arr[j] == v[i]){\n\
    \            break;\n        }\n        j++;\n    }\n    while(j < arr.size()){\n\
    \        if(arr[j] != v[j]){\n            return false;\n        }\n        j++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxdeknjbb.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpxdeknjbb.cpp:29:5: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   29 |     vector<long> v = arr;\n      |     ^~~~~~\n/tmp/tmpxdeknjbb.cpp:29:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxdeknjbb.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxdeknjbb.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpxdeknjbb.cpp:29:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     vector<long>\
    \ v = arr;\n      |            ^~~~\n/tmp/tmpxdeknjbb.cpp:30:10: error: \u2018\
    v\u2019 was not declared in this scope\n   30 |     sort(v.begin(), v.end());\n\
    \      |          ^\n/tmp/tmpxdeknjbb.cpp:30:5: error: \u2018sort\u2019 was not\
    \ declared in this scope; did you mean \u2018std::sort\u2019?\n   30 |     sort(v.begin(),\
    \ v.end());\n      |     ^~~~\n      |     std::sort\nIn file included from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxdeknjbb.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:296:1:\
    \ note: \u2018std::sort\u2019 declared here\n  296 | sort(_ExecutionPolicy&& __exec,\
    \ _RandomAccessIterator __first,"
  stdout: ''
  timestamp: 1660111305
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0){\n        return\
    \ true;\n    }\n    std::sort(arr.begin(), arr.end());\n    if(arr[0] == 1){\n\
    \        return true;\n    }else{\n        return false;\n    }\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmur7ohj7: /tmp/tmpmur7ohj7.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    bool pos = true;\n    while (pos)\
    \ {\n        pos = false;\n        for (int i = 0; i < arr.size() - 1; i++) {\n\
    \            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n\
    \                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n  \
    \              pos = true;\n            }\n        }\n    }\n    if (arr[0] ==\
    \ 1) {\n        return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp__7ar9di: /tmp/tmp__7ar9di.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end());\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] != i + 1) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy0zupnmu: /tmp/tmpy0zupnmu.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        int j = i;\n        while(arr[j] != i+1) {\n            j++;\n  \
    \      }\n        if(j-i > 1) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1r78mn2l: /tmp/tmp1r78mn2l.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\t\treturn true;\n\
    \tint small = INT_MAX;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ < small)\n\t\t\tsmall = arr[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpapp5ps5t: /tmp/tmpapp5ps5t.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // your code goes here\n  int count=0;\n\
    \  int n=arr.size();\n  int max=0;\n  for(int i=0;i<n;i++)\n  {\n      if(arr[i]>max)\n\
    \        max=arr[i];\n      if(arr[i]==max)\n      {\n          for(int j=i;j<n;j++)\n\
    \          {\n              if(arr[j]>max)\n              {\n                \
    \  count++;\n                  break;\n              }\n          }\n      }\n\
    \  }\n  if(count==1)\n  return true;\n  else\n  return false;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyv5jgni4: /tmp/tmpyv5jgni4.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> result(arr.size());\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        result[i] = i + 1;\n    }\n\
    \    sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] != result[i]) {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppw9kojuv: /tmp/tmppw9kojuv.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\tint n =\
    \ arr.size();\n\tint minm = INT_MAX;\n\tint minmindex = -1;\n\tfor (int i = 0;\
    \ i < n; i++) {\n\t\tif (arr[i] < minm) {\n\t\t\tminm = arr[i];\n\t\t\tminmindex\
    \ = i;\n\t\t}\n\t}\n\tfor (int i = minmindex; i < n; i++) {\n\t\tif (arr[i] >\
    \ arr[i + 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpt5e_wo1m: /tmp/tmpt5e_wo1m.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::map<long, int> m;\n    std::vector<int>\
    \ k;\n    int n = arr.size();\n    if(n==0)\n        return true;\n    for(int\
    \ i=0;i<n;i++)\n        m[arr[i]]++;\n    for(auto it = m.begin();it!=m.end();it++)\n\
    \        k.push_back(it->second);\n    sort(k.begin(), k.end());\n    int g =\
    \ k[0];\n    for(int i=1;i<k.size();i++)\n        if(k[i]%g!=0)\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmxo0ax_g: /tmp/tmpmxo0ax_g.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() < 1) {\n    return\
    \ true;\n  }\n\n  int n = arr.size();\n  std::vector<int> count(n);\n  for (int\
    \ i = 0; i < n; i++) {\n    assert(arr[i] <= n);\n    assert(arr[i] >= 1);\n \
    \   count[arr[i] - 1]++;\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (count[i]\
    \ > 1) {\n      return false;\n    }\n  }\n\n  int turn = 0;\n  for (int i = 0;\
    \ i < n; i++) {\n    if (arr[i] != i + 1) {\n      int idx = i;\n      while (arr[idx]\
    \ != i + 1) {\n        idx++;\n      }\n      while (idx != i) {\n        std::swap(arr[idx],\
    \ arr[idx - 1]);\n        idx--;\n        turn++;\n      }\n    }\n  }\n\n  return\
    \ turn % 2 == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfs5pc3ob: /tmp/tmpfs5pc3ob.cpp:32: bool move_one_ball(std::vector<long
    int>): Assertion `arr[i] <= n'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0){\n        return\
    \ true;\n    }\n    for(int i = 0; i < arr.size() - 1; i++){\n        if(arr[i]\
    \ > arr[i + 1]){\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpntxfszhi: /tmp/tmpntxfszhi.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t//cout << \"Arr size: \" << arr.size()\
    \ << endl;\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tlong largest =\
    \ arr[0];\n\tlong smallest = arr[0];\n\tfor (long i = 0; i < arr.size(); i++)\
    \ {\n\t\tif (arr[i] > largest) {\n\t\t\tlargest = arr[i];\n\t\t}\n\t\tif (arr[i]\
    \ < smallest) {\n\t\t\tsmallest = arr[i];\n\t\t}\n\t}\n\t//cout << \"Largest:\
    \ \" << largest << endl;\n\t//cout << \"Smallest: \" << smallest << endl;\n\t\
    if (arr.size() == 1) {\n\t\treturn true;\n\t}\n\tif (largest - smallest <= arr.size()\
    \ - 1) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp89k1ke8o: /tmp/tmp89k1ke8o.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // your code goes here\n    if(arr.size()\
    \ == 0)\n        return true;\n    std::vector<long> arr_sort(arr);\n    std::sort(arr_sort.begin(),\
    \ arr_sort.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != arr_sort[i])\n            return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpad_c37v3: /tmp/tmpad_c37v3.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    //write your code here\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpunkracfj: /tmp/tmpunkracfj.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    int max = *std::max_element(arr.begin(), arr.end());\n    int min\
    \ = *std::min_element(arr.begin(), arr.end());\n    return min == 1;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmblauh06: /tmp/tmpmblauh06.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // Write your code here\n  // To print\
    \ results to the standard output you can use the cout stream\n  // Example: cout\
    \ << \"Hello world!\";\n  if(arr.size()==0)\n      return true;\n  int pivot=arr[0];\n\
    \  long n=arr.size();\n  int j;\n  for(j=1;j<n;j++)\n  {\n      if(arr[j]<pivot)\n\
    \          break;\n  }\n  int i=j;\n  while(i<n && arr[i]>=pivot)\n      i++;\n\
    \  while(i<n)\n  {\n      if(arr[i]<pivot)\n          return false;\n      i++;\n\
    \  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy3sq052m: /tmp/tmpy3sq052m.cpp:51: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0)\n        return true;\n    for(int i = 1; i < n; i++) {\n        if(arr[i]\
    \ < arr[i-1]) {\n            if(i == 1) {\n                return false;\n   \
    \         }\n            if(arr[i] < arr[i-2]) {\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmkwom_5g: /tmp/tmpmkwom_5g.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    for(int i = 0; i < arr.size() - 1; i++) {\n        if(arr[i] > arr[i + 1])\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmph6gt39op: /tmp/tmph6gt39op.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\t\treturn true;\n\
    \tlong max = arr[0];\n\tlong count = 0;\n\tfor (int i = 1; i < arr.size(); i++)\
    \ {\n\t\tif (arr[i] < max) {\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tmax = arr[i];\n\
    \t}\n\tif (count > 1)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5e037y17: /tmp/tmp5e037y17.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Feel free to add helper functions\n\
    \    // Don't forget to define them before use\n    for(auto j=0;j<arr.size();j++){\n\
    \        for(auto i=0;i<arr.size()-1;i++){\n            if(arr[i]>arr[i+1]){\n\
    \                arr.push_back(arr[i]);\n                arr.erase(arr.begin()+i);\n\
    \            }\n        }\n    }\n    return std::is_sorted(arr.begin(),arr.end());\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdt851gq2: /tmp/tmpdt851gq2.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()\
    \ == 0) return true;\n    std::map<long, int> m;\n    for(int i = 0; i < arr.size();\
    \ i++) {\n        m[arr[i]] = i;\n    }\n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        if(m[i+1] != i) {\n            if(arr[arr.size()-1] == (i+1))\n \
    \               return true;\n            else\n                return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_r7v5r01: /tmp/tmp_r7v5r01.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int count = 0;\n    if(arr.size()\
    \ == 0)\n        return true;\n    if(arr.size() == 1)\n        return true;\n\
    \    if(arr.size() == 2){\n        if(arr[0] < arr[1])\n            return true;\n\
    \        else\n            return false;\n    }\n    for(int i = 0; i < arr.size()\
    \ - 1; i++){\n        if(arr[i] > arr[i+1]){\n            count++;\n        }\n\
    \    }\n    if(count == 0)\n        return true;\n    if(count == 1)\n       \
    \ return true;\n    else\n        return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0) return true;\n\
    \    std::vector<long> ans;\n    for(int i=0;i<arr.size();i++){\n        if(ans.size()==0)\
    \ ans.push_back(arr[i]);\n        else{\n            int l = 0, h = ans.size()-1;\n\
    \            while(l<=h){\n                int mid = l + (h-l)/2;\n          \
    \      if(ans[mid]>arr[i]){\n                    if(mid==0) {\n              \
    \          ans.insert(ans.begin(),arr[i]);\n                        break;\n \
    \                   }\n                    else if(ans[mid-1]<=arr[i]){\n    \
    \                    ans.insert(ans.begin()+mid,arr[i]);\n                   \
    \     break;\n                    }\n                    else h = mid-1;\n   \
    \             }\n                else if(ans[mid]<arr[i]){\n                 \
    \   if(mid==ans.size()-1) {\n                        ans.push_back(arr[i]);\n\
    \                        break;\n                    }\n                    else\
    \ if(ans[mid+1]>=arr[i]){\n                        ans.insert(ans.begin()+mid+1,arr[i]);\n\
    \                        break;\n                    }\n                    else\
    \ l = mid+1;\n                }\n                else{\n                    ans.insert(ans.begin()+mid,arr[i]);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    if(ans==arr) return true;\n    else return false;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3sqv8n51: /tmp/tmp3sqv8n51.cpp:67: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end());\n\
    \    if (arr.size() == 0) {\n        return true;\n    }\n    long last_elem =\
    \ arr[arr.size() - 1];\n    for (int i = 0; i < arr.size() - 1; i++) {\n     \
    \   if (arr[i] > last_elem) {\n            return false;\n        }\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjaadmhii: /tmp/tmpjaadmhii.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\
    \ {\n\t\treturn true;\n\t}\n\tint pos = -1;\n\tfor (int i = 0; i < n; i++) {\n\
    \t\tif (arr[i] == 1) {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pos ==\
    \ -1) {\n\t\treturn false;\n\t}\n\tfor (int i = pos; i < n; i++) {\n\t\tif (arr[i]\
    \ != i + 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplatie69d: /tmp/tmplatie69d.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // write your code here\n    std::sort(arr.begin(),\
    \ arr.end());\n    int i;\n    for(i=0; i<arr.size(); i++)\n    {\n        if(arr[i]\
    \ != i+1)\n            return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbjnph4u2: /tmp/tmpbjnph4u2.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111306
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0){\n        return\
    \ true;\n    }\n    for(int i = 0; i < arr.size() - 1; i++){\n        if(arr[i]\
    \ > arr[i + 1]){\n            std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n\
    \            if(arr[i] > arr[i + 1]){\n                return false;\n       \
    \     }\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111306
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()==0)\
    \ return true;\n    int max_element=0;\n    int n=arr.size();\n    int arr1[n];\n\
    \    for(int i=0;i<n;i++){\n        arr1[i]=arr[i];\n    }\n    int count=0;\n\
    \    while(count<n){\n        if(max_element!=arr[count]){\n            max_element=arr[count];\n\
    \            count++;\n        }\n        else{\n            break;\n        }\n\
    \    }\n    sort(arr1,arr1+n);\n    for(int i=0;i<n;i++){\n        if(arr1[i]!=arr[i])\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7qjg8uw4.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7qjg8uw4.cpp:43:5: error: \u2018sort\u2019 was not declared\
    \ in this scope; did you mean \u2018std::sort\u2019?\n   43 |     sort(arr1,arr1+n);\n\
    \      |     ^~~~\n      |     std::sort\nIn file included from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7qjg8uw4.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:296:1:\
    \ note: \u2018std::sort\u2019 declared here\n  296 | sort(_ExecutionPolicy&& __exec,\
    \ _RandomAccessIterator __first, _RandomAccessIterator __last);\n      | ^~~~\n"
  stdout: ''
  timestamp: 1660111306
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  std::vector<long> temp;\n  for(int\
    \ i=0;i<arr.size();i++){\n    temp.push_back(arr[i]);\n  }\n  std::sort(temp.begin(),temp.end());\n\
    \  long count=0;\n  for(int i=0;i<arr.size();i++){\n    if(arr[i]==temp[0]){\n\
    \      count++;\n    }\n  }\n  if(count==1){\n    return true;\n  }\n  else if(count==arr.size()){\n\
    \    return true;\n  }\n  else{\n    return false;\n  }\n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphf_fk6xq: /tmp/tmphf_fk6xq.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    for(int i=0;i<arr.size();i++){\n\
    \        long max=-1;\n        int pos=-1;\n        for(int j=i;j<arr.size();j++){\n\
    \            if(arr[j]>max){\n                max=arr[j];\n                pos=j;\n\
    \            }\n        }\n        if(pos==i)\n            continue;\n       \
    \ if(pos==arr.size()-1)\n            return false;\n        std::rotate(arr.begin()+i,arr.begin()+pos,arr.begin()+pos+1);\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdslnmiu9: /tmp/tmpdslnmiu9.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // your code goes here\n    if(arr.size()==0)\n\
    \        return true;\n    long min=arr[0];\n    long min_index=0;\n    bool flag=true;\n\
    \    for(int i=1;i<arr.size();i++){\n        if(arr[i]<min){\n            min=arr[i];\n\
    \            min_index=i;\n            flag=false;\n        }\n    }\n    if(flag==true)\n\
    \        return true;\n    for(int i=min_index;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n\
    \            return false;\n    }\n    for(int i=0;i<min_index;i++){\n       \
    \ if(arr[i]>arr[i+1])\n            return false;\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8z2d56cn: /tmp/tmp8z2d56cn.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tstd::vector<long> sortedArr;\n\tbool\
    \ flag = false;\n\tif (arr.size() == 0) {\n\t\treturn true;\n\t}\n\tfor (int i\
    \ = 0; i < arr.size(); i++) {\n\t\tfor (int j = 0; j < arr.size(); j++) {\n\t\t\
    \tif (arr[i] < arr[j]) {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\
    flag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == true) {\n\t\t\t\
    sortedArr.push_back(arr[i]);\n\t\t}\n\t}\n\tif (sortedArr.size() == arr.size())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpgy8vbwlj: /tmp/tmpgy8vbwlj.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0) return true;\n\
    \    std::map<long,int> freq;\n    std::vector<long> b;\n    std::vector<long>\
    \ c;\n    for(auto i:arr) {\n        if(freq.find(i)==freq.end()) freq[i]=1;\n\
    \        else freq[i]++;\n    }\n    for(auto j:freq) {\n        if(j.second==1)\
    \ b.push_back(j.first);\n        else c.push_back(j.first);\n    }\n    std::sort(b.begin(),b.end());\n\
    \    std::sort(c.begin(),c.end());\n    if(c.size()==0) return true;\n    if(b.size()==0)\
    \ return false;\n    int i=b.size()-1;\n    while(i>=0) {\n        if(b[i]<c[c.size()-1])\
    \ return false;\n        i--;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb4o69wfv: /tmp/tmpb4o69wfv.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  bool result = true;\n  if (arr.size()\
    \ == 0) {\n    return result;\n  }\n  std::vector<long> new_arr = arr;\n  std::sort(new_arr.begin(),\
    \ new_arr.end());\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] !=\
    \ new_arr[i]) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz8tlyc9v: /tmp/tmpz8tlyc9v.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min) {\n            return false;\n        }\n        min = arr[i];\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0z8y0v3x: /tmp/tmp0z8y0v3x.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0){\n        return\
    \ true;\n    }\n    for(int i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1]){\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyz62t0ni: /tmp/tmpyz62t0ni.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // TODO\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxd0z4e_p: /tmp/tmpxd0z4e_p.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111308
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int start = 0;\n    int end = arr.size()\
    \ - 1;\n    if (arr.size() == 0) {\n        return true;\n    }\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        int index = 0;\n        int max = arr[0];\n\
    \        for (int j = 0; j < arr.size(); j++) {\n            if (arr[j] > max)\
    \ {\n                max = arr[j];\n                index = j;\n            }\n\
    \        }\n        if (i == 0) {\n            if (index == arr.size() - 1) {\n\
    \                return false;\n            }\n        }\n        else {\n   \
    \         if (index == i - 1) {\n                return false;\n            }\n\
    \        }\n        arr[index] = -1;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3z8c9z3r: /tmp/tmp3z8c9z3r.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111308
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // write your code here\n    int\
    \ n = arr.size();\n    if(n == 0) return true;\n    if(n == 1) return true;\n\
    \    int minIndx = 0;\n    for(int i = 1; i < n; i++){\n        if(arr[i] < arr[minIndx])\
    \ minIndx = i;\n    }\n    int l = minIndx;\n    int r = minIndx;\n    if(minIndx\
    \ == 0){\n        for(int i = 1; i < n; i++){\n            if(arr[i] > arr[l])\
    \ l = i;\n        }\n        for(int i = n-1; i >= 1; i--){\n            if(arr[i]\
    \ < arr[r]) r = i;\n        }\n    }\n    else if(minIndx == n-1){\n        for(int\
    \ i = 0; i < n-1; i++){\n            if(arr[i] > arr[l]) l = i;\n        }\n \
    \       for(int i = n-2; i >= 0; i--){\n            if(arr[i] < arr[r]) r = i;\n\
    \        }\n    }\n    else{\n        for(int i = 0; i < minIndx; i++){\n    \
    \        if(arr[i] > arr[l]) l = i;\n        }\n        for(int i = n-1; i > minIndx;\
    \ i--){\n            if(arr[i] < arr[r]) r = i;\n        }\n    }\n    // std::cout\
    \ << \"l: \" << l << \" r: \" << r << std::endl;\n    if(l < r) return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpi4fuf0pc: /tmp/tmpi4fuf0pc.cpp:67: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111308
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() <= 1)\n        return\
    \ true;\n    if(arr.size() == 2)\n        return arr[0] < arr[1];\n    std::vector<long>\
    \ sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n    long i = 0;\n\
    \    while(sorted[i] != arr[i])\n        i++;\n    long j = i;\n    i++;\n   \
    \ long n = arr.size();\n    for(; i < n; i++) {\n        if(sorted[i] != arr[j])\n\
    \            return false;\n        j = (j + 1) % n;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1v9uacnq: /tmp/tmp1v9uacnq.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111308
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\t// to print\
    \ all the elements\n\tstd::cout << \"\\n The contents of arr are:\";\n\tfor (std::vector<long>::iterator\
    \ it = arr.begin(); it != arr.end(); ++it)\n\t\tstd::cout << ' ' << *it;\n\tstd::cout\
    \ << '\\n';\n\treturn false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpd4jl0zp6: /tmp/tmpd4jl0zp6.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111308
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0) return true;\n\
    \    long val=0;\n    for(int i=0;i<arr.size();i++){\n        val=max(val,arr[i]);\n\
    \    }\n    //if the maximum element is in the left side\n    if(val==arr[0])\
    \ return false;\n    //if the maximum element is in the right side\n    for(int\
    \ i=1;i<arr.size();i++){\n        if(arr[i]==val) return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphdvyux2l.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmphdvyux2l.cpp:28:13: error: \u2018max\u2019 was not declared\
    \ in this scope; did you mean \u2018std::max\u2019?\n   28 |         val=max(val,arr[i]);\n\
    \      |             ^~~\n      |             std::max\nIn file included from\
    \ /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphdvyux2l.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660111307
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Implement this function\n   \
    \ // For C++ users: Don't use std::sort.\n    // You can assume the vector is\
    \ not empty.\n    // Sort the array.\n    std::sort(arr.begin(), arr.end());\n\
    \    long n = arr.size();\n    long left_max = arr[0];\n    long right_min = arr[n-1];\n\
    \    for(long i = 1; i < n-1; i++) {\n        if(arr[i] < left_max && arr[i] >\
    \ right_min) {\n            return false;\n        }\n        if(arr[i] > left_max)\
    \ {\n            left_max = arr[i];\n        }\n        if(arr[n-i-1] < right_min)\
    \ {\n            right_min = arr[n-i-1];\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmped5nxkio: /tmp/tmped5nxkio.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111308
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t/*int i,j,k,n=arr.size();\n\tfor(i=0;i<n;i++)\n\
    \t{\n\t\tfor(j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(arr[i]>arr[j])\n\t\t\t{\n\t\t\t\t\
    for(k=j+1;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(arr[k]<arr[i])\n\t\t\t\t\t{\n\t\t\t\
    \t\t\tarr[k]=arr[k]+arr[i];\n\t\t\t\t\t\tarr[i]=arr[k]-arr[i];\n\t\t\t\t\t\tarr[k]=arr[k]-arr[i];\n\
    \t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k==n)\n\t\t\t\t{\n\t\t\t\
    \t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tstd::set<long>\
    \ s(arr.begin(),arr.end());\n\tif(s.size()!=arr.size())\n\t{\n\t\treturn false;\n\
    \t}\n\tsort(arr.begin(),arr.end());\n\tfor(int i=0;i<arr.size();i++)\n\t{\n\t\t\
    if(arr[i]!=i+1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfam79ela: /tmp/tmpfam79ela.cpp:68: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    for(int i = 0; i < arr.size() - 1; i++) {\n        if(arr[i] > arr[i + 1])\
    \ {\n            long temp = arr[i];\n            arr[i] = arr[i + 1];\n     \
    \       arr[i + 1] = temp;\n            break;\n        }\n    }\n    for(int\
    \ i = 0; i < arr.size() - 1; i++) {\n        if(arr[i] > arr[i + 1]) return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9u4g74vl: /tmp/tmp9u4g74vl.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int max_idx = -1;\n    int max_val = -1;\n\
    \    int n = arr.size();\n    if(n == 0)\n        return true;\n    for(int i\
    \ = 0; i < n; i++){\n        if(arr[i] > max_val){\n            max_val = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    if(max_idx == n-1)\n        return\
    \ true;\n    else\n        return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpuw__t8ac: /tmp/tmpuw__t8ac.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int len = arr.size();\n    if(len\
    \ == 0)\n        return true;\n    bool** dp = new bool*[len];\n    for(int i\
    \ = 0; i < len; i++)\n        dp[i] = new bool[len];\n    for(int i = 0; i < len;\
    \ i++)\n        for(int j = 0; j < len; j++)\n            dp[i][j] = false;\n\
    \    // std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < len; i++)\n\
    \        dp[i][i] = true;\n    for(int i = 0; i < len - 1; i++)\n        dp[i][i\
    \ + 1] = (arr[i] <= arr[i + 1]);\n    for(int l = 2; l < len; l++) {\n       \
    \ for(int i = 0; i < len - l; i++) {\n            int j = i + l;\n           \
    \ if(arr[i] <= arr[j])\n                dp[i][j] = dp[i + 1][j - 1];\n       \
    \     else\n                dp[i][j] = (dp[i + 1][j] || dp[i][j - 1]);\n     \
    \   }\n    }\n    // for(int i = 0; i < len; i++) {\n    //     for(int j = 0;\
    \ j < len; j++)\n    //         std::cout << dp[i][j] << \" \";\n    //     std::cout\
    \ << std::endl;\n    // }\n    return dp[0][len - 1];\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfzhf980j: /tmp/tmpfzhf980j.cpp:59: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\
    \ return true;\n\tint shift[n];\n\tmemset(shift, 0, sizeof(shift));\n\tfor (int\
    \ i = 0; i < n; i++) {\n\t\tint val = arr[i];\n\t\tint pos = val - 1;\n\t\tint\
    \ count = 0;\n\t\twhile (pos != i) {\n\t\t\tval = arr[pos];\n\t\t\tpos = val -\
    \ 1;\n\t\t\tcount++;\n\t\t}\n\t\tshift[i] = count;\n\t}\n\tint sum = 0;\n\tfor\
    \ (int i = 0; i < n; i++) {\n\t\tsum += shift[i];\n\t}\n\tif (sum % 2 == 0) return\
    \ true;\n\treturn false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660111313
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() < 2) return true;\n\
    \  for (int i = 0; i < arr.size() - 1; i++) {\n    if (arr[i] > arr[i + 1]) {\n\
    \      std::vector<long> temp = arr;\n      for (int j = 0; j < arr.size(); j++)\
    \ {\n        arr[j] = temp[j + 1];\n        if (j == arr.size() - 1) arr[j] =\
    \ temp[0];\n      }\n      if (move_one_ball(arr)) return true;\n      return\
    \ false;\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0) {\n        return true;\n    }\n    std::sort(arr.begin(), arr.end());\n\
    \    for(int i = 0; i < n; i++) {\n        if(arr[i] != i + 1) {\n           \
    \ return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdkeclr1i: /tmp/tmpdkeclr1i.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n <=\
    \ 0) return true;\n    int i = n - 1;\n    while(i > 0) {\n        if(arr[i] >\
    \ arr[i - 1]) break;\n        i--;\n    }\n    return (i == 0);\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxirhv8sw: /tmp/tmpxirhv8sw.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() == 0) {\n    return\
    \ true;\n  }\n  std::vector<long> copy = arr;\n  std::sort(copy.begin(), copy.end());\n\
    \  if (arr == copy) {\n    return true;\n  }\n  std::vector<long> temp = arr;\n\
    \  int len = arr.size();\n  for (int i = 0; i < len; i++) {\n    temp.push_back(temp[0]);\n\
    \    temp.erase(temp.begin());\n    if (temp == copy) {\n      return true;\n\
    \    }\n  }\n  return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    if(arr.size() == 1)\n        return true;\n    int prev = arr[0];\n\
    \    int max = prev;\n    int count = 0;\n    for(int i = 1; i < arr.size(); i++){\n\
    \        if(prev > arr[i]){\n            count++;\n        }\n        else{\n\
    \            if(arr[i] > max)\n                max = arr[i];\n        }\n    \
    \    prev = arr[i];\n    }\n    if(max != arr[0])\n        count++;\n    if(count\
    \ > 1)\n        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8bw7uhhp: /tmp/tmp8bw7uhhp.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\
    \ return true;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (arr[i] > arr[i +\
    \ 1]) {\n\t\t\tlong temp = arr[i];\n\t\t\tarr[i] = arr[i + 1];\n\t\t\tarr[i +\
    \ 1] = temp;\n\t\t\tfor (int j = i; j > 0; j--) {\n\t\t\t\tif (arr[j] < arr[j\
    \ - 1]) {\n\t\t\t\t\tlong temp = arr[j];\n\t\t\t\t\tarr[j] = arr[j - 1];\n\t\t\
    \t\t\tarr[j - 1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i\
    \ < n - 1; i++) {\n\t\tif (arr[i] > arr[i + 1]) return false;\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphaajg_lx: /tmp/tmphaajg_lx.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> arr1 = arr;\n    sort(arr1.begin(), arr1.end());\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] != arr1[i])\n  \
    \          return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbrhmhjem: /tmp/tmpbrhmhjem.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tstd::vector<int> isVisited;\n\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\tisVisited.push_back(0);\n\t}\n\tstd::stack<int> stack;\n\tstack.push(0);\n\
    \twhile (!stack.empty()) {\n\t\tint val = stack.top();\n\t\tstack.pop();\n\t\t\
    if (isVisited[val] == 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tisVisited[val] = 1;\n\t\
    \tint right = (val + 1) % arr.size();\n\t\tint left = (val - 1 + arr.size()) %\
    \ arr.size();\n\t\tif (arr[right] < arr[val] && isVisited[right] == 0) {\n\t\t\
    \tstack.push(right);\n\t\t}\n\t\tif (arr[left] < arr[val] && isVisited[left] ==\
    \ 0) {\n\t\t\tstack.push(left);\n\t\t}\n\t}\n\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\tif (isVisited[i] == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp91qnir8s: /tmp/tmp91qnir8s.cpp:59: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()\
    \ == 0){\n        return true;\n    }\n    for(int i = 0; i < arr.size() - 1;\
    \ i++){\n        if(arr[i] > arr[i + 1]){\n            return false;\n       \
    \ }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1qgmqu7i: /tmp/tmp1qgmqu7i.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    int min_index = std::distance(arr.begin(), std::min_element(arr.begin(),\
    \ arr.end()));\n    if(min_index == 0 || min_index == arr.size() - 1) return true;\n\
    \    if(min_index == 1) return arr[0] <= arr[2];\n    if(min_index == arr.size()\
    \ - 2) return arr[arr.size() - 3] <= arr[arr.size() - 1];\n    return arr[min_index\
    \ - 2] <= arr[min_index] && arr[min_index - 1] <= arr[min_index + 1];\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmputaqti_f: /tmp/tmputaqti_f.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    assert(arr.size() > 0);\n    if\
    \ (arr.size() == 1) {\n        return true;\n    }\n    int i;\n    for (i = 1;\
    \ i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            break;\n\
    \        }\n    }\n    if (i == arr.size()) {\n        return true;\n    }\n \
    \   int j;\n    for (j = arr.size() - 1; j > 0; j--) {\n        if (arr[j] < arr[j\
    \ - 1]) {\n            break;\n        }\n    }\n    if (j == 0) {\n        return\
    \ true;\n    }\n    int min_elem = std::min(arr[i], arr[j]);\n    int max_elem\
    \ = std::max(arr[i], arr[j]);\n    for (int k = 0; k < arr.size(); k++) {\n  \
    \      if (arr[k] > min_elem && arr[k] < max_elem) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz67xhymk: /tmp/tmpz67xhymk.cpp:25: bool move_one_ball(std::vector<long
    int>): Assertion `arr.size() > 0'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  if (arr.size() <= 1) {\n    return\
    \ true;\n  }\n  // if (arr.size() == 2) {\n  //   return (arr[0] < arr[1]);\n\
    \  // }\n  for (int i = 0; i < arr.size() - 1; i++) {\n    for (int j = i + 1;\
    \ j < arr.size(); j++) {\n      if (arr[i] > arr[j]) {\n        int temp = arr[i];\n\
    \        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  if (arr[0]\
    \ == 1) {\n    return true;\n  }\n  return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpsa0leem6: /tmp/tmpsa0leem6.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    long m = arr[0];\n    for(auto it = arr.begin() + 1; it != arr.end(); it++)\
    \ {\n        if(m > *it) return false;\n        m = *it;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnecs9ty3: /tmp/tmpnecs9ty3.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    bool ans = true;\n    if(arr.size()\
    \ == 0)\n        return ans;\n    if(arr.size() == 1)\n        return ans;\n \
    \   if(arr.size() == 2){\n        if(arr[0] > arr[1])\n            return ans;\n\
    \        else\n            return false;\n    }\n    if(arr.size() > 2){\n   \
    \     for(int i = 0; i < arr.size() - 1; i++){\n            if(arr[i] > arr[i+1]){\n\
    \                int j = i + 1;\n                while(j < arr.size()){\n    \
    \                if(arr[j] < arr[i]){\n                        if(arr[j-1] < arr[j]){\n\
    \                            ans = false;\n                            break;\n\
    \                        }\n                        else{\n                  \
    \          int temp = arr[j];\n                            arr[j] = arr[j-1];\n\
    \                            arr[j-1] = temp;\n                            break;\n\
    \                        }\n                    }\n                    j++;\n\
    \                }\n                if(ans == false)\n                    break;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvbfpg9so: /tmp/tmpvbfpg9so.cpp:66: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // Your code goes here\n  if(arr.size()\
    \ == 0)\n  {\n      return true;\n  }\n  for(int i = 0; i < arr.size() - 1; i++)\n\
    \  {\n      if(arr[i] > arr[i + 1])\n      {\n          return false;\n      }\n\
    \  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp323egwf7: /tmp/tmp323egwf7.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tlong min;\n\tstd::vector<long> v(arr.size());\n\tfor (int i =\
    \ 0; i < arr.size(); i++) {\n\t\tv[i] = 0;\n\t}\n\t// Your implementation goes\
    \ here\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\t// change the arr[i] with\
    \ min and min++\n\t\tmin = arr[i];\n\t\tint j = i;\n\t\twhile (v[j] == 0) {\n\t\
    \t\tif (arr[j] == min) {\n\t\t\t\tv[j] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\
    \t\t\tif (j == arr.size()) {\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t}\n\t\tif (v[j] ==\
    \ 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpivi89j43: /tmp/tmpivi89j43.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0){\n        return\
    \ true;\n    }\n    for(int i = 0; i < arr.size() - 1; i++){\n        if(arr[i]\
    \ > arr[i + 1]){\n            arr.push_back(arr[0]);\n            arr.erase(arr.begin());\n\
    \            i--;\n        }\n    }\n    for(int i = 0; i < arr.size() - 1; i++){\n\
    \        if(arr[i] > arr[i + 1]){\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpeuc7rewc: /tmp/tmpeuc7rewc.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    bool\
    \ flag = false;\n    if(arr.size() == 0)\n        return true;\n    // Loop to\
    \ find the last element of the vector\n    for(int i = arr.size() - 1; i >= 0;\
    \ i--){\n        if(arr[i] == arr.size()){\n            flag = true;\n       \
    \     arr.erase(arr.begin() + i);\n            break;\n        }\n    }\n    //\
    \ If the last element is not present, return false\n    if(!flag)\n        return\
    \ false;\n    if(arr.size() == 0)\n        return true;\n    // Sort the vector\n\
    \    std::sort(arr.begin(), arr.end());\n    // Return true if no break found\
    \ in the sorted vector\n    for(int i = 0; i < arr.size(); i++){\n        if(arr[i]\
    \ - i != 1)\n            return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpx8q683ln: /tmp/tmpx8q683ln.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < arr[i-1]) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpillxx519: /tmp/tmpillxx519.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tstd::vector<long> original_arr = arr;\n\tstd::sort(arr.begin(),\
    \ arr.end());\n\tint pos_of_min_element = 0;\n\tint pos_of_max_element = 0;\n\t\
    for (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] == original_arr[0]) {\n\
    \t\t\tpos_of_min_element = i;\n\t\t}\n\t\tif (arr[i] == original_arr[original_arr.size()\
    \ - 1]) {\n\t\t\tpos_of_max_element = i;\n\t\t}\n\t}\n\tif (pos_of_min_element\
    \ < pos_of_max_element) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3b78udfu: /tmp/tmp3b78udfu.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::map<long,int> mp;\n    int\
    \ max = 0;\n    for(int i=0;i<arr.size();i++){\n        if(mp.find(arr[i]) ==\
    \ mp.end()){\n            mp[arr[i]] = 1;\n        }\n        else\n         \
    \   mp[arr[i]] += 1;\n    }\n    std::map<long,int>::iterator it;\n    for(it\
    \ = mp.begin();it!=mp.end();it++){\n        if(it->second > max)\n           \
    \ max = it->second;\n    }\n    if(max<=arr.size()/2)\n        return true;\n\
    \    else\n        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpibch3ewe: /tmp/tmpibch3ewe.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\n\
    \t\treturn true;\n\tif (n == 1)\n\t\treturn true;\n\tint i = 0;\n\tint max = arr[0];\n\
    \tfor (i = 1; i < n; i++) {\n\t\tif (arr[i] < max)\n\t\t\tbreak;\n\t\telse\n\t\
    \t\tmax = arr[i];\n\t}\n\tif (i == n)\n\t\treturn true;\n\tint min = arr[n - 1];\n\
    \tfor (i = n - 2; i >= 0; i--) {\n\t\tif (arr[i] > min)\n\t\t\tbreak;\n\t\telse\n\
    \t\t\tmin = arr[i];\n\t}\n\tif (i == -1)\n\t\treturn true;\n\telse\n\t\treturn\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpybdzxk3_: /tmp/tmpybdzxk3_.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    return false;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpt_1pjc__: /tmp/tmpt_1pjc__.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    //If array is empty\n    if(arr.size()\
    \ == 0) return true;\n    //Find the minimum element in the array\n    long min\
    \ = *std::min_element(arr.begin(), arr.end());\n    std::cout << \"min is: \"\
    \ << min << std::endl;\n    //Find the smallest index of the minimum value in\
    \ the array\n    long min_index = std::distance(arr.begin(), std::find(arr.begin(),\
    \ arr.end(), min));\n    std::cout << \"min_index is: \" << min_index << std::endl;\n\
    \    //Finding the number of elements greater than the minimum in the array\n\
    \    long greater_than_min = std::count_if(arr.begin(), arr.end(), [min](long\
    \ i){return i > min;});\n    std::cout << \"greater_than_min is: \" << greater_than_min\
    \ << std::endl;\n    //Finding the number of elements less than the minimum in\
    \ the array\n    long less_than_min = std::count_if(arr.begin(), arr.end(), [min](long\
    \ i){return i < min;});\n    std::cout << \"less_than_min is: \" << less_than_min\
    \ << std::endl;\n    //Finding the number of elements equal to the minimum in\
    \ the array\n    long equal_to_min = std::count_if(arr.begin(), arr.end(), [min](long\
    \ i){return i == min;});\n    std::cout << \"equal_to_min is: \" << equal_to_min\
    \ << std::endl;\n    if(greater_than_min == 0) return true;\n    if(less_than_min\
    \ + equal_to_min == 0) return false;\n    if(less_than_min + equal_to_min == 1)\
    \ {\n        if(min_index == arr.size() - 1) return true;\n        else return\
    \ false;\n    }\n    //If there are multiple minimums and the minimums are at\
    \ the start or at the end of the array\n    if(min_index == 0 || min_index ==\
    \ arr.size() - 1) return true;\n    else return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxpjczeqa: /tmp/tmpxpjczeqa.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: 'min is: 1

    min_index is: 3

    greater_than_min is: 4

    less_than_min is: 0

    equal_to_min is: 1

    '
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() <= 1)\n\t\treturn true;\n\
    \tstd::vector<long>::iterator min_it = std::min_element(arr.begin(), arr.end());\n\
    \tif (*min_it == arr[0])\n\t\treturn true;\n\tif (*min_it == arr[arr.size() -\
    \ 1])\n\t\treturn false;\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_mrtw9v_: /tmp/tmp_mrtw9v_.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n\tif(arr.size()\
    \ <= 0)\n\t\treturn true;\n\tint n = arr.size();\n\tint flag = 0;\n\tfor(int i\
    \ = 0; i < n-1; i++)\n\t{\n\t\tif(arr[i] > arr[i+1])\n\t\t{\n\t\t\tif(i+1 == n-1)\n\
    \t\t\t{\n\t\t\t\tif(flag == 0)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\
    \treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(flag == 0)\n\t\t\t\t\
    {\n\t\t\t\t\tif(arr[i+1] > arr[i+2])\n\t\t\t\t\t\treturn false;\n\t\t\t\t\telse\n\
    \t\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint n = arr.size();\n\tif (n == 0)\
    \ return true;\n\tif (n == 1) return true;\n\tlong target = arr[0];\n\tint counter\
    \ = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (arr[i] < target) counter++;\n\
    \t\telse target = arr[i];\n\t}\n\tif (counter == n - 1) return true;\n\telse return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpat_kxm2l: /tmp/tmpat_kxm2l.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111309
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    //replace this code with your own\
    \ code\n    assert(false);\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzf2w7c_g: /tmp/tmpzf2w7c_g.cpp:26: bool move_one_ball(std::vector<long
    int>): Assertion `false'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    long init = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ > init)\n            return false;\n        init = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3z4440ur: /tmp/tmp3z4440ur.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tlong max = arr[0];\n\tfor (int i = 1; i < arr.size(); i++) {\n\
    \t\tif (arr[i] < max) {\n\t\t\treturn false;\n\t\t}\n\t\tmax = arr[i];\n\t}\n\t\
    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphfnsjmre: /tmp/tmphfnsjmre.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tint minm = arr[0];\n\tint flag = 0;\n\tfor (int i = 1; i < arr.size();\
    \ i++) {\n\t\tif (arr[i] < minm) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\
    minm = arr[i];\n\t}\n\tif (flag == 0) {\n\t\treturn true;\n\t}\n\telse {\n\t\t\
    return false;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpowwmnpsz: /tmp/tmpowwmnpsz.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    bool\
    \ sorted=true;\n    int temp=0;\n    for(int i=0;i<arr.size();i++){\n        if(i+1<arr.size()){\n\
    \            if(arr[i]>arr[i+1]){\n                sorted=false;\n           \
    \     break;\n            }\n        }\n    }\n    if(sorted){\n        return\
    \ true;\n    }\n    else{\n        temp=arr[arr.size()-1];\n        for(int i=arr.size()-1;i>0;i--){\n\
    \            arr[i]=arr[i-1];\n        }\n        arr[0]=temp;\n        return\
    \ move_one_ball(arr);\n    }\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    bool isSorted = false;\n    for(int i =\
    \ 0; i < arr.size(); i++) {\n        if(arr[i] == i + 1) {\n            isSorted\
    \ = true;\n        } else {\n            isSorted = false;\n            break;\n\
    \        }\n    }\n    return isSorted;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2w3nq49_: /tmp/tmp2w3nq49_.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0){\n        return\
    \ true;\n    }\n    // long a = arr[0];\n    for(int i=0;i<arr.size()-1;i++){\n\
    \        if(arr[i]>arr[i+1]){\n            return false;\n        }\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnbs8lo0l: /tmp/tmpnbs8lo0l.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    //write your code here\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpv3edlx8u: /tmp/tmpv3edlx8u.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here.\n    int\
    \ n = arr.size();\n    if(n == 0)\n        return true;\n    int pos = 0;\n  \
    \  for(int i = 0; i < n; i++)\n    {\n        if(arr[i] == i + 1)\n          \
    \  pos = i;\n    }\n    if(pos == n - 1)\n        return true;\n    for(int i\
    \ = pos + 1; i < n; i++)\n    {\n        if(arr[i] <= arr[i - 1])\n          \
    \  return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcmov5ff6: /tmp/tmpcmov5ff6.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\t// To print\
    \ results to the standard output you can use std::cout\n\t// Example: std::cout\
    \ << \"Hello world!\";\n\t\n\tstd::sort(arr.begin(), arr.end());\n\t\n\tint n\
    \ = arr.size();\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tif(arr[i + 1] - arr[i]\
    \ != 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyzxtg6ej: /tmp/tmpyzxtg6ej.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    // your code goes here\n    int n = arr.size();\n    std::vector<long> v\
    \ = arr;\n    std::sort(v.begin(), v.end());\n    for(int i = 0; i < n; i++) {\n\
    \        if(arr[i] != v[i]) {\n            arr.erase(arr.begin() + i);\n     \
    \       arr.insert(arr.begin(), v[i]);\n            if(arr == v) {\n         \
    \       return true;\n            }\n            else {\n                arr.erase(arr.begin());\n\
    \                arr.push_back(v[i]);\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjfx_pzmg: /tmp/tmpjfx_pzmg.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::vector<long> arr1 = arr;\n\
    \    std::sort(arr1.begin(), arr1.end());\n    int i = 0;\n    while(i < arr.size()\
    \ && arr[i] == arr1[i])\n        i++;\n    int j = arr.size() - 1;\n    while(j\
    \ >= 0 && arr[j] == arr1[j])\n        j--;\n    if(i == arr.size() && j == -1)\n\
    \        return true;\n    if(j - i <= 1)\n        return false;\n    if(arr[i]\
    \ == arr1[j] && arr[j] == arr1[i])\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzebr6o2a: /tmp/tmpzebr6o2a.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tlong n = arr.size();\n\tlong index;\n\tfor (long i = 0; i < n;\
    \ i++) {\n\t\tif (arr[i] != i + 1) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\
    }\n\tfor (long i = index; i < n; i++) {\n\t\tif (arr[i] != arr[index]) {\n\t\t\
    \treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkgvr8pj0: /tmp/tmpkgvr8pj0.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0){\n        return\
    \ true;\n    }\n    long arr_size = arr.size();\n    int left_most_wrong_elem\
    \ = -1;\n    for(int i = 0; i < arr_size - 1; i++){\n        if(arr[i] > arr[i+1]){\n\
    \            left_most_wrong_elem = i;\n            break;\n        }\n    }\n\
    \    if(left_most_wrong_elem == -1){\n        return true;\n    }\n    int right_most_wrong_elem\
    \ = left_most_wrong_elem + 1;\n    for(int i = left_most_wrong_elem; i < arr_size\
    \ - 1; i++){\n        if(arr[i] > arr[i+1]){\n            right_most_wrong_elem\
    \ = i + 1;\n        }\n    }\n    if(left_most_wrong_elem == 0 && right_most_wrong_elem\
    \ == arr_size - 1){\n        return false;\n    }\n    for(int i = 0; i < arr_size;\
    \ i++){\n        if(i < left_most_wrong_elem || i > right_most_wrong_elem){\n\
    \            if(arr[i] > arr[right_most_wrong_elem]){\n                return\
    \ false;\n            }\n        }\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqpurjmqh: /tmp/tmpqpurjmqh.cpp:59: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int temp = 0;\n    int min = INT_MAX;\n\
    \    int min_index = 0;\n    int len = arr.size();\n    if(len == 0){\n      \
    \  return true;\n    }\n    for(int i = 0; i < len; i++){\n        if(arr[i] <\
    \ min){\n            min = arr[i];\n            min_index = i;\n        }\n  \
    \  }\n    int n = len - 1;\n    int k = 0;\n    for(int i = 0; i < len; i++){\n\
    \        if(i == min_index){\n            if(i == n){\n                return\
    \ true;\n            }\n            if(arr[i] > arr[i+1]){\n                return\
    \ false;\n            }\n        }else{\n            if(arr[i] < arr[i+1]){\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdkfoyzcn: /tmp/tmpdkfoyzcn.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn\
    \ true;\n\t}\n\tstd::vector<long> temp;\n\tfor (int i = 0; i < arr.size(); i++)\
    \ {\n\t\ttemp.push_back(arr[i]);\n\t}\n\tstd::sort(temp.begin(), temp.end());\n\
    \tint c = 0;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] == temp[c])\
    \ {\n\t\t\tc++;\n\t\t}\n\t}\n\tif (c == arr.size()) {\n\t\treturn true;\n\t}\n\
    \treturn false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptwxnqxme: /tmp/tmptwxnqxme.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\tint l=arr.size();\n\tint k;\n\tfor(int\
    \ i=0;i<l;i++)\n\t{\n\t\tif(arr[i]==i+1)\n\t\t\tcontinue;\n\t\telse\n\t\t{\n\t\
    \t\tk=arr[i];\n\t\t\tfor(int j=0;j<l;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]==k)\n\t\t\
    \t\t{\n\t\t\t\t\tarr[j]=arr[i];\n\t\t\t\t\tarr[i]=k;\n\t\t\t\t\tbreak;\n\t\t\t\
    \t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(arr[i]!=i+1)\n\t\
    \t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5xpe8go5: /tmp/tmp5xpe8go5.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // arr is a non-empty vector of unique\
    \ integers. \n  if (arr.size() == 0) {\n    return true;\n  }\n\n  long max =\
    \ arr[0];\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] > max) {\n\
    \      max = arr[i];\n    } else {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmf86al7t: /tmp/tmpmf86al7t.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    else if(arr.size() == 1)\n        return true;\n    else if(arr.size()\
    \ == 2)\n        return arr[0] <= arr[1];\n    std::vector<long> temp;\n    temp.push_back(arr[arr.size()-1]);\n\
    \    for(int i = 0; i < arr.size()-1; i++)\n        temp.push_back(arr[i]);\n\
    \    for(int i = 0; i < arr.size(); i++)\n        arr[i] = temp[i];\n    for(int\
    \ i = 0; i < arr.size()-1; i++)\n        if(arr[i] > arr[i+1])\n            return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp13c29vsz: /tmp/tmp13c29vsz.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    std::stack<long> s;\n    long size\
    \ = arr.size();\n    if(size == 0)\n        return true;\n    for(long i = 0;\
    \ i < size; i++) {\n        s.push(arr[i]);\n    }\n    long i = 0;\n    while(!s.empty())\
    \ {\n        arr[i] = s.top();\n        s.pop();\n        i++;\n    }\n    for(long\
    \ i = 0; i < size - 1; i++) {\n        if(arr[i] > arr[i + 1])\n            return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8mg7etnt: /tmp/tmp8mg7etnt.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// write your code here\n\tint i =\
    \ 0;\n\tint temp;\n\tbool flag = false;\n\tif (arr.size() > 1) {\n\t\twhile (flag\
    \ == false) {\n\t\t\tif (arr[i] > arr[i + 1]) {\n\t\t\t\ttemp = arr[i];\n\t\t\t\
    \tarr[i] = arr[i + 1];\n\t\t\t\tarr[i + 1] = temp;\n\t\t\t\tflag = true;\n\t\t\
    \t}\n\t\t\ti++;\n\t\t}\n\t\tint j = 1;\n\t\twhile (j < arr.size()) {\n\t\t\tif\
    \ (arr[j] < arr[j - 1]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\
    \t\treturn true;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp284ee7ec: /tmp/tmp284ee7ec.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// your code here\n\t//some_r_shifts(arr,\
    \ N);\n\t//for (int i = 0; i < N - 1; i++)\n\t//{\n\t//\tif (arr[i] > arr[i +\
    \ 1])\n\t//\t\treturn false;\n\t//}\n\t//return true;\n\t/*int flag = 0;\n\tfor\
    \ (int i = 0; i < arr.size() - 1; i++)\n\t{\n\t\tif (arr[i] > arr[i + 1])\n\t\t\
    {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag == 0)\n\t\treturn true;\n\
    \telse\n\t{\n\t\tfor (int i = 0; i < arr.size() - 1; i++)\n\t\t{\n\t\t\tif (arr[i]\
    \ < arr[i + 1])\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < arr.size() - 1; j++)\n\
    \t\t\t\t{\n\t\t\t\t\tif (arr[j] > arr[j + 1])\n\t\t\t\t\t\treturn false;\n\t\t\
    \t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}*/\n\tlong int min_pos = 0;\n\t\
    long int max_pos = 0;\n\tbool flag1 = true;\n\tbool flag2 = true;\n\tfor (int\
    \ i = 0; i < arr.size() - 1; i++)\n\t{\n\t\tif (arr[i] > arr[i + 1])\n\t\t{\n\t\
    \t\tflag1 = false;\n\t\t\tif (arr[i + 1] > arr[max_pos])\n\t\t\t\tmax_pos = i\
    \ + 1;\n\t\t}\n\t\tif (arr[i] < arr[i + 1])\n\t\t{\n\t\t\tflag2 = false;\n\t\t\
    \tif (arr[i] < arr[min_pos])\n\t\t\t\tmin_pos = i;\n\t\t}\n\t}\n\tif (flag1)\n\
    \t\treturn true;\n\tif (flag2)\n\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnboknwtl.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpnboknwtl.cpp:82:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmpnboknwtl.cpp:82:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   82 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660111310
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// your code goes here\n\t// Return\
    \ true if it is possible to obtain a sorted vector \n\t// else return false.\n\
    \tint count = 0;\n\tstd::vector<long> _arr = arr;\n\tstd::sort(_arr.begin(), _arr.end());\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] != _arr[i]) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\tif (count > 2) {\n\t\treturn false;\n\t}\n\telse {\n\t\
    \treturn true;\n\t}\n}\nint main() {\n    auto candidate = move_one_ball;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmps35rzrgj: /tmp/tmps35rzrgj.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111311
