language: cpp
name: HumanEval_143_words_in_sentence
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words = split(sentence, ' ');\n    std::string res;\n    for (const auto &word\
    \ : words) {\n        if (is_prime(word.size())) {\n            res += word +\
    \ \" \";\n        }\n    }\n    if (res.size() > 0) {\n        res.pop_back();\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl7vagn9p.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpl7vagn9p.cpp:18:38: error: \u2018split\u2019 was not declared in this\
    \ scope\n   18 |     std::vector<std::string> words = split(sentence, ' ');\n\
    \      |                                      ^~~~~\n/tmp/tmpl7vagn9p.cpp:21:13:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   21 |        \
    \ if (is_prime(word.size())) {\n      |             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    char delim = ' ';\n\
    \    std::vector<std::string> words;\n    words.push_back(\"\");\n    int i =\
    \ 0;\n    for (const char& c : sentence) {\n        if (c == delim) {\n      \
    \      words.push_back(\"\");\n            i++;\n        } else {\n          \
    \  words[i] += c;\n        }\n    }\n    std::stringstream ss;\n    for (const\
    \ std::string& word : words) {\n        bool check = false;\n        if (word.length()\
    \ > 1) {\n            for (int i = 2; i < word.length(); i++) {\n            \
    \    if (word.length() % i == 0) {\n                    check = true;\n      \
    \              break;\n                }\n            }\n        }\n        if\
    \ (!check) {\n            ss << word << \" \";\n        }\n    }\n    return ss.str();\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmph7ejasbv: /tmp/tmph7ejasbv.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    std::vector<int> res;\n    std::string word;\n    std::stringstream ss(sentence);\n\
    \    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    for (auto i = 0; i < words.size(); i++) {\n        if (is_prime(words[i].size()))\
    \ {\n            res.push_back(i);\n        }\n    }\n    for (auto i = 0; i <\
    \ res.size(); i++) {\n        result += words[res[i]];\n        if (i != res.size()\
    \ - 1) {\n            result += \" \";\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc1o7it70.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpc1o7it70.cpp:27:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   27 |         if (is_prime(words[i].size())) {\n      |      \
    \       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::istringstream iss(sentence);\n\
    \  std::string words;\n  std::string result;\n  bool prime_found = false;\n  while\
    \ (iss >> words) {\n    bool is_prime = true;\n    int word_len = words.length();\n\
    \    if (word_len > 1) {\n      for (int i = 2; i < word_len; i++) {\n       \
    \ if (word_len % i == 0) {\n          is_prime = false;\n          break;\n  \
    \      }\n      }\n    }\n    if (is_prime) {\n      if (prime_found) {\n    \
    \    result += \" \";\n      }\n      result += words;\n      prime_found = true;\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsfckmqfl: /tmp/tmpsfckmqfl.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string final =\
    \ \"\";\n    std::vector<std::string> fin = {};\n    std::vector<std::string>\
    \ words = {};\n    std::string word = \"\";\n    int p = 0;\n    for (size_t i\
    \ = 0; i < sentence.size(); i++) {\n        if (sentence[i] == ' ') {\n      \
    \      words.push_back(word);\n            word = \"\";\n        } else {\n  \
    \          word += sentence[i];\n        }\n    }\n    words.push_back(word);\n\
    \    for (size_t i = 0; i < words.size(); i++) {\n        for (size_t j = 2; j\
    \ < words[i].size(); j++) {\n            if (words[i].size() % j == 0) {\n   \
    \             p = 1;\n                break;\n            }\n        }\n     \
    \   if (p == 0) {\n            fin.push_back(words[i]);\n        }\n        p\
    \ = 0;\n    }\n    for (size_t i = 0; i < fin.size(); i++) {\n        final +=\
    \ fin[i];\n        if (i < fin.size() - 1) {\n            final += \" \";\n  \
    \      }\n    }\n    return final;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpu8heqdem: /tmp/tmpu8heqdem.cpp:54: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::string word = \"\";\n    int number = 0;\n    std::vector<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] == ' ') {\n            if (std::find(primes.begin(),\
    \ primes.end(), word.length()) != primes.end()) {\n                result += word\
    \ + \" \";\n            }\n            word = \"\";\n        } else {\n      \
    \      word += sentence[i];\n        }\n    }\n    if (std::find(primes.begin(),\
    \ primes.end(), word.length()) != primes.end()) {\n        result += word;\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp_ecrkjho: /tmp/tmp_ecrkjho.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::string word = \"\";\n    for (size_t i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (word.length() > 1)\
    \ {\n                int x = word.length();\n                int y = x;\n    \
    \            while (y > 1) {\n                    if (x % y == 0) {\n        \
    \                break;\n                    }\n                    y--;\n   \
    \             }\n                if (y == 1) {\n                    result +=\
    \ word + \" \";\n                }\n            }\n            word = \"\";\n\
    \        } else {\n            word += sentence[i];\n        }\n    }\n    if\
    \ (word.length() > 1) {\n        int x = word.length();\n        int y = x;\n\
    \        while (y > 1) {\n            if (x % y == 0) {\n                break;\n\
    \            }\n            y--;\n        }\n        if (y == 1) {\n         \
    \   result += word;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpitkw6n2p: /tmp/tmpitkw6n2p.cpp:57: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::vector<std::string> words;\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<int> lengths;\n\
    \    std::string answer;\n    for (std::string word : words) {\n        lengths.push_back(word.length());\n\
    \    }\n    for (int length : lengths) {\n        bool prime = true;\n       \
    \ for (int j = 2; j <= length / 2; j++) {\n            if (length % j == 0) {\n\
    \                prime = false;\n                break;\n            }\n     \
    \   }\n        if (prime) {\n            answer += std::to_string(length) + \"\
    \ \";\n        }\n    }\n    return answer;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp1v8bhec9: /tmp/tmp1v8bhec9.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098939
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream in(sentence);\n\
    \    std::string word;\n    std::string result = \"\";\n    std::stringstream\
    \ out;\n    while (in >> word) {\n        if (is_prime(word.length())) {\n   \
    \         out << word << \" \";\n        }\n    }\n    result = out.str();\n \
    \   result.pop_back();\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3nhlved_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp3nhlved_.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code here\n \
    \ vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  std::string s=\"\";\n  std::string\
    \ ret=\"\";\n  int len=sentence.length();\n  int flag=0;\n  for(int i=0;i<len;i++)\n\
    \  {\n    if(sentence[i]!=' ')\n    {\n      s+=sentence[i];\n      flag=1;\n\
    \    }\n    else\n    {\n      if(flag==1)\n      {\n        int c=s.length();\n\
    \        int count=0;\n        for(int i=0;i<primes.size();i++)\n        {\n \
    \         if(primes[i]==c)\n          {\n            count++;\n            break;\n\
    \          }\n        }\n        if(count!=0)\n        {\n          if(ret.length()==0)\n\
    \          {\n            ret+=s;\n          }\n          else\n          {\n\
    \            ret+=\" \";\n            ret+=s;\n          }\n        }\n      \
    \  s=\"\";\n        flag=0;\n      }\n    }\n  }\n  int c=s.length();\n  int count=0;\n\
    \  for(int i=0;i<primes.size();i++)\n  {\n    if(primes[i]==c)\n    {\n      count++;\n\
    \      break;\n    }\n  }\n  if(count!=0)\n  {\n    if(ret.length()==0)\n    {\n\
    \      ret+=s;\n    }\n    else\n    {\n      ret+=\" \";\n      ret+=s;\n   \
    \ }\n  }\n  return ret;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9oo30bls.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp9oo30bls.cpp:19:3: error: \u2018vector\u2019 was not declared in this\
    \ scope\n   19 |   vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n      |   ^~~~~~\n\
    /tmp/tmp9oo30bls.cpp:19:3: note: suggested alternatives:\nIn file included from\
    \ /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9oo30bls.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9oo30bls.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp9oo30bls.cpp:19:10:\
    \ error: expected primary-expression before \u2018int\u2019\n   19 |   vector<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n      |          ^~~\n/tmp/tmp9oo30bls.cpp:37:23:\
    \ error: \u2018primes\u2019 was not declared in this scope\n   37 |         for(int\
    \ i=0;i<primes.size();i++)\n      |                       ^~~~~~\n/tmp/tmp9oo30bls.cpp:64:17:\
    \ error: \u2018primes\u2019 was not declared in this scope\n   64 |   for(int\
    \ i=0;i<primes.size();i++)\n      |                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string new_sentence\
    \ = \"\";\n    int length = sentence.length();\n    for (int i = 0; i < length;\
    \ i++) {\n        if (sentence[i] == ' ') {\n            continue;\n        }\n\
    \        std::string word = \"\";\n        while (sentence[i] != ' ' && i < length)\
    \ {\n            word += sentence[i];\n            i++;\n        }\n        bool\
    \ is_prime = true;\n        for (int j = 2; j < word.length(); j++) {\n      \
    \      if (word.length() % j == 0) {\n                is_prime = false;\n    \
    \            break;\n            }\n        }\n        if (is_prime && word.length()\
    \ > 1) {\n            new_sentence += word + \" \";\n        }\n    }\n    new_sentence.pop_back();\n\
    \    return new_sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpe8o43ger: /tmp/tmpe8o43ger.cpp:50: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::vector<std::string> v;\n    while (ss >> word)\
    \ {\n        v.push_back(word);\n    }\n    auto IsPrime = [](int n) {\n     \
    \   if (n < 2) {\n            return false;\n        }\n        for (int i = 2;\
    \ i < n; i++) {\n            if (n % i == 0) {\n                return false;\n\
    \            }\n        }\n        return true;\n    };\n    for (int i = 0; i\
    \ < v.size(); i++) {\n        if (!IsPrime(v[i].size())) {\n            v.erase(v.begin()\
    \ + i);\n            i--;\n        }\n    }\n    std::string res;\n    for (int\
    \ i = 0; i < v.size(); i++) {\n        res += v[i];\n        if (i < v.size()\
    \ - 1) {\n            res += \" \";\n        }\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ list;\n    std::string str;\n    for(int i=0;i<sentence.length();i++){\n   \
    \     if(sentence[i]==' '){\n            list.push_back(str);\n            str=\"\
    \";\n        }\n        else\n            str+=sentence[i];\n    }\n    list.push_back(str);\n\
    \    for(int i=0;i<list.size();i++){\n        int n=list[i].length();\n      \
    \  if(n==2 || n==3 || n==5 || n==7 || n==11 || n==13 || n==17 || n==19 || n==23\
    \ || n==29 || n==31 || n==37 || n==41 || n==43 || n==47 || n==53 || n==59 || n==61\
    \ || n==67 || n==71 || n==73 || n==79 || n==83 || n==89 || n==97 || n==101 ||\
    \ n==103 || n==107 || n==109 || n==113 || n==127 || n==131 || n==137 || n==139\
    \ || n==149 || n==151 || n==157 || n==163 || n==167 || n==173 || n==179 || n==181\
    \ || n==191 || n==193 || n==197 || n==199){\n            str+=list[i];\n     \
    \       str+=\" \";\n        }\n    }\n    return str;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpa7q_7zhn: /tmp/tmpa7q_7zhn.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  //your code here\n  std::vector<std::string>\
    \ tmp;\n  std::stringstream ss(sentence);\n  std::string word;\n  while(ss >>\
    \ word)\n    tmp.push_back(word);\n  std::vector<std::string> res;\n  for(auto\
    \ w : tmp)\n    if(w.size() > 1 && w.size() != 2 && w.size() % 2 != 0)\n     \
    \ res.push_back(w);\n  std::string s;\n  for(auto &e : res)\n    s += e + \" \"\
    ;\n  s.pop_back();\n  return s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp8n5c0dio: /tmp/tmp8n5c0dio.cpp:36: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    std::string str;\n    std::stringstream ss(sentence);\n    while (ss >> str)\
    \ {\n        if(isPrime(str.length())){\n            result += str + \" \";\n\
    \        }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy62oi4lh.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpy62oi4lh.cpp:22:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   22 |         if(isPrime(str.length())){\n      |            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\nstd::cout<<sentence<<std::endl;\n\
    \  std::string result=\"\";\n  std::stringstream x(sentence);\n  int counter=0;\n\
    \  while(x)\n  {\n    std::string word;\n    x>>word;\n    // std::cout<<word<<std::endl;\n\
    \    int checker=0;\n    for(int i=2;i<word.length();i++)\n    {\n      if(word.length()%i==0)\n\
    \      {\n        checker++;\n      }\n    }\n    if(checker==0)\n    {\n    \
    \  result+=word;\n      result+=\" \";\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpcpqbqu6y: /tmp/tmpcpqbqu6y.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: 'This is a test

    '
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  int strLength = sentence.length();\n\
    \  int i, j, count;\n  std::string result = \"\";\n  // Iterate through all characters\
    \ of input string and\n  // update max if a separator is found\n  for (i = 0;\
    \ i < strLength; i++) {\n    count = 0;\n    if (sentence[i] == ' ') {\n     \
    \ for (j = i - 1; j >= 0 && sentence[j] != ' '; j--) {\n        count++;\n   \
    \   }\n      if (count > 1) {\n        for (j = 2; j <= count; j++) {\n      \
    \    if (count % j == 0) {\n            break;\n          }\n        }\n     \
    \   if (j == count) {\n          result += sentence[i];\n        }\n      }\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpz82dmaos: /tmp/tmpz82dmaos.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code here\n \
    \ bool flag = true;\n  std::vector<std::string> result;\n  std::string temp =\
    \ \"\";\n  std::stringstream ss(sentence);\n  for(int i = 0; i < sentence.length();\
    \ i++){\n    char c = sentence[i];\n    if(c == ' '){\n      if(temp.length()\
    \ > 1){\n        for(int j = 2; j < temp.length(); j++){\n          if(temp.length()\
    \ % j == 0){\n            flag = false;\n            break;\n          }\n   \
    \     }\n        if(flag){\n          result.push_back(temp);\n        }\n   \
    \     temp = \"\";\n        flag = true;\n      }\n    }\n    else{\n      temp\
    \ += c;\n    }\n  }\n  if(temp.length() > 1){\n    for(int j = 2; j < temp.length();\
    \ j++){\n      if(temp.length() % j == 0){\n        flag = false;\n        break;\n\
    \      }\n    }\n    if(flag){\n      result.push_back(temp);\n    }\n    temp\
    \ = \"\";\n    flag = true;\n  }\n  std::string return_string = \"\";\n  for(int\
    \ i = 0; i < result.size(); i++){\n    return_string += result[i];\n    if(i !=\
    \ result.size() - 1){\n      return_string += \" \";\n    }\n  }\n  return return_string;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpfzjlyt_r: /tmp/tmpfzjlyt_r.cpp:68: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string res = \"\
    \";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss\
    \ >> word) {\n        if (is_prime(word.length()))\n            res += word +\
    \ \" \";\n    }\n    return res.substr(0, res.length() - 1);\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7o6yx2h1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp7o6yx2h1.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.length()))\n      |          \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    stringstream splitter(sentence);\n\
    \    string word;\n    vector<string> words;\n    bool isPrime(string word);\n\
    \    while(splitter >> word) {\n        if(isPrime(word)) words.push_back(word);\n\
    \    }\n    string ret = \"\";\n    for(int i = 0; i < words.size(); i++) {\n\
    \        ret = ret + words[i] + \" \";\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps9135rxl.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmps9135rxl.cpp:18:5: error: \u2018stringstream\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stringstream\u2019?\n   18 |     stringstream\
    \ splitter(sentence);\n      |     ^~~~~~~~~~~~\n      |     std::stringstream\n\
    In file included from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmps9135rxl.cpp:2:\n/usr/include/c++/9/iosfwd:156:37: note: \u2018std::stringstream\u2019\
    \ declared here\n  156 |   typedef basic_stringstream<char>  stringstream;\n \
    \     |                                     ^~~~~~~~~~~~\n/tmp/tmps9135rxl.cpp:19:5:\
    \ error: \u2018string\u2019 was not declared in this scope\n   19 |     string\
    \ word;\n      |     ^~~~~~\n/tmp/tmps9135rxl.cpp:19:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmps9135rxl.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex"
  stdout: ''
  timestamp: 1660098940
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code goes here\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  std::string ans;\n\
    \  bool flag = false;\n  while(ss >> word){\n    if(word.length()==2 || word.length()==3\
    \ || word.length()==5 || word.length()==7){\n      if(flag)\n        ans = ans\
    \ + \" \" + word;\n      else\n        ans = word;\n      flag = true;\n    }\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098940
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<int> spaces;\n\
    \    for (int i = 0; i < sentence.size(); i++) {\n        if (sentence[i] == '\
    \ ') {\n            spaces.push_back(i);\n        }\n    }\n    std::vector<std::string>\
    \ words;\n    int i = 0;\n    for (auto s : spaces) {\n        words.push_back(sentence.substr(i,\
    \ s - i));\n        i = s + 1;\n    }\n    if (i < sentence.size()) {\n      \
    \  words.push_back(sentence.substr(i, sentence.size() - i));\n    }\n    std::vector<std::string>\
    \ result;\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    for (auto\
    \ w : words) {\n        if (std::find(primes.begin(), primes.end(), w.size())\
    \ != primes.end()) {\n            result.push_back(w);\n        }\n    }\n   \
    \ std::string resultString;\n    for (auto w : result) {\n        resultString\
    \ += w + \" \";\n    }\n    return resultString.substr(0, resultString.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words = split_words(sentence);\n  std::vector<std::string> prime_words;\n  for\
    \ (auto word : words) {\n    if (is_prime(word.length())) {\n      prime_words.push_back(word);\n\
    \    }\n  }\n  return join_words(prime_words);\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3alilf_7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp3alilf_7.cpp:18:36: error: \u2018split_words\u2019 was not declared\
    \ in this scope\n   18 |   std::vector<std::string> words = split_words(sentence);\n\
    \      |                                    ^~~~~~~~~~~\n/tmp/tmp3alilf_7.cpp:21:9:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   21 |     if (is_prime(word.length()))\
    \ {\n      |         ^~~~~~~~\n/tmp/tmp3alilf_7.cpp:25:10: error: \u2018join_words\u2019\
    \ was not declared in this scope\n   25 |   return join_words(prime_words);\n\
    \      |          ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words = split_string(sentence, ' ');\n    std::string result;\n    for (int\
    \ i = 0; i < words.size(); i++) {\n        if (is_prime(words[i].size())) {\n\
    \            result += words[i] + \" \";\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz62pkkr1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpz62pkkr1.cpp:18:38: error: \u2018split_string\u2019 was not declared\
    \ in this scope\n   18 |     std::vector<std::string> words = split_string(sentence,\
    \ ' ');\n      |                                      ^~~~~~~~~~~~\n/tmp/tmpz62pkkr1.cpp:21:13:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   21 |        \
    \ if (is_prime(words[i].size())) {\n      |             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string r = \"\"\
    ;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == ' ') continue;\n        int t = 1;\n        for (int j = i + 1; j < sentence.length();\
    \ j++) {\n            if (sentence[j] == ' ') break;\n            t++;\n     \
    \   }\n        if (t == 2 || t == 3 || t == 5 || t == 7 || t == 11 || t == 13\
    \ || t == 17 || t == 19 || t == 23 || t == 29 || t == 31 || t == 37 || t == 41\
    \ || t == 43 || t == 47 || t == 53 || t == 59 || t == 61 || t == 67 || t == 71\
    \ || t == 73 || t == 79 || t == 83 || t == 89 || t == 97) {\n            for (int\
    \ j = i; j < sentence.length(); j++) {\n                if (sentence[j] == ' ')\
    \ break;\n                r += sentence[j];\n            }\n            r += '\
    \ ';\n        }\n        i += t;\n    }\n    r.pop_back();\n    return r;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp15n0eb7e: /tmp/tmp15n0eb7e.cpp:45: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string word;\n    for (char ch : sentence) {\n        if (ch\
    \ == ' ') {\n            words.push_back(word);\n            word = \"\";\n  \
    \      } else {\n            word += ch;\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (std::string word : words) {\n        if (is_prime(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    if (result.size()\
    \ > 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplp8194_c.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmplp8194_c.cpp:31:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   31 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss;\n\
    \    ss << sentence;\n    std::string t;\n    std::vector<std::string> splitedStrings;\n\
    \    while (ss >> t)\n    {\n        splitedStrings.push_back(t);\n    }\n   \
    \ std::string str;\n    int count = 0;\n    for(int i = 0; i < splitedStrings.size();\
    \ i++){\n        if(isPrime(splitedStrings[i].length())){\n            str +=\
    \ splitedStrings[i];\n            count++;\n            if(count < splitedStrings.size()){\n\
    \                str += \" \";\n            }\n        }\n    }\n    return str;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6lxvsde7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp6lxvsde7.cpp:29:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   29 |         if(isPrime(splitedStrings[i].length())){\n     \
    \ |            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    int cnt = 0;\n    for (int i = 0; i < sentence.size(); i++) {\n        if\
    \ (sentence[i] == ' ') {\n            if (cnt > 1) {\n                int is_prime\
    \ = 1;\n                for (int j = 2; j < cnt; j++) {\n                    if\
    \ (cnt % j == 0) {\n                        is_prime = 0;\n                  \
    \      break;\n                    }\n                }\n                if (is_prime)\
    \ {\n                    result += sentence[i];\n                }\n         \
    \   }\n            cnt = 0;\n        } else {\n            cnt++;\n          \
    \  result += sentence[i];\n        }\n    }\n    if (cnt > 1) {\n        int is_prime\
    \ = 1;\n        for (int j = 2; j < cnt; j++) {\n            if (cnt % j == 0)\
    \ {\n                is_prime = 0;\n                break;\n            }\n  \
    \      }\n        if (is_prime) {\n            result += ' ';\n        }\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmptenj36th: /tmp/tmptenj36th.cpp:56: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::istringstream ss(sentence);\n    std::string temp;\n    while\
    \ (std::getline(ss, temp, ' ')) {\n        words.push_back(temp);\n    }\n   \
    \ std::vector<std::string> primes;\n    std::string result = \"\";\n    for (auto&\
    \ word : words) {\n        int length = word.length();\n        if (length ==\
    \ 1) {\n            primes.push_back(word);\n        } else {\n            for\
    \ (int i = 2; i < length; i++) {\n                if (length % i == 0) {\n   \
    \                 break;\n                } else if (i == length - 1) {\n    \
    \                primes.push_back(word);\n                }\n            }\n \
    \       }\n    }\n    std::ostringstream os;\n    std::copy(primes.begin(), primes.end()\
    \ - 1, std::ostream_iterator<std::string>(os, \" \"));\n    os << primes.back();\n\
    \    return os.str();\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpcffbz6pq: /tmp/tmpcffbz6pq.cpp:47: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  assert(sentence.size()\
    \ > 0);\n  assert(sentence.size() <= 100);\n  std::stringstream ss(sentence);\n\
    \  std::string temp;\n  std::string result;\n  std::set<int> primes = {2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97};\n  while (ss >> temp) {\n    if (primes.find(temp.size()) != primes.end())\
    \ {\n      result += temp + \" \";\n    }\n  }\n  if (result.size() > 0)\n   \
    \ result.pop_back();\n  return result;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string output;\n\
    \    std::vector<int> word_lengths;\n    std::vector<std::string> words;\n   \
    \ std::string word;\n    for (int i = 0; i < sentence.length(); i++) {\n     \
    \   if (sentence[i] == ' ') {\n            word_lengths.push_back(word.length());\n\
    \            words.push_back(word);\n            word = \"\";\n        } else\
    \ {\n            word += sentence[i];\n        }\n    }\n    word_lengths.push_back(word.length());\n\
    \    words.push_back(word);\n    for (int i = 0; i < word_lengths.size(); i++)\
    \ {\n        if (word_lengths[i] == 1) continue;\n        if (word_lengths[i]\
    \ == 2) {\n            output += words[i] + \" \";\n            continue;\n  \
    \      }\n        bool is_prime = true;\n        for (int j = 2; j <= std::sqrt(word_lengths[i]);\
    \ j++) {\n            if (word_lengths[i] % j == 0) {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            output += words[i] + \" \";\n        }\n    }\n    return output;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpuq2suk7i: /tmp/tmpuq2suk7i.cpp:54: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098941
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words = split(sentence);\n  std::string output;\n  for (auto w : words) {\n\
    \    if (is_prime(w.length())) {\n      output += w + \" \";\n    }\n  }\n  return\
    \ output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_fsghurx.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_fsghurx.cpp:18:36: error: \u2018split\u2019 was not declared in this\
    \ scope\n   18 |   std::vector<std::string> words = split(sentence);\n      |\
    \                                    ^~~~~\n/tmp/tmp_fsghurx.cpp:21:9: error:\
    \ \u2018is_prime\u2019 was not declared in this scope\n   21 |     if (is_prime(w.length()))\
    \ {\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string word;\n    std::string new_sentence;\n    bool is_prime;\n\
    \    for (char &c : sentence) {\n        if (c == ' ') {\n            words.push_back(word);\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    words.push_back(word);\n    for (std::string &w : words) {\n     \
    \   is_prime = true;\n        for (int i = 2; i < w.length(); i++) {\n       \
    \     if (w.length() % i == 0) {\n                is_prime = false;\n        \
    \        break;\n            }\n        }\n        if (is_prime) {\n         \
    \   new_sentence += w + \" \";\n        }\n    }\n    new_sentence.pop_back();\n\
    \    return new_sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpk4_ele2f: /tmp/tmpk4_ele2f.cpp:48: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  bool ckprime;\n  std::string\
    \ newSentence = \"\";\n  std::vector<std::string> words;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word)\n    words.push_back(word);\n\
    \  for (int i = 0; i < words.size(); i++) {\n    ckprime = true;\n    for (int\
    \ j = 2; j < words[i].length(); j++) {\n      if (words[i].length() % j == 0)\
    \ {\n        ckprime = false;\n        break;\n      }\n    }\n    if (ckprime)\
    \ {\n      newSentence += words[i] + \" \";\n    }\n  }\n  return newSentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpg7yav1m0: /tmp/tmpg7yav1m0.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    sentence += \" \";\n\
    \    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char\
    \ c : sentence) {\n        if (c == ' ') {\n            words.push_back(word);\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    std::vector<std::string>\
    \ result;\n    for (int i = 0; i < words.size(); i++) {\n        for (int prime\
    \ : primes) {\n            if (words[i].size() == prime) {\n                result.push_back(words[i]);\n\
    \                break;\n            }\n        }\n    }\n    std::string result_str\
    \ = \"\";\n    for (std::string word : result) {\n        result_str += word +\
    \ \" \";\n    }\n    return result_str.substr(0, result_str.size() - 1);\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098939
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // Your code here\n\
    \    //break the sentence into the words\n    std::vector<std::string> words;\n\
    \    std::string word = \"\";\n    //iterate through the sentence\n    for(char\
    \ letter : sentence){\n        //if it is a space add the word to the vector and\
    \ clear the word\n        if(letter == ' '){\n            words.push_back(word);\n\
    \            word = \"\";\n        }\n        //if it is not a space continue\
    \ building the word\n        else{\n            word = word + letter;\n      \
    \  }\n    }\n    //add the last word to the vector\n    words.push_back(word);\n\
    \    //iterate through the vector\n    for(std::string word : words){\n      \
    \  //create a vector for the factoring of the word length\n        std::vector<int>\
    \ factors;\n        //assume that the word length is prime and then prove it is\
    \ not true\n        bool prime = true;\n        //start at 2 and go up to the\
    \ word length checking if any is a factor and if so add to the factors vector\n\
    \        for(int i = 2; i < word.length(); i++){\n            if(word.length()\
    \ % i == 0){\n                factors.push_back(i);\n                //if a factor\
    \ is found that is greater than 1 it is not prime\n                prime = false;\n\
    \            }\n        }\n        //if it is not prime\n        if(!prime){\n\
    \            //erase it from the vector\n            words.erase(std::remove(words.begin(),\
    \ words.end(), word), words.end());\n        }\n    }\n    //create a new string\
    \ to hold the result\n    std::string result = \"\";\n    //iterate through the\
    \ words\n    for(std::string word : words){\n        //add the word to the result\
    \ with a space at the end\n        result = result + word + \" \";\n    }\n  \
    \  //remove the space at the end of the result\n    result.pop_back();\n    //return\
    \ the result\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpqi5kkv3b: /tmp/tmpqi5kkv3b.cpp:70: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool isPrime = false;\n\
    \    std::string myword = \"\";\n    std::string result = \"\";\n    int wordlength\
    \ = 0;\n    for (auto letter : sentence) {\n        if (letter == ' ') {\n   \
    \         if (wordlength != 0) {\n                if (wordlength == 1) {\n   \
    \                 isPrime = false;\n                } else if (wordlength == 2)\
    \ {\n                    isPrime = true;\n                } else {\n         \
    \           isPrime = true;\n                    for (int i = 2; i < wordlength;\
    \ i++) {\n                        if (wordlength % i == 0) {\n               \
    \             isPrime = false;\n                            break;\n         \
    \               }\n                    }\n                }\n                if\
    \ (isPrime) {\n                    result += myword + \" \";\n               \
    \ }\n                myword = \"\";\n                wordlength = 0;\n       \
    \     }\n        } else {\n            myword += letter;\n            wordlength++;\n\
    \        }\n    }\n    if (wordlength != 0) {\n        if (wordlength == 1) {\n\
    \            isPrime = false;\n        } else if (wordlength == 2) {\n       \
    \     isPrime = true;\n        } else {\n            isPrime = true;\n       \
    \     for (int i = 2; i < wordlength; i++) {\n                if (wordlength %\
    \ i == 0) {\n                    isPrime = false;\n                    break;\n\
    \                }\n            }\n        }\n        if (isPrime) {\n       \
    \     result += myword;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp6lcn4ljs: /tmp/tmp6lcn4ljs.cpp:71: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string ans = \"\"\
    ;\n  // your code goes here\n  if(sentence == \"\"){\n      return \"\";\n  }\n\
    \  int n = sentence.length();\n  std::vector<std::string> result;\n  for(int i\
    \ = 0; i < n; i++){\n      std::string temp = \"\";\n      while(sentence[i] !=\
    \ ' ' && i < n){\n          temp += sentence[i];\n          i++;\n      }\n  \
    \    result.push_back(temp);\n  }\n  int r_size = result.size();\n  for(int i\
    \ = 0; i < r_size; i++){\n      int num = result[i].length();\n      int f = 0;\n\
    \      for(int j = 2; j <= num / 2; j++){\n          if(num % j == 0){\n     \
    \         f = 1;\n              break;\n          }\n      }\n      if(f == 0){\n\
    \          ans += result[i] + \" \";\n      }\n  }\n  if(ans.length() != 0){\n\
    \      ans.pop_back();\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpg07_poxo: /tmp/tmpg07_poxo.cpp:54: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // Write your code\
    \ here\n    std::string result;\n    std::string words=\"\";\n    int i=0;\n \
    \   while(sentence[i]!='\\0'){\n        if(sentence[i]==' '){\n            if(isPrime(words.length()))\n\
    \                result+=words+\" \";\n            words=\"\";\n        }\n  \
    \      else\n            words+=sentence[i];\n        i++;\n    }\n    if(isPrime(words.length()))\n\
    \        result+=words;\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp65ku446m.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp65ku446m.cpp:24:16: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   24 |             if(isPrime(words.length()))\n      |       \
    \         ^~~~~~~\n/tmp/tmp65ku446m.cpp:32:8: error: \u2018isPrime\u2019 was not\
    \ declared in this scope\n   32 |     if(isPrime(words.length()))\n      |   \
    \     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  int i, j, k;\n  std::string\
    \ out;\n  int len = sentence.length();\n  for (i = 0; i < len; i++) {\n    for\
    \ (j = i; j < len; j++) {\n      if (sentence[j] == ' ') {\n        if (check_prime(j\
    \ - i)) {\n          for (k = i; k < j; k++) {\n            out.push_back(sentence[k]);\n\
    \          }\n          out.push_back(' ');\n        }\n        i = j;\n     \
    \   break;\n      }\n    }\n  }\n  return out;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmparzom2_3.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmparzom2_3.cpp:24:13: error: \u2018check_prime\u2019 was not declared\
    \ in this scope\n   24 |         if (check_prime(j - i)) {\n      |          \
    \   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::stringstream ss(sentence);\n    std::string temp;\n    while\
    \ (ss >> temp)\n        words.push_back(temp);\n    std::string ret;\n    for\
    \ (int i = 0; i < words.size(); i++) {\n        if (words[i].size() == 1) {\n\
    \            ret += words[i] + \" \";\n            continue;\n        }\n    \
    \    if (words[i].size() == 2) {\n            ret += words[i] + \" \";\n     \
    \       continue;\n        }\n        bool prime = true;\n        for (int j =\
    \ 2; j <= words[i].size() / 2; j++) {\n            if (words[i].size() % j ==\
    \ 0) {\n                prime = false;\n                break;\n            }\n\
    \        }\n        if (prime)\n            ret += words[i] + \" \";\n    }\n\
    \    return ret;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpm24ph1tr: /tmp/tmpm24ph1tr.cpp:47: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string primes =\
    \ \"\";\n  std::istringstream ss(sentence);\n  std::string word;\n  while (std::getline(ss,\
    \ word, ' ')) {\n    if (is_prime(word.length())) {\n      primes += word + \"\
    \ \";\n    }\n  }\n  primes.pop_back();\n  return primes;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyw6ihtwf.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpyw6ihtwf.cpp:22:9: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |     if (is_prime(word.length())) {\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // your code here\n\
    \    std::string result;\n    std::string tmp;\n    for(auto ch : sentence){\n\
    \        if(ch == ' '){\n            if(std::find(begin(primes), end(primes),\
    \ tmp.size()) != end(primes)){\n                result += tmp + ' ';\n       \
    \     }\n            tmp.clear();\n        }else{\n            tmp += ch;\n  \
    \      }\n    }\n    if(!tmp.empty()){\n        if(std::find(begin(primes), end(primes),\
    \ tmp.size()) != end(primes)){\n            result += tmp;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp941ozi48.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp941ozi48.cpp:23:32: error: \u2018primes\u2019 was not declared in this\
    \ scope\n   23 |             if(std::find(begin(primes), end(primes), tmp.size())\
    \ != end(primes)){\n      |                                ^~~~~~\n/tmp/tmp941ozi48.cpp:23:26:\
    \ error: \u2018begin\u2019 was not declared in this scope\n   23 |           \
    \  if(std::find(begin(primes), end(primes), tmp.size()) != end(primes)){\n   \
    \   |                          ^~~~~\n/tmp/tmp941ozi48.cpp:23:26: note: suggested\
    \ alternatives:\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp941ozi48.cpp:2:\n/usr/include/c++/9/valarray:1224:5:\
    \ note:   \u2018std::begin\u2019\n 1224 |     begin(const valarray<_Tp>& __va)\n\
    \      |     ^~~~~\nIn file included from /usr/include/c++/9/filesystem:38,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmp941ozi48.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:516:3:\
    \ note:   \u2018std::filesystem::__cxx11::begin\u2019\n  516 |   begin(recursive_directory_iterator\
    \ __iter) noexcept\n      |   ^~~~~\n/tmp/tmp941ozi48.cpp:23:41: error: \u2018\
    end\u2019 was not declared in this scope\n   23 |             if(std::find(begin(primes),\
    \ end(primes), tmp.size()) != end(primes)){\n      |                         \
    \                ^~~\n/tmp/tmp941ozi48.cpp:23:41: note: suggested alternatives:\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp941ozi48.cpp:2:\n/usr/include/c++/9/valarray:1244:5:\
    \ note:   \u2018std::end\u2019\n 1244 |     end(const valarray<_Tp>& __va)\n \
    \     |     ^~~\nIn file included from /usr/include/c++/9/filesystem:38,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n \
    \                from /tmp/tmp941ozi48.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:520:3:\
    \ note:   \u2018std::filesystem::__cxx11::end\u2019\n  520 |   end(recursive_directory_iterator)\
    \ noexcept\n      |   ^~~\n/tmp/tmp941ozi48.cpp:32:28: error: \u2018primes\u2019\
    \ w"
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // Write your code here\n\
    \  std::vector<std::string>prime;\n  std::stringstream ss(sentence);\n  std::string\
    \ word;\n  while(ss>>word){\n    bool isPrime=true;\n    for(int i=2;i<word.size();i++){\n\
    \      if(word.size()%i==0){\n        isPrime=false;\n        break;\n      }\n\
    \    }\n    if(isPrime)\n      prime.push_back(word);\n  }\n  std::string result;\n\
    \  for(auto i:prime)\n    result+=i+\" \";\n  return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp2ajihtxp: /tmp/tmp2ajihtxp.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // Implement the function\
    \ here\n    return \"\";\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp63bzsg0d: /tmp/tmp63bzsg0d.cpp:23: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tbool is_prime(int n);\n\
    \tint word_count(std::string sentence);\n\tint word_length(std::string sentence,\
    \ int word_num);\n\tstd::string separate_word(std::string sentence, int word_num);\n\
    \tstd::string words_in_sentence(\"\");\n\tint word_num = 0;\n\tint total_num =\
    \ word_count(sentence);\n\twhile (word_num < total_num) {\n\t\tint length = word_length(sentence,\
    \ word_num);\n\t\tif (is_prime(length)) {\n\t\t\twords_in_sentence += separate_word(sentence,\
    \ word_num);\n\t\t\twords_in_sentence += \" \";\n\t\t}\n\t\tword_num++;\n\t}\n\
    \treturn words_in_sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: '/usr/bin/ld: /tmp/ccqKAMkN.o: in function `words_in_sentence(std::__cxx11::basic_string<char,
    std::char_traits<char>, std::allocator<char> >)'':

    tmp8uxw7d3r.cpp:(.text+0x75): undefined reference to `word_count(std::__cxx11::basic_string<char,
    std::char_traits<char>, std::allocator<char> >)''

    /usr/bin/ld: tmp8uxw7d3r.cpp:(.text+0xb4): undefined reference to `word_length(std::__cxx11::basic_string<char,
    std::char_traits<char>, std::allocator<char> >, int)''

    /usr/bin/ld: tmp8uxw7d3r.cpp:(.text+0xcd): undefined reference to `is_prime(int)''

    /usr/bin/ld: tmp8uxw7d3r.cpp:(.text+0xfa): undefined reference to `separate_word(std::__cxx11::basic_string<char,
    std::char_traits<char>, std::allocator<char> >, int)''

    collect2: error: ld returned 1 exit status

    '
  stdout: ''
  timestamp: 1660098940
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code here\n \
    \ std::vector<std::string> result;\n  std::string word = \"\";\n  for (int i =\
    \ 0; i < sentence.length(); i++) {\n    if (sentence[i] == ' ') {\n      if (isPrime(word.length()))\
    \ {\n        result.push_back(word);\n      }\n      word = \"\";\n    } else\
    \ {\n      word += sentence[i];\n    }\n  }\n  if (isPrime(word.length())) {\n\
    \    result.push_back(word);\n  }\n  std::string finalResult = \"\";\n  for (int\
    \ i = 0; i < result.size(); i++) {\n    finalResult += result[i];\n    if (i !=\
    \ result.size() - 1) {\n      finalResult += \" \";\n    }\n  }\n  return finalResult;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprlh_dcgn.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmprlh_dcgn.cpp:23:11: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   23 |       if (isPrime(word.length())) {\n      |           ^~~~~~~\n\
    /tmp/tmprlh_dcgn.cpp:31:7: error: \u2018isPrime\u2019 was not declared in this\
    \ scope\n   31 |   if (isPrime(word.length())) {\n      |       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098942
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::vector<std::string> words = {\"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\"};\n    int k = 0;\n    for (int i = 0; i\
    \ < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n           \
    \ k++;\n        } else {\n            words[k] += sentence[i];\n        }\n  \
    \  }\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\n\
    \    for (int i = 0; i < k; i++) {\n        if (std::find(primes.begin(), primes.end(),\
    \ words[i].length()) != primes.end()) {\n            result += words[i] + \" \"\
    ;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpktsppl0h: /tmp/tmpktsppl0h.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098942
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n   std::string s = \"\"\
    ;\n   std::vector<std::string> arr = {};\n   int flag = 0;\n   bool is_prime =\
    \ true;\n   std::string res = \"\";\n   for(int i = 0; i < sentence.length();\
    \ i++) {\n      char ch = sentence[i];\n      if(ch == ' ') {\n         arr.push_back(s);\n\
    \         s = \"\";\n      }\n      else {\n         s += ch;\n      }\n   }\n\
    \   arr.push_back(s);\n   for(int i = 0; i < arr.size(); i++) {\n      if(arr[i].length()\
    \ == 1 || arr[i].length() == 2) {\n         res += arr[i] + \" \";\n      }\n\
    \      else {\n         for(int j = 2; j < arr[i].length(); j++) {\n         \
    \   if(arr[i].length() % j == 0) {\n               is_prime = false;\n       \
    \        break;\n            }\n         }\n         if(is_prime) {\n        \
    \    res += arr[i] + \" \";\n         }\n         is_prime = true;\n      }\n\
    \   }\n   res.pop_back();\n   return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpxxri1p79: /tmp/tmpxxri1p79.cpp:56: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    for (int i = 0; i < sentence.size(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            sentence[i] = ',';\n        }\n    }\n    std::string\
    \ str;\n    std::stringstream ss(sentence);\n    while (getline(ss, str, ','))\
    \ {\n        words.push_back(str);\n    }\n    std::string answer;\n    for (int\
    \ i = 0; i < words.size(); i++) {\n        if (words[i].size() == 2 || words[i].size()\
    \ == 3 || words[i].size() == 5 || words[i].size() == 7) {\n            answer\
    \ += words[i] + \" \";\n        }\n    }\n    return answer;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpj3lijnlz: /tmp/tmpj3lijnlz.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // Your code goes here\n\
    \    // std::string ret;\n    std::stringstream ss(sentence);\n    std::string\
    \ word;\n    std::string ans;\n    while(ss >> word){\n      if(word.length()\
    \ <= 1)\n        continue;\n      int flag = 1;\n      for(int i = 2; i < word.length();\
    \ i++){\n        if(word.length() % i == 0){\n          flag = 0;\n          break;\n\
    \        }\n      }\n      if(flag)\n        ans += word + \" \";\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpeddxntu6: /tmp/tmpeddxntu6.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::string answer =\
    \ \"\";\n\tstd::stringstream ss(sentence);\n\tstd::string word;\n\twhile (ss >>\
    \ word) {\n\t\tif (word.length() == 2 || word.length() == 3 || word.length() ==\
    \ 5 || word.length() == 7) {\n\t\t\tanswer += word + \" \";\n\t\t}\n\t}\n\tif\
    \ (answer != \"\") {\n\t\treturn answer.substr(0, answer.length() - 1);\n\t}\n\
    \treturn answer;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098942
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    //your code here\n\
    \    bool isPrime(int n);\n    std::string res;\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    while(ss >> word){\n        int len = word.length();\n\
    \        if(isPrime(len)){\n            res += word + \" \";\n        }\n    }\n\
    \    res.pop_back();\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: '/usr/bin/ld: /tmp/ccAv0iun.o: in function `words_in_sentence(std::__cxx11::basic_string<char,
    std::char_traits<char>, std::allocator<char> >)'':

    tmpk_2ocio7.cpp:(.text+0xc5): undefined reference to `isPrime(int)''

    collect2: error: ld returned 1 exit status

    '
  stdout: ''
  timestamp: 1660098942
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    std::istringstream iss(sentence);\n    std::vector<std::string> words(std::istream_iterator<std::string>{iss},\n\
    \                                   std::istream_iterator<std::string>());\n \
    \   for (auto word : words) {\n        bool prime = true;\n        for (int i\
    \ = 2; i < word.length(); i++) {\n            if (word.length() % i == 0) {\n\
    \                prime = false;\n                break;\n            }\n     \
    \   }\n        if (prime) {\n            result += word + \" \";\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp729tgyot: /tmp/tmp729tgyot.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::string result =\
    \ \"\";\n\tstd::vector<std::string> words;\n\tstd::stringstream ss(sentence);\n\
    \tstd::string word;\n\twhile (ss >> word)\n\t\twords.push_back(word);\n\tfor (int\
    \ i = 0; i < words.size(); i++) {\n\t\tint len = words[i].length();\n\t\tif (len\
    \ < 2)\n\t\t\tcontinue;\n\t\tif (len == 2) {\n\t\t\tresult += words[i] + \" \"\
    ;\n\t\t\tcontinue;\n\t\t}\n\t\tbool is_prime = true;\n\t\tfor (int j = 2; j <=\
    \ len / 2; j++) {\n\t\t\tif (len % j == 0) {\n\t\t\t\tis_prime = false;\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t}\n\t\tif (is_prime)\n\t\t\tresult += words[i] + \" \"\
    ;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpadzybrn5: /tmp/tmpadzybrn5.cpp:46: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string result;\n    // splite sentence by space\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n\
    \    }\n    // check if size of words is prime or not\n    for (auto it = words.begin();\
    \ it != words.end(); it++) {\n        int size = (*it).size();\n        bool isPrime\
    \ = true;\n        for (int i = 2; i <= size / 2; i++) {\n            if (size\
    \ % i == 0) {\n                isPrime = false;\n                break;\n    \
    \        }\n        }\n        if (isPrime) {\n            result += (*it);\n\
    \            result += \" \";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4gn1x8ly: /tmp/tmp4gn1x8ly.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::string tmp = \"\";\n    std::istringstream iss(sentence);\n\
    \    do {\n        std::string word;\n        iss >> word;\n        // word =>\
    \ word.length()\n        if (word.length() == 1){\n            // 1 is not prime\
    \ number\n            continue;\n        }\n        bool is_prime = true;\n  \
    \      for (int i = 2; i <= word.length()/2; i++){\n            if (word.length()\
    \ % i == 0){\n                is_prime = false;\n                break;\n    \
    \        }\n        }\n        if (is_prime)\n            result += word + \"\
    \ \";\n    } while (iss);\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp65kdrz6j: /tmp/tmp65kdrz6j.cpp:43: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::vector<std::string> words;\n    while (std::getline(ss,\
    \ word, ' ')) {\n        words.push_back(word);\n    }\n    std::vector<bool>\
    \ is_prime(101, true);\n    for (int i = 2; i < 101; i++) {\n        if (is_prime[i])\
    \ {\n            for (int j = i * i; j < 101; j += i) {\n                is_prime[j]\
    \ = false;\n            }\n        }\n    }\n    std::string result;\n    for\
    \ (auto word : words) {\n        if (is_prime[word.size()]) {\n            result\
    \ += word + \" \";\n        }\n    }\n    return result.substr(0, result.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmphoy4tmhx: /tmp/tmphoy4tmhx.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tint arr[100];\n\tint\
    \ count = 0;\n\t// std::cout << sentence;\n\tfor (int i = 0; i < sentence.length();\
    \ i++) {\n\t\tif (sentence[i] == ' ')\n\t\t\tcount++;\n\t}\n\t// std::cout <<\
    \ count;\n\tint a = 0;\n\tfor (int i = 0; i < sentence.length(); i++) {\n\t\t\
    if (sentence[i] == ' ') {\n\t\t\tint c = i - a;\n\t\t\tarr[a] = c;\n\t\t\ta =\
    \ i + 1;\n\t\t}\n\t}\n\tint s = sentence.length() - a;\n\tarr[a] = s;\n\t// for\
    \ (int i = 0; i < count; i++) {\n\t// \tstd::cout << arr[i] << std::endl;\n\t\
    // }\n\t// std::cout << a;\n\t// std::cout << arr[a];\n\tstd::string result;\n\
    \tfor (int i = 0; i < sentence.length(); i++) {\n\t\tif (sentence[i] == ' ') {\n\
    \t\t\t// std::cout << \"test\" << std::endl;\n\t\t\tint a = i - 1;\n\t\t\tint\
    \ j = i + 1;\n\t\t\tif (is_prime(arr[a])) {\n\t\t\t\t// std::cout << \"test2\"\
    \ << std::endl;\n\t\t\t\twhile (sentence[j] != ' ') {\n\t\t\t\t\tresult += sentence[j];\n\
    \t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tresult += ' ';\n\t\t\t}\n\t\t}\n\t}\n\tif (is_prime(arr[a]))\
    \ {\n\t\t// std::cout << \"test3\" << std::endl;\n\t\tfor (int i = a; i < sentence.length();\
    \ i++) {\n\t\t\tresult += sentence[i];\n\t\t}\n\t}\n\treturn result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf0j4g1b1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpf0j4g1b1.cpp:47:8: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   47 |    if (is_prime(arr[a])) {\n      |        ^~~~~~~~\n/tmp/tmpf0j4g1b1.cpp:57:6:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   57 |  if (is_prime(arr[a]))\
    \ {\n      |      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098942
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    char s = ' ';\n   \
    \ std::string res = \"\";\n    std::vector<std::string> words;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (std::getline(ss, word, s))\
    \ {\n        words.push_back(word);\n    }\n    for (int i = 0; i < words.size();\
    \ i++) {\n        if (isPrime(words[i].length())) {\n            res += (words[i]\
    \ + \" \");\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptr71k1kt.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptr71k1kt.cpp:27:13: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   27 |         if (isPrime(words[i].length())) {\n      |     \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098942
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result =\
    \ \"\";\n  if (sentence.size() == 0) return result;\n  std::vector<std::string>\
    \ words;\n  std::istringstream iss(sentence);\n  for (std::string s; iss >> s;)\
    \ {\n    words.push_back(s);\n  }\n  for (size_t i = 0; i < words.size(); i++)\
    \ {\n    size_t temp_length = words[i].size();\n    if (temp_length < 2) continue;\n\
    \    if (temp_length == 2) {\n      result += words[i] + \" \";\n      continue;\n\
    \    }\n    bool is_prime = true;\n    for (size_t j = 2; j < temp_length; j++)\
    \ {\n      if (temp_length % j == 0) {\n        is_prime = false;\n        break;\n\
    \      }\n    }\n    if (is_prime) result += words[i] + \" \";\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpaa8n27pm: /tmp/tmpaa8n27pm.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string res;\n\
    \    std::stringstream s(sentence);\n    std::string word;\n    while (s >> word)\
    \ {\n        if (word.size() == 1 || word.size() == 2) {\n            res += word\
    \ + \" \";\n        } else {\n            bool isPrime = true;\n            for\
    \ (int i = 2; i <= word.size() / 2; i++) {\n                if (word.size() %\
    \ i == 0) {\n                    isPrime = false;\n                    break;\n\
    \                }\n            }\n            if (isPrime) {\n              \
    \  res += word + \" \";\n            }\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpon_vzh1v: /tmp/tmpon_vzh1v.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::istringstream\
    \ ss(sentence);\n    std::vector<std::string> tokens;\n    std::string temp;\n\
    \    while (ss >> temp)\n        tokens.push_back(temp);\n    std::string answer\
    \ = \"\";\n    for (auto& s : tokens) {\n        if (s.length() == 1 || s.length()\
    \ == 2) {\n            answer += s + \" \";\n        } else {\n            bool\
    \ isPrime = true;\n            for (int i = 2; i <= s.length() / 2; ++i) {\n \
    \               if (s.length() % i == 0) {\n                    isPrime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (isPrime) {\n                answer += s + \" \";\n            }\n        }\n\
    \    }\n    return answer;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3jt4necg: /tmp/tmp3jt4necg.cpp:44: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss;\n\
    \    ss << sentence;\n    std::string word;\n    std::vector<std::string> words;\n\
    \    while (ss >> word) {\n        words.push_back(word);\n    }\n    std::stringstream\
    \ ss2;\n    for (std::string w : words) {\n        if (w.size() > 1) {\n     \
    \       bool isPrime = true;\n            for (int i = 2; i <= w.size() / 2; ++i)\
    \ {\n                if (w.size() % i == 0) {\n                    isPrime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (isPrime) {\n                ss2 << w << \" \";\n            }\n        }\n\
    \    }\n    std::string res = ss2.str();\n    if (res.size() > 0) {\n        res.pop_back();\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098942
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::istringstream buf(sentence);\n    for(std::string word; buf\
    \ >> word; )\n        words.push_back(word);\n    std::vector<bool> is_prime_leng(101,\
    \ true);\n    is_prime_leng[0] = is_prime_leng[1] = false;\n    for(int i = 2;\
    \ i < 100; ++i)\n        if(is_prime_leng[i])\n            for(int j = i + i;\
    \ j < 100; j += i)\n                is_prime_leng[j] = false;\n    std::string\
    \ ans;\n    for(int i = 0; i < words.size(); ++i)\n        if(is_prime_leng[words[i].size()])\n\
    \            ans += words[i] + ' ';\n    return ans.substr(0, ans.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098943
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string s;\n    std::vector<std::string> v;\n    while(ss >> s)\n   \
    \     v.push_back(s);\n    std::string result;\n    std::cout << v.size() << std::endl;\n\
    \    for(int i = 0; i < v.size(); i++) {\n        if(isPrime(v[i].size())) {\n\
    \            result += v[i] + \" \";\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ud8u3a1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp8ud8u3a1.cpp:26:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   26 |         if(isPrime(v[i].size())) {\n      |            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098942
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string ret = \"\"\
    ;\n  for (int i = 0; i < sentence.length(); i++) {\n    if (sentence[i] == ' ')\
    \ {\n      continue;\n    }\n    int len = 0;\n    while (sentence[i] != ' ' &&\
    \ i < sentence.length()) {\n      len++;\n      i++;\n    }\n    if (len == 1\
    \ || len == 2 || len == 3 || len == 5 || len == 7 || len == 11 || len == 13 ||\
    \ len == 17 || len == 19 || len == 23 || len == 29 || len == 31 || len == 37 ||\
    \ len == 41 || len == 43 || len == 47 || len == 53 || len == 59 || len == 61 ||\
    \ len == 67 || len == 71 || len == 73 || len == 79 || len == 83 || len == 89 ||\
    \ len == 97) {\n      ret += std::to_string(len);\n      ret += \" \";\n    }\n\
    \  }\n  return ret;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp_q660dsy: /tmp/tmp_q660dsy.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool prime[100+1];\n\
    \    memset(prime, true, sizeof(prime));\n    for (int p=2; p*p<=100; p++)\n \
    \   {\n        if (prime[p] == true)\n        {\n            for (int i=p*2; i<=100;\
    \ i += p)\n                prime[i] = false;\n        }\n    }\n    int cnt =\
    \ 0;\n    std::stringstream ss(sentence);\n    std::string s;\n    std::string\
    \ ans;\n    while(ss >> s) {\n        if(prime[s.length()]) {\n            if(cnt)\
    \ {\n                ans += \" \";\n            }\n            ans += s;\n   \
    \         cnt++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpfz27q9pc: /tmp/tmpfz27q9pc.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string newSentence;\n\
    \  std::string word;\n  int count;\n  int i;\n  bool isPrime;\n  isPrime = false;\n\
    \  count = 0;\n  std::stringstream ss(sentence);\n  while (ss >> word) {\n   \
    \ count = 0;\n    for (i = 0; i < word.length(); i++) {\n      if (((int)word[i]\
    \ >= 97 && (int)word[i] <= 122) || ((int)word[i] >= 65 && (int)word[i] <= 90))\
    \ {\n        count++;\n      }\n    }\n    for (i = 2; i <= count / 2; i++) {\n\
    \      if (count % i == 0) {\n        isPrime = false;\n        break;\n     \
    \ }\n      isPrime = true;\n    }\n    if (isPrime == true) {\n      newSentence\
    \ += word + \" \";\n    }\n  }\n  if (newSentence.length() == 0) {\n    return\
    \ (\"\");\n  }\n  return (newSentence.substr(0, newSentence.length() - 1));\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp6mg35djl: /tmp/tmp6mg35djl.cpp:51: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string ans = \"\
    \";\n    bool has = false;\n    std::istringstream iss(sentence);\n    do {\n\
    \        std::string sub;\n        iss >> sub;\n        if (sub.size() == 1) {\n\
    \            has = true;\n            ans += sub + \" \";\n        } else if (sub.size()\
    \ == 2) {\n            has = true;\n            ans += sub + \" \";\n        }\
    \ else if (sub.size() == 3) {\n            if (sub[0] != '3' && sub[0] != '5'\
    \ && sub[0] != '7') {\n                has = true;\n                ans += sub\
    \ + \" \";\n            }\n        } else if (sub.size() == 5) {\n           \
    \ if (sub[0] != '5' && sub[0] != '7') {\n                has = true;\n       \
    \         ans += sub + \" \";\n            }\n        } else if (sub.size() ==\
    \ 7) {\n            if (sub[0] != '7') {\n                has = true;\n      \
    \          ans += sub + \" \";\n            }\n        }\n    } while (iss);\n\
    \    if (has) {\n        ans.pop_back();\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3wtu2mbi: /tmp/tmp3wtu2mbi.cpp:54: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result =\
    \ \"\";\n  std::string word = \"\";\n  for (auto ch : sentence) {\n    if (ch\
    \ == ' ') {\n      bool isPrime = true;\n      for (int i = 2; i <= sqrt(word.length());\
    \ i++) {\n        if (word.length() % i == 0) {\n          isPrime = false;\n\
    \          break;\n        }\n      }\n      if (isPrime && word.length() > 1)\
    \ {\n        result += word + \" \";\n      }\n      word = \"\";\n    } else\
    \ {\n      word += ch;\n    }\n  }\n  bool isPrime = true;\n  for (int i = 2;\
    \ i <= sqrt(word.length()); i++) {\n    if (word.length() % i == 0) {\n      isPrime\
    \ = false;\n      break;\n    }\n  }\n  if (isPrime && word.length() > 1) {\n\
    \    result += word;\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpk2e6fzlz: /tmp/tmpk2e6fzlz.cpp:51: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool is_prime[101];\n\
    \    memset(is_prime, true, sizeof(is_prime));\n    for (int i = 2; i * i <= 100;\
    \ i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= 100;\
    \ j += i)\n                is_prime[j] = false;\n        }\n    }\n    std::string\
    \ result = \"\";\n    std::string word = \"\";\n    for (char c : sentence) {\n\
    \        if (c == ' ') {\n            if (is_prime[word.length()]) {\n       \
    \         result += word + \" \";\n            }\n            word = \"\";\n \
    \       } else {\n            word += c;\n        }\n    }\n    if (is_prime[word.length()])\
    \ {\n        result += word;\n    }\n    if (result.length() == 0)\n        return\
    \ \"\";\n    if (result[result.length() - 1] == ' ')\n        result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpklc9yvjm: /tmp/tmpklc9yvjm.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream inputStream(sentence);\n\
    \    std::string current;\n    std::string output;\n    while (inputStream >>\
    \ current) {\n        int count = 0;\n        for (int i = 1; i <= current.length();\
    \ i++) {\n            if (current.length() % i == 0) {\n                count++;\n\
    \            }\n        }\n        if (count == 2) {\n            output += current\
    \ + \" \";\n        }\n    }\n    return output;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmphceytmf1: /tmp/tmphceytmf1.cpp:36: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098944
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words;\n  std::string currentWord;\n  for (int i = 0; i < sentence.length();\
    \ i++) {\n    if (sentence[i] == ' ') {\n      words.push_back(currentWord);\n\
    \      currentWord = \"\";\n    } else {\n      currentWord += sentence[i];\n\
    \    }\n  }\n  words.push_back(currentWord);\n  std::string result = \"\";\n \
    \ for (int i = 0; i < words.size(); i++) {\n    if (words[i].length() == 1) {\n\
    \      result += words[i] + \" \";\n    } else if (words[i].length() > 1) {\n\
    \      bool isPrime = true;\n      for (int j = 2; j < words[i].length(); j++)\
    \ {\n        if (words[i].length() % j == 0) {\n          isPrime = false;\n \
    \         break;\n        }\n      }\n      if (isPrime) {\n        result +=\
    \ words[i] + \" \";\n      }\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpdfbm9sis: /tmp/tmpdfbm9sis.cpp:50: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words;\n  std::string word;\n  for (auto ch : sentence) {\n    if (ch == ' ')\
    \ {\n      words.push_back(word);\n      word = \"\";\n    } else {\n      word\
    \ += ch;\n    }\n  }\n  words.push_back(word);\n  std::string res;\n  for (auto\
    \ word : words) {\n    int len = word.size();\n    bool isPrime = true;\n    for\
    \ (int i = 2; i < len; i++) {\n      if (len % i == 0) {\n        isPrime = false;\n\
    \        break;\n      }\n    }\n    if (isPrime) {\n      res += word + \" \"\
    ;\n    }\n  }\n  res.pop_back();\n  return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpyi6twexx: /tmp/tmpyi6twexx.cpp:48: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::istringstream\
    \ iss(sentence);\n    std::vector<std::string> vec{std::istream_iterator<std::string>{iss},\
    \ std::istream_iterator<std::string>{}};\n    std::string ans;\n    bool prime;\n\
    \    for (auto i : vec) {\n        if (i.size() == 1) continue;\n        prime\
    \ = true;\n        for (int j = 2; j <= i.size() / 2; j++) {\n            if (i.size()\
    \ % j == 0) {\n                prime = false;\n                break;\n      \
    \      }\n        }\n        if (prime) ans += (i + \" \");\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpey81xxiy: /tmp/tmpey81xxiy.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\t// your code here\n\t\
    // you need to return the string that contains the words separated by a space\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::vector<std::string>\
    \ v;\n\tstd::stringstream ss(sentence);\n\tstd::string word;\n\twhile (std::getline(ss,\
    \ word, ' ')) {\n\t\tv.push_back(word);\n\t}\n\tstd::string res = \"\";\n\tfor\
    \ (int i = 0; i < v.size(); i++) {\n\t\tint n = v[i].size();\n\t\tint flag = 0;\n\
    \t\tfor (int j = 2; j < n / 2; j++) {\n\t\t\tif (n % j == 0) {\n\t\t\t\tflag =\
    \ 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0) {\n\t\t\tres += v[i]\
    \ + \" \";\n\t\t}\n\t}\n\tres.pop_back();\n\treturn res;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4c8poip1: /tmp/tmp4c8poip1.cpp:43: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string new_sentence\
    \ = \"\";\n  std::istringstream iss(sentence);\n  std::string word;\n  while (iss\
    \ >> word) {\n    int len = word.length();\n    if (std::all_of(word.begin(),\
    \ word.end(), ::isdigit)) {\n      break;\n    }\n    if (len == 1 || len == 2)\
    \ {\n      if (len == 2) {\n        if (word[0] == '1' || word[0] == '3' || word[0]\
    \ == '5' || word[0] == '7') {\n          new_sentence += word + \" \";\n     \
    \   }\n      } else {\n        new_sentence += word + \" \";\n      }\n    } else\
    \ {\n      int flag = 0;\n      for (int i = 2; i <= len / 2; ++i) {\n       \
    \ if (len % i == 0) {\n          flag = 1;\n          break;\n        }\n    \
    \  }\n      if (flag == 0) {\n        new_sentence += word + \" \";\n      }\n\
    \    }\n  }\n  return new_sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp6vzcrhll: /tmp/tmp6vzcrhll.cpp:51: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code goes here\n\
    \  std::string ans = \"\";\n  std::stringstream s(sentence);\n  std::string word;\n\
    \  while(s >> word) {\n    if(isPrime(word.length())) {\n      ans += word + \"\
    \ \";\n    }\n  }\n  ans.pop_back();\n  return ans;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpod6cvk6e.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpod6cvk6e.cpp:23:8: error: \u2018isPrime\u2019 was not declared in this\
    \ scope\n   23 |     if(isPrime(word.length())) {\n      |        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098942
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::vector<std::string> words;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    bool is_prime;\n    std::string\
    \ result = \"\";\n    for (int i = 0; i < words.size(); i++) {\n        is_prime\
    \ = true;\n        for (int j = 2; j < words[i].length(); j++) {\n           \
    \ if (words[i].length() % j == 0) {\n                is_prime = false;\n     \
    \           break;\n            }\n        }\n        if (is_prime) {\n      \
    \      result = result + words[i] + \" \";\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp_ceewt7v: /tmp/tmp_ceewt7v.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result;\n\
    \  std::vector<std::string> words;\n  std::string word;\n  for (int i = 0; i <\
    \ sentence.size(); i++) {\n    if (sentence[i] == ' ') {\n      words.push_back(word);\n\
    \      word = \"\";\n    } else {\n      word += sentence[i];\n    }\n  }\n  words.push_back(word);\n\
    \  for (int i = 0; i < words.size(); i++) {\n    if (words[i].size() == 1 || words[i].size()\
    \ == 2) {\n      continue;\n    }\n    bool check = true;\n    for (int j = 2;\
    \ j <= words[i].size() / 2; j++) {\n      if (words[i].size() % j == 0) {\n  \
    \      check = false;\n        break;\n      }\n    }\n    if (check) {\n    \
    \  result += words[i] + \" \";\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpr961g0ke: /tmp/tmpr961g0ke.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n   std::string result =\
    \ \"\";\n    for (int i = 0; i < sentence.length(); i++) {\n        int counter\
    \ = 0;\n        std::string word = \"\";\n        while (sentence[i] != ' ' &&\
    \ i < sentence.length()) {\n            word += sentence[i];\n            i++;\n\
    \        }\n        for (int j = 1; j <= word.length(); j++) {\n            if\
    \ (word.length() % j == 0) {\n                counter++;\n            }\n    \
    \    }\n        if (counter == 2) {\n            result += word + \" \";\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpc9sazvk6: /tmp/tmpc9sazvk6.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098943
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words;\n  std::string word;\n  std::stringstream ss(sentence);\n  while (ss\
    \ >> word) {\n    words.push_back(word);\n  }\n  std::vector<std::string> prime_words;\n\
    \  for (auto word : words) {\n    if (word.length() == 2) {\n      prime_words.push_back(word);\n\
    \    } else if (word.length() == 3) {\n      prime_words.push_back(word);\n  \
    \  } else if (word.length() == 5) {\n      prime_words.push_back(word);\n    }\
    \ else if (word.length() == 7) {\n      prime_words.push_back(word);\n    } else\
    \ if (word.length() == 11) {\n      prime_words.push_back(word);\n    } else if\
    \ (word.length() == 13) {\n      prime_words.push_back(word);\n    } else if (word.length()\
    \ == 17) {\n      prime_words.push_back(word);\n    } else if (word.length() ==\
    \ 19) {\n      prime_words.push_back(word);\n    } else if (word.length() == 23)\
    \ {\n      prime_words.push_back(word);\n    } else if (word.length() == 29) {\n\
    \      prime_words.push_back(word);\n    } else if (word.length() == 31) {\n \
    \     prime_words.push_back(word);\n    } else if (word.length() == 37) {\n  \
    \    prime_words.push_back(word);\n    } else if (word.length() == 41) {\n   \
    \   prime_words.push_back(word);\n    } else if (word.length() == 43) {\n    \
    \  prime_words.push_back(word);\n    } else if (word.length() == 47) {\n     \
    \ prime_words.push_back(word);\n    } else if (word.length() == 53) {\n      prime_words.push_back(word);\n\
    \    } else if (word.length() == 59) {\n      prime_words.push_\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_7geoad8.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_7geoad8.cpp:59:19: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018push_\u2019\n   59 |       prime_words.push_\n\
    \      |                   ^~~~~\n/tmp/tmp_7geoad8.cpp:61:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   61 | int main() {\n     \
    \ |            ^\n/tmp/tmp_7geoad8.cpp:70:1: error: expected \u2018}\u2019 at\
    \ end of input\n   70 | }\n      | ^\n/tmp/tmp_7geoad8.cpp:25:27: note: to match\
    \ this \u2018{\u2019\n   25 |   for (auto word : words) {\n      |           \
    \                ^\n/tmp/tmp_7geoad8.cpp:70:1: error: expected \u2018}\u2019 at\
    \ end of input\n   70 | }\n      | ^\n/tmp/tmp_7geoad8.cpp:17:53: note: to match\
    \ this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string sentence)\
    \ {\n      |                                                     ^\n/tmp/tmp_7geoad8.cpp:70:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   70 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::string result;\n\
    \tint length = sentence.length();\n\tif (length == 0)\n\t\treturn result;\n\t\
    for (int i = 0; i < length; i++) {\n\t\tstd::string word;\n\t\twhile (sentence[i]\
    \ != ' ' && i < length) {\n\t\t\tword += sentence[i];\n\t\t\ti++;\n\t\t}\n\t\t\
    int word_length = word.length();\n\t\tif (word_length == 0)\n\t\t\tcontinue;\n\
    \t\tif (word_length == 1) {\n\t\t\tresult += word;\n\t\t\tresult += ' ';\n\t\t\
    \tcontinue;\n\t\t}\n\t\tfor (int j = 2; j < word_length; j++) {\n\t\t\tif (word_length\
    \ % j == 0)\n\t\t\t\tbreak;\n\t\t\tif (j == word_length - 1) {\n\t\t\t\tresult\
    \ += word;\n\t\t\t\tresult += ' ';\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3fnc07u6: /tmp/tmp3fnc07u6.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098944
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::vector<std::string> words;\n    std::stringstream check1(sentence);\n\
    \    std::string intermediate;\n    while(getline(check1, intermediate, ' '))\
    \ {\n        words.push_back(intermediate);\n    }\n    for (int i = 0; i < words.size();\
    \ i++) {\n        bool f = true;\n        if (words[i].length() == 1) {\n    \
    \        f = false;\n        }\n        for (int j = 2; j <= sqrt(words[i].length());\
    \ j++) {\n            if (words[i].length() % j == 0) {\n                f = false;\n\
    \                break;\n            }\n        }\n        if (f) {\n        \
    \    result += words[i] + \" \";\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpklyg3_3d: /tmp/tmpklyg3_3d.cpp:44: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098944
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // Your code here\n\
    \    // return \"\";\n    std::string s = \"\";\n    int i, j, count;\n    std::string\
    \ array[] = { };\n    // std::stringstream sstr(sentence);\n    // for (std::string\
    \ s; sstr >> s;) {\n    //     std::cout << s << std::endl;\n    // }\n    std::istringstream\
    \ iss(sentence);\n    for (std::string s; iss >> s;) {\n        // std::cout <<\
    \ s << std::endl;\n        array[i] = s;\n        i++;\n    }\n    for (i = 0;\
    \ i < sizeof(array); i++) {\n        count = 0;\n        for (j = 2; j <= array[i].length()\
    \ / 2; j++) {\n            if (array[i].length() % j == 0) {\n               \
    \ count++;\n                break;\n            }\n        }\n        if (count\
    \ == 0 && array[i].length() != 1) {\n            s += array[i];\n            s\
    \ += \" \";\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660098944
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    for (auto it = sentence.begin(); it != sentence.end();) {\n    \
    \    auto begin = it;\n        while (it != sentence.end() && *it != ' ') ++it;\n\
    \        auto end = it;\n        words.push_back(std::string(begin, end));\n \
    \       if (it != sentence.end()) ++it;\n    }\n    std::string ans;\n    for\
    \ (auto&& s : words) {\n        int len = static_cast<int>(s.size());\n      \
    \  bool flag = true;\n        for (int i = 2; i * i <= len; ++i)\n           \
    \ if (len % i == 0) {\n                flag = false;\n                break;\n\
    \            }\n        if (flag) ans += s + ' ';\n    }\n    ans.pop_back();\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpwgv72kfw: /tmp/tmpwgv72kfw.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098944
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // your code here\n\
    \    bool isPrime = true;\n    stringstream ss(sentence);\n    string word;\n\
    \    string solution;\n    while(getline(ss, word, ' ')){\n        isPrime = true;\n\
    \        if(word.length()==1){\n            isPrime = true;\n        }else{\n\
    \            for(int i = 2; i<word.length(); i++){\n                if(word.length()%i==0){\n\
    \                    isPrime = false;\n                    break;\n          \
    \      }\n            }\n        }\n        if(isPrime){\n            solution.append(word);\n\
    \            solution.append(\" \");\n        }\n    }\n    return solution;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0onknxnk.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp0onknxnk.cpp:20:5: error: \u2018stringstream\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stringstream\u2019?\n   20 |     stringstream\
    \ ss(sentence);\n      |     ^~~~~~~~~~~~\n      |     std::stringstream\nIn file\
    \ included from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0onknxnk.cpp:2:\n/usr/include/c++/9/iosfwd:156:37: note: \u2018std::stringstream\u2019\
    \ declared here\n  156 |   typedef basic_stringstream<char>  stringstream;\n \
    \     |                                     ^~~~~~~~~~~~\n/tmp/tmp0onknxnk.cpp:21:5:\
    \ error: \u2018string\u2019 was not declared in this scope\n   21 |     string\
    \ word;\n      |     ^~~~~~\n/tmp/tmp0onknxnk.cpp:21:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0onknxnk.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n "
  stdout: ''
  timestamp: 1660098943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ s;\n  std::string res;\n  std::stringstream ss(sentence);\n  for (std::string\
    \ i; ss >> i;) {\n    s.push_back(i);\n  }\n  for (auto k : s) {\n    int count\
    \ = 0;\n    for (int i = 2; i <= sqrt(k.length()); i++) {\n      if (k.length()\
    \ % i == 0) {\n        count++;\n        break;\n      }\n    }\n    if (count\
    \ == 0 && k.length() != 1) {\n      res += k + \" \";\n    }\n  }\n  return res;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpdsgvmg8q: /tmp/tmpdsgvmg8q.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098944
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // Write your code here\n\
    \  std::vector<std::string> vec;\n  std::string result;\n  std::stringstream ss(sentence);\n\
    \  std::string token;\n  while(getline(ss, token, ' ')) {\n    vec.push_back(token);\n\
    \  }\n  for(int i = 0; i < vec.size(); i++) {\n    int counter = 0;\n    for(int\
    \ j = 1; j <= vec[i].size(); j++) {\n      if(vec[i].size() % j == 0) {\n    \
    \    counter++;\n      }\n    }\n    if(counter == 2) {\n      result += vec[i]\
    \ + \" \";\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3l1_usyp: /tmp/tmp3l1_usyp.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098944
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string s = \"\"\
    ;\n    for (int i = 0; i < sentence.length(); i++) {\n        std::string temp\
    \ = \"\";\n        for (int j = i; j < sentence.length(); j++) {\n           \
    \ if (sentence[j] == ' ') {\n                break;\n            }\n         \
    \   temp += sentence[j];\n        }\n        if (temp.length() > 1) {\n      \
    \      if (temp.length() == 2) {\n                s += temp + \" \";\n       \
    \     } else {\n                bool flag = true;\n                for (int k\
    \ = 2; k <= sqrt(temp.length()); k++) {\n                    if (temp.length()\
    \ % k == 0) {\n                        flag = false;\n                       \
    \ break;\n                    }\n                }\n                if (flag)\
    \ {\n                    s += temp + \" \";\n                }\n            }\n\
    \        }\n        i += temp.length();\n    }\n    return s;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmplxlieya4: /tmp/tmplxlieya4.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098944
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string ans;\n  std::istringstream\
    \ iss(sentence);\n  do {\n    std::string word;\n    iss >> word;\n    std::ostringstream\
    \ ss;\n    ss << word;\n    if (word.length() != 1 && !word.empty()) {\n     \
    \ int num = std::stoi(ss.str());\n      if (is_prime(num)) {\n        ans.append(word\
    \ + \" \");\n      }\n    }\n  } while (iss);\n  return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpysh3yvr9.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpysh3yvr9.cpp:27:11: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   27 |       if (is_prime(num)) {\n      |           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098944
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  int len = sentence.length();\n\
    \  if (len < 2) return sentence;\n  int arr[len];\n  int i = 0;\n  int j = 0;\n\
    \  for (i = 0; i < len; i++) {\n    if (sentence[i] == ' ') {\n      arr[j] =\
    \ i - 1;\n      j++;\n    }\n  }\n  arr[j] = len - 1;\n  j++;\n  i = 0;\n  std::string\
    \ result = \"\";\n  while (i < j) {\n    int k = arr[i];\n    int c = 0;\n   \
    \ while (k >= 0) {\n      if (k == 0) break;\n      if (k % 2 == 0 || k % 3 ==\
    \ 0 || k % 5 == 0 || k % 7 == 0) break;\n      k--;\n      c++;\n    }\n    if\
    \ (c == arr[i] + 1) {\n      int x = 0;\n      while (x <= arr[i]) {\n       \
    \ result += sentence[x];\n        x++;\n      }\n      result += \" \";\n    }\n\
    \    i++;\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3pttqmxb: /tmp/tmp3pttqmxb.cpp:56: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // your code goes here\n\
    \    std::stringstream ss(sentence);\n    std::string result;\n    std::string\
    \ temp;\n    while(ss >> temp){\n        if(is_prime(temp.length()))\n       \
    \     result.append(temp + \" \");\n    }\n    result.pop_back();\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4mjaz8ln.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4mjaz8ln.cpp:23:12: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if(is_prime(temp.length()))\n      |           \
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098944
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::string output;\n\
    \tstd::string word = \"\";\n\t// for(int i = 0; i < sentence.length(); i++) {\n\
    \t// \tif(sentence[i] == ' ') {\n\t// \t\tif(isPrime(word.length()))\n\t// \t\t\
    \toutput += word + \" \";\n\t// \t\tword = \"\";\n\t// \t}\n\t// \telse\n\t//\
    \ \t\tword += sentence[i];\n\t// }\n\t// if(isPrime(word.length()))\n\t// \toutput\
    \ += word;\n\t// if(output.length() > 0)\n\t// \toutput.pop_back();\n\tstd::istringstream\
    \ iss(sentence);\n\tdo {\n\t\tiss >> word;\n\t\tif(isPrime(word.length()))\n\t\
    \t\toutput += word + \" \";\n\t} while(iss);\n\tif(output.length() > 0)\n\t\t\
    output.pop_back();\n\treturn output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdoslrqu7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdoslrqu7.cpp:36:6: error: \u2018isPrime\u2019 was not declared in this\
    \ scope\n   36 |   if(isPrime(word.length()))\n      |      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098944
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ v;\n    std::string temp = \"\";\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            v.push_back(temp);\n \
    \           temp = \"\";\n        } else {\n            temp += sentence[i];\n\
    \        }\n    }\n    v.push_back(temp);\n    int cnt = 0;\n    for(int i = 0;\
    \ i < v.size(); i++) {\n        int rt = sqrt(v[i].length());\n        if(rt *\
    \ rt == v[i].length()) {\n            cnt++;\n        }\n    }\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < v.size(); i++) {\n        int rt = sqrt(v[i].length());\n\
    \        if(rt * rt == v[i].length()) {\n            ans += v[i];\n          \
    \  if(cnt > 1) {\n                ans += \" \";\n            }\n            cnt--;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpfqww3kg9: /tmp/tmpfqww3kg9.cpp:51: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // std::cout << sentence\
    \ << std::endl;\n  std::istringstream iss(sentence);\n  std::vector<std::string>\
    \ words{std::istream_iterator<std::string>{iss},\n                           \
    \      std::istream_iterator<std::string>{}};\n  std::vector<std::string> result;\n\
    \  for (auto &word : words) {\n    // std::cout << word << std::endl;\n    if\
    \ (word.size() == 1 || word.size() == 2) {\n      result.push_back(word);\n  \
    \    continue;\n    }\n    bool isPrime = true;\n    for (int i = 2; i < word.size();\
    \ i++) {\n      if (word.size() % i == 0) {\n        isPrime = false;\n      \
    \  break;\n      }\n    }\n    if (isPrime) {\n      result.push_back(word);\n\
    \    }\n  }\n  // for (auto &word : result) {\n  //   std::cout << word << std::endl;\n\
    \  // }\n  return std::accumulate(std::begin(result), std::end(result), std::string(\"\
    \"),\n                         [](std::string a, std::string b) {\n          \
    \                 return a + \" \" + b;\n                         });\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpptjvhfkr: /tmp/tmpptjvhfkr.cpp:50: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string new_sentence = \"\";\n    bool is_prime;\n\
    \    while (ss >> word) {\n        is_prime = true;\n        for (int i = 2; i\
    \ <= word.length() / 2; i++) {\n            if (word.length() % i == 0) {\n  \
    \              is_prime = false;\n                break;\n            }\n    \
    \    }\n        if (is_prime) {\n            new_sentence += (word + \" \");\n\
    \        }\n    }\n    return new_sentence;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpyd7r4cu7: /tmp/tmpyd7r4cu7.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream iss(sentence);\n\
    \    std::vector<std::string> words;\n    std::string word;\n    while (iss >>\
    \ word)\n        words.push_back(word);\n    std::vector<std::string> res;\n \
    \   for (std::string s : words) {\n        std::set<int> divisors = {2, 3, 5,\
    \ 7};\n        for (int i : divisors) {\n            if (s.size() % i == 0) {\n\
    \                res.push_back(s);\n                break;\n            }\n  \
    \      }\n    }\n    std::string result;\n    for (std::string s : res)\n    \
    \    result += s + \" \";\n    return result.substr(0, result.size() - 1);\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmphyksm98l: /tmp/tmphyksm98l.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words;\n  std::string delimiter = \" \";\n  size_t pos = 0;\n  std::string token;\n\
    \  while ((pos = sentence.find(delimiter)) != std::string::npos) {\n    token\
    \ = sentence.substr(0, pos);\n    words.push_back(token);\n    sentence.erase(0,\
    \ pos + delimiter.length());\n  }\n  words.push_back(sentence);\n  std::vector<std::string>\
    \ prime_length_words;\n  for (auto w : words) {\n    if (w.length() == 2 || w.length()\
    \ == 3 || w.length() == 5 ||\n        w.length() == 7) {\n      prime_length_words.push_back(w);\n\
    \    }\n  }\n  std::string result;\n  for (auto w : prime_length_words) {\n  \
    \  result += w + \" \";\n  }\n  result.pop_back();\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpujg3uthe: /tmp/tmpujg3uthe.cpp:49: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    std::string word;\n    for (int i = 0; i < sentence.length(); i++) {\n  \
    \      if (sentence[i] == ' ') {\n            result += word + ' ';\n        \
    \    word = \"\";\n        } else {\n            word += sentence[i];\n      \
    \  }\n    }\n    result += word;\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpbuuunvx4: /tmp/tmpbuuunvx4.cpp:33: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result =\
    \ \"\";\n  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >>\
    \ word) {\n    if (is_prime(word.length()))\n      result += word + \" \";\n \
    \ }\n  if (result.length() > 0)\n    result.pop_back();\n  return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeh_p19bm.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpeh_p19bm.cpp:22:9: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |     if (is_prime(word.length()))\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string res = \"\
    \";\n    int flag = 0;\n    for(int i = 0; i < sentence.length(); i++) {\n   \
    \     if(sentence[i] == ' ') {\n            if(flag == 1) {\n                res.push_back('\
    \ ');\n            }\n            flag = 0;\n        }\n        else {\n     \
    \       if(flag == 0) {\n                bool prime = true;\n                for(int\
    \ j = 2; j * j <= sentence[i]; j++) {\n                    if(sentence[i] % j\
    \ == 0) {\n                        prime = false;\n                        break;\n\
    \                    }\n                }\n                if(prime) {\n     \
    \               flag = 1;\n                }\n            }\n            if(flag\
    \ == 1) {\n                res.push_back(sentence[i]);\n            }\n      \
    \  }\n    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp6vcxngy_: /tmp/tmp6vcxngy_.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string word = \"\";\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            words.push_back(word);\n\
    \            word = \"\";\n        } else {\n            word = word + sentence[i];\n\
    \        }\n    }\n    words.push_back(word);\n    std::string ans = \"\";\n \
    \   bool prime = true;\n    for (int i = 0; i < words.size(); i++) {\n       \
    \ for (int j = 2; j < words[i].length(); j++) {\n            if (words[i].length()\
    \ % j == 0) {\n                prime = false;\n                break;\n      \
    \      }\n        }\n        if (prime) {\n            ans = ans + words[i] +\
    \ \" \";\n        }\n        prime = true;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpnt4j9j4c: /tmp/tmpnt4j9j4c.cpp:47: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098945
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    int st = 0;\n    string\
    \ ret = \"\";\n    for(int i = 0; i < sentence.size(); i++){\n        if(sentence[i]\
    \ == ' '){\n            int l = i - st;\n            bool flag = true;\n     \
    \       for(int i = 2; i < l; i++){\n                if(l % i == 0){\n       \
    \             flag = false;\n                    break;\n                }\n \
    \           }\n            if(flag) ret = ret + sentence.substr(st, l) + \" \"\
    ;\n            st = i + 1;\n        }\n    }\n    int l = sentence.size() - st;\n\
    \    bool flag = true;\n    for(int i = 2; i < l; i++){\n        if(l % i == 0){\n\
    \            flag = false;\n            break;\n        }\n    }\n    if(flag)\
    \ ret = ret + sentence.substr(st, l) + \" \";\n    return ret.substr(0, ret.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2zimm7ff.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp2zimm7ff.cpp:19:5: error: \u2018string\u2019 was not declared in this\
    \ scope\n   19 |     string ret = \"\";\n      |     ^~~~~~\n/tmp/tmp2zimm7ff.cpp:19:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp2zimm7ff.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp2zimm7ff.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmp2zimm7ff.cpp:30:22: error: \u2018ret\u2019 was not declared in this scope\n\
    \   30 |             if(flag) ret = ret + sentence.substr(st, l) + \" \";\n  \
    \    |                      ^~~\n/tmp/tmp2zimm7ff.cpp:42:14: error: \u2018ret\u2019\
    \ was not declared in this scope\n   42 |     if(flag) ret = ret + sentence.substr(st,\
    \ l) + \" \";\n      |              ^~~\n/tmp/tmp2zimm7ff.cpp:43:12: error: \u2018\
    ret\u2019 was not declared in this scope\n   43 |     return ret.substr(0, ret.size()\
    \ - 1);\n      |            ^~~\n"
  stdout: ''
  timestamp: 1660098945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code here\n \
    \ int sz = sentence.size();\n  std::vector<bool> primes(sz+1, true);\n  primes[0]\
    \ = primes[1] = false;\n  for(int i = 2; i <= sz; i++) {\n    if(primes[i]) {\n\
    \      for(int j = i*i; j <= sz; j += i) {\n        primes[j] = false;\n     \
    \ }\n    }\n  }\n  std::stringstream ss(sentence);\n  std::string word;\n  std::string\
    \ res;\n  while(std::getline(ss, word, ' ')) {\n    if(primes[word.size()]) {\n\
    \      res += word + \" \";\n    }\n  }\n  return res.substr(0, res.size()-1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string buff;\n    std::stringstream input(sentence);\n    while\
    \ (input >> buff) {\n        words.push_back(buff);\n    }\n    auto is_prime\
    \ = [](int number) {\n        if (number < 2) return false;\n        if (number\
    \ % 2 == 0) return (number == 2);\n        for (int i = 3; (i * i) <= number;\
    \ i += 2) {\n            if (number % i == 0) return false;\n        }\n     \
    \   return true;\n    };\n    std::string output = \"\";\n    for (auto word :\
    \ words) {\n        if (is_prime(word.length())) {\n            output += word\
    \ + \" \";\n        }\n    }\n    return output.substr(0, output.length() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n   std::stringstream ss(sentence);\n\
    \   std::string word;\n   std::string output;\n   // the vector primes is a modified\
    \ version of vector<bool>\n   // it's used to keep track of all the primes up\
    \ to 100,\n   // with the index of the vector representing the number,\n   //\
    \ an element at index i = 1 if that number is prime,\n   // else if i = 0, the\
    \ number is not prime.\n   std::vector<bool> primes(100, true);\n   // we set\
    \ all numbers to prime, then set any non-prime numbers to 0.\n   primes[0] = primes[1]\
    \ = false;\n   for (int i = 2; i < 100; i++) {\n      if (primes[i]) {\n     \
    \    for (int j = i * i; j < 100; j += i) {\n            primes[j] = false;\n\
    \         }\n      }\n   }\n   // if the length of the word is prime,\n   // it's\
    \ added to the output string.\n   while (ss >> word) {\n      if (primes[word.length()])\
    \ {\n         output += word + \" \";\n      }\n   }\n   // the last space in\
    \ the string is removed and the string is returned.\n   output.pop_back();\n \
    \  return output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpc9w8y_rw: /tmp/tmpc9w8y_rw.cpp:54: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    int n = sentence.length();\n\
    \    std::string res;\n    int i = 0;\n    while(i < n) {\n        int len = 0;\n\
    \        while(i < n && sentence[i] != ' ') {\n            len++;\n          \
    \  i++;\n        }\n        if(isPrime(len)) {\n            int start = i - len;\n\
    \            for(int j = start; j < i; j++) {\n                res.push_back(sentence[j]);\n\
    \            }\n            res.push_back(' ');\n        }\n        i++;\n   \
    \ }\n    res.pop_back();\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pnz8_ji.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp6pnz8_ji.cpp:27:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   27 |         if(isPrime(len)) {\n      |            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098945
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    auto &s = sentence;\n\
    \    auto is_prime = [](int n) {\n        if (n < 2) {\n            return false;\n\
    \        }\n        if (n == 2) {\n            return true;\n        }\n     \
    \   if (n % 2 == 0) {\n            return false;\n        }\n        for (int\
    \ i = 3; i <= std::sqrt(n); i += 2) {\n            if (n % i == 0) {\n       \
    \         return false;\n            }\n        }\n        return true;\n    };\n\
    \    std::string result;\n    size_t i = 0;\n    while (i < s.size()) {\n    \
    \    size_t j = i;\n        for (; j < s.size() && s[j] != ' '; ++j) {\n     \
    \   }\n        if (is_prime(j - i)) {\n            result += s.substr(i, j - i);\n\
    \            result += ' ';\n        }\n        i = j + 1;\n    }\n    if (!result.empty())\
    \ {\n        result.pop_back();\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098945
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string res;\n\
    \    std::string temp;\n    for(size_t i = 0; i < sentence.size(); i++) {\n  \
    \      if(sentence[i] == ' ') {\n            if(is_prime(temp.size())) {\n   \
    \             res += temp + \" \";\n            }\n            temp.clear();\n\
    \        } else {\n            temp += sentence[i];\n        }\n    }\n    if(is_prime(temp.size()))\
    \ {\n        res += temp;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph7ylb589.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmph7ylb589.cpp:22:16: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |             if(is_prime(temp.size())) {\n      |       \
    \         ^~~~~~~~\n/tmp/tmph7ylb589.cpp:30:8: error: \u2018is_prime\u2019 was\
    \ not declared in this scope\n   30 |     if(is_prime(temp.size())) {\n      |\
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ my_vector;\n  std::istringstream iss(sentence);\n  std::string word;\n  // \uC54C\
    \uD30C\uBCB3\uC778\uC9C0 \uD655\uC778\uD558\uB294 \uD568\uC218\n  auto is_alpha\
    \ = [](std::string word) -> bool {\n    for (char c : word) {\n      if (!std::isalpha(c))\
    \ {\n        return false;\n      }\n    }\n    return true;\n  };\n  // \uC18C\
    \uC218\uC778\uC9C0 \uD655\uC778\uD558\uB294 \uD568\uC218\n  auto is_prime = [](int\
    \ n) -> bool {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n\
    \    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <=\
    \ n; i += 6) {\n      if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n\
    \    return true;\n  };\n  while (iss >> word) {\n    // \uC54C\uD30C\uBCB3\uC774\
    \ \uC544\uB2C8\uBA74 \uB2E4\uC74C \uB2E8\uC5B4\uB85C \uB118\uC5B4\uAC10\n    if\
    \ (!is_alpha(word)) continue;\n    // \uC18C\uC218\uAC00 \uC544\uB2C8\uBA74 \uB2E4\
    \uC74C \uB2E8\uC5B4\uB85C \uB118\uC5B4\uAC10\n    if (!is_prime(word.size()))\
    \ continue;\n    my_vector.push_back(word);\n  }\n  // \uBC30\uC5F4\uC744 \uBB38\
    \uC790\uC5F4\uB85C \uBCC0\uD658\n  std::string result = \"\";\n  for (auto &s\
    \ : my_vector) {\n    result += (s + \" \");\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp180c014a: /tmp/tmp180c014a.cpp:56: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<int> primes\
    \ = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97 };\n    std::vector<std::string> words;\n    std::string\
    \ temp = \"\";\n    std::string result = \"\";\n    bool include = false;\n  \
    \  for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] == '\
    \ ') {\n            words.push_back(temp);\n            temp = \"\";\n       \
    \ }\n        else {\n            temp += sentence[i];\n        }\n    }\n    words.push_back(temp);\n\
    \    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < primes.size();\
    \ j++) {\n            if (words[i].length() == primes[j]) {\n                include\
    \ = true;\n                break;\n            }\n        }\n        if (include)\
    \ {\n            result += words[i] + \" \";\n        }\n        include = false;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp0p0182zk: /tmp/tmp0p0182zk.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words = {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\",\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps2z7_073.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmps2z7_073.cpp:20:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018int\u2019\n   20 | int main() {\n      | ^~~\n/tmp/tmps2z7_073.cpp:29:1:\
    \ error: expected \u2018}\u2019 at end of input\n   29 | }\n      | ^\n/tmp/tmps2z7_073.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmps2z7_073.cpp:29:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   29 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // your code here\n\
    \    std::string result = \"\";\n    bool prime = true;\n    std::string temp\
    \ = \"\";\n    bool first = true;\n    for(int i = 0; i < sentence.length(); i++){\n\
    \        if(sentence[i] == ' '){\n            if(temp.length() != 0){\n      \
    \          if(temp.length() == 1){\n                    prime = true;\n      \
    \          }\n                else{\n                    for(int j = 2; j < temp.length();\
    \ j++){\n                        if(temp.length() % j == 0){\n               \
    \             prime = false;\n                            break;\n           \
    \             }\n                    }\n                }\n                if(prime){\n\
    \                    if(first){\n                        result += temp;\n   \
    \                     first = false;\n                    }\n                \
    \    else{\n                        result += ' ';\n                        result\
    \ += temp;\n                    }\n                }\n                temp = \"\
    \";\n            }\n        }\n        else{\n            temp += sentence[i];\n\
    \        }\n    }\n    if(temp.length() != 0){\n        if(temp.length() == 1){\n\
    \            prime = true;\n        }\n        else{\n            for(int j =\
    \ 2; j < temp.length(); j++){\n                if(temp.length() % j == 0){\n \
    \                   prime = false;\n                    break;\n             \
    \   }\n            }\n        }\n        if(prime){\n            if(first){\n\
    \                result += temp;\n                first = false;\n           \
    \ }\n            else{\n                result += ' ';\n                result\
    \ += temp;\n            }\n        }\n        temp = \"\";\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp2p06sd7t: /tmp/tmp2p06sd7t.cpp:82: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool prime;\n    std::stringstream\
    \ ss;\n    ss << sentence;\n    std::string word;\n    std::string new_str = \"\
    \";\n    while (ss >> word) {\n        prime = true;\n        if (word.length()\
    \ > 1) {\n            for (int i = 2; i < word.length(); i++) {\n            \
    \    if (word.length() % i == 0) {\n                    prime = false;\n     \
    \               break;\n                }\n            }\n        }\n        if\
    \ (prime) {\n            new_str += word + \" \";\n        }\n    }\n    return\
    \ new_str;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsofziz0g: /tmp/tmpsofziz0g.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result =\
    \ \"\";\n  int flag = 0;\n  for (int i = 0; i < sentence.length(); i++) {\n  \
    \  if (sentence[i] == ' ' || sentence[i] == '\\0') {\n      if (flag == 0) {\n\
    \        result += sentence[i];\n      }\n      flag = 0;\n    } else {\n    \
    \  flag++;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpk_bwbv3g: /tmp/tmpk_bwbv3g.cpp:34: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string ans = \"\
    \";\n    std::string temp = \"\";\n    for(int i = 0; i < sentence.length(); i++)\
    \ {\n        if(sentence[i] == ' ') {\n            temp += sentence[i];\n    \
    \        int len = temp.length() - 1;\n            if(len == 1) {\n          \
    \      ans += temp;\n            }\n            else {\n                for(int\
    \ j = 2; j < len; j++) {\n                    if(len % j == 0) {\n           \
    \             break;\n                    }\n                    if(j == len -\
    \ 1) {\n                        ans += temp;\n                    }\n        \
    \        }\n            }\n            temp = \"\";\n        }\n        else {\n\
    \            temp += sentence[i];\n        }\n    }\n    int len = temp.length();\n\
    \    if(len == 1) {\n        ans += temp;\n    }\n    else {\n        for(int\
    \ j = 2; j < len; j++) {\n            if(len % j == 0) {\n                break;\n\
    \            }\n            if(j == len - 1) {\n                ans += temp;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpxpfk6e74: /tmp/tmpxpfk6e74.cpp:61: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string current_word = \"\";\n    for (auto c : sentence) {\n\
    \        if (c == ' ') {\n            words.push_back(current_word);\n       \
    \     current_word = \"\";\n        } else {\n            current_word += c;\n\
    \        }\n    }\n    words.push_back(current_word);\n    current_word = \"\"\
    ;\n    for (auto word : words) {\n        bool is_prime = true;\n        for (int\
    \ i = 2; i <= word.size() / 2; i++) {\n            if (word.size() % i == 0) {\n\
    \                is_prime = false;\n                break;\n            }\n  \
    \      }\n        if (is_prime) {\n            current_word += word + \" \";\n\
    \        }\n    }\n    return current_word.substr(0, current_word.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpazanjd37: /tmp/tmpazanjd37.cpp:46: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // put your code here\n\
    \  std::vector<std::string> words;\n  std::string temp;\n  for(int i = 0; i <\
    \ sentence.size(); i++){\n    if(sentence[i] == ' '){\n      words.push_back(temp);\n\
    \      temp = \"\";\n    }else{\n      temp += sentence[i];\n    }\n  }\n  words.push_back(temp);\n\
    \  std::string result;\n  for(int i = 0; i < words.size(); i++){\n    int count\
    \ = 0;\n    for(int j = 1; j <= words[i].size(); j++){\n      if(words[i].size()\
    \ % j == 0){\n        count++;\n      }\n    }\n    if(count == 2){\n      result\
    \ += words[i] + \" \";\n    }\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpbbvd_pmv: /tmp/tmpbbvd_pmv.cpp:46: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  if (sentence.size() ==\
    \ 0) return \"\";\n  bool flag = true;\n  std::string result;\n  std::string temp\
    \ = \"\";\n  int len = sentence.size();\n  for (int i = 0; i < len; i++) {\n \
    \   if (sentence[i] == ' ') {\n      for (int j = 2; j < temp.size(); j++) {\n\
    \        if (temp.size() % j == 0) {\n          flag = false;\n          break;\n\
    \        }\n      }\n      if (flag) {\n        result += temp;\n        result\
    \ += ' ';\n      }\n      temp = \"\";\n      flag = true;\n    } else {\n   \
    \   temp += sentence[i];\n    }\n  }\n  for (int j = 2; j < temp.size(); j++)\
    \ {\n    if (temp.size() % j == 0) {\n      flag = false;\n      break;\n    }\n\
    \  }\n  if (flag) {\n    result += temp;\n  }\n  if (result[result.size() - 1]\
    \ == ' ') result.pop_back();\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmparqm8fph: /tmp/tmparqm8fph.cpp:55: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // write your code\
    \ here\n    std::string result = \"\";\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while(ss >> word)\
    \ {\n        words.push_back(word);\n    }\n    for(std::string w : words) {\n\
    \        if(isPrime(w.length())) {\n            result += w + \" \";\n       \
    \ }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftn5ffsv.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpftn5ffsv.cpp:27:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   27 |         if(isPrime(w.length())) {\n      |            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098945
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    std::string temp_word;\n    for (int i = 0; i < sentence.length(); i++) {\n\
    \        if (sentence[i] == ' ') {\n            if (is_prime(temp_word.length()))\
    \ {\n                result += temp_word + \" \";\n            }\n           \
    \ temp_word = \"\";\n        } else {\n            temp_word += sentence[i];\n\
    \        }\n    }\n    if (is_prime(temp_word.length())) {\n        result +=\
    \ temp_word;\n    }\n    return result;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4_dmji4z.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4_dmji4z.cpp:22:17: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |             if (is_prime(temp_word.length())) {\n      |\
    \                 ^~~~~~~~\n/tmp/tmp4_dmji4z.cpp:30:9: error: \u2018is_prime\u2019\
    \ was not declared in this scope\n   30 |     if (is_prime(temp_word.length()))\
    \ {\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  int count = 1;\n  std::string\
    \ str = \"\";\n  std::string temp = \"\";\n  if (sentence.size() == 0) {\n   \
    \ return sentence;\n  }\n  for (int i = 0; i < sentence.size(); i++) {\n    if\
    \ (sentence[i] == ' ') {\n      for (int j = 1; j <= count; j++) {\n        if\
    \ (count % j == 0) {\n          if (j == count) {\n            temp = temp + temp\
    \ + temp;\n            str = str + temp;\n          }\n        }\n      }\n  \
    \    count = 0;\n    }\n    count++;\n  }\n  return str;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpo3ezi3uo: /tmp/tmpo3ezi3uo.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // Write your code\
    \ here\n    std::vector<std::string> words;\n    std::stringstream check1(sentence);\n\
    \    std::string word;\n    while(getline(check1, word, ' ')){\n        words.push_back(word);\n\
    \    }\n    std::string new_sentence = \"\";\n    for(int i = 0; i < words.size();\
    \ i++){\n        if(words[i].length() == 1){\n            new_sentence += words[i]\
    \ + \" \";\n        }\n        else if(words[i].length() == 2){\n            if(words[i][0]\
    \ != words[i][1]){\n                new_sentence += words[i] + \" \";\n      \
    \      }\n        }\n        else{\n            int flag = 0;\n            for(int\
    \ j = 2; j <= words[i].length()/2; j++){\n                if(words[i].length()\
    \ % j == 0){\n                    flag = 1;\n                    break;\n    \
    \            }\n            }\n            if(flag == 0){\n                new_sentence\
    \ += words[i] + \" \";\n            }\n        }\n    }\n    return new_sentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp23hxa0sv: /tmp/tmp23hxa0sv.cpp:52: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words;\n  std::string current_word;\n  for (const char& c : sentence) {\n  \
    \  if (c == ' ') {\n      words.push_back(current_word);\n      current_word =\
    \ \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  words.push_back(current_word);\n\
    \  std::string result;\n  int last_prime_word_len = 0;\n  for (const std::string&\
    \ word : words) {\n    int word_len = word.length();\n    bool is_prime = true;\n\
    \    if (word_len <= 1) {\n      is_prime = false;\n    } else {\n      for (int\
    \ i = 2; i <= word_len / 2; ++i) {\n        if (word_len % i == 0) {\n       \
    \   is_prime = false;\n          break;\n        }\n      }\n    }\n    if (is_prime)\
    \ {\n      if (last_prime_word_len != 0) {\n        result += \" \";\n      }\n\
    \      result += word;\n      last_prime_word_len = word_len;\n    }\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    bool checker[101];\n    for(int i = 0; i <= 100; i++) {\n     \
    \   checker[i] = true;\n    }\n    for(int i = 2; i <= 100; i++) {\n        if(checker[i])\
    \ {\n            for(int j = i * 2; j <= 100; j += i) {\n                checker[j]\
    \ = false;\n            }\n        }\n    }\n    std::stringstream words(sentence);\n\
    \    std::string word;\n    while(std::getline(words, word, ' ')) {\n        if(checker[word.length()])\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp1aeplktc: /tmp/tmp1aeplktc.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\nstd::string res = \"\"\
    ;\n\tstd::vector<std::string> words = {\"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\", \"\", \"\",\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo2pepiva.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpo2pepiva.cpp:21:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018int\u2019\n   21 | int main() {\n      | ^~~\n/tmp/tmpo2pepiva.cpp:30:1:\
    \ error: expected \u2018}\u2019 at end of input\n   30 | }\n      | ^\n/tmp/tmpo2pepiva.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpo2pepiva.cpp:30:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   30 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // your code here\n\
    \    int flag = 0;\n    int len = sentence.length();\n    int word_len = 0;\n\
    \    std::string ans;\n    for(int i = 0; i<len; i++){\n        if(sentence[i]\
    \ == ' ') {\n            flag = 0;\n            for(int j = 2; j<=word_len/2;\
    \ j++){\n                if(word_len%j == 0){\n                    flag = 1;\n\
    \                    break;\n                }\n            }\n            if(flag\
    \ == 0){\n                ans += sentence[i];\n            }\n            word_len\
    \ = 0;\n        }\n        else {\n            word_len += 1;\n            if(flag\
    \ == 0){\n                ans += sentence[i];\n            }\n        }\n    }\n\
    \    flag = 0;\n    for(int j = 2; j<=word_len/2; j++){\n        if(word_len%j\
    \ == 0){\n            flag = 1;\n            break;\n        }\n    }\n    if(flag\
    \ == 0){\n        ans += sentence[len-1];\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmptt2f1zlh: /tmp/tmptt2f1zlh.cpp:58: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string ans;\n\
    \    bool prime[101];\n    memset(prime, true, sizeof(prime));\n    for (int p\
    \ = 2; p * p <= 100; p++) {\n        if (prime[p] == true) {\n            for\
    \ (int i = p * 2; i <= 100; i += p) {\n                prime[i] = false;\n   \
    \         }\n        }\n    }\n    int size = 0;\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (prime[size]) {\n\
    \                ans += ' ';\n                ans += sentence[i - size];\n   \
    \             for (int j = i - size + 1; j < i; j++) {\n                    ans\
    \ += sentence[j];\n                }\n            }\n            size = 0;\n \
    \       } else {\n            size++;\n        }\n    }\n    if (prime[size])\
    \ {\n        ans += ' ';\n        ans += sentence[sentence.size() - size];\n \
    \       for (int j = sentence.size() - size + 1; j < sentence.size(); j++) {\n\
    \            ans += sentence[j];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsor499wz: /tmp/tmpsor499wz.cpp:54: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098946
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    auto isPrime = [](int\
    \ n) {\n        if (n <= 1) return false;\n        for (int i = 2; i <= n / 2;\
    \ ++i)\n            if (n % i == 0) return false;\n        return true;\n    };\n\
    \    std::string res;\n    std::stringstream ss(sentence);\n    std::string word;\n\
    \    while (ss >> word) {\n        if (isPrime(word.size())) {\n            res\
    \ += word + \" \";\n        }\n    }\n    if (res.size() > 0) res.pop_back();\n\
    \    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string item;\n  std::vector<std::string> splittedStrings;\n  while (std::getline(ss,\
    \ item, ' ')) {\n      splittedStrings.push_back(item);\n  }\n  std::vector<std::string>\
    \ result;\n  for (int i = 0; i < splittedStrings.size(); i++) {\n    if (splittedStrings[i].length()\
    \ == 1 ||\n        splittedStrings[i].length() == 2 ||\n        splittedStrings[i].length()\
    \ == 3 ||\n        splittedStrings[i].length() == 5 ||\n        splittedStrings[i].length()\
    \ == 7) {\n      result.push_back(splittedStrings[i]);\n    }\n  }\n  std::string\
    \ ans = \"\";\n  for (int i = 0; i < result.size(); i++) {\n    ans += result[i];\n\
    \    if (i != result.size() - 1) {\n      ans += \" \";\n    }\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp88jvncuk: /tmp/tmp88jvncuk.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::istringstream iss(sentence);\n    std::vector<std::string>\
    \ words;\n    std::copy(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>(),\
    \ std::back_inserter(words));\n    std::vector<int> Primes = {2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97};\n    for (auto i : words) {\n        if (std::find(Primes.begin(), Primes.end(),\
    \ i.length()) != Primes.end()) {\n            result += i + \" \";\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpgst7n48u: /tmp/tmpgst7n48u.cpp:32: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream words(sentence);\n\
    \    std::string word;\n    std::vector<std::string> primeWords;\n    // std::set<std::string>\
    \ primeWords;\n    std::string primeSentence;\n    bool isPrime;\n    // http://www.cplusplus.com/reference/string/string/substr/\n\
    \    while (std::getline(words, word, ' ')) {\n        isPrime = true;\n     \
    \   for (int i = 2; i < word.length(); i++) {\n            if (word.length() %\
    \ i == 0) {\n                isPrime = false;\n                break;\n      \
    \      }\n        }\n        if (isPrime) {\n            primeWords.push_back(word);\n\
    \        }\n    }\n    for (int i = 0; i < primeWords.size(); i++) {\n       \
    \ primeSentence += primeWords[i];\n        if (i != primeWords.size() - 1) {\n\
    \            primeSentence += \" \";\n        }\n    }\n    return primeSentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpgeqrs3v8: /tmp/tmpgeqrs3v8.cpp:47: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098947
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\t// because you are not\
    \ allowed to modify the string\n\t// first lets create a new sentence\n\tstd::string\
    \ new_sentence;\n\tint start = 0;\n\t// iterate through the sentence\n\tfor (int\
    \ i = 0; i < sentence.length(); i++) {\n\t\t// if the current char is a space\n\
    \t\tif (sentence[i] == ' ') {\n\t\t\t// add it to the new string\n\t\t\t// and\
    \ also check if the length is prime\n\t\t\t// if it is then append the word to\
    \ new_sentence\n\t\t\t// or else do nothing\n\t\t\tif (is_prime(i - start)) {\n\
    \t\t\t\tfor (int j = start; j < i; j++) {\n\t\t\t\t\tnew_sentence += sentence[j];\n\
    \t\t\t\t}\n\t\t\t\tnew_sentence += ' ';\n\t\t\t}\n\t\t\t// update the start index\n\
    \t\t\tstart = i + 1;\n\t\t}\n\t}\n\t// if the last word is prime\n\t// then add\
    \ it to the new_sentence\n\tif (is_prime(sentence.length() - start)) {\n\t\tfor\
    \ (int i = start; i < sentence.length(); i++) {\n\t\t\tnew_sentence += sentence[i];\n\
    \t\t}\n\t}\n\t// return the new_sentence\n\treturn new_sentence;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxqq6lcij.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpxqq6lcij.cpp:30:8: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   30 |    if (is_prime(i - start)) {\n      |        ^~~~~~~~\n\
    /tmp/tmpxqq6lcij.cpp:42:6: error: \u2018is_prime\u2019 was not declared in this\
    \ scope\n   42 |  if (is_prime(sentence.length() - start)) {\n      |      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string output =\
    \ \"\";\n  std::string word = \"\";\n  int count = 0;\n  for (int i = 0; i < sentence.length();\
    \ i++) {\n    if (sentence[i] == ' ') {\n      for (int i = 1; i <= word.length();\
    \ i++) {\n        if (word.length() % i == 0)\n          count++;\n      }\n \
    \     if (count == 2)\n        output += word + \" \";\n      word = \"\";\n \
    \     count = 0;\n    } else {\n      word += sentence[i];\n    }\n  }\n  for\
    \ (int i = 1; i <= word.length(); i++) {\n    if (word.length() % i == 0)\n  \
    \    count++;\n  }\n  if (count == 2)\n    output += word;\n  return output;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpleieyfxw: /tmp/tmpleieyfxw.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string current_word;\n    for (auto c : sentence) {\n     \
    \   if (c == ' ') {\n            words.push_back(current_word);\n            current_word\
    \ = \"\";\n        } else {\n            current_word += c;\n        }\n    }\n\
    \    words.push_back(current_word);\n    std::string filtered_words;\n    for\
    \ (auto &w : words) {\n        bool is_prime = true;\n        for (int i = 2;\
    \ i <= w.size() / 2; i++) {\n            if (w.size() % i == 0) {\n          \
    \      is_prime = false;\n                break;\n            }\n        }\n \
    \       if (is_prime) {\n            filtered_words += w + \" \";\n        }\n\
    \    }\n    if (filtered_words.size() > 0) {\n        filtered_words.erase(filtered_words.size()\
    \ - 1);\n    }\n    return filtered_words;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3pz7phr_: /tmp/tmp3pz7phr_.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098947
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // your code here\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    std::stringstream\
    \ sentenceout;\n    while(ss >> word){\n        if(isPrime(word.length())){\n\
    \            sentenceout << word;\n            sentenceout << \" \";\n       \
    \ }\n    }\n    return sentenceout.str();\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoop9go2q.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpoop9go2q.cpp:23:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   23 |         if(isPrime(word.length())){\n      |           \
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    int len = sentence.length();\n\
    \    if(len == 0) {\n        return \"\";\n    }\n    std::string out;\n    std::stringstream\
    \ stream(sentence);\n    std::string word;\n    while(stream >> word) {\n    \
    \    int word_len = word.length();\n        bool prime = true;\n        for(int\
    \ i = 2; i < word_len; i++) {\n            if(word_len % i == 0) {\n         \
    \       prime = false;\n                break;\n            }\n        }\n   \
    \     if(prime) {\n            out += word + \" \";\n        }\n    }\n    return\
    \ out;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp54sqa_ad: /tmp/tmp54sqa_ad.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string s;\n  \
    \  std::stringstream ss(sentence);\n    std::string word;\n    while(ss >> word)\
    \ {\n        if(is_prime(word.length())) {\n            s += word + \" \";\n \
    \       }\n    }\n    s.pop_back();\n    return s;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn6irwkbz.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpn6irwkbz.cpp:22:12: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if(is_prime(word.length())) {\n      |         \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098947
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words = Split(sentence);\n  std::string result = \"\";\n  for (auto word : words)\
    \ {\n    if (is_prime(word.length())) {\n      result += (word + \" \");\n   \
    \ }\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp7i1hjt7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpp7i1hjt7.cpp:18:36: error: \u2018Split\u2019 was not declared in this\
    \ scope\n   18 |   std::vector<std::string> words = Split(sentence);\n      |\
    \                                    ^~~~~\n/tmp/tmpp7i1hjt7.cpp:21:9: error:\
    \ \u2018is_prime\u2019 was not declared in this scope\n   21 |     if (is_prime(word.length()))\
    \ {\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098947
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::stringstream ss(sentence);\n    std::string temp;\n    while\
    \ (ss >> temp) {\n        if (isPrime(temp.length())) {\n            result +=\
    \ (temp + \" \");\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpghjvhekq.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpghjvhekq.cpp:22:13: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   22 |         if (isPrime(temp.length())) {\n      |         \
    \    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool isPrime[101];\n\
    \    memset(isPrime, true, sizeof(isPrime));\n    for (int i = 2; i <= 100; i++)\
    \ {\n        if (isPrime[i]) {\n            for (int j = i * i; j <= 100; j +=\
    \ i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\
    \    std::stringstream ss(sentence);\n    std::string result = \"\";\n    std::string\
    \ intermediate;\n    std::vector<std::string> v;\n    while (std::getline(ss,\
    \ intermediate, ' ')) {\n        v.push_back(intermediate);\n    }\n    for (int\
    \ i = 0; i < v.size(); i++) {\n        if (isPrime[v[i].length()]) {\n       \
    \     result = result + v[i] + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpspv4_bog: /tmp/tmpspv4_bog.cpp:44: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string res;\n  std::string\
    \ temp = \"\";\n  for (auto ch : sentence) {\n    if (ch == ' ') {\n      if (isPrime(temp.size()))\
    \ {\n        res += temp + \" \";\n      }\n      temp = \"\";\n    } else {\n\
    \      temp += ch;\n    }\n  }\n  if (isPrime(temp.size())) {\n    res += temp;\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt56xrozf.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpt56xrozf.cpp:22:11: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   22 |       if (isPrime(temp.size())) {\n      |           ^~~~~~~\n\
    /tmp/tmpt56xrozf.cpp:30:7: error: \u2018isPrime\u2019 was not declared in this\
    \ scope\n   30 |   if (isPrime(temp.size())) {\n      |       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string res;\n  bool\
    \ flag = false;\n  for (int i = 0; i < sentence.size(); i++) {\n    if (sentence[i]\
    \ == ' ') {\n      flag = false;\n      continue;\n    }\n    if (sentence[i]\
    \ != ' ' && flag == false) {\n      flag = true;\n      int count = 0;\n     \
    \ while (sentence[i] != ' ' && i < sentence.size()) {\n        count++;\n    \
    \    i++;\n      }\n      i--;\n      bool is_prime = true;\n      for (int j\
    \ = 2; j < count; j++) {\n        if (count % j == 0) {\n          is_prime =\
    \ false;\n          break;\n        }\n      }\n      if (is_prime == true) {\n\
    \        res.push_back(' ');\n        for (int j = 0; j < count; j++) {\n    \
    \      res.push_back(sentence[i - count + 1 + j]);\n        }\n      }\n    }\n\
    \  }\n  if (res.size() > 0)\n    res.erase(res.begin());\n  return res;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpirvhyesm: /tmp/tmpirvhyesm.cpp:54: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  assert(1 <= sentence.length()\
    \ && sentence.length() <= 100);\n  std::regex words_in_sentence_reg(\"([a-zA-Z]+)\"\
    );\n  std::smatch result;\n  std::string result_string;\n  while (std::regex_search(sentence,\
    \ result, words_in_sentence_reg)) {\n    if (result[1].length() == 2 || result[1].length()\
    \ == 3 ||\n        result[1].length() == 5 || result[1].length() == 7) {\n   \
    \   result_string += result[1] + \" \";\n    }\n    sentence = result.suffix().str();\n\
    \  }\n  return result_string;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbfn9x222.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbfn9x222.cpp:25:34: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018const value_type\u2019 {aka \u2018const std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> > >\u2019} and \u2018const char [2]\u2019\
    )\n   25 |       result_string += result[1] + \" \";\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbfn9x222.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpbfn9x222.cpp:25:36:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018const char [2]\u2019\n   25 |       result_string += result[1] + \"\
    \ \";\n      |                                    ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbfn9x222.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     operator+(typename move_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h"
  stdout: ''
  timestamp: 1660098948
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result =\
    \ \"\";\n  std::stringstream check1(sentence);\n  std::string intermediate;\n\
    \  while(getline(check1, intermediate, ' ')) {\n    if (intermediate.length()\
    \ == 1) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 2) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 3) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 5) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 7) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 11) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 13) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 17) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 19) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 23) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 29) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 31) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 37) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 41) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 43) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 47) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 53) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 59) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 61) {\n      result += intermediate + \" \";\n    } else if (intermediate.length()\
    \ == 67)\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp01kly4b1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp01kly4b1.cpp:61:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   61 | }\n      | ^\n/tmp/tmp01kly4b1.cpp:62:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   62 | int main() {\n     \
    \ |            ^\n/tmp/tmp01kly4b1.cpp:71:1: error: expected \u2018}\u2019 at\
    \ end of input\n   71 | }\n      | ^\n/tmp/tmp01kly4b1.cpp:17:53: note: to match\
    \ this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string sentence)\
    \ {\n      |                                                     ^\n/tmp/tmp01kly4b1.cpp:71:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   71 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098947
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // remove space from\
    \ the start and end\n  if(sentence.length() <= 0) return \"\";\n  int n = sentence.length();\n\
    \  int start = 0, end = n - 1;\n  while(sentence[start] == ' ') start++;\n  while(sentence[end]\
    \ == ' ') end--;\n  int newlen = end - start + 1;\n  if(newlen <= 0) return \"\
    \";\n  // remove all other spaces\n  sentence = sentence.substr(start, newlen);\n\
    \  std::stringstream ss(sentence);\n  std::string item;\n  std::vector<std::string>\
    \ wordList;\n  while(std::getline(ss, item, ' ')) {\n    wordList.push_back(item);\n\
    \  }\n  std::string answer = \"\";\n  for(auto it : wordList) {\n    if(isPrime(it.length()))\
    \ answer += it + \" \";\n  }\n  return answer.substr(0, answer.length() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpinxd02_1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpinxd02_1.cpp:36:8: error: \u2018isPrime\u2019 was not declared in this\
    \ scope\n   36 |     if(isPrime(it.length())) answer += it + \" \";\n      | \
    \       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098947
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string str=\"\"\
    ;\n  std::string str1=\"\";\n  std::string str2=\"\";\n  std::string s=\"\";\n\
    \  std::cout<<\"enter a sentence\"<<\"\\n\";\n  std::getline(std::cin,sentence);\n\
    \  std::stringstream ss(sentence);\n  while(ss>>str)\n  {\n    str1+=str+\" \"\
    ;\n  }\n  for(int i=0;i<str1.length();i++)\n  {\n    if(str1[i]!=' ')\n    {\n\
    \      s+=str1[i];\n    }\n    else\n    {\n      int c=0;\n      for(int j=2;j<s.length();j++)\n\
    \      {\n        if(s.length()%j==0)\n        {\n          c++;\n        }\n\
    \      }\n      if(c==0)\n      {\n        str2+=s+\" \";\n      }\n      s=\"\
    \";\n    }\n  }\n  return str2;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: 'enter a sentence

    '
  timestamp: 1660098953
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // Write your code\
    \ here\n    std::stringstream ss(sentence);\n    std::string word;\n    std::string\
    \ s=\"\";\n    std::vector<std::string> words;\n    int j=0;\n    while(ss>>word){\n\
    \        words.push_back(word);\n    }\n    for(int i=0;i<words.size();i++){\n\
    \        int j=1;\n        int flag=0;\n        while(j<=words[i].size()){\n \
    \           if(words[i].size()%j==0){\n                flag++;\n            }\n\
    \            j++;\n        }\n        if(flag==2){\n            s+=words[i]+\"\
    \ \";\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpk52_4oww: /tmp/tmpk52_4oww.cpp:44: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::stringstream ss;\n\
    \tstd::string word;\n\twhile (std::getline(ss, word, ' ')) {\n\t\tif (word.size()\
    \ == 1) {\n\t\t\tss << word << ' ';\n\t\t} else {\n\t\t\tbool flag = true;\n\t\
    \t\tfor (int i = 2; i < word.size(); i++) {\n\t\t\t\tif (word.size() % i == 0)\
    \ {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\
    \ {\n\t\t\t\tss << word << ' ';\n\t\t\t}\n\t\t}\n\t}\n\treturn ss.str();\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpl3iph8p5: /tmp/tmpl3iph8p5.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string res;\n\
    \    std::vector<std::string> arr;\n    int s = 0;\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            std::string temp = sentence.substr(s,\
    \ i - s);\n            arr.push_back(temp);\n            s = i + 1;\n        }\n\
    \    }\n    std::string temp = sentence.substr(s, sentence.size() - s);\n    arr.push_back(temp);\n\
    \    for (auto i : arr) {\n        int count = 0;\n        for (int j = 2; j <\
    \ i.size(); j++) {\n            if (i.size() % j == 0) {\n                count++;\n\
    \            }\n        }\n        if (count == 0) {\n            res += i + \"\
    \ \";\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpynqcl79t: /tmp/tmpynqcl79t.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::string temp_word;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            words.push_back(temp_word);\n\
    \            temp_word = \"\";\n        } else {\n            temp_word += sentence[i];\n\
    \        }\n    }\n    words.push_back(temp_word);\n    std::string result;\n\
    \    for (int i = 0; i < words.size(); i++) {\n        if (words[i].length() ==\
    \ 1 || words[i].length() == 2) {\n            result += words[i] + \" \";\n  \
    \      } else {\n            int flag = 1;\n            for (int j = 2; j < words[i].length();\
    \ j++) {\n                if (words[i].length() % j == 0) {\n                \
    \    flag = 0;\n                    break;\n                }\n            }\n\
    \            if (flag == 1) {\n                result += words[i] + \" \";\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpgy61fsfw: /tmp/tmpgy61fsfw.cpp:50: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    int i, flag;\n    std::vector<std::string>\
    \ words;\n    std::string word = \"\";\n    for (i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            words.push_back(word);\n\
    \            word = \"\";\n        } else {\n            word += sentence[i];\n\
    \        }\n    }\n    words.push_back(word);\n    std::string res = \"\";\n \
    \   for (i = 0; i < words.size(); i++) {\n        flag = 0;\n        for (int\
    \ j = 2; j <= words[i].length() / 2; j++) {\n            if (words[i].length()\
    \ % j == 0) {\n                flag = 1;\n                break;\n           \
    \ }\n        }\n        if (flag == 0) {\n            res += words[i] + \" \"\
    ;\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp5brd1nmo: /tmp/tmp5brd1nmo.cpp:47: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::vector<std::string>\
    \ words;\n  std::string word;\n  std::stringstream stream(sentence);\n  while\
    \ (std::getline(stream, word, ' ')) {\n    words.push_back(word);\n  }\n  auto\
    \ is_prime = [](int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i\
    \ * i <= n; ++i) {\n      if (n % i == 0) return false;\n    }\n    return true;\n\
    \  };\n  std::string result;\n  for (int i = 0; i < words.size(); ++i) {\n   \
    \ if (is_prime(words[i].size())) {\n      result += words[i] + ' ';\n    }\n \
    \ }\n  if (result.size() > 0) result.pop_back();\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098948
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string primes;\n\
    \  std::stringstream strm(sentence);\n  std::string word;\n  while (std::getline(strm,\
    \ word, ' ')) {\n    if (std::find(std::begin(primes), std::end(primes), word)\
    \ == std::end(primes)) {\n      if (word.length() == 2) {\n        primes += word\
    \ + \" \";\n      } else {\n        bool isPrime = true;\n        for (int i =\
    \ 2; i < word.length(); i++) {\n          if (word.length() % i == 0) {\n    \
    \        isPrime = false;\n            break;\n          }\n        }\n      \
    \  if (isPrime) {\n          primes += word + \" \";\n        }\n      }\n   \
    \ }\n  }\n  primes.pop_back();\n  return primes;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n    \
    \             from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpuhs6559v.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Value = const std::__cxx11::basic_string<char>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Predicate\
    \ = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:161:23:   required from \u2018\
    _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const\
    \ std::__cxx11::basic_string<char> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:3944:28:\
    \   required from \u2018_IIter std::find(_IIter, _IIter, const _Tp&) [with _IIter\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Tp\
    \ = std::__cxx11::basic_string<char>]\u2019\n/tmp/tmpuhs6559v.cpp:22:61:   required\
    \ from here\n/usr/include/c++/9/bits/predefined_ops.h:241:17: error: no match\
    \ for \u2018operator==\u2019 (operand types are \u2018char\u2019 and \u2018const\
    \ std::__cxx11::basic_string<char>\u2019)\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41"
  stdout: ''
  timestamp: 1660098948
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string word = \"\
    \";\n  std::string output = \"\";\n  for (char c : sentence) {\n    if (c == '\
    \ ') {\n      if (is_prime(word.length())) {\n        output += word + \" \";\n\
    \      }\n      word = \"\";\n    } else {\n      word += c;\n    }\n  }\n  return\
    \ output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjrwlnxh1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpjrwlnxh1.cpp:22:11: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |       if (is_prime(word.length())) {\n      |          \
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    int count = 0;\n  \
    \  int s_index = 0;\n    int e_index = 0;\n    bool prime;\n    std::string result\
    \ = \"\";\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            for (int j = 2; j < e_index - s_index; j++) {\n     \
    \           if ((e_index - s_index) % j == 0) {\n                    prime = false;\n\
    \                    break;\n                }\n                else\n       \
    \             prime = true;\n            }\n            if (prime == true) {\n\
    \                for (int k = s_index; k < e_index; k++) {\n                 \
    \   result += sentence[k];\n                }\n                count++;\n    \
    \            if (count >= 2)\n                    result += ' ';\n           \
    \ }\n            s_index = e_index + 1;\n        }\n        e_index++;\n    }\n\
    \    // We need to check the last word\n    // Don't forget to check the last\
    \ word\n    for (int j = 2; j < e_index - s_index; j++) {\n        if ((e_index\
    \ - s_index) % j == 0) {\n            prime = false;\n            break;\n   \
    \     }\n        else\n            prime = true;\n    }\n    if (prime == true)\
    \ {\n        for (int k = s_index; k < e_index; k++) {\n            result +=\
    \ sentence[k];\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmptayo7npn: /tmp/tmptayo7npn.cpp:64: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // replace this code\
    \ with your implementation\n    return std::string();\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpxl5mi41g: /tmp/tmpxl5mi41g.cpp:23: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    if(sentence.length()\
    \ == 0) return \"\";\n    std::vector<std::string> str_vec;\n    std::stringstream\
    \ stream(sentence);\n    std::string s;\n    while(stream >> s) str_vec.push_back(s);\n\
    \    std::string res = \"\";\n    for(int i = 0; i < str_vec.size(); i++) {\n\
    \        bool is_prime = true;\n        for(int j = 2; j < str_vec[i].length();\
    \ j++) {\n            if(str_vec[i].length() % j == 0) {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if(is_prime\
    \ && str_vec[i].length() != 1) res += str_vec[i] + \" \";\n    }\n    if(res[res.length()\
    \ - 1] == ' ') res.pop_back();\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // 1. Split string\
    \ into words\n    // 2. Get the length of each word\n    // 3. Check if the length\
    \ is prime\n    // 4. If the length is prime, append the word to the final string\
    \ and return the string.\n    std::string sentence_copy = sentence;\n    std::istringstream\
    \ iss(sentence_copy);\n    std::vector<std::string> words;\n    for (std::string\
    \ s; iss >> s;) {\n        words.push_back(s);\n    }\n    std::string final_string;\n\
    \    for (std::string word : words) {\n        int word_length = word.length();\n\
    \        int i;\n        bool is_prime = true;\n        for (i = 2; i <= word_length\
    \ / 2; i++) {\n            if (word_length % i == 0) {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            final_string.append(word);\n            final_string.append(\"\
    \ \");\n        }\n    }\n    return final_string;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpmb83wzhy: /tmp/tmpmb83wzhy.cpp:48: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::vector<std::string> words;\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<int> prime_numbers(words.size());\n\
    \    for (int i = 0; i < words.size(); i++) {\n        prime_numbers[i] = 0;\n\
    \    }\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 2;\
    \ j < words[i].size(); j++) {\n            if (words[i].size() % j == 0) {\n \
    \               prime_numbers[i]++;\n            }\n        }\n    }\n    std::string\
    \ new_string;\n    for (int i = 0; i < words.size(); i++) {\n        if (prime_numbers[i]\
    \ == 0) {\n            new_string += words[i] + \" \";\n        }\n    }\n   \
    \ return new_string;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpmh1ink8d: /tmp/tmpmh1ink8d.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    char *str = (char *)\
    \ sentence.c_str();\n    const char delim[2] = \" \";\n    char *token;\n    token\
    \ = strtok(str, delim);\n    std::string ans;\n    std::vector<std::string> words;\n\
    \    while (token != NULL) {\n        std::string word(token);\n        words.push_back(word);\n\
    \        token = strtok(NULL, delim);\n    }\n    for (auto &word : words) {\n\
    \        if (word.length() == 2 || word.length() == 3 || word.length() == 5 ||\
    \ word.length() == 7) {\n            ans += word + \" \";\n        }\n    }\n\
    \    ans.pop_back();\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpuszz30xn: /tmp/tmpuszz30xn.cpp:44: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::istringstream iss(sentence);\n    std::string word;\n    while\
    \ (iss >> word)\n        words.push_back(word);\n    std::string result;\n   \
    \ for (std::string &word : words) {\n        int length = word.length();\n   \
    \     bool prime = true;\n        for (int i = 2; i < length; i++) {\n       \
    \     if (length % i == 0) {\n                prime = false;\n               \
    \ break;\n            }\n        }\n        if (prime)\n            result +=\
    \ word + \" \";\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmper3hz3ls: /tmp/tmper3hz3ls.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result, temp;\n\
    \  for (unsigned int i = 0; i < sentence.length(); i++) {\n    if (sentence[i]\
    \ == ' ') {\n      temp = \"\";\n    } else {\n      temp += sentence[i];\n  \
    \  }\n    if (sentence[i] == ' ' || i == sentence.length() - 1) {\n      if (isPrime(temp.length()))\
    \ {\n        result += temp + \" \";\n      }\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1zzkie22.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp1zzkie22.cpp:26:11: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   26 |       if (isPrime(temp.length())) {\n      |           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::stringstream str(sentence);\n\
    \  std::string result;\n  std::string item;\n  while (std::getline(str, item,\
    \ ' ')) {\n    bool prime = true;\n    for (int i = 2; i < item.length(); i++)\
    \ {\n      if (item.length() % i == 0) {\n        prime = false;\n        break;\n\
    \      }\n    }\n    if (prime) {\n      result += item + \" \";\n    }\n  }\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpuxc9o3b7: /tmp/tmpuxc9o3b7.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    int j = 0;\n    for (int i = 0; i < sentence.size(); i++) {\n  \
    \      if (sentence[i] == ' ') {\n            words.push_back(sentence.substr(j,\
    \ i - j));\n            j = i + 1;\n        }\n    }\n    words.push_back(sentence.substr(j,\
    \ sentence.size() - j));\n    std::string answer = \"\";\n    for (int i = 0;\
    \ i < words.size(); i++) {\n        bool prime = true;\n        if (words[i].size()\
    \ == 1) {\n            continue;\n        }\n        for (int j = 2; j < words[i].size();\
    \ j++) {\n            if (words[i].size() % j == 0) {\n                prime =\
    \ false;\n                break;\n            }\n        }\n        if (prime)\
    \ {\n            answer += words[i] + \" \";\n        }\n    }\n    if (answer.size()\
    \ > 0) {\n        answer.pop_back();\n    }\n    return answer;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string str;\n\
    \    std::string t = \" \";\n    int len = 0;\n    bool flag = true;\n    for(int\
    \ i = 0; i < sentence.length(); i++) {\n        if(sentence[i] == ' ') {\n   \
    \         for(int j = 2; j <= len/2; j++) {\n                if(len % j == 0)\
    \ {\n                    flag = false;\n                    break;\n         \
    \       }\n            }\n            if(flag) {\n                for(int j =\
    \ i - len; j < i; j++) {\n                    str += sentence[j];\n          \
    \      }\n                str += t;\n            }\n            len = 0;\n   \
    \         flag = true;\n        }\n        else {\n            len++;\n      \
    \  }\n    }\n    for(int j = 2; j <= len/2; j++) {\n        if(len % j == 0) {\n\
    \            flag = false;\n            break;\n        }\n    }\n    if(flag)\
    \ {\n        for(int j = sentence.length() - len; j < sentence.length(); j++)\
    \ {\n            str += sentence[j];\n        }\n    }\n    return str;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpt17drnoq: /tmp/tmpt17drnoq.cpp:58: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    bool is_first\
    \ = true;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n\
    \            if (is_first) {\n                result = word;\n               \
    \ is_first = false;\n            } else {\n                result += \" \" + word;\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa_zf5t3l.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpa_zf5t3l.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098948
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tassert(sentence.size()\
    \ <= 100);\n\tstd::string result;\n\tstd::vector<int> primeNumbers;\n\tstd::vector<std::string>\
    \ sentence_splitted;\n\tprimeNumbers.push_back(2);\n\tfor (int i = 3; i < 100;\
    \ i++) {\n\t\tbool isPrime = true;\n\t\tfor (int j = 2; j < i; j++) {\n\t\t\t\
    if (i % j == 0) {\n\t\t\t\tisPrime = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    \tif (isPrime) {\n\t\t\tprimeNumbers.push_back(i);\n\t\t}\n\t}\n\tfor (int i =\
    \ 0; i < sentence.size(); i++) {\n\t\tif (sentence[i] == ' ') {\n\t\t\tsentence[i]\
    \ = ' ';\n\t\t}\n\t}\n\tsentence_splitted = split(sentence, ' ');\n\tfor (int\
    \ i = 0; i < sentence_splitted.size(); i++) {\n\t\tbool isPrime = false;\n\t\t\
    for (int j = 0; j < primeNumbers.size(); j++) {\n\t\t\tif (sentence_splitted[i].size()\
    \ == primeNumbers[j]) {\n\t\t\t\tisPrime = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\
    }\n\t\tif (isPrime) {\n\t\t\tresult.append(sentence_splitted[i]);\n\t\t\tresult.append(\"\
    \ \");\n\t\t}\n\t}\n\tresult.pop_back();\n\treturn result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqx8ekqmd.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpqx8ekqmd.cpp:40:22: error: \u2018split\u2019 was not declared in this\
    \ scope\n   40 |  sentence_splitted = split(sentence, ' ');\n      |         \
    \             ^~~~~\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result;\n\
    \    int n = sentence.length();\n    std::vector<int> prime(n, 1);\n    prime[0]\
    \ = 0;\n    prime[1] = 0;\n    for (int i = 2; i < n; i++) {\n        if (prime[i]\
    \ == 1) {\n            for (int j = i * i; j < n; j += i) {\n                prime[j]\
    \ = 0;\n            }\n        }\n    }\n    for (int i = 2; i < n; i++) {\n \
    \       if (prime[i] == 1) {\n            std::cout << i << \" \";\n        }\n\
    \    }\n    std::cout << \"\\n\";\n    int i = 0;\n    while (i < n) {\n     \
    \   std::string s;\n        while (sentence[i] != ' ' && i < n) {\n          \
    \  s += sentence[i];\n            i++;\n        }\n        i++;\n        if (prime[s.length()]\
    \ == 1) {\n            result += s;\n            result += \" \";\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpz218sb2w: /tmp/tmpz218sb2w.cpp:53: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::istringstream\
    \ ss(sentence);\n    std::vector<std::string> v;\n    std::string word;\n    while\
    \ (ss >> word) {\n        v.push_back(word);\n    }\n    std::vector<std::string>\
    \ result;\n    for (auto& word : v) {\n        if (is_prime(word.size())) {\n\
    \            result.push_back(word);\n        }\n    }\n    return join(result,\
    \ \" \");\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_hs6l8f0.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_hs6l8f0.cpp:26:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   26 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n/tmp/tmp_hs6l8f0.cpp:30:12: error: \u2018join\u2019 was not declared\
    \ in this scope; did you mean \u2018jn\u2019?\n   30 |     return join(result,\
    \ \" \");\n      |            ^~~~\n      |            jn\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    int n = sentence.length();\n    int start = 0;\n    for (int i =\
    \ 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            std::string\
    \ w = sentence.substr(start, i - start);\n            words.push_back(w);\n  \
    \          start = i + 1;\n        }\n    }\n    std::string w = sentence.substr(start,\
    \ n - start);\n    words.push_back(w);\n    std::string res = \"\";\n    for (int\
    \ i = 0; i < words.size(); i++) {\n        int len = words[i].length();\n    \
    \    if (len == 2) {\n            res += words[i] + \" \";\n            continue;\n\
    \        }\n        bool isPrime = true;\n        for (int j = 2; j * j <= len;\
    \ j++) {\n            if (len % j == 0) {\n                isPrime = false;\n\
    \                break;\n            }\n        }\n        if (isPrime) {\n  \
    \          res += words[i] + \" \";\n        }\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4w1nu5w7: /tmp/tmp4w1nu5w7.cpp:52: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::vector<std::string>\
    \ words;\n\tstd::string result;\n\tstd::stringstream s(sentence);\n\tstd::string\
    \ word;\n\twhile (s >> word)\n\t\twords.push_back(word);\n\tfor (std::string w\
    \ : words) {\n\t\tint counter = 0;\n\t\tfor (int i = 1; i <= w.length(); i++)\
    \ {\n\t\t\tif (w.length() % i == 0)\n\t\t\t\tcounter++;\n\t\t}\n\t\tif (counter\
    \ == 2)\n\t\t\tresult += w + \" \";\n\t}\n\treturn result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3vp4d9e4: /tmp/tmp3vp4d9e4.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool is_prime(int x);\n\
    \    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n  \
    \  std::string buf;\n    while (ss >> buf) {\n        words.push_back(buf);\n\
    \    }\n    std::string result;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        if (is_prime(words[i].size())) {\n            result += words[i] + \"\
    \ \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: '/usr/bin/ld: /tmp/ccMiri30.o: in function `words_in_sentence(std::__cxx11::basic_string<char,
    std::char_traits<char>, std::allocator<char> >)'':

    tmp0int7jx_.cpp:(.text+0x127): undefined reference to `is_prime(int)''

    collect2: error: ld returned 1 exit status

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    string str;\n    bool\
    \ flag = false;\n    stringstream ss(sentence);\n    string word;\n    while(ss\
    \ >> word){\n        int len = word.length();\n        int cnt = 0;\n        for(int\
    \ i = 1; i <= len; i++){\n            if(len % i == 0) cnt++;\n        }\n   \
    \     if(cnt == 2){\n            if(flag) str += \" \";\n            flag = true;\n\
    \            str += word;\n        }\n    }\n    return str;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbay2830l.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbay2830l.cpp:18:5: error: \u2018string\u2019 was not declared in this\
    \ scope\n   18 |     string str;\n      |     ^~~~~~\n/tmp/tmpbay2830l.cpp:18:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpbay2830l.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpbay2830l.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpbay2830l.cpp:20:5: error: \u2018stringstream\u2019 was not declared in\
    \ this scope; did you mean \u2018std::stringstream\u2019?\n   20 |     stringstream\
    \ ss(sentence);\n      |     ^~~~~~~~~~~~\n      |     std::stringstream\nIn file\
    \ included from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/"
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string s = \"\"\
    , result = \"\";\n    for (int i = 0; i < sentence.length(); i++) {\n        if\
    \ (sentence[i] == ' ') {\n            if (s.length() > 0) {\n                if\
    \ (s.length() == 2 || s.length() == 3 || s.length() == 5 || s.length() == 7 ||\
    \ s.length() == 11 || s.length() == 13 || s.length() == 17 || s.length() == 19\
    \ || s.length() == 23 || s.length() == 29 || s.length() == 31 || s.length() ==\
    \ 37 || s.length() == 41 || s.length() == 43 || s.length() == 47 || s.length()\
    \ == 53 || s.length() == 59 || s.length() == 61 || s.length() == 67 || s.length()\
    \ == 71 || s.length() == 73 || s.length() == 79 || s.length() == 83 || s.length()\
    \ == 89 || s.length() == 97) {\n                    result += s + \" \";\n   \
    \             }\n                s = \"\";\n            }\n        } else {\n\
    \            s += sentence[i];\n        }\n    }\n    if (s.length() > 0) {\n\
    \        if (s.length() == 2 || s.length() == 3 || s.length() == 5 || s.length()\
    \ == 7 || s.length() == 11 || s.length() == 13 || s.length() == 17 || s.length()\
    \ == 19 || s.length() == 23 || s.length() == 29 || s.length() == 31 || s.length()\
    \ == 37 || s.length() == 41 || s.length() == 43 || s.length() == 47 || s.length()\
    \ == 53 || s.length() == 59 || s.length() == 61 || s.length() == 67 || s.length()\
    \ == 71 || s.length() == 73 || s.length() == 79 || s.length() == 83 || s.length()\
    \ == 89 || s.length() == 97) {\n            result += s;\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpc9pi3im1: /tmp/tmpc9pi3im1.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ primes;\n    int i,j;\n    bool is_prime;\n    std::string word;\n    std::stringstream\
    \ word_ss(sentence);\n    std::vector<std::string> words;\n    while(word_ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    for(i=0;i<words.size();i++)\
    \ {\n        is_prime = true;\n        for(j=2;j<words[i].size();j++) {\n    \
    \        if(words[i].size()%j == 0) {\n                is_prime = false;\n   \
    \             break;\n            }\n        }\n        if(is_prime) {\n     \
    \       primes.push_back(words[i]);\n        }\n    }\n    std::string result;\n\
    \    for(i=0;i<primes.size();i++) {\n        result += primes[i];\n        if(i\
    \ < primes.size()-1) {\n            result += \" \";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpdhxbshge: /tmp/tmpdhxbshge.cpp:50: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::stringstream ss(sentence);\n\
    \tstd::string word;\n\tstd::string output = \"\";\n\twhile (std::getline(ss, word,\
    \ ' ')) {\n\t\tbool prime = true;\n\t\tif (word.length() == 1) {\n\t\t\toutput\
    \ += word + \" \";\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 2; i < word.length();\
    \ i++) {\n\t\t\tif (word.length() % i == 0) {\n\t\t\t\tprime = false;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t\tif (prime) {\n\t\t\toutput += word + \" \";\n\t\t\
    }\n\t}\n\treturn output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpbbbhlo0d: /tmp/tmpbbbhlo0d.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool check=false;\n\
    \    std::string temp;\n    std::string result;\n    for(int i=0;i<sentence.length();i++){\n\
    \        if(sentence[i]==' '){\n            for(int j=2;j<=temp.length()/2;j++){\n\
    \                if(temp.length()%j==0){\n                    check=true;\n  \
    \                  break;\n                }\n            }\n            if(check==false){\n\
    \                result+=temp;\n                result+=' ';\n            }\n\
    \            temp.clear();\n            check=false;\n        }\n        else{\n\
    \            temp+=sentence[i];\n        }\n    }\n    for(int j=2;j<=temp.length()/2;j++){\n\
    \        if(temp.length()%j==0){\n            check=true;\n            break;\n\
    \        }\n    }\n    if(check==false){\n        result+=temp;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpvx8bkpae: /tmp/tmpvx8bkpae.cpp:53: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string delim = \"\
    \ \";\n  std::string new_sentence;\n  // vector of prime numbers\n  std::vector<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n  // tokenize sentence\n  std::istringstream iss(sentence);\n\
    \  std::vector<std::string> tokens{std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>{}};\n\
    \  for (auto i = 0; i < tokens.size(); i++) {\n    if (std::find(primes.begin(),\
    \ primes.end(), tokens[i].length()) != primes.end()) {\n      new_sentence.append(tokens[i]\
    \ + \" \");\n    }\n  }\n  return new_sentence;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmprivllh_8: /tmp/tmprivllh_8.cpp:34: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code here\n \
    \ std::string output;\n  int count = 0;\n  std::stringstream ss(sentence);\n \
    \ for (std::string word; ss >> word;) {\n    for (int i = 2; i <= word.length();\
    \ i++) {\n      if (word.length() % i == 0) {\n        count++;\n      }\n   \
    \ }\n    if (count == 0) {\n      output += word + \" \";\n    }\n    count =\
    \ 0;\n  }\n  return output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp29f1w0vi: /tmp/tmp29f1w0vi.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string output;\n\
    \  std::string temp;\n  for (auto ch: sentence) {\n    if (ch == ' ') {\n    \
    \  if (is_prime(temp.size())) {\n        output += temp + ' ';\n      }\n    \
    \  temp.clear();\n    } else {\n      temp += ch;\n    }\n  }\n  if (is_prime(temp.size()))\
    \ {\n    output += temp;\n  }\n  if (output.size() == 0) {\n    return output;\n\
    \  }\n  output.pop_back();\n  return output;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcu3q9t6z.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpcu3q9t6z.cpp:22:11: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |       if (is_prime(temp.size())) {\n      |           ^~~~~~~~\n\
    /tmp/tmpcu3q9t6z.cpp:30:7: error: \u2018is_prime\u2019 was not declared in this\
    \ scope\n   30 |   if (is_prime(temp.size())) {\n      |       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string res = \"\
    \";\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n\
    \    std::string token;\n    while (getline(ss, token, ' ')) {\n        words.push_back(token);\n\
    \    }\n    for (int i = 0; i < words.size(); i++) {\n        if (isPrime(words[i].length()))\
    \ {\n            res += words[i] + \" \";\n        }\n    }\n    if (res.length()\
    \ > 0) {\n        res.pop_back();\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvgkz9b40.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpvgkz9b40.cpp:26:13: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   26 |         if (isPrime(words[i].length())) {\n      |     \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n\tstd::vector<std::string>\
    \ words;\n\tstd::string::iterator it = sentence.begin();\n\tstd::string word;\n\
    \twhile (it != sentence.end()) {\n\t\twhile (*it == ' ') {\n\t\t\tit++;\n\t\t\
    }\n\t\twhile (*it != ' ' && it != sentence.end()) {\n\t\t\tword.push_back(*it);\n\
    \t\t\tit++;\n\t\t}\n\t\twords.push_back(word);\n\t\tword.clear();\n\t}\n\tstd::vector<int>\
    \ prime_lengths;\n\tfor (auto i : words) {\n\t\tbool is_prime = true;\n\t\tfor\
    \ (int j = 2; j < i.length(); j++) {\n\t\t\tif (i.length() % j == 0) {\n\t\t\t\
    \tis_prime = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (is_prime) {\n\t\t\
    \tprime_lengths.push_back(i.length());\n\t\t}\n\t}\n\tstd::string result;\n\t\
    for (auto i : words) {\n\t\tfor (auto j : prime_lengths) {\n\t\t\tif (i.length()\
    \ == j) {\n\t\t\t\tresult.append(i);\n\t\t\t\tresult.push_back(' ');\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp8hio2zwm: /tmp/tmp8hio2zwm.cpp:58: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::vector<std::string>\
    \ words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while\
    \ (ss >> word)\n        words.push_back(word);\n    std::string result;\n    for\
    \ (const auto& word : words) {\n        bool is_prime = true;\n        for (int\
    \ i = 2; i < word.size(); ++i) {\n            if (word.size() % i == 0) {\n  \
    \              is_prime = false;\n                break;\n            }\n    \
    \    }\n        if (is_prime)\n            result += word + \" \";\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpapxakbvx: /tmp/tmpapxakbvx.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    // primer numbers\n\
    \    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    std::string res = \"\"\
    ;\n    std::vector<std::string> splited;\n    std::string temp = \"\";\n    for\
    \ (int i = 0; i < sentence.size(); i++) {\n        if (sentence[i] == ' ') {\n\
    \            splited.push_back(temp);\n            temp = \"\";\n        } else\
    \ {\n            temp += sentence[i];\n        }\n    }\n    splited.push_back(temp);\n\
    \    for (int i = 0; i < splited.size(); i++) {\n        if (std::find(primes.begin(),\
    \ primes.end(), splited[i].size()) != primes.end()) {\n            res += splited[i]\
    \ + \" \";\n        }\n    }\n    res.pop_back();\n    return res;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpnwmn97jv: /tmp/tmpnwmn97jv.cpp:47: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool primeFlag = false;\n\
    \    std::vector<std::string> words;\n    std::string toReturn = \"\";\n    std::string\
    \ temp = \"\";\n    for(int i = 0; i < sentence.length(); i++){\n        if(sentence[i]\
    \ == ' '){\n            words.push_back(temp);\n            temp = \"\";\n   \
    \     }\n        else{\n            temp += sentence[i];\n        }\n    }\n \
    \   if(temp != \"\"){\n        words.push_back(temp);\n    }\n    for(int i =\
    \ 0; i < words.size(); i++){\n        int wordLength = words[i].length();\n  \
    \      for(int j = 2; j < wordLength; j++){\n            if(wordLength % j ==\
    \ 0){\n                primeFlag = true;\n                break;\n           \
    \ }\n        }\n        if(!primeFlag){\n            toReturn += words[i] + \"\
    \ \";\n        }\n        primeFlag = false;\n    }\n    return toReturn;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmppdq72oa1: /tmp/tmppdq72oa1.cpp:51: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string result\
    \ = \"\";\n    std::stringstream ss(sentence);\n    std::string buffer;\n    while\
    \ (ss >> buffer) {\n        if (is_prime(buffer.length())) {\n            result\
    \ += buffer + \" \";\n        }\n    }\n    return result.substr(0, result.length()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsutouuu7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpsutouuu7.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(buffer.length())) {\n      |      \
    \       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool prime(int n) {\n\
    \        if (n < 2) {\n            return false;\n        }\n        if (n ==\
    \ 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n     \
    \       return false;\n        }\n        for (int i = 3; i <= sqrt(n); i += 2)\
    \ {\n            if (n % i == 0) {\n                return false;\n          \
    \  }\n        }\n        return true;\n    }\n    std::string s = \"\";\n    std::string\
    \ out = \"\";\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            if (prime(s.length())) {\n                out += s +\
    \ \" \";\n            }\n            s = \"\";\n        } else {\n           \
    \ s += sentence[i];\n        }\n    }\n    if (prime(s.length())) {\n        out\
    \ += s;\n    }\n    return out;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkltakh4t.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpkltakh4t.cpp:18:23: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   18 |     bool prime(int n) {\n      |       \
    \                ^\n/tmp/tmpkltakh4t.cpp:39:17: error: \u2018prime\u2019 was not\
    \ declared in this scope\n   39 |             if (prime(s.length())) {\n     \
    \ |                 ^~~~~\n/tmp/tmpkltakh4t.cpp:47:9: error: \u2018prime\u2019\
    \ was not declared in this scope\n   47 |     if (prime(s.length())) {\n     \
    \ |         ^~~~~\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string res = \"\"\
    ;\n  std::stringstream ss(sentence);\n  int word_num = 0;\n  while(!ss.eof())\
    \ {\n    std::string word;\n    ss >> word;\n    word_num++;\n    int len = word.length();\n\
    \    int flag = 1;\n    for(int i = 2; i < len; i++) {\n      if(len % i == 0)\
    \ {\n        flag = 0;\n        break;\n      }\n    }\n    if(flag) {\n     \
    \ res += word;\n      if(word_num < sentence.length()) {\n        res += \" \"\
    ;\n      }\n    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpdaf2pmf9: /tmp/tmpdaf2pmf9.cpp:44: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    int i, j, res;\n  \
    \  std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string\
    \ temp;\n    while (ss >> temp) {\n        res = 0;\n        for (i = 0; i < temp.length();\
    \ i++) {\n            res += temp[i];\n        }\n        if (res == 2 || res\
    \ == 3 || res == 5 || res == 7 || res == 11 || res == 13 || res == 17 || res ==\
    \ 19 || res == 23 || res == 29 || res == 31 || res == 37 || res == 41 || res ==\
    \ 43 || res == 47 || res == 53 || res == 59 || res == 61 || res == 67 || res ==\
    \ 71 || res == 73 || res == 79 || res == 83 || res == 89 || res == 97) {\n   \
    \         result += temp + \" \";\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp_4okfzy6: /tmp/tmp_4okfzy6.cpp:35: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098950
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  // your code goes here\n\
    \  std::string result = \"\";\n  std::string word = \"\";\n  for (char i : sentence)\
    \ {\n    if (i == ' ') {\n      if (word != \"\") {\n        if (isPrime(word.length()))\
    \ {\n          result += word + \" \";\n        }\n        word = \"\";\n    \
    \  }\n    } else {\n      word += i;\n    }\n  }\n  if (word != \"\") {\n    if\
    \ (isPrime(word.length())) {\n      result += word;\n    }\n  }\n  if (result[result.length()\
    \ - 1] == ' ') {\n    result = result.substr(0, result.length() - 1);\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpimtbcuax.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpimtbcuax.cpp:24:13: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   24 |         if (isPrime(word.length())) {\n      |         \
    \    ^~~~~~~\n/tmp/tmpimtbcuax.cpp:34:9: error: \u2018isPrime\u2019 was not declared\
    \ in this scope\n   34 |     if (isPrime(word.length())) {\n      |         ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string sol = \"\
    \";\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for\
    \ (char c : sentence) {\n        if (c == ' ') {\n            words.push_back(word);\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    words.push_back(word);\n    for (std::string word : words) {\n   \
    \     if (word.length() == 2 || word.length() == 3 || word.length() == 5 || word.length()\
    \ == 7) {\n            sol += word + \" \";\n        }\n    }\n    return sol;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp_7y4voxx: /tmp/tmp_7y4voxx.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string result;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word)\
    \ {\n    int count = 0;\n    for (int i = 1; i <= word.length(); i++) {\n    \
    \  if (word.length() % i == 0) {\n        count++;\n      }\n    }\n    if (count\
    \ == 2) {\n      result += word + \" \";\n    }\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpfk8qlf_w: /tmp/tmpfk8qlf_w.cpp:36: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098950
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::string answer\
    \ = \"\";\n    for (char& c : sentence) {\n        if (c == ' ') {\n         \
    \   c = ',';\n        }\n    }\n    // std::cout << sentence << std::endl;\n \
    \   std::vector<std::string> words = split_str(sentence, ',');\n    for (auto\
    \ i : words) {\n        if (is_prime(i.length())) {\n            answer.append(i);\n\
    \            answer.append(\" \");\n        }\n    }\n    answer.pop_back();\n\
    \    return answer;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwfu35iy6.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpwfu35iy6.cpp:25:38: error: \u2018split_str\u2019 was not declared in\
    \ this scope\n   25 |     std::vector<std::string> words = split_str(sentence,\
    \ ',');\n      |                                      ^~~~~~~~~\n/tmp/tmpwfu35iy6.cpp:27:13:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   27 |        \
    \ if (is_prime(i.length())) {\n      |             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    bool is_prime[1000];\n\
    \    memset(is_prime,true,sizeof(is_prime));\n    for(int i=2;i*i<1000;i++){\n\
    \        if(is_prime[i]){\n            for(int j=i*i;j<1000;j+=i){\n         \
    \       is_prime[j]=false;\n            }\n        }\n    }\n    std::stringstream\
    \ ss(sentence);\n    std::string temp,res;\n    while(ss>>temp){\n        if(is_prime[temp.length()]){\n\
    \            res=res+temp+\" \";\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpuet4li9r: /tmp/tmpuet4li9r.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098950
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n  std::string delimiter\
    \ = \" \";\n  size_t pos = 0;\n  std::string token;\n  std::string final = \"\"\
    ;\n  int a = 0;\n  int b = 0;\n  int c = 0;\n  int i = 0;\n  int count = 0;\n\
    \  while ((pos = sentence.find(delimiter)) != std::string::npos) {\n    token\
    \ = sentence.substr(0, pos);\n    // std::cout << token << std::endl;\n    while\
    \ (i < token.length()) {\n      i++;\n      count++;\n    }\n    //std::cout <<\
    \ count << std::endl;\n    if ((count == 1) || (count == 2) || (count == 3) ||\
    \ (count == 5) || (count == 7) || (count == 11) || (count == 13) || (count ==\
    \ 17) || (count == 19) || (count == 23) || (count == 29) || (count == 31) || (count\
    \ == 37) || (count == 41) || (count == 43) || (count == 47) || (count == 53) ||\
    \ (count == 59) || (count == 61) || (count == 67) || (count == 71) || (count ==\
    \ 73) || (count == 79) || (count == 83) || (count == 89) || (count == 97)) {\n\
    \      final = final + token + \" \";\n    }\n    sentence.erase(0, pos + delimiter.length());\n\
    \    count = 0;\n    i = 0;\n  }\n  token = sentence.substr(0, pos);\n  while\
    \ (i < token.length()) {\n    i++;\n    count++;\n  }\n  if ((count == 1) || (count\
    \ == 2) || (count == 3) || (count == 5) || (count == 7) || (count == 11) || (count\
    \ == 13) || (count == 17) || (count == 19) || (count == 23) || (count == 29) ||\
    \ (count == 31) || (count == 37) || (count == 41) || (count == 43) || (count ==\
    \ 47) || (count == 53) || (count == 59) || (count ==\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe2ppvfsn.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpe2ppvfsn.cpp:48:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   48 | }\n      | ^\n/tmp/tmpe2ppvfsn.cpp:47:317: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   47 |   if ((count == 1) || (count\
    \ == 2) || (count == 3) || (count == 5) || (count == 7) || (count == 11) || (count\
    \ == 13) || (count == 17) || (count == 19) || (count == 23) || (count == 29) ||\
    \ (count == 31) || (count == 37) || (count == 41) || (count == 43) || (count ==\
    \ 47) || (count == 53) || (count == 59) || (count ==\n      |                \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                ~        ^\n\
    \      |                                                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                    )\n   48 | }\n      | ~                                 \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                       \n/tmp/tmpe2ppvfsn.cpp:47:317:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   47 |   if ((count\
    \ == 1) || (count == 2) || (count == 3) || (count == 5) || (count == 7) || (count\
    \ == 11) || (count == 13) || (count == 17) || (count == 19) || (count == 23) ||\
    \ (count == 29) || (count == 31) || (count == 37) || (count == 41) || (count ==\
    \ 43) || (count == 47) || (count == 53) || (count == 59) || (count ==\n      |\
    \      ~                                                             "
  stdout: ''
  timestamp: 1660098950
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example\
    \ 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n\
    // Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n\
    std::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      int w_len = word.length();\n        bool is_prime = true;\n        for\
    \ (int i = 2; i < w_len; i++) {\n            if (w_len % i == 0) {\n         \
    \       is_prime = false;\n                break;\n            }\n        }\n\
    \        if (is_prime) {\n            result += word + \" \";\n        }\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp9q48l0p9: /tmp/tmp9q48l0p9.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098950
