language: cpp
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t//your code here\n\t\
    //return std::nullopt;\n\tif (arr.size() == 0)\n\t\treturn std::nullopt;\n\tlong\
    \ prod = 1;\n\tfor (long i = 0; i < arr.size(); i++)\n\t{\n\t\tif (arr[i] < 0)\n\
    \t\t\tprod *= -1;\n\t\tif (arr[i] == 0)\n\t\t\treturn 0;\n\t}\n\tlong sum = 0;\n\
    \tfor (long i = 0; i < arr.size(); i++)\n\t{\n\t\tsum += std::abs(arr[i]);\n\t\
    }\n\treturn sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum = 0;\n  long product = 1;\n  for (auto& it: arr) {\n\
    \    if (it == 0) continue;\n    if (it > 0) product *= 1;\n    else if (it <\
    \ 0) product *= -1;\n    sum += abs(it);\n  }\n  return sum * product;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpym9gpdj2: /tmp/tmpym9gpdj2.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -8
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum = 0;\n  long prod = 1;\n  for (long i : arr) {\n \
    \   prod *= (i / abs(i));\n    sum += abs(i);\n  }\n  return sum * prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() <\
    \ 1) return std::nullopt;\n    int result = 1;\n    for (auto i : arr) {\n   \
    \     if (i > 0) {\n            result *= 1;\n        } else if (i < 0) {\n  \
    \          result *= -1;\n        } else {\n            result *= 0;\n       \
    \ }\n    }\n    if (result == 0) return 0;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        sum += abs(i);\n    }\n    return sum * result;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size()==0)\
    \ return std::nullopt;\n    long sum=0;\n    long sign_prod=1;\n    for (long\
    \ i=0; i<arr.size(); i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n\
    \        } else if (arr[i] < 0) {\n            sum += -arr[i];\n            sign_prod\
    \ *= -1;\n        } else {\n            sign_prod = 0;\n        }\n    }\n   \
    \ return sum*sign_prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int prod = 1;\n  long sum = 0;\n  for (int i\
    \ = 0; i < arr.size(); i++) {\n    int val = arr[i];\n    if (val == 0) {\n  \
    \    continue;\n    }\n    prod *= val < 0 ? -1 : 1;\n    sum += abs(val);\n \
    \ }\n  return prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpttg_r4bw: /tmp/tmpttg_r4bw.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    int sign_arr[] = {1, -1, 0};\n    int sign_arr_size\
    \ = sizeof(sign_arr)/sizeof(sign_arr[0]);\n    long sum = 0;\n    for (int i =\
    \ 0; i < arr.size(); i++) {\n        for (int j = 0; j < sign_arr_size; j++) {\n\
    \            sum += std::abs(arr[i]) * sign_arr[j];\n        }\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpa8_qfdbi: /tmp/tmpa8_qfdbi.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpqrfmfj8o: /tmp/tmpqrfmfj8o.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() <\
    \ 1) {\n        return std::nullopt;\n    }\n    int res = 1;\n    long sum =\
    \ 0;\n    for (int i : arr) {\n        if (i < 0) {\n            res *= -1;\n\
    \        } else if (i > 0) {\n            res *= 1;\n        } else {\n      \
    \      res *= 0;\n        }\n        sum += std::abs(i);\n    }\n    return sum\
    \ * res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int sign = 1;\n  long sum = 0;\n  for (auto i: arr) {\n   \
    \ if (i == 0) continue;\n    sign *= i > 0 ? 1 : -1;\n    sum += std::abs(i);\n\
    \  }\n  return sum * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp7f18sb3r: /tmp/tmp7f18sb3r.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpb3vcugw8: /tmp/tmpb3vcugw8.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   int zeros = 0;\n    int neg = 0;\n    for (auto num : arr) {\n        if (num\
    \ == 0)\n            zeros++;\n        else if (num < 0)\n            neg++;\n\
    \        sum += std::abs(num);\n    }\n    if (zeros == arr.size())\n        return\
    \ 0;\n    if (neg % 2 == 0)\n        return sum;\n    else\n        return -sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpky5q8_na: /tmp/tmpky5q8_na.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong result = 1;\n\t\
    long sum = 0;\n\tfor (auto element : arr) {\n\t\tif (element > 0) {\n\t\t\tresult\
    \ *= 1;\n\t\t\tsum += element;\n\t\t}\n\t\telse if (element < 0) {\n\t\t\tresult\
    \ *= -1;\n\t\t\tsum += element * -1;\n\t\t}\n\t\telse {\n\t\t\tresult *= 0;\n\t\
    \t}\n\t}\n\tif (arr.size() == 0) {\n\t\treturn std::nullopt;\n\t}\n\treturn result\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  std::vector<long> result;\n  long sign = 1;\n\
    \  for (auto el: arr) {\n    if (el == 0) {\n      sign = 1;\n    } else if (el\
    \ > 0) {\n      sign *= 1;\n    } else {\n      sign *= -1;\n    }\n    result.push_back(std::abs(el));\n\
    \  }\n  return std::accumulate(result.begin(), result.end(), 0) * sign;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpv_o2xzde: /tmp/tmpv_o2xzde.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod\
    \ = 1;\n    for (auto i : arr) {\n        sum += std::abs(i);\n        if (i !=\
    \ 0) {\n            prod *= (i < 0 ? -1 : 1);\n        }\n    }\n    return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmph7_83rmt: /tmp/tmph7_83rmt.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sign_prod = 1;\n  long mag_sum = 0;\n  for (long num :\
    \ arr) {\n    if (num > 0) sign_prod *= 1;\n    else if (num < 0) sign_prod *=\
    \ -1;\n    else if (num == 0) sign_prod *= 0;\n    mag_sum += std::abs(num);\n\
    \  }\n  return sign_prod * mag_sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ret = 0;\n \
    \   long mult = 1;\n    for (size_t i = 0; i < arr.size(); i++) {\n        if\
    \ (arr[i] < 0) {\n            mult *= -1;\n        }\n        ret += arr[i] <\
    \ 0 ? arr[i] * -1 : arr[i];\n    }\n    return ret * mult;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp158e1j1s: /tmp/tmp158e1j1s.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ sum = 0;\n  std::optional<long> prod = 1;\n  for (auto el: arr) {\n    if (el\
    \ < 0) {\n      prod *= -1;\n    } else if (el > 0) {\n      sum += el;\n    }\
    \ else {\n      prod = 0;\n    }\n  }\n  if (sum.has_value()) {\n    return sum.value()\
    \ * prod.value();\n  } else {\n    return std::nullopt;\n  }\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5phqdrgx.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp5phqdrgx.cpp:19:12: error: no match for \u2018operator*=\u2019\
    \ (operand types are \u2018std::optional<long int>\u2019 and \u2018int\u2019)\n\
    \   19 |       prod *= -1;\n      |       ~~~~~^~~~~\n/tmp/tmp5phqdrgx.cpp:21:11:\
    \ error: no match for \u2018operator+=\u2019 (operand types are \u2018std::optional<long\
    \ int>\u2019 and \u2018long int\u2019)\n   21 |       sum += el;\n      |    \
    \   ~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    \n    // your code\
    \ here\n    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgy7lqk6m: /tmp/tmpgy7lqk6m.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::cout << \"Not\
    \ Implemented\" << std::endl;\n  std::optional<long> ret = std::nullopt;\n  return\
    \ ret;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp7__9i8vo: /tmp/tmp7__9i8vo.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: 'Not Implemented

    '
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ < 0) {\n            prod *= -1;\n        }\n        if (arr[i] != 0) {\n   \
    \         sum += abs(arr[i]);\n        }\n    }\n    return prod * sum;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpn95im0lz: /tmp/tmpn95im0lz.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\t// write your code here\n\tint sum = 0;\n\tint signProd\
    \ = 1;\n\tfor (auto num : arr) {\n\t\tif (num < 0)\n\t\t\tsignProd *= -1;\n\t\t\
    sum += abs(num);\n\t}\n\treturn signProd * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmputk8u481: /tmp/tmputk8u481.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    assert(std::is_same<\n\
    \        decltype(prod_signs(arr)),\n        std::optional<long>\n    >::value);\n\
    \    if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    int sign\
    \ = 1;\n    long prod = 1;\n    for (long i : arr) {\n        if (i == 0) {\n\
    \            return 0;\n        }\n        if (i < 0) {\n            sign *= -1;\n\
    \        }\n        prod *= std::abs(i);\n    }\n    return sign * prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz3lmjqbd.cpp:18:13: error: macro \"assert\" passed 2 arguments,\
    \ but takes just 1\n   18 |     >::value);\n      |             ^\nIn file included\
    \ from /usr/include/c++/9/cassert:44,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz3lmjqbd.cpp:2:\n/usr/include/assert.h:92: note:\
    \ macro \"assert\" defined here\n   92 | #  define assert(expr)       \\\n   \
    \   | \n/tmp/tmpz3lmjqbd.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpz3lmjqbd.cpp:15:5: error: \u2018assert\u2019 was not declared\
    \ in this scope\n   15 |     assert(std::is_same<\n      |     ^~~~~~\n/tmp/tmpz3lmjqbd.cpp:3:1:\
    \ note: \u2018assert\u2019 is defined in header \u2018<cassert>\u2019; did you\
    \ forget to \u2018#include <cassert>\u2019?\n    2 | #include<bits/stdc++.h>\n\
    \  +++ |+#include <cassert>\n    3 | // You are given a vector arr of integers\
    \ and you need to return\n"
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\tlong sum = 0;\n\tlong prod = 1;\n\tfor (auto n : arr)\
    \ {\n\t\tif (n == 0)\n\t\t\tcontinue;\n\t\tsum += abs(n);\n\t\tprod *= n > 0 ?\
    \ 1 : -1;\n\t}\n\treturn sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpr0ysb9z2: /tmp/tmpr0ysb9z2.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product=1;\n\
    \    long sum=0;\n    for(int i=0;i<arr.size();i++){\n        product*=signbit(arr[i]);\n\
    \        sum+=abs(arr[i]);\n    }\n    if(arr.size()==0){\n        return std::nullopt;\n\
    \    }\n    else{\n        return sum*product;\n    }\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0ygvgz33.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp0ygvgz33.cpp:18:18: error: \u2018signbit\u2019 was not\
    \ declared in this scope; did you mean \u2018std::signbit\u2019?\n   18 |    \
    \     product*=signbit(arr[i]);\n      |                  ^~~~~~~\n      |   \
    \               std::signbit\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp0ygvgz33.cpp:2:\n/usr/include/c++/9/cmath:677:5:\
    \ note: \u2018std::signbit\u2019 declared here\n  677 |     signbit(_Tp __x)\n\
    \      |     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size()==0)\n\
    \        return std::nullopt;\n    long sum=0;\n    long prod=1;\n    for (auto\
    \ x:arr){\n        sum+=x;\n        if (x!=0)\n            prod*=x/abs(x);\n \
    \   }\n    return sum*prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmppz13b59b: /tmp/tmppz13b59b.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return 0;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpy_ql8nab: /tmp/tmpy_ql8nab.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\telse\n\t{\n\t\tlong sum = 0;\n\t\tlong prod = 1;\n\
    \t\tfor (long num : arr)\n\t\t{\n\t\t\tif (num > 0)\n\t\t\t\tprod *= 1;\n\t\t\t\
    else if (num < 0)\n\t\t\t\tprod *= -1;\n\t\t\telse\n\t\t\t\tprod *= 0;\n\t\t\t\
    sum += std::abs(num);\n\t\t}\n\t\treturn prod * sum;\n\t}\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  // # 2 == 1\n  auto sign = [](auto x) { return\
    \ (x > 0) - (x < 0); };\n  auto prod = std::accumulate(arr.begin(), arr.end(),\
    \ (long)1,\n                              [sign](auto init, auto y) {\n      \
    \                          return init * sign(y);\n                          \
    \    });\n  auto sum = std::accumulate(arr.begin(), arr.end(), (long)0,\n    \
    \                         [](auto init, auto y) {\n                          \
    \     return init + std::abs(y);\n                             });\n  return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    //your code here\n\
    \    long count = 0;\n    long prod = 1;\n    for(int i = 0; i < arr.size(); i++){\n\
    \      if(arr[i] == 0){\n        continue;\n      }\n      count += abs(arr[i]);\n\
    \      if(arr[i] > 0){\n        prod *= 1;\n      }\n      else{\n        prod\
    \ *= -1;\n      }\n    }\n    if(count == 0){\n      return std::nullopt;\n  \
    \  }\n    return count * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpkz91x966: /tmp/tmpkz91x966.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  std::vector<int> signs(arr.size());\n  std::transform(arr.begin(),\
    \ arr.end(), signs.begin(), [](auto num) {\n    return (num > 0) - (num < 0);\n\
    \  });\n  std::vector<int> mags(arr.size());\n  std::transform(arr.begin(), arr.end(),\
    \ mags.begin(), [](auto num) {\n    return std::abs(num);\n  });\n  return std::accumulate(mags.begin(),\
    \ mags.end(), (long)0) *\n         std::accumulate(signs.begin(), signs.end(),\
    \ (long)1,\n                         std::multiplies<long>());\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) prod *= -1;\n       \
    \ if (arr[i] != 0) sum += std::abs(arr[i]);\n    }\n    return sum * prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpxfq3d423: /tmp/tmpxfq3d423.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long pro = 1;\n \
    \   long sum = 0;\n    for(long i = 0; i < arr.size(); i++){\n        if(arr[i]\
    \ < 0){\n            pro *= -1;\n        }\n        if(arr[i] != 0){\n       \
    \     sum += abs(arr[i]);\n        }\n    }\n    if(arr.size() > 0){\n       \
    \ return pro * sum;\n    }\n    else{\n        return std::nullopt;\n    }\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpay_uafeh: /tmp/tmpay_uafeh.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long total\
    \ = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n\
    \            sum += abs(arr[i]);\n            total *= -1;\n        } else if\
    \ (arr[i] > 0) {\n            sum += abs(arr[i]);\n            total *= 1;\n \
    \       } else {\n            total *= 0;\n        }\n    }\n    return sum *\
    \ total;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    } else {\n        long prod = 1;\n \
    \       long sum = 0;\n        for (auto i : arr) {\n            if (i == 0) {\n\
    \                continue;\n            } else if (i > 0) {\n                prod\
    \ *= 1;\n                sum += i;\n            } else {\n                prod\
    \ *= -1;\n                sum += i * -1;\n            }\n        }\n        if\
    \ (prod < 0) {\n            return std::nullopt;\n        } else {\n         \
    \   return prod * sum;\n        }\n    }\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmptxodh2kz: /tmp/tmptxodh2kz.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  long prod = 1;\n  long sum = 0;\n  if(arr.size() == 0) return std::nullopt;\n\
    \  for(long i = 0; i < arr.size(); i++){\n    if(arr[i] > 0) prod *= 1;\n    else\
    \ if(arr[i] < 0) prod *= -1;\n    else prod *= 0;\n    sum += abs(arr[i]);\n \
    \ }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int total = 1;\n  int abs_total = 0;\n  for (auto i : arr)\
    \ {\n    total *= std::signbit(i) ? -1 : 1;\n    abs_total += std::abs(i);\n \
    \ }\n  return total * abs_total;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpl2sib83q: /tmp/tmpl2sib83q.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\tlong prod = 1;\n\tlong sum = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] < 0) {\n\t\t\tprod *= -1;\n\t\t\
    }\n\t\telse if (arr[i] > 0) {\n\t\t\tprod *= 1;\n\t\t}\n\t\telse {\n\t\t\tprod\
    \ *= 0;\n\t\t}\n\t\tsum += abs(arr[i]);\n\t}\n\treturn sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\telse {\n\t\tlong product = 1;\n\t\tlong sum = 0;\n\
    \t\tfor (long i = 0; i < arr.size(); i++) {\n\t\t\tsum += std::abs(arr[i]);\n\t\
    \t\tif (arr[i] != 0)\n\t\t\t\tproduct *= arr[i] / std::abs(arr[i]);\n\t\t}\n\t\
    \treturn sum * product;\n\t}\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpfzdodi03: /tmp/tmpfzdodi03.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpod_j3jx3: /tmp/tmpod_j3jx3.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  long magnitude = 0;\n  for (auto x : arr)\
    \ {\n    magnitude += abs(x);\n    if (x > 0) prod *= 1;\n    else if (x < 0)\
    \ prod *= -1;\n    else if (x == 0) prod *= 0;\n  }\n  return magnitude * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106077
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tint i, len;\n\tlong\
    \ long prod=1, sum=0;\n\tlen = arr.size();\n\tif(len==0)\n\t\treturn std::nullopt;\n\
    \tfor(i=0; i<len; i++)\n\t{\n\t\tif(arr[i]>0)\n\t\t\tprod = prod*1;\n\t\telse\
    \ if(arr[i]<0)\n\t\t\tprod = prod*(-1);\n\t\telse\n\t\t\tprod = prod*0;\n\t\t\
    sum = sum + abs(arr[i]);\n\t}\n\treturn sum*prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code goes here\n\
    \  if(arr.size() == 0) return std::nullopt;\n  long sum = 0;\n  long product =\
    \ 1;\n  for(auto i : arr){\n    if(i > 0)\n      sum += i;\n    else if(i < 0)\n\
    \      sum -= i;\n    if(i != 0)\n      product *= i < 0 ? -1 : 1;\n  }\n  return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp2xqem1fm: /tmp/tmp2xqem1fm.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sumOfMagnitudes = 0;\n  for (int i = 0;\
    \ i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      sumOfMagnitudes += arr[i];\n\
    \    } else if (arr[i] < 0) {\n      sumOfMagnitudes += arr[i] * -1;\n    }\n\
    \  }\n  int productOfSigns = 1;\n  for (int i = 0; i < arr.size(); i++) {\n  \
    \  if (arr[i] > 0) {\n      productOfSigns *= 1;\n    } else if (arr[i] < 0) {\n\
    \      productOfSigns *= -1;\n    } else {\n      productOfSigns *= 0;\n    }\n\
    \  }\n  long ans = sumOfMagnitudes * productOfSigns;\n  return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long ans = 0;\n    long product = 1;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n            product\
    \ *= -1;\n        } else if (arr[i] == 0) {\n            product = 0;\n      \
    \      ans = 0;\n            break;\n        }\n        ans += std::abs(arr[i]);\n\
    \    }\n    return product * ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106077
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    long prod\
    \ = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n\
    \            prod *= -1;\n        }\n        if (arr[i] != 0) {\n            sum\
    \ += abs(arr[i]);\n        }\n    }\n    return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp_jeefr83: /tmp/tmp_jeefr83.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int p = 1;\n  int sum = 0;\n  for (auto i : arr) {\n    p *=\
    \ i == 0 ? 1 : (i < 0 ? -1 : 1);\n    sum += abs(i);\n  }\n  return p * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpr91f7n2v: /tmp/tmpr91f7n2v.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t\n  if(arr.size() ==\
    \ 0) return std::nullopt;\n  long acc = 0;\n  for(int i = 0; i < arr.size(); i++){\n\
    \    int sign = 1;\n    if(arr[i] > 0) sign = 1;\n    else if(arr[i] < 0) sign\
    \ = -1;\n    else sign = 0;\n    acc += std::abs(arr[i]) * sign;\n  }\n  return\
    \ acc;\n  \n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpl36c86dq: /tmp/tmpl36c86dq.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  else{\n    // int total = 0;\n    int prod_signs\
    \ = 1;\n    for (int i = 0; i < arr.size(); i++) {\n      // total += std::abs(arr[i]);\n\
    \      if (arr[i] < 0) {\n        prod_signs *= -1;\n      }\n      else if (arr[i]\
    \ > 0) {\n        prod_signs *= 1;\n      }\n      else{\n        prod_signs *=\
    \ 0;\n      }\n    }\n    long total = std::accumulate(arr.begin(), arr.end(),\
    \ 0, [](auto &a, auto &b) {\n      return std::abs(a) + std::abs(b);\n    });\n\
    \    return total * prod_signs;\n  }\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  \tif(arr.size() ==\
    \ 0)\n      return std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for(long\
    \ i = 0; i < arr.size(); i++)\n  {\n    if(arr[i] == 0)\n      continue;\n   \
    \ else if(arr[i] > 0)\n      product *= 1;\n    else\n      product *= -1;\n \
    \   \n    sum += abs(arr[i]);\n  }\n  return sum * product;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpw7uq11gf: /tmp/tmpw7uq11gf.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\tlong sum = 0;\n\tlong prod = 1;\n\tfor (auto\
    \ num : arr) {\n\t\tif (num > 0) {\n\t\t\tsum += num;\n\t\t\tprod *= 1;\n\t\t\
    } else if (num < 0) {\n\t\t\tsum += -num;\n\t\t\tprod *= -1;\n\t\t} else {\n\t\
    \t\tprod *= 0;\n\t\t}\n\t}\n\tif (prod == 0) {\n\t\treturn 0;\n\t}\n\treturn sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong long sum = 0;\n\
    \tlong long prod = 1;\n\tfor (long long i = 0; i < arr.size(); i++) {\n\t\tlong\
    \ long abs_val = abs(arr[i]);\n\t\tsum += abs_val;\n\t\tif (arr[i] != 0) {\n\t\
    \t\tprod *= arr[i] / abs_val;\n\t\t}\n\t}\n\treturn sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpdclmwu17: /tmp/tmpdclmwu17.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (long number : arr) {\n        if (number > 0) {\n           \
    \ product *= 1;\n        } else if (number < 0) {\n            product *= -1;\n\
    \        } else {\n            product *= 0;\n        }\n        sum += std::abs(number);\n\
    \    }\n    return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long result = 0;\n    long signs\
    \ = 1;\n    for (auto& i : arr) {\n        result += abs(i);\n        if (i <\
    \ 0) {\n            signs *= -1;\n        }\n    }\n    return result * signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmphf82e_r2: /tmp/tmphf82e_r2.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long prod = 1;\n  for (auto it = arr.begin();\
    \ it != arr.end(); ++it) {\n    if (*it > 0) {\n      prod *= 1;\n    } else if\
    \ (*it < 0) {\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n\
    \  long sum = 0;\n  for (auto it = arr.begin(); it != arr.end(); ++it) {\n   \
    \ sum += abs(*it);\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n   if(arr.size()==0)\n\
    \   {\n       return std::nullopt;\n   }\n   int product=1;\n   long sum=0;\n\
    \   for(int i=0;i<arr.size();i++)\n   {\n       if(arr[i]<0)\n       {\n     \
    \      product*=-1;\n       }\n       if(arr[i]!=0)\n       {\n           sum+=abs(arr[i]);\n\
    \       }\n   }\n   return sum*product;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpdncc5rrx: /tmp/tmpdncc5rrx.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long count = 0;\n\
    \    long prod = 1;\n    if (arr.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    for (long element : arr) {\n        if (element == 0) {\n        \
    \    prod = 0;\n            break;\n        }\n        if (element < 0) {\n  \
    \          count++;\n        }\n        if (count % 2 == 0) {\n            prod\
    \ = 1;\n        } else {\n            prod = -1;\n        }\n    }\n    long sum\
    \ = 0;\n    for (long element : arr) {\n        if (element != 0) {\n        \
    \    sum += std::abs(element);\n        }\n    }\n    return prod * sum;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code goes here\n\
    \  if(arr.size() == 0)\n    return std::nullopt;\n  std::vector<long> signs;\n\
    \  for(long i = 0; i < arr.size(); i++)\n  {\n    if(arr[i] == 0)\n      signs.push_back(0);\n\
    \    else if(arr[i] > 0)\n      signs.push_back(1);\n    else\n      signs.push_back(-1);\n\
    \  }\n  long prod = 1;\n  for(long i = 0; i < signs.size(); i++)\n    prod *=\
    \ signs[i];\n  long sum = 0;\n  for(long i = 0; i < arr.size(); i++)\n    sum\
    \ += abs(arr[i]);\n  return sum * prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tint flag = 1;\n\tlong\
    \ sum = 0;\n\tint len = arr.size();\n\tif (len == 0)\n\t\treturn std::nullopt;\n\
    \tfor (auto x : arr) {\n\t\tif (x < 0)\n\t\t\tflag *= -1;\n\t\tsum += abs(x);\n\
    \t}\n\treturn sum * flag;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp33ygffir: /tmp/tmp33ygffir.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long long ans = 1;\n  for (auto i : arr) {\n\
    \    ans *= (i ? (i > 0 ? 1 : -1) : 0);\n  }\n  return std::abs(ans);\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpuplh6muq: /tmp/tmpuplh6muq.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int negative_counter\
    \ = 0;\n  long sum = 0;\n  if (arr.size() == 0) {\n    return std::nullopt;\n\
    \  }\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n     \
    \ return 0;\n    }\n    if (arr[i] < 0) {\n      negative_counter++;\n    }\n\
    \    sum += std::abs(arr[i]);\n  }\n  if (negative_counter % 2 == 0) {\n    return\
    \ sum;\n  } else {\n    return sum * -1;\n  }\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for (auto e : arr) {\n \
    \   if (e != 0) {\n      prod *= e > 0 ? 1 : -1;\n      sum += std::abs(e);\n\
    \    }\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmparit0abo: /tmp/tmparit0abo.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() > 0)\
    \ {\n\t\tlong sign = 0;\n\t\tlong sum = 0;\n\t\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\t\tif (arr[i] > 0) {\n\t\t\t\tsign += 1;\n\t\t\t}\n\t\t\telse if\
    \ (arr[i] < 0) {\n\t\t\t\tsign -= 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsign += 0;\n\
    \t\t\t}\n\t\t\tsum += std::abs(arr[i]);\n\t\t}\n\t\treturn sign * sum;\n\t}\n\t\
    else {\n\t\treturn std::nullopt;\n\t}\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpziq62vzv: /tmp/tmpziq62vzv.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::sort(arr.begin(),\
    \ arr.end());\n    std::map<long, int> m;\n    for (auto& i : arr)\n        m[i]++;\n\
    \    long product = 1;\n    for (auto& i : m) {\n        if (i.first == 0)\n \
    \           continue;\n        if (i.first > 0) {\n            product *= std::pow(i.first,\
    \ i.second);\n        } else {\n            product *= std::pow(-i.first, i.second);\n\
    \        }\n    }\n    return product;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpm2chdenv: /tmp/tmpm2chdenv.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    std::vector<int> signs;\n   \
    \ for (long a : arr) {\n        signs.push_back(a > 0 ? 1 : a < 0 ? -1 : 0);\n\
    \    }\n    // int sign_prod = std::accumulate(signs.begin(), signs.end(), 1,\
    \ std::multiplies<>());\n    int sign_prod = std::accumulate(signs.begin(), signs.end(),\
    \ 1, [](int x, int y) { return x * y; });\n    long mag_sum = std::accumulate(arr.begin(),\
    \ arr.end(), 0, [](long a, long b) { return a + std::abs(b); });\n    return mag_sum\
    \ * sign_prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int zeroes = 0;\n \
    \ int neg = 0;\n  int pos = 0;\n  long prod = 1;\n  long total = 0;\n  if (arr.size()\
    \ == 0)\n    return std::nullopt;\n  for (long i = 0; i < arr.size(); i++) {\n\
    \    if (arr[i] == 0) {\n      zeroes++;\n    } else if (arr[i] < 0) {\n     \
    \ prod *= -1;\n      neg++;\n    } else {\n      pos++;\n    }\n    total += std::abs(arr[i]);\n\
    \  }\n  if (neg % 2 == 0) {\n    return total * prod;\n  } else {\n    return\
    \ total * prod * -1;\n  }\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpoqmlnzih: /tmp/tmpoqmlnzih.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  \n  if(arr.size() ==\
    \ 0)\n    return std::nullopt;\n  long sum = 0;\n  long prod = 1;\n  for(int i\
    \ = 0; i < arr.size(); i++)\n  {\n    if(arr[i] == 0)\n      return 0;\n    else\
    \ if(arr[i] > 0)\n      prod *= 1;\n    else if(arr[i] < 0)\n      prod *= -1;\n\
    \  }\n  for(int i = 0; i < arr.size(); i++)\n  {\n    sum += abs(arr[i]);\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    int cnt = 0;\n    for (long &\
    \ i : arr) {\n        if (i != 0) {\n            i = i/abs(i);\n            cnt\
    \ += 1;\n        }\n    }\n    if (cnt == 0) {\n        return 0;\n    }\n   \
    \ long prod = 1;\n    for (long i : arr) {\n        prod *= i;\n    }\n    return\
    \ (std::accumulate(arr.begin(), arr.end(), 0,\n        [](long a, long b) { return\
    \ a + abs(b); })) * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmprzq2_vvh: /tmp/tmprzq2_vvh.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\tlong prod = 1;\n\tlong sum = 0;\n\tfor (int i = 0;\
    \ i < arr.size(); i++) {\n\t\tif (arr[i] == 0)\n\t\t\tcontinue;\n\t\tsum += abs(arr[i]);\n\
    \t\tif (arr[i] < 0)\n\t\t\tprod *= -1;\n\t}\n\treturn sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpconfqvxd: /tmp/tmpconfqvxd.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (long\
    \ el : arr) {\n        if (el > 0) {\n            prod *= 1;\n            sum\
    \ += el;\n        } else if (el < 0) {\n            prod *= -1;\n            sum\
    \ += abs(el);\n        } else {\n            prod *= 0;\n        }\n    }\n  \
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\tint sign = 1;\n\tint sum = 0;\n\tfor (int i = 0; i\
    \ < arr.size(); i++) {\n\t\tif (arr[i] < 0)\n\t\t\tsign *= -1;\n\t\telse if (arr[i]\
    \ == 0)\n\t\t\tsign = 0;\n\t\tsum += std::abs(arr[i]);\n\t}\n\treturn sign * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tstd::optional<long>\
    \ result;\n\tif (arr.size() == 0)\n\t\treturn result;\n\telse {\n\t\tresult =\
    \ 1;\n\t\tfor (long i = 0; i < arr.size(); i++) {\n\t\t\tif (arr[i] < 0)\n\t\t\
    \t\t*result *= -1;\n\t\t\tif (arr[i] != 0)\n\t\t\t\t*result *= abs(arr[i]);\n\t\
    \t}\n\t\treturn result;\n\t}\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpb7kjuijy: /tmp/tmpb7kjuijy.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size()==0)\
    \ return std::nullopt;\n    int product = 1;\n    int sum = 0;\n    for (auto\
    \ i = arr.begin(); i != arr.end(); i++) {\n        if (*i < 0) product *= -1;\n\
    \        sum += std::abs(*i);\n    }\n    return product * sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpg5y_ubkt: /tmp/tmpg5y_ubkt.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  std::vector<long> signs;\n  long magnitudes = 0;\n  for (auto\
    \ const &i : arr) {\n    if (i > 0) {\n      signs.push_back(1);\n      magnitudes\
    \ += i;\n    } else if (i < 0) {\n      signs.push_back(-1);\n      magnitudes\
    \ += i * -1;\n    } else if (i == 0) {\n      signs.push_back(0);\n    }\n  }\n\
    \  long product = 1;\n  for (auto const &i : signs) {\n    product *= i;\n  }\n\
    \  return product * magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum = 0;\n    long prod = 1;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        long item = arr[i];\n        if (item\
    \ == 0) continue;\n        if (item < 0) prod *= -1;\n        sum += std::abs(item);\n\
    \    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp0t3odnk1: /tmp/tmp0t3odnk1.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long product = 1;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] == 0) {\n            return\
    \ 0;\n        }\n        product *= arr[i] > 0 ? 1 : -1;\n    }\n    long magnitude\
    \ = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        magnitude += std::abs(arr[i]);\n\
    \    }\n    return magnitude * product;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sign_prod = 1;\n    long\
    \ abs_sum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        // sign of\
    \ this number\n        int sign = (arr[i] < 0) ? -1 : ((arr[i] > 0) ? 1 : 0);\n\
    \        // we need to flip sign_prod every time we encounter\n        // a negative\
    \ number. By default it is 1\n        if (sign == -1) {\n            sign_prod\
    \ *= -1;\n        }\n        // we take the absolute value and add it to sum\n\
    \        abs_sum += std::abs(arr[i]);\n    }\n    return abs_sum * sign_prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpdts15ue0: /tmp/tmpdts15ue0.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod\
    \ = 1;\n    for (long e : arr) {\n        if (e > 0) {\n            sum += e;\n\
    \            prod *= 1;\n        } else if (e < 0) {\n            sum += -e;\n\
    \            prod *= -1;\n        } else {\n            prod *= 0;\n        }\n\
    \    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long signs_product\
    \ = 1;\n    long result = 0;\n    for (long x : arr) {\n        switch (x > 0)\
    \ {\n            case 0:\n                switch (x == 0) {\n                \
    \    case 0:\n                        signs_product *= -1;\n                 \
    \       break;\n                    case 1:\n                        break;\n\
    \                }\n                break;\n            case 1:\n            \
    \    signs_product *= 1;\n                break;\n        }\n        result +=\
    \ abs(x);\n    }\n    if (result == 0) {\n        return std::nullopt;\n    }\n\
    \    return result * signs_product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpy__mhzvl: /tmp/tmpy__mhzvl.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    int sign =\
    \ 1;\n    for (const auto& e : arr) {\n        if (e == 0) {\n            sign\
    \ = 0;\n            break;\n        }\n        if (e < 0) {\n            sign\
    \ *= -1;\n        }\n        sum += abs(e);\n    }\n    return sum * sign;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum_of_magnitudes = 0;\n\
    \    long product_of_signs = 1;\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] == 0) {\n            continue;\n        }\n        sum_of_magnitudes\
    \ += std::abs(arr[i]);\n        product_of_signs *= (arr[i] > 0) ? 1 : -1;\n \
    \   }\n    long value = product_of_signs * sum_of_magnitudes;\n    return value;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp0tnet5s9: /tmp/tmp0tnet5s9.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  if(arr.size() == 0) return std::nullopt;\n  long sum = 0;\n  long prod = 1;\n\
    \  for(auto i : arr){\n    if(i == 0) continue;\n    sum += std::abs(i);\n   \
    \ prod *= i < 0 ? -1 : 1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmptyj50mzo: /tmp/tmptyj50mzo.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106080
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    for (auto el : arr) {\n        prod *= el == 0 ? 1 : el > 0 ? 1 :\
    \ -1;\n        sum += std::abs(el);\n    }\n    return prod * sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp_5t3c58f: /tmp/tmp_5t3c58f.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int sum = 0;\n  long product = 1;\n  for (auto el: arr) {\n\
    \    if (el == 0) {\n      product = 0;\n      break;\n    }\n    if (el > 0)\
    \ {\n      product *= 1;\n    } else {\n      product *= -1;\n    }\n    sum +=\
    \ std::abs(el);\n  }\n  return product * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (auto elem : arr) {\n        if (elem == 0) {\n            continue;\n\
    \        }\n        sum += std::abs(elem);\n        product *= elem < 0 ? -1 :\
    \ 1;\n    }\n    return sum * product;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpbp4s5e_q: /tmp/tmpbp4s5e_q.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long sum = 0;\n  for (long\
    \ number : arr) {\n    if (number > 0) {\n      product *= 1;\n    } else if (number\
    \ < 0) {\n      product *= -1;\n    } else {\n      product *= 0;\n    }\n   \
    \ sum += std::abs(number);\n  }\n  return sum * product;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  long\
    \ prod = 1;\n  int count = 0;\n  for (int i = 0; i < arr.size(); i++) {\n    sum\
    \ += std::abs(arr[i]);\n    prod *= arr[i] < 0 ? -1 : arr[i] > 0 ? 1 : 0;\n  \
    \  if (arr[i] == 0) {\n      count++;\n    }\n  }\n  if (count == arr.size())\
    \ {\n    return std::nullopt;\n  }\n  return sum * prod;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  std::vector<long> is_zero;\n  for (auto const &val : arr) {\n\
    \    if (val == 0) {\n      is_zero.push_back(val);\n    }\n  }\n  if (is_zero.size()\
    \ == arr.size()) return 0;\n  long res = 1;\n  for (auto const &val : arr) {\n\
    \    if (val > 0) {\n      res *= 1;\n    } else if (val < 0) {\n      res *=\
    \ -1;\n    }\n  }\n  long res2 = 0;\n  for (auto const &val : arr) {\n    res2\
    \ += std::abs(val);\n  }\n  return res * res2;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpbewp271v: /tmp/tmpbewp271v.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum_magnitudes = 0;\n    long prod_signs =\
    \ 1;\n    for (auto num : arr) {\n        sum_magnitudes += std::abs(num);\n \
    \       if (num > 0) prod_signs *= 1;\n        else if (num < 0) prod_signs *=\
    \ -1;\n        else prod_signs *= 0;\n    }\n    return sum_magnitudes * prod_signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    product *= std::signbit(arr[i]) ? -1 : 1;\n    sum += std::abs(arr[i]);\n\
    \  }\n  return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp8d10e3jq: /tmp/tmp8d10e3jq.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum = 0;\n  long product = 1;\n  for (auto v : arr) {\n\
    \    if (v < 0) {\n      product *= -1;\n    } else if (v > 0) {\n      sum +=\
    \ v;\n    }\n  }\n  return sum * product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp0ikds2hp: /tmp/tmp0ikds2hp.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\tlong sum = 0;\n\tlong sign_prod = 1;\n\t\
    for (long i = 0; i < arr.size(); i++) {\n\t\tsum += std::abs(arr[i]);\n\t\tsign_prod\
    \ *= arr[i] < 0 ? -1 : arr[i] > 0 ? 1 : 0;\n\t}\n\treturn sum * sign_prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106081
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\tlong sum = 0;\n\tlong prod = 1;\n\tfor (auto x : arr)\
    \ {\n\t\tsum += abs(x);\n\t\tif (x > 0)\n\t\t\tprod *= 1;\n\t\telse if (x < 0)\n\
    \t\t\tprod *= -1;\n\t\telse\n\t\t\tprod *= 0;\n\t}\n\treturn sum * prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106082
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sgn = 1;\n    long sum = 0;\n    for (auto\
    \ n : arr) {\n        if (n != 0) {\n            sgn *= n < 0 ? -1 : 1;\n    \
    \        sum += abs(n);\n        }\n    }\n    return sum * sgn;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmppgeme2bv: /tmp/tmppgeme2bv.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    for (auto item : arr) {\n        sum += std::abs(item);\n\
    \        if (item < 0) prod *= -1;\n    }\n    if (sum == 0) return std::nullopt;\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp_fbzx6pn: /tmp/tmp_fbzx6pn.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long size = arr.size();\n\
    \  if (size == 0) {\n    return std::nullopt;\n  }\n  long sign_product = 1;\n\
    \  long sum_of_magnitudes = 0;\n  for (auto n : arr) {\n    sign_product *= (n\
    \ > 0) - (n < 0);\n    sum_of_magnitudes += abs(n);\n  }\n  return sign_product\
    \ * sum_of_magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106082
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long ret = 0;\n  int\
    \ size = arr.size();\n  if (size == 0) {\n    return std::nullopt;\n  }\n  long\
    \ product = 1;\n  for (int i = 0; i < size; i++) {\n    if (arr[i] > 0) {\n  \
    \    product *= 1;\n    } else if (arr[i] < 0) {\n      product *= -1;\n    }\
    \ else {\n      product *= 0;\n    }\n    if (arr[i] != 0) {\n      ret += std::abs(arr[i]);\n\
    \    }\n  }\n  return product * ret;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106082
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long sum = 0;\n  for (long&\
    \ elem : arr) {\n    sum += std::abs(elem);\n    if (elem == 0) {\n      continue;\n\
    \    }\n    if (elem > 0) {\n      product *= 1;\n    } else {\n      product\
    \ *= -1;\n    }\n  }\n  return sum * product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpa74u_6fg: /tmp/tmpa74u_6fg.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (auto\
    \ elem : arr) {\n        if (elem > 0) prod *= 1;\n        else if (elem < 0)\
    \ prod *= -1;\n        else prod *= 0;\n        sum += std::abs(elem);\n    }\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum = 0;\n    long prod = 1;\n    for (long\
    \ num : arr) {\n        if (num == 0) continue;\n        sum += abs(num);\n  \
    \      prod *= num/abs(num);\n    }\n    return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpz5xi8q1n: /tmp/tmpz5xi8q1n.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpod_j3jx3: /tmp/tmpod_j3jx3.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sumOfMagnitudes = 0;\n \
    \   long productOfSigns = 1;\n    for (int i = 0; i < arr.size(); i++) {\n   \
    \     long currentElement = arr[i];\n        if (currentElement > 0) {\n     \
    \       sumOfMagnitudes += currentElement;\n        } else if (currentElement\
    \ < 0) {\n            sumOfMagnitudes += (-1 * currentElement);\n            productOfSigns\
    \ *= -1;\n        }\n    }\n    return sumOfMagnitudes * productOfSigns;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmptkhw50vy: /tmp/tmptkhw50vy.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    int prod = 1;\n    long sum =\
    \ 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n\
    \            prod *= -1;\n        }\n        if (arr[i] != 0) {\n            sum\
    \ += abs(arr[i]);\n        }\n    }\n    return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp9rgi2bmj: /tmp/tmp9rgi2bmj.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code goes\
    \ here\n    if(arr.size()==0)\n        return std::nullopt;\n    long sum = 0;\n\
    \    long prod = 1;\n    for(long i = 0; i < arr.size(); i++)\n    {\n       \
    \ sum += abs(arr[i]);\n        if(arr[i] != 0)\n            prod *= arr[i]/abs(arr[i]);\n\
    \    }\n    return sum*prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp27e4_aib: /tmp/tmp27e4_aib.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  std::vector<long> calcArr = arr;\n  std::sort(calcArr.begin(),\
    \ calcArr.end());\n  long total = 1;\n  long product = 1;\n  auto calcFunc = [&](auto\
    \ val) {\n    if (val < 0) {\n      product *= -1;\n      val *= -1;\n    }\n\
    \    total += val;\n  };\n  std::for_each(calcArr.begin(), calcArr.end(), calcFunc);\n\
    \  return total * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpo1d5lxhf: /tmp/tmpo1d5lxhf.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code goes\
    \ here\n    if(arr.size()==0)\n        return {};\n    long sum = 0;\n    long\
    \ pro = 1;\n    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=0)\n\
    \        {\n            sum += abs(arr[i]);\n            if(arr[i]>0)\n      \
    \          pro *= 1;\n            else\n                pro *= -1;\n        }\n\
    \    }\n    return sum*pro;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgaz7swqe: /tmp/tmpgaz7swqe.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long pro = 1;\n    long sum =\
    \ 0;\n    for (auto a : arr) {\n        if (a != 0) {\n            pro *= a /\
    \ abs(a);\n            sum += abs(a);\n        }\n    }\n    return pro * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp_wrrj9pq: /tmp/tmp_wrrj9pq.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long prod_signs = 1;\n    long\
    \ sum_magnitudes = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        sum_magnitudes\
    \ += std::abs(arr[i]);\n        prod_signs *= arr[i] > 0 ? 1 : arr[i] < 0 ? -1\
    \ : 0;\n    }\n    return sum_magnitudes * prod_signs;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // TODO: implement\
    \ this\n  return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpll996964: /tmp/tmpll996964.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long prod = 1;\n    long sum\
    \ = 0;\n    for (auto x : arr) {\n        if (x == 0) {\n            continue;\n\
    \        }\n        if (x > 0) {\n            prod *= 1;\n        } else {\n \
    \           prod *= -1;\n        }\n        sum += std::abs(x);\n    }\n    return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpcqe_jat4: /tmp/tmpcqe_jat4.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long result = 0;\n  for (auto i : arr) {\n \
    \   if (i == 0) {\n      continue;\n    }\n    result += std::abs(i);\n  }\n \
    \ if (std::all_of(arr.begin(), arr.end(), [](int i) { return i > 0; })) {\n  \
    \  return result;\n  }\n  if (std::all_of(arr.begin(), arr.end(), [](int i) {\
    \ return i < 0; })) {\n    return -result;\n  }\n  return 0;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpa_j4o54d: /tmp/tmpa_j4o54d.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 0;\n  long sum = 0;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] == 0)\n      continue;\n    else if (arr[i] > 0)\n  \
    \    prod++;\n    else\n      prod--;\n    sum += std::abs(arr[i]);\n  }\n  return\
    \ prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp6b2ldxtx: /tmp/tmp6b2ldxtx.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\tint sum = 0;\n\tint product = 1;\n\tfor (int i = 0;\
    \ i < arr.size(); i++) {\n\t\tsum += abs(arr[i]);\n\t\tif (arr[i] > 0)\n\t\t\t\
    product *= 1;\n\t\telse if (arr[i] < 0)\n\t\t\tproduct *= -1;\n\t\telse\n\t\t\t\
    product *= 0;\n\t}\n\treturn sum * product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t// your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpfaz0_9d2: /tmp/tmpfaz0_9d2.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\treturn {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgbh1h0t5: /tmp/tmpgbh1h0t5.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    if (arr.size() == 1) {\n    \
    \    if (arr[0] == 0) {\n            return 0;\n        }\n        return arr[0];\n\
    \    }\n    long sum_magnitudes = 0;\n    int sign_of_all = 1;\n    for (long\
    \ num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n  \
    \      sign_of_all *= num > 0 ? 1 : -1;\n        sum_magnitudes += abs(num);\n\
    \    }\n    return sum_magnitudes * sign_of_all;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long result = 0;\n    for (auto i : arr) {\n  \
    \      result += std::abs(i);\n    }\n    for (auto i : arr) {\n        if (i\
    \ == 0) {\n            result = 0;\n            break;\n        }\n        else\
    \ if (i < 0) {\n            result *= -1;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product_signs = 1;\n  long sum_magnitudes\
    \ = 0;\n  for (auto const &num : arr) {\n    sum_magnitudes += std::abs(num);\n\
    \    product_signs *= num < 0 ? -1 : num > 0 ? 1 : 0;\n  }\n  return sum_magnitudes\
    \ * product_signs;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_signs\
    \ = 1;\n  for (auto e : arr) {\n    sum_magnitudes += std::abs(e);\n    if (e\
    \ < 0) {\n      product_signs *= -1;\n    } else if (e > 0) {\n      product_signs\
    \ *= 1;\n    }\n  }\n  return sum_magnitudes * product_signs;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp44ppkdyy: /tmp/tmp44ppkdyy.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\tlong sum = 0;\n\tlong product = 1;\n\tfor (auto i\
    \ = arr.begin(); i != arr.end(); i++) {\n\t\tif (*i > 0)\n\t\t\tproduct *= 1;\n\
    \t\telse if (*i < 0)\n\t\t\tproduct *= -1;\n\t\telse\n\t\t\tproduct *= 0;\n\t\t\
    sum += std::abs(*i);\n\t}\n\treturn sum * product;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long prod = 1;\n  long magnitude = 0;\n  for\
    \ (auto i = arr.begin(); i != arr.end(); i++) {\n    if (*i > 0) {\n      prod\
    \ *= 1;\n    } else if (*i < 0) {\n      prod *= -1;\n    } else {\n      prod\
    \ *= 0;\n    }\n    magnitude += std::abs(*i);\n  }\n  long res = prod * magnitude;\n\
    \  return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size()==0)\
    \ return std::nullopt;\n    long product=1;\n    long sum=0;\n    for (int i=0;\
    \ i<arr.size(); i++){\n        product*=sgn(arr[i]);\n        sum+=abs(arr[i]);\n\
    \    }\n    return sum*product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8yjdh8u8.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp8yjdh8u8.cpp:19:18: error: \u2018sgn\u2019 was not declared\
    \ in this scope; did you mean \u2018sin\u2019?\n   19 |         product*=sgn(arr[i]);\n\
    \      |                  ^~~\n      |                  sin\n"
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    //your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmph57clo8s: /tmp/tmph57clo8s.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long mag = 0;\n  long signs = 1;\n  for (auto\
    \ x : arr) {\n    if (x == 0) {\n      return 0;\n    }\n    mag += std::abs(x);\n\
    \    signs *= x > 0 ? 1 : -1;\n  }\n  return mag * signs;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpqrfmfj8o: /tmp/tmpqrfmfj8o.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\telse\n\t{\n\t\t//mag = abs\n\t\tlong magnitudes =\
    \ 0;\n\t\tlong sign = 1;\n\t\tfor (int i = 0; i < arr.size(); i++)\n\t\t{\n\t\t\
    \tif (arr[i] == 0)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmagnitudes\
    \ += abs(arr[i]);\n\t\t\t\tsign *= arr[i] < 0 ? -1 : 1;\n\t\t\t}\n\t\t}\n\t\t\
    return magnitudes * sign;\n\t}\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong product = 1;\n\
    \tlong sum = 0;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0)\n\
    \t\t\tproduct *= 1;\n\t\telse if (arr[i] < 0)\n\t\t\tproduct *= -1;\n\t\telse\n\
    \t\t\tproduct *= 0;\n\t\tsum += abs(arr[i]);\n\t}\n\tif (product == 0)\n\t\treturn\
    \ std::nullopt;\n\treturn product * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmplga4xpd3: /tmp/tmplga4xpd3.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod\
    \ = 1;\n    for (auto it = arr.begin(); it != arr.end(); it++) {\n        if (*it\
    \ > 0) {\n            sum += *it;\n            prod *= 1;\n        } else if (*it\
    \ < 0) {\n            sum += *it * -1;\n            prod *= -1;\n        } else\
    \ {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum = 0;\n    long prod = 1;\n    for (auto\
    \ x : arr) {\n        if (x == 0) continue;\n        sum += std::abs(x);\n   \
    \     prod *= (x < 0 ? -1 : 1);\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp2g3gsw0o: /tmp/tmp2g3gsw0o.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::vector<int>\
    \ signs(arr.size());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ > 0) {\n            signs[i] = 1;\n        } else if (arr[i] < 0) {\n      \
    \      signs[i] = -1;\n        } else {\n            signs[i] = 0;\n        }\n\
    \    }\n    long prod = 1;\n    long sum = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        prod *= signs[i];\n        sum += abs(arr[i]);\n    }\n    return\
    \ prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpeg0shj24: /tmp/tmpeg0shj24.cpp:38: int main(): Assertion `candidate((std::vector<long>()))
    == std::nullopt'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    int n = arr.size();\n    if(n == 0)\n        return std::nullopt;\n\
    \    for(auto i : arr){\n        if(i == 0)\n            continue;\n        sum\
    \ += std::abs(i);\n        if(i > 0)\n            prod *= 1;\n        else\n \
    \           prod *= -1;\n    }\n    return sum * prod;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpzto5s9gp: /tmp/tmpzto5s9gp.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int count_of_neg = 0;\n  int count_of_zero =\
    \ 0;\n  int i = 0;\n  int prod = 1;\n  long sum = 0;\n  while (i < arr.size())\
    \ {\n    if (arr[i] < 0) {\n      count_of_neg++;\n      prod *= -1;\n    } else\
    \ if (arr[i] == 0) {\n      count_of_zero++;\n    }\n    sum += std::abs(arr[i]);\n\
    \    i++;\n  }\n  return sum * (count_of_neg % 2 == 0 ? 1 : -1) * (count_of_zero\
    \ > 0 ? 0 : 1);\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpod_j3jx3: /tmp/tmpod_j3jx3.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106078
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here\n\
    \    if(arr.size()==0)\n        return std::nullopt;\n    int a=0;\n    int prod=1;\n\
    \    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]<0)\n        {\n \
    \           a-=arr[i];\n            prod*=-1;\n        }\n        else if(arr[i]>0)\n\
    \        {\n            a+=arr[i];\n        }\n        else if(arr[i]==0)\n  \
    \      {\n            return 0;\n        }\n    }\n    return a*prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum = 0;\n  long pro = 1;\n  for (auto a : arr) {\n  \
    \  if (a < 0) pro *= -1;\n    sum += std::abs(a);\n  }\n  return sum * pro;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpwqgorchj: /tmp/tmpwqgorchj.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return 0;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpkjt8u3cy: /tmp/tmpkjt8u3cy.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  long\
    \ product = 1;\n  if (arr.size()==0) {\n    return std::nullopt;\n  }\n  for (long\
    \ i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n      continue;\n   \
    \ }\n    sum += std::abs(arr[i]);\n    product *= std::signbit(arr[i])? -1 : 1;\n\
    \  }\n  return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp5oaf5ach: /tmp/tmp5oaf5ach.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   int prod = 1;\n    for (const auto& el : arr) {\n        if (el != 0) {\n\
    \            sum += std::abs(el);\n            prod *= el > 0 ? 1 : -1;\n    \
    \    }\n    }\n    return sum == 0 ? std::nullopt : std::optional<long>(sum *\
    \ prod);\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpu7cnj85l: /tmp/tmpu7cnj85l.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long product\
    \ = 1;\n    for (long num : arr) {\n        if (num > 0) {\n            sum +=\
    \ num;\n        } else if (num < 0) {\n            sum += abs(num);\n        \
    \    product *= -1;\n        }\n    }\n    return sum * product;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpozklavnu: /tmp/tmpozklavnu.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ result;\n  if (arr.size() == 0) {\n    return result;\n  }\n  else if (arr.size()\
    \ == 1) {\n    result = arr[0];\n    return result;\n  }\n  else {\n    long product\
    \ = 1;\n    long sum = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \ if (arr[i] == 0) {\n        continue;\n      }\n      else if (arr[i] < 0) {\n\
    \        product *= -1;\n        sum += abs(arr[i]);\n      }\n      else {\n\
    \        sum += arr[i];\n      }\n    }\n    result = sum * product;\n    return\
    \ result;\n  }\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp8t3g0ts5: /tmp/tmp8t3g0ts5.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106084
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  long ans = 0;\n  for (auto n : arr) {\n \
    \   if (n < 0) {\n      prod *= -1;\n      ans += n * -1;\n    } else if (n >\
    \ 0) {\n      ans += n;\n    } else {\n      prod = 0;\n    }\n  }\n  return ans\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106084
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  if(arr.size() == 0)\n    return std::nullopt;\n  long prod = 1;\n  long sum\
    \ = 0;\n  for(long n : arr)\n  {\n    if(n > 0)\n      prod *= 1;\n    else if(n\
    \ < 0)\n      prod *= -1;\n    else\n      prod *= 0;\n    sum += std::abs(n);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106085
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  if (n == 0) return std::nullopt;\n  long ret = 0;\n  for (int i = 0; i < n;\
    \ i++) {\n    if (arr[i] < 0) ret++;\n    else if (arr[i] > 0) ret += (long)1;\n\
    \  }\n  long p = 1;\n  for (int i = 0; i < n; i++) {\n    p *= (long)pow(arr[i],\
    \ 2);\n  }\n  return (ret%2==0?p:-p);\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmppljcmkmr: /tmp/tmppljcmkmr.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106085
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum=0;\n  int\
    \ prod=1;\n  for(int i=0;i<arr.size();i++){\n    sum=sum+abs(arr[i]);\n    if(arr[i]>0)\n\
    \      prod=prod*1;\n    else if(arr[i]<0)\n      prod=prod*(-1);\n    else\n\
    \      prod=prod*0;\n  }\n  long res=sum*prod;\n  if(arr.size()==0)\n    return\
    \ std::nullopt;\n  else\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106085
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    if (arr.size() == 1) return arr[0];\n    if (arr.size()\
    \ == 2) return arr[0] * arr[1];\n    // TODO finish implementation\n    return\
    \ 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmppy980m_9: /tmp/tmppy980m_9.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code here\n\
    \    std::optional<long> result;\n    if(arr.size() == 0)\n        return result;\n\
    \    long sum = 0;\n    long sign_prod = 1;\n    for(const auto& i : arr)\n  \
    \  {\n        if(i > 0)\n            sign_prod *= 1;\n        else if(i < 0)\n\
    \            sign_prod *= -1;\n        else\n            sign_prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    result = sum * sign_prod;\n    return result;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106085
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int signs = 1;\n\
    \    long sum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ == 0) {\n            return {};\n        }\n        if (arr[i] > 0) {\n    \
    \        sum += arr[i];\n        } else {\n            sum -= arr[i];\n      \
    \      signs *= -1;\n        }\n    }\n    return sum * signs;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp9yvvvi0n: /tmp/tmp9yvvvi0n.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (auto\
    \ item : arr) {\n    if (item > 0) {\n      sum += item;\n      prod *= 1;\n \
    \   } else if (item < 0) {\n      sum += item * -1;\n      prod *= -1;\n    }\
    \ else {\n      prod *= 0;\n    }\n  }\n  return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106085
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here!\n\
    \  long len=arr.size();\n  if(len==0) return std::nullopt;\n  long prod=1;\n \
    \ long sum=0;\n  for(long ele:arr){\n    if(ele<0) prod*=(-1);\n    sum+=std::abs(ele);\n\
    \  }\n  return sum*prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpshdjjumo: /tmp/tmpshdjjumo.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\t// int product = 1;\n\tlong long product\
    \ = 1;\n\tlong long sum_of_magnitudes = 0;\n\tfor (auto i : arr) {\n\t\tif (i\
    \ < 0) {\n\t\t\tproduct *= -1;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tsum_of_magnitudes\
    \ += abs(i);\n\t\t}\n\t}\n\treturn sum_of_magnitudes * product;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp7bq9f9qn: /tmp/tmp7bq9f9qn.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return (std::accumulate(arr.begin(),\
    \ arr.end(), 0,\n                            [](long sum, long a) {\n        \
    \                        return sum + (a >= 0 ? 1 : -1) * std::abs(a);\n     \
    \                       }));\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpw7qf35c_: /tmp/tmpw7qf35c_.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long sum = 0;\n  for (long\
    \ num : arr) {\n    sum += abs(num);\n    if (num == 0) {\n      product = 0;\n\
    \    } else if (num > 0) {\n      product *= 1;\n    } else {\n      product *=\
    \ -1;\n    }\n  }\n  return sum * product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t// your code here\n\
    \tlong cnt = 0;\n\tlong sum = 0;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\
    \tif (arr[i] < 0) {\n\t\t\tcnt++;\n\t\t}\n\t\tif (arr[i] != 0) {\n\t\t\tsum +=\
    \ abs(arr[i]);\n\t\t}\n\t}\n\tif (arr.size() == 0) {\n\t\treturn {};\n\t}\n\t\
    if (cnt % 2 == 0) {\n\t\treturn sum;\n\t}\n\telse {\n\t\treturn -sum;\n\t}\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmps9v9xtnu: /tmp/tmps9v9xtnu.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long value = 0;\n    long pro\
    \ = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n\
    \            value -= arr[i];\n            pro *= -1;\n        } else if (arr[i]\
    \ > 0) {\n            value += arr[i];\n            pro *= 1;\n        } else\
    \ {\n            pro *= 0;\n        }\n    }\n    if (pro == 0) {\n        return\
    \ 0;\n    }\n    return pro * value;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106085
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod\
    \ = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n\
    \            sum -= arr[i];\n            prod *= -1;\n        } else if (arr[i]\
    \ > 0) {\n            sum += arr[i];\n            prod *= 1;\n        } else {\n\
    \            return 0;\n        }\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ zero = std::nullopt;\n  long res = 0;\n  long prod = 1;\n  for (int i = 0; i\
    \ < arr.size(); i++) {\n    res += abs(arr[i]);\n    if (arr[i] == 0) {\n    \
    \  return zero;\n    }\n    prod *= arr[i] > 0 ? 1 : -1;\n  }\n  return res *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpiwsbjp83: /tmp/tmpiwsbjp83.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum = 0;\n    long prod = 1;\n    for (long\
    \ n : arr) {\n        sum += std::abs(n);\n        prod *= n == 0 ? 1 : n < 0\
    \ ? -1 : 1;\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp_os675mo: /tmp/tmp_os675mo.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    \n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp15wjs_s5: /tmp/tmp15wjs_s5.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size()==0)\
    \ return std::nullopt;\n    long sum = 0;\n    long pos = 1;\n    long neg = 1;\n\
    \    long zero = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]==0)\
    \ {\n            zero++;\n        } else if (arr[i]>0) {\n            pos *= arr[i];\n\
    \        } else {\n            neg *= arr[i];\n        }\n        sum += std::abs(arr[i]);\n\
    \    }\n    if (zero > 0) {\n        return 0;\n    } else {\n        return sum\
    \ * (pos * neg);\n    }\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpvodl257s: /tmp/tmpvodl257s.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // write your code\
    \ here\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpq0nvvadv: /tmp/tmpq0nvvadv.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int sign = 1;\n  long\
    \ sum = 0;\n  for (int i = 0; i < arr.size(); i++) {\n    sign *= arr[i] >= 0\
    \ ? 1 : -1;\n    sum += abs(arr[i]);\n  }\n  return sign != 0 ? sign * sum : std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpida8_y6a.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpida8_y6a.cpp:21:20: error: operands to ?: have different\
    \ types \u2018long int\u2019 and \u2018const std::nullopt_t\u2019\n   21 |   return\
    \ sign != 0 ? sign * sum : std::nullopt;\n      |          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660106085
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\tstd::vector<long> magnitudes;\n\tstd::vector<long>\
    \ signs;\n\tfor (auto& x : arr) {\n\t\tif (x == 0) {\n\t\t\treturn std::nullopt;\n\
    \t\t}\n\t\tmagnitudes.push_back(std::abs(x));\n\t\tif (x > 0) {\n\t\t\tsigns.push_back(1);\n\
    \t\t}\n\t\telse {\n\t\t\tsigns.push_back(-1);\n\t\t}\n\t}\n\tlong sum = 0;\n\t\
    for (auto& x : magnitudes) {\n\t\tsum += x;\n\t}\n\tlong prod = 1;\n\tfor (auto&\
    \ x : signs) {\n\t\tprod *= x;\n\t}\n\treturn sum * prod;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpu1ddv0ac: /tmp/tmpu1ddv0ac.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\tlong int prod = 1;\n\tlong int sum = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0)\n\t\t\tprod *= 1;\n\t\telse\
    \ if (arr[i] < 0)\n\t\t\tprod *= -1;\n\t\telse\n\t\t\tprod *= 0;\n\t\tif (arr[i]\
    \ != 0)\n\t\t\tsum += std::abs(arr[i]);\n\t}\n\tlong int res = sum * prod;\n\t\
    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106086
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    std::vector<int> signs;\n   \
    \ long total = 0;\n    for (auto elem : arr) {\n        if (elem > 0) {\n    \
    \        signs.push_back(1);\n        } else if (elem < 0) {\n            signs.push_back(-1);\n\
    \        } else {\n            signs.push_back(0);\n        }\n        total +=\
    \ abs(elem);\n    }\n    int product = 1;\n    for (auto elem : signs) {\n   \
    \     product *= elem;\n    }\n    total *= product;\n    return total;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\n\
    \t\treturn std::nullopt;\n\telse {\n\t\tlong sum = 0;\n\t\tlong prod = 1;\n\t\t\
    for (long i = 0; i < arr.size(); i++) {\n\t\t\tif (arr[i] == 0)\n\t\t\t\tcontinue;\n\
    \t\t\tsum += std::abs(arr[i]);\n\t\t\tprod *= (arr[i] > 0) ? 1 : -1;\n\t\t}\n\t\
    \treturn sum * prod;\n\t}\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp0o1ri1qs: /tmp/tmp0o1ri1qs.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        sum += abs(arr[i]);\n    }\n    int sign = 1;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] != 0) {\n            sign\
    \ *= arr[i]/abs(arr[i]);\n        }\n    }\n    return sum * sign;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp503boobs: /tmp/tmp503boobs.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sign_product = 1;\n    long\
    \ magnitude_sum = 0;\n    for (long num : arr) {\n        sign_product *= (num\
    \ == 0) ? 1 : (num > 0) ? 1 : -1;\n        magnitude_sum += std::abs(num);\n \
    \   }\n    return sign_product * magnitude_sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpy3oaoi38: /tmp/tmpy3oaoi38.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long sum = 0;\n  for (long\
    \ i : arr) {\n    sum += std::abs(i);\n    if (i == 0) {\n      continue;\n  \
    \  }\n    if (i > 0) {\n      product *= 1;\n    } else {\n      product *= -1;\n\
    \    }\n  }\n  return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp9eam2g7i: /tmp/tmp9eam2g7i.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long prod = 1;\n    long mag_sum\
    \ = 0;\n    for (auto &item : arr) {\n        mag_sum += abs(item);\n        if\
    \ (item > 0) {\n            prod *= 1;\n        } else if (item < 0) {\n     \
    \       prod *= -1;\n        } else {\n            prod *= 0;\n        }\n   \
    \ }\n    return mag_sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp_q2bjf2t: /tmp/tmp_q2bjf2t.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int productOfSigns\
    \ = 1;\n  int sumOfMagnitudes = 0;\n  if (arr.size() > 0) {\n    for (int i =\
    \ 0; i < arr.size(); i++) {\n      if (arr[i] > 0) {\n        productOfSigns *=\
    \ 1;\n        sumOfMagnitudes += arr[i];\n      } else if (arr[i] < 0) {\n   \
    \     productOfSigns *= -1;\n        sumOfMagnitudes += arr[i] * -1;\n      }\
    \ else {\n        sumOfMagnitudes += 0;\n      }\n    }\n    return productOfSigns\
    \ * sumOfMagnitudes;\n  } else {\n    return std::nullopt;\n  }\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpkdhwcxaf: /tmp/tmpkdhwcxaf.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code here\n\
    \    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpuo_tumml: /tmp/tmpuo_tumml.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return arr.empty()\
    \ ? std::nullopt : std::accumulate(arr.begin(), arr.end(), 0L,\n        [](const\
    \ long& acc, const long& num) {\n            return acc + abs(num) * ((num > 0)\
    \ - (num < 0));\n        });\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpertg398w.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpertg398w.cpp:15:24: error: operands to ?: have different\
    \ types \u2018const std::nullopt_t\u2019 and \u2018long int\u2019\n   15 |   \
    \  return arr.empty() ? std::nullopt : std::accumulate(arr.begin(), arr.end(),\
    \ 0L,\n      |            ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   16 |         [](const long& acc, const long& num) {\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   17 |             return acc + abs(num) * ((num > 0) - (num < 0));\n      |\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   18 |      \
    \   });\n      |         ~~              \n"
  stdout: ''
  timestamp: 1660106086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tstd::vector<long> sign;\n\
    \tfor (auto &x : arr) {\n\t\tif (x > 0) {\n\t\t\tsign.push_back(1);\n\t\t} else\
    \ if (x < 0) {\n\t\t\tsign.push_back(-1);\n\t\t} else {\n\t\t\tsign.push_back(0);\n\
    \t\t}\n\t}\n\tstd::optional<long> val = std::reduce(sign.begin(), sign.end(),\
    \ std::nullopt, [](auto &a, auto &b) {\n\t\treturn (a) ? a * b : b;\n\t});\n\t\
    if (!val) {\n\t\treturn std::nullopt;\n\t}\n\tlong product = *val;\n\treturn std::accumulate(arr.begin(),\
    \ arr.end(), 0L, [product](auto &a, auto &b) {\n\t\treturn a + std::abs(b) * product;\n\
    \t});\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2tpncg8o.cpp: In instantiation of \u2018prod_signs(std::vector<long\
    \ int>)::<lambda(auto:22&, auto:23&)> [with auto:22 = std::nullopt_t; auto:23\
    \ = std::nullopt_t]\u2019:\n/usr/include/c++/9/type_traits:2330:26:   required\
    \ by substitution of \u2018template<class _Fn, class ... _Args> static std::__result_of_success<decltype\
    \ (declval<_Fn>()((declval<_Args>)()...)), std::__invoke_other> std::__result_of_other_impl::_S_test(int)\
    \ [with _Fn = prod_signs(std::vector<long int>)::<lambda(auto:22&, auto:23&)>&;\
    \ _Args = {std::nullopt_t&, std::nullopt_t&}]\u2019\n/usr/include/c++/9/type_traits:2341:55:\
    \   required from \u2018struct std::__result_of_impl<false, false, prod_signs(std::vector<long\
    \ int>)::<lambda(auto:22&, auto:23&)>&, std::nullopt_t&, std::nullopt_t&>\u2019\
    \n/usr/include/c++/9/type_traits:2787:12:   recursively required by substitution\
    \ of \u2018template<class _Result, class _Ret> struct std::__is_invocable_impl<_Result,\
    \ _Ret, false, std::__void_t<typename _Result::type> > [with _Result = std::__invoke_result<prod_signs(std::vector<long\
    \ int>)::<lambda(auto:22&, auto:23&)>&, std::nullopt_t&, std::nullopt_t&>; _Ret\
    \ = std::nullopt_t]\u2019\n/usr/include/c++/9/type_traits:2787:12:   required\
    \ from \u2018struct std::is_invocable_r<std::nullopt_t, prod_signs(std::vector<long\
    \ int>)::<lambda(auto:22&, auto:23&)>&, std::nullopt_t&, std::nullopt_t&>\u2019\
    \n/usr/include/c++/9/type_traits:2827:27:   required from \u2018constexpr const\
    \ bool std::is_invocable_r_v<std::nullopt_t, prod_signs(std::vector<long int>)::<lambda(auto:22&,\
    \ auto:23&)>&, std::nullopt_t&, std::nullopt_t&>\u2019\n/usr/include/c++/9/numeric:265:21:\
    \   required from \u2018_Tp std::reduce(_InputIterator, _InputIterator, _Tp, _BinaryOperation)\
    \ [with _InputIterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >; _Tp = std::nullopt_t; _BinaryOperation = prod_signs(std::vector<long\
    \ int>)::<lambda(auto:22&, auto:23&)>]\u2019\n/tmp/tmp2tpncg8o.cpp:27:3:   required\
    \ from here\n/tmp/tmp2tpncg8o.cpp:26:18: error: no match for \u2018operator*\u2019\
    \ (operand types are \u2018std::nullopt_t\u2019 and \u2018std::n"
  stdout: ''
  timestamp: 1660106086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sz = arr.size();\n  if (sz == 1) {\n    if (arr[0] ==\
    \ 0)\n      return 0;\n    else\n      return 1;\n  }\n  long r = 1;\n  long s\
    \ = 0;\n  for (long i = 0; i < sz; i++) {\n    if (arr[i] < 0)\n      r *= -1;\n\
    \    if (arr[i] != 0)\n      s += abs(arr[i]);\n  }\n  return r * s;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpt22jf58k: /tmp/tmpt22jf58k.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod = 1;\n\
    \    long sum = 0;\n    for (auto i : arr) {\n        if (i != 0) {\n        \
    \    prod *= (i < 0 ? -1 : 1);\n            sum += std::abs(i);\n        }\n \
    \   }\n    return arr.size() == 0 ? std::nullopt : std::optional<long>(sum * prod);\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmphjk8bhtn: /tmp/tmphjk8bhtn.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  std::vector<long> signs, magnitudes;\n  long signs_product\
    \ = 1, magnitudes_sum = 0;\n  for (auto it : arr) {\n    if (it > 0) {\n     \
    \ signs.push_back(1);\n      magnitudes.push_back(it);\n    } else if (it < 0)\
    \ {\n      signs.push_back(-1);\n      magnitudes.push_back(-it);\n    } else\
    \ {\n      signs.push_back(0);\n      magnitudes.push_back(0);\n    }\n  }\n \
    \ for (auto it : signs) {\n    signs_product *= it;\n  }\n  for (auto it : magnitudes)\
    \ {\n    magnitudes_sum += it;\n  }\n  return std::make_optional(magnitudes_sum\
    \ * signs_product);\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\tauto ans = std::accumulate(arr.begin(),\
    \ arr.end(), (long)0,\n\t\t[](long sum, long x) {\n\t\t\tif (x > 0) {\n\t\t\t\t\
    return sum + std::abs(x);\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\treturn sum - std::abs(x);\n\
    \t\t\t}\n\t\t\treturn sum;\n\t\t});\n\treturn ans;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmppx9mqdrq: /tmp/tmppx9mqdrq.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    if (arr.size() == 0)\n        return std::nullopt;\n \
    \   for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n     \
    \       prod *= -1;\n            sum += (-1 * arr[i]);\n        } else if (arr[i]\
    \ > 0) {\n            sum += arr[i];\n        } else {\n            prod = 0;\n\
    \        }\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code goes\
    \ here\n    return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpc_dne4v_: /tmp/tmpc_dne4v_.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int negatives = 0;\n\
    \  long sum = 0;\n  for (long i : arr) {\n    if (i > 0) {\n      sum += i;\n\
    \    } else if (i < 0) {\n      sum += -i;\n      negatives++;\n    }\n  }\n \
    \ if (arr.size() > 0) {\n    return sum * pow(-1, negatives);\n  } else {\n  \
    \  return std::nullopt;\n  }\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpoypj20u0: /tmp/tmpoypj20u0.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tint count=0;\n\tint\
    \ sign_prod=1;\n\tint sum=0;\n\tfor(int i=0;i<arr.size();i++)\n\t{\n\t\tif(arr[i]==0)\n\
    \t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse if(arr[i]>0)\n\t\t{\n\t\t\tsign_prod=sign_prod*1;\n\
    \t\t\tsum=sum+arr[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsign_prod=sign_prod*(-1);\n\
    \t\t\tsum=sum+arr[i];\n\t\t}\n\t}\n\tif(count==arr.size())\n\t{\n\t\treturn std::nullopt;\n\
    \t}\n\telse\n\t{\n\t\treturn sign_prod*sum;\n\t}\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp0my5brzh: /tmp/tmp0my5brzh.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Your code here\n\
    \  if(arr.size() == 0)\n  {\n    return std::nullopt;\n  }\n  int temp = 1;\n\
    \  int sum = 0;\n  for(int i = 0; i < arr.size(); i++)\n  {\n    if(arr[i] > 0)\n\
    \    {\n      temp *= 1;\n    }\n    else if(arr[i] < 0)\n    {\n      temp *=\
    \ -1;\n    }\n    else\n    {\n      temp *= 0;\n    }\n    sum += abs(arr[i]);\n\
    \  }\n  long res = temp * sum;\n  return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    else {\n        std::vector<int>\
    \ signs(arr.size());\n        std::transform(arr.begin(), arr.end(), signs.begin(),\n\
    \                       [](long l) {\n                           if (l < 0) {\n\
    \                               return -1;\n                           }\n   \
    \                        else if (l > 0) {\n                               return\
    \ 1;\n                           }\n                           else {\n      \
    \                         return 0;\n                           }\n          \
    \             });\n        std::vector<long> mags(arr.size());\n        std::transform(arr.begin(),\
    \ arr.end(), mags.begin(),\n                       [](long l) {\n            \
    \               return std::abs(l);\n                       });\n        int sign_prod\
    \ = std::accumulate(signs.begin(), signs.end(), 1,\n                         \
    \               std::multiplies<int>());\n        long mag_sum = std::accumulate(mags.begin(),\
    \ mags.end(), 0L);\n        return sign_prod * mag_sum;\n    }\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (auto\
    \ i : arr) {\n        if (i > 0) prod *= 1;\n        else if (i < 0) prod *= -1;\n\
    \        else prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            product *=\
    \ 1;\n        } else if (i < 0) {\n            product *= -1;\n        } else\
    \ {\n            product *= 0;\n        }\n        sum += abs(i);\n    }\n   \
    \ return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long prod=1;\n  long\
    \ sum=0;\n  if(arr.size()==0)\n  {\n    return std::nullopt;\n  }\n  for(int i=0;i<arr.size();i++)\n\
    \  {\n    if(arr[i]>0)\n    {\n      prod*=1;\n      sum+=arr[i];\n    }\n   \
    \ else if(arr[i]<0)\n    {\n      prod*=-1;\n      sum+=arr[i];\n    }\n    else\n\
    \    {\n      prod*=0;\n      sum+=arr[i];\n    }\n  }\n  return sum*prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpwxu77r7e: /tmp/tmpwxu77r7e.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum = 0;\n    long prod = 1;\n    for (long\
    \ el : arr) {\n        prod *= std::signbit(el) ? -1 : std::signbit(el) ? 0 :\
    \ 1;\n        sum += std::abs(el);\n    }\n    return prod * sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpo1lrngmc: /tmp/tmpo1lrngmc.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong product_sign =\
    \ 1;\n\tlong sum_magnitude = 0;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\t\
    if (arr[i] < 0) {\n\t\t\tproduct_sign *= -1;\n\t\t}\n\t\tif (arr[i] == 0) {\n\t\
    \t\tproduct_sign = 0;\n\t\t}\n\t\tsum_magnitude += abs(arr[i]);\n\t}\n\treturn\
    \ product_sign * sum_magnitude;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpev5u605e: /tmp/tmpev5u605e.cpp:33: int main(): Assertion `candidate((std::vector<long>()))
    == std::nullopt'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t// your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpfaz0_9d2: /tmp/tmpfaz0_9d2.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106083
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\tlong a = 1;\n\tlong b = 0;\n\tfor (long\
    \ i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] < 0) {\n\t\t\ta *= -1;\n\t\t}\n\
    \t\tif (arr[i] != 0) {\n\t\t\tb += std::abs(arr[i]);\n\t\t}\n\t}\n\treturn a *\
    \ b;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpczx6bu55: /tmp/tmpczx6bu55.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106088
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long p = 1;\n    long sum = 0;\n    for (long x\
    \ : arr) {\n        p *= x == 0 ? 1 : (x < 0 ? -1 : 1);\n        sum += abs(x);\n\
    \    }\n    return sum * p;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp94bbqto_: /tmp/tmp94bbqto_.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n    long sum = 0;\n    long product = 1;\n    for (auto&\
    \ element : arr) {\n        if (element > 0) product *= 1;\n        else if (element\
    \ < 0) product *= -1;\n        else if (element == 0) product *= 0;\n        sum\
    \ += element;\n    }\n    sum *= product;\n    return sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpefhjbq6s: /tmp/tmpefhjbq6s.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  long\
    \ prod = 1;\n  for (auto x : arr) {\n    if (x == 0) continue;\n    prod *= x\
    \ < 0 ? -1 : 1;\n    sum += abs(x);\n  }\n  return prod ? prod * sum : std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgalo16_d.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpgalo16_d.cpp:22:15: error: operands to ?: have different\
    \ types \u2018long int\u2019 and \u2018const std::nullopt_t\u2019\n   22 |   return\
    \ prod ? prod * sum : std::nullopt;\n      |          ~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t// to add the magnitudes\
    \ of each element in the array\n\tlong sum = 0;\n\tif (arr.size() == 0) {\n\t\t\
    return std::nullopt;\n\t}\n\t// to check whether all elements are zero or not\n\
    \tbool all_zero = true;\n\t// to store the sign of each element\n\tint sign =\
    \ 1;\n\tfor (long i : arr) {\n\t\tsum += abs(i);\n\t\tif (i < 0) {\n\t\t\tsign\
    \ *= -1;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tall_zero = false;\n\t\t}\n\t}\n\t//\
    \ if all are zero then return 0\n\tif (all_zero) {\n\t\treturn 0;\n\t}\n\treturn\
    \ sum * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgxszvkkj: /tmp/tmpgxszvkkj.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  int sign = 1;\n  long sum = 0;\n  for (auto\
    \ i : arr) {\n    if (i < 0) {\n      sign *= -1;\n    } else if (i > 0) {\n \
    \     sign *= 1;\n    } else {\n      sign *= 0;\n    }\n    sum += abs(i);\n\
    \  }\n  return std::make_optional(sum * sign);\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    long value = arr[i];\n    sum += abs(value);\n\
    \    if (value > 0) {\n      prod *= 1;\n    } else if (value < 0) {\n      prod\
    \ *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum * prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong ans = 1;\n\tlong\
    \ sum = 0;\n\tfor (auto i : arr) {\n\t\tans *= sgn(i);\n\t\tsum += abs(i);\n\t\
    }\n\tif (ans) {\n\t\treturn sum * ans;\n\t}\n\treturn std::nullopt;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuo5d91en.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpuo5d91en.cpp:18:10: error: \u2018sgn\u2019 was not declared\
    \ in this scope; did you mean \u2018sin\u2019?\n   18 |   ans *= sgn(i);\n   \
    \   |          ^~~\n      |          sin\n"
  stdout: ''
  timestamp: 1660106087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long sum = 0;\n    int mul =\
    \ 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n\
    \            mul *= -1;\n        }\n        if (arr[i] != 0) {\n            sum\
    \ += std::abs(arr[i]);\n        }\n    }\n    return sum * mul;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpooflsw7i: /tmp/tmpooflsw7i.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106088
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the vector, represented by 1,\
    \ -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0,\
    \ (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long res = 0;\n    long prod\
    \ = 1;\n    for (auto a : arr) {\n        if (a == 0) {\n            continue;\n\
    \        }\n        if (a > 0) {\n            res += a;\n        } else {\n  \
    \          res -= a;\n            prod *= -1;\n        }\n    }\n    return res\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpqanc1c0w: /tmp/tmpqanc1c0w.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106088
