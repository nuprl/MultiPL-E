name: HumanEval_83_starts_one_ends
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer\
  \ n, return the count of the numbers of n-digit\n// positive integers that start\
  \ or end with 1.\nlong starts_one_ends(long n) {\n"
tests: "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1))\
  \ == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n\
  \    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n\
  }\n"
completions: ["    assert(n > 0);\n    if (n == 1) return 2;\n    if (n == 2) return\
    \ 3;\n    long num_end_one = 1;\n    long num_start_one = 1;\n    long last_start_one\
    \ = 1;\n    long last_end_one = 1;\n    long i = 1;\n    while (i < n) {\n   \
    \     num_end_one = last_start_one + last_end_one;\n        num_start_one = last_start_one\
    \ + last_end_one;\n        last_start_one = num_start_one;\n        last_end_one\
    \ = num_end_one;\n        i++;\n    }\n    return num_start_one + num_end_one;",
  "  if (n == 1) {\n    return 2;\n  }\n  long ans = 1;\n  for (int i = 0; i < n -\
    \ 1; i++) {\n    ans *= 2;\n  }\n  return 2 * ans;", "  if (n == 1) return 10;\n\
    \  long ans = 10, dp[10][n + 1];\n  memset(dp, 0, sizeof(dp));\n  for (int i =\
    \ 0; i < 10; i++) {\n    dp[i][1] = 1;\n  }\n  for (int i = 2; i <= n; i++) {\n\
    \    for (int j = 0; j < 10; j++) {\n      dp[j][i] = dp[j][i - 1];\n      if\
    \ (j > 0) {\n        dp[j][i] += dp[j - 1][i - 1];\n      }\n    }\n  }\n  for\
    \ (int i = 1; i < 10; i++) {\n    ans += dp[i][n] + dp[i][n];\n  }\n  return ans;",
  "  long length = std::to_string(n).length();\n  if (length == 1) {\n    return 1;\n\
    \  }\n  long max_num = std::pow(10, length - 1);\n  long min_num = std::pow(10,\
    \ length - 2);\n  long cnt = 0;\n  for (long i = 0; i < length; i++) {\n    cnt\
    \ += 9 * std::pow(10, i) * (i + 1);\n  }\n  cnt += (n - max_num + 1) * length;\n\
    \  if (n >= min_num) {\n    cnt += starts_one_ends(n - min_num);\n  }\n  return\
    \ cnt;", "    if (n == 1) return 2;\n    if (n == 2) return 3;\n    return starts_one_ends(n-1)\
    \ + starts_one_ends(n-2);", "  // Write your code here\n  int a[n];\n  int i,j;\n\
    \  int count=0;\n  for(i=0;i<n;i++)\n  {\n    a[i]=1;\n  }\n  for(i=0;i<n;i++)\n\
    \  {\n    if(a[i]==1)\n    {\n      count++;\n    }\n  }\n  return count;", " \
    \   if (n == 1) {\n        return 10;\n    }\n    return (starts_one_ends(n -\
    \ 1) * 9) + pow(10, n - 1);", "  if (n == 1) {\n    return 2;\n  }\n  long count\
    \ = 9;\n  for (long i = 1; i < n; i++) {\n    count *= 10;\n  }\n  count *= 2;\n\
    \  return count;", "  if (n == 1) {\n    return 10;\n  }\n  if (n == 2) {\n  \
    \  return 180;\n  }\n  long N = n;\n  long tens = 1;\n  while (n > 1) {\n    tens\
    \ *= 10;\n    n--;\n  }\n  long result = 1 * 90 * tens;\n  for (long i = 3; i\
    \ <= N; i++) {\n    result += (9 * 9 * tens * 1);\n    tens /= 10;\n  }\n  return\
    \ result;", "    // Notice that we need to consider only the numbers that have\
    \ all the digits\n    // less than 9\n    // Assume we have a number of 'n' digits\
    \ that starts with 1, then the number\n    // of possible numbers can be shown\
    \ as follows\n    //\n    // (1) If n = 2, then the number of such numbers is\
    \ 9, since the other digit\n    // can be any of the digits 2-9\n    // (2) If\
    \ n = 3, then the number of such numbers is 9 * 9, since we can have\n    // any\
    \ of the 2-9 digits followed by any of the 2-9 digits\n    // (3) If n = 4, then\
    \ the number of such numbers is 9 * 9 * 9, since we can\n    // have any of the\
    \ 2-9 digits followed by any of the 2-9 digits followed by\n    // any of the\
    \ 2-9 digits\n    //\n    // From the above, we can clearly see that if we have\
    \ a number of 'n' digits\n    // that starts with 1, then the number of possible\
    \ numbers will be 9 ^ (n -\n    // 1)\n    //\n    // Also, for any number of\
    \ 'n' digits, the total number of numbers can be\n    // given by\n    //\n  \
    \  // (1) If n = 1, then the number of such numbers is 10, since the other digit\n\
    \    // can be any of the digits 0-9\n    // (2) If n = 2, then the number of\
    \ such numbers is 10 * 10, since we can\n    // have any of the 0-9 digits followed\
    \ by any of the 0-9 digits\n    // (3) If n = 3, then the number of such numbers\
    \ is 10 * 10 * 10, since we\n    // can have any of the 0-9 digits followed by\
    \ any of the 0-9 digits followed\n    // by any of the 0-9 digits\n    //\n  \
    \  // From the above, we can clearly see that if we have a number of 'n' digits\n\
    \    // then the number of possible numbers will be 10 ^ n\n    //\n    // From\
    \ the above, the required result would be given by\n    //\n    // Total count\
    \ of numbers of n-digits that start or end with 1 =\n    //                  \
    \                        9 ^ (n - 1", "    long s = 0;\n    while (n != 0) {\n\
    \        long d = n % 10;\n        if (d == 1) {\n            s++;\n        }\n\
    \        n /= 10;\n    }\n    return s;", "    if (n == 1) {\n        return 10;\n\
    \    }\n    if (n == 2) {\n        return 55;\n    }\n    long start_with_one\
    \ = 9;\n    long end_with_one = 10;\n    long i = 3;\n    while (i <= n) {\n \
    \       long temp = start_with_one;\n        start_with_one = end_with_one;\n\
    \        end_with_one = temp * 10 + end_with_one;\n        i++;\n    }\n    return\
    \ start_with_one + end_with_one;", "  long sum = 0;\n  for (long i = 1; i <= n;\
    \ i++) {\n    sum += (long)(pow(10, i - 1));\n  }\n  return sum * 2;", "  if (n\
    \ < 1) return 0;\n  // f(n) = 9 + f(n-1)\n  long sum = 1;\n  for (int i = 1; i\
    \ < n; ++i) {\n    sum = 9 + sum;\n  }\n  return sum;", "    long ans = 1;\n \
    \   long digits = 1;\n    long base = 1;\n    for (long i = 1; i < n; i++) {\n\
    \        base *= 10;\n        digits = 9 * base + digits;\n        ans += digits;\n\
    \    }\n    return ans;", "    long count = 0;\n    // If the number is a single\
    \ digit then there are nine options\n    if (n == 1) {\n        return 9;\n  \
    \  }\n    // Make the number a string\n    string number = to_string(n);\n   \
    \ // Check the starting digit\n    if (number[0] == '1') {\n        // If the\
    \ number starts with 1, then it can have any other digit\n        // for the remaining\
    \ digits\n        count += 10 * pow(9, n - 1);\n    }\n    // Check the ending\
    \ digit\n    if (number[n - 1] == '1') {\n        // If the number ends with 1,\
    \ then it can have any other digit\n        // for the remaining digits\n    \
    \    count += 10 * pow(9, n - 1);\n    }\n    // If both starting and ending digits\
    \ are 1, then there are 9 digit options\n    // for the remaining digits\n   \
    \ if (number[0] == '1' && number[n - 1] == '1') {\n        count += pow(9, n -\
    \ 1);\n    }\n    return count;", "  long s = 0;\n  for (long i = 1; i <= n; i++)\
    \ {\n    if (i == 1)\n      s += 1;\n    else\n      s += pow(10, i - 1);\n  }\n\
    \  return s;", "  if (n == 1) {\n    return 10;\n  }\n  if (n == 2) {\n    return\
    \ 100;\n  }\n  long result = (n - 1) * 10 * 9;\n  long p = 1;\n  for (int i =\
    \ 1; i < n; i++) {\n    p *= 10;\n  }\n  result += p;\n  return result;", "  long\
    \ count = 0;\n  if (n == 1) {\n    return 2;\n  }\n  for (long i = 0; i < n; i++)\
    \ {\n    count += pow(10, i);\n  }\n  return count * 2;", "    if (n <= 2) {\n\
    \        return 1;\n    }\n    long temp = starts_one_ends(n - 1);\n    long possible_first_digits\
    \ = 9;\n    long first_digit_count = possible_first_digits * temp;\n    long remaining_count\
    \ = pow(10, n - 2) * pow(2, n - 2);\n    return first_digit_count + remaining_count;"]
stop_tokens:
- "\n}"
