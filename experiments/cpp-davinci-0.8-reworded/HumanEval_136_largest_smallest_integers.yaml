name: HumanEval_136_largest_smallest_integers
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns\
  \ a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is\
  \ the smallest\n// of positive integers in a vector.\n// If there is no negative\
  \ or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2,\
  \ (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n\
  // std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n\
  // >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>>\
  \ largest_smallest_integers(std::vector<long> lst) {\n"
tests: "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2,\
  \ (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
  \ (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3,\
  \ (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n\
  \    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2,\
  \ (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7,\
  \ (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9,\
  \ 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0})))\
  \ == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n\
  \    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6})))\
  \ == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n\
  \    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6,\
  \ (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n\
  \    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3,\
  \ (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6,\
  \ (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n\
  }\n"
completions: ["\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));",
  "    std::optional<long> largest, smallest;\n    bool found = false;\n    for (auto\
    \ a : lst) {\n        if (a < 0) {\n            if (!found) {\n              \
    \  largest = a;\n                found = true;\n            } else {\n       \
    \         largest = std::max(largest.value(), a);\n            }\n        } else\
    \ if (a > 0) {\n            if (!found) {\n                smallest = a;\n   \
    \             found = true;\n            } else {\n                smallest =\
    \ std::min(smallest.value(), a);\n            }\n        }\n    }\n    return\
    \ std::make_tuple(largest, smallest);", "    // Your code here\n    std::vector<long>\
    \ positive;\n    std::vector<long> negative;\n    for(long val : lst){\n     \
    \   if(val > 0){\n            positive.push_back(val);\n        }else if(val <\
    \ 0){\n            negative.push_back(val);\n        }\n    }\n    std::optional<long>\
    \ max_neg = std::nullopt;\n    std::optional<long> min_pos = std::nullopt;\n \
    \   if(positive.size() > 0){\n        std::sort(positive.begin(), positive.end());\n\
    \        min_pos = positive[0];\n    }\n    if(negative.size() > 0){\n       \
    \ std::sort(negative.begin(), negative.end());\n        max_neg = negative[negative.size()\
    \ - 1];\n    }\n    return std::make_tuple(max_neg, min_pos);", "    long int\
    \ larg=lst[0];\n    long int small=lst[0];\n    bool neg=false;\n    bool pos=false;\n\
    \    for(long i=0;i<lst.size();i++)\n    {\n        if(lst[i]>0){\n          \
    \  pos=true;\n            if(lst[i]<small)\n                small=lst[i];\n  \
    \      }\n        else{\n            neg=true;\n            if(lst[i]>larg)\n\
    \                larg=lst[i];\n        }\n    }\n    if(neg==false && pos==false)\n\
    \        return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    else if(neg==false)\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(small));\n    else if(pos==false)\n        return std::make_tuple(std::optional<long>(larg),\
    \ std::optional<long>(std::nullopt));\n    else\n        return std::make_tuple(std::optional<long>(larg),\
    \ std::optional<long>(small));", "\tlong least = LONG_MAX;\n\tlong most = LONG_MIN;\n\
    \tfor (auto& i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (i > most) most = i;\n\t\t\
    }\n\t\telse if (i > 0) {\n\t\t\tif (i < least) least = i;\n\t\t}\n\t}\n\tif (most\
    \ == LONG_MIN && least == LONG_MAX) return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\telse if (most == LONG_MIN) return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(least));\n\telse if (least == LONG_MAX) return std::make_tuple(std::optional<long>(most),\
    \ std::optional<long>(std::nullopt));\n\telse return std::make_tuple(std::optional<long>(most),\
    \ std::optional<long>(least));", "    std::optional<long> la,sb;\n    long a=LONG_MIN,b=LONG_MAX;\n\
    \    for(auto x:lst){\n        if(x>=0 && x<b)\n            b=x;\n        if(x<0\
    \ && x>a)\n            a=x;\n    }\n    if(a==LONG_MIN)\n        la=std::nullopt;\n\
    \    else\n        la=a;\n    if(b==LONG_MAX)\n        sb=std::nullopt;\n    else\n\
    \        sb=b;\n    return std::make_tuple(la,sb);", "    std::optional<long>\
    \ m,n;\n    if(lst.size()==0)\n        return std::make_tuple(m,n);\n    auto\
    \ itr = std::min_element(lst.begin(),lst.end());\n    auto itr1 = std::max_element(lst.begin(),lst.end());\n\
    \    if(*itr>0)\n        n = *itr;\n    if(*itr1<0)\n        m = *itr1;\n    return\
    \ std::make_tuple(m,n);", "    bool noPositive = true;\n    bool noNegative =\
    \ true;\n    long smallestPositive = lst[0];\n    long largestNegative = lst[0];\n\
    \    std::vector<long> positives;\n    std::vector<long> negatives;\n    for (long\
    \ i : lst) {\n        if (i >= 0) {\n            noPositive = false;\n       \
    \     positives.push_back(i);\n        }\n        if (i < 0) {\n            noNegative\
    \ = false;\n            negatives.push_back(i);\n        }\n    }\n    if (noPositive\
    \ && noNegative) {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }\n    for (long i : positives) {\n\
    \        if (i < smallestPositive) {\n            smallestPositive = i;\n    \
    \    }\n    }\n    for (long i : negatives) {\n        if (i > largestNegative)\
    \ {\n            largestNegative = i;\n        }\n    }\n    if (noNegative) {\n\
    \        return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(smallestPositive));\n\
    \    }\n    if (noPositive) {\n        return std::make_tuple(std::optional<long>(largestNegative),\
    \ std::optional<long>(std::nullopt));\n    }\n    return std::make_tuple(std::optional<long>(largestNegative),\
    \ std::optional<long>(smallestPositive));", "\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> answer;\n\tstd::optional<long> largestNegative, smallestPositive;\n\
    \tbool isLargestNegativeInitialized = false, isSmallestPositiveInitialized = false;\n\
    \tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tif (!isLargestNegativeInitialized)\
    \ {\n\t\t\t\tlargestNegative = lst[i];\n\t\t\t\tisLargestNegativeInitialized =\
    \ true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (lst[i] > largestNegative) {\n\t\t\t\
    \t\tlargestNegative = lst[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (lst[i]\
    \ > 0) {\n\t\t\tif (!isSmallestPositiveInitialized) {\n\t\t\t\tsmallestPositive\
    \ = lst[i];\n\t\t\t\tisSmallestPositiveInitialized = true;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\tif (lst[i] < smallestPositive) {\n\t\t\t\t\tsmallestPositive = lst[i];\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!isLargestNegativeInitialized)\n\t\tlargestNegative\
    \ = std::nullopt;\n\tif (!isSmallestPositiveInitialized)\n\t\tsmallestPositive\
    \ = std::nullopt;\n\tanswer = std::make_tuple(largestNegative, smallestPositive);\n\
    \treturn answer;", "    std::vector<long> positives, negatives;\n    for (auto\
    \ item : lst) {\n        if (item > 0) {\n            positives.push_back(item);\n\
    \        } else if (item < 0) {\n            negatives.push_back(item);\n    \
    \    }\n    }\n    std::sort(positives.begin(), positives.end());\n    std::sort(negatives.begin(),\
    \ negatives.end());\n    if (positives.size() > 0) {\n        if (negatives.size()\
    \ > 0) {\n            return std::make_tuple(std::optional<long>(negatives[negatives.size()\
    \ - 1]), std::optional<long>(positives[0]));\n        } else {\n            return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(positives[0]));\n\
    \        }\n    } else {\n        if (negatives.size() > 0) {\n            return\
    \ std::make_tuple(std::optional<long>(negatives[negatives.size() - 1]), std::optional<long>(std::nullopt));\n\
    \        } else {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n        }\n    }", "    bool positive =\
    \ false;\n    bool negative = false;\n    long min_positive = 0;\n    long max_negative\
    \ = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] > 0) {\n\
    \            if (!positive) {\n                min_positive = lst[i];\n      \
    \          positive = true;\n            } else {\n                if (lst[i]\
    \ < min_positive) {\n                    min_positive = lst[i];\n            \
    \    }\n            }\n        } else if (lst[i] < 0) {\n            if (!negative)\
    \ {\n                max_negative = lst[i];\n                negative = true;\n\
    \            } else {\n                if (lst[i] > max_negative) {\n        \
    \            max_negative = lst[i];\n                }\n            }\n      \
    \  }\n    }\n    if (positive) {\n        if (negative) {\n            return\
    \ std::make_tuple(std::optional<long>(max_negative), std::optional<long>(min_positive));\n\
    \        } else {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min_positive));\n        }\n    } else {\n        if (negative)\
    \ {\n            return std::make_tuple(std::optional<long>(max_negative), std::optional<long>(std::nullopt));\n\
    \        } else {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n        }\n    }", "    int min = 1e9,\
    \ max = -1e9;\n    int min_idx = -1, max_idx = -1;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < 0) {\n            if (lst[i] > max) {\n       \
    \         max = lst[i];\n                max_idx = i;\n            }\n       \
    \ } else {\n            if (lst[i] < min) {\n                min = lst[i];\n \
    \               min_idx = i;\n            }\n        }\n    }\n    if (min_idx\
    \ == -1 && max_idx == -1) {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    } else if (min_idx == -1) {\n     \
    \   return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(max));\n\
    \    } else if (max_idx == -1) {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min));\n    } else {\n        return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));\n    }", "  std::optional<long> max = {};\n  std::optional<long>\
    \ min = {};\n  for (auto i : lst) {\n    if (i < 0) {\n      if (!max.has_value()\
    \ || i > max.value()) {\n        max = i;\n      }\n    } else if (i > 0) {\n\
    \      if (!min.has_value() || i < min.value()) {\n        min = i;\n      }\n\
    \    }\n  }\n  return std::make_tuple(max, min);", "    auto opt = std::optional<long>(std::nullopt);\n\
    \    auto opt1 = std::optional<long>(std::nullopt);\n    auto answer = std::make_tuple(opt,\
    \ opt1);\n    std::tuple<std::optional<long>, std::optional<long>> ans;\n    int\
    \ flag = 0;\n    int flag1 = 0;\n    if (lst.size() == 0) {\n        return answer;\n\
    \    }\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 0; i\
    \ < lst.size(); i++) {\n        if (lst[i] > 0) {\n            flag1 = 1;\n  \
    \          if (lst[i] < min) {\n                min = lst[i];\n            }\n\
    \        }\n        if (lst[i] < 0) {\n            flag = 1;\n            if (lst[i]\
    \ > max) {\n                max = lst[i];\n            }\n        }\n    }\n \
    \   if (flag == 1) {\n        ans = std::make_tuple(max, opt1);\n    }\n    if\
    \ (flag1 == 1) {\n        ans = std::make_tuple(opt, min);\n    }\n    if (flag\
    \ == 1 && flag1 == 1) {\n        ans = std::make_tuple(max, min);\n    }\n   \
    \ return ans;", "\t\n\tif(lst.size() == 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\tlong min;\n\tlong max;\n\t\n\tmin = *std::min_element(lst.begin(),\
    \ lst.end());\n\tmax = *std::max_element(lst.begin(), lst.end());\n\tif(min >=\
    \ 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(min));\n\
    \tif(max <= 0)\n\t\treturn std::make_tuple(std::optional<long>(max), std::optional<long>(std::nullopt));\n\
    \t\n\treturn std::make_tuple(std::optional<long>(max), std::optional<long>(min));",
  "    if(lst.size()==0) {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }\n    else {\n        long min=1000;\n\
    \        long max=-1000;\n        for(long i=0;i<lst.size();i++) {\n         \
    \   if(lst[i]>=0 && lst[i]<min) {\n                min=lst[i];\n            }\n\
    \            if(lst[i]<0 && lst[i]>max) {\n                max=lst[i];\n     \
    \       }\n        }\n        if(min==1000) {\n            min=std::nullopt;\n\
    \        }\n        if(max==-1000) {\n            max=std::nullopt;\n        }\n\
    \        return std::make_tuple(std::optional<long>(max), std::optional<long>(min));\n\
    \    }", "\tint len=lst.size();\n\tlong max;\n\tlong min;\n\tint max_count=0;\n\
    \tint min_count=0;\n\tfor(int i=0;i<len;i++)\n\t{\n\t\tif(lst[i]<0)\n\t\t{\n\t\
    \t\tmax=lst[i];\n\t\t\tmax_count++;\n\t\t}\n\t\tif(lst[i]>0)\n\t\t{\n\t\t\tmin=lst[i];\n\
    \t\t\tmin_count++;\n\t\t}\n\t}\n\tfor(int i=0;i<len;i++)\n\t{\n\t\tif(lst[i]<0)\n\
    \t\t{\n\t\t\tif(lst[i]>max)\n\t\t\t{\n\t\t\t\tmax=lst[i];\n\t\t\t}\n\t\t}\n\t\t\
    if(lst[i]>0)\n\t\t{\n\t\t\tif(lst[i]<min)\n\t\t\t{\n\t\t\t\tmin=lst[i];\n\t\t\t\
    }\n\t\t}\n\t}\n\tif(max_count==0)\n\t{\n\t\tmax=NULL;\n\t}\n\tif(min_count==0)\n\
    \t{\n\t\tmin=NULL;\n\t}\n\treturn std::make_tuple(max,min);", "  if (lst.size()\
    \ == 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \  }\n  std::vector<long> v1, v2;\n  std::copy_if(lst.begin(), lst.end(), std::back_inserter(v1),\
    \ [](long i) { return i < 0; });\n  std::copy_if(lst.begin(), lst.end(), std::back_inserter(v2),\
    \ [](long i) { return i > 0; });\n  std::sort(v1.begin(), v1.end());\n  std::sort(v2.begin(),\
    \ v2.end());\n  std::optional<long> a, b;\n  if (v1.size() > 0) {\n    a = std::make_optional(v1[v1.size()\
    \ - 1]);\n  }\n  if (v2.size() > 0) {\n    b = std::make_optional(v2[0]);\n  }\n\
    \  return std::make_tuple(a, b);", "    // Your code here\n    long max_neg =\
    \ INT_MIN;\n    long min_pos = INT_MAX;\n    for(int i = 0; i < lst.size(); i++){\n\
    \      if(lst[i] >= 0 && lst[i] < min_pos){\n        min_pos = lst[i];\n     \
    \ }\n      if(lst[i] < 0 && lst[i] > max_neg){\n        max_neg = lst[i];\n  \
    \    }\n    }\n    std::optional<long> max = max_neg;\n    std::optional<long>\
    \ min = min_pos;\n    if(min_pos == INT_MAX){\n      min = {};\n    }\n    if(max_neg\
    \ == INT_MIN){\n      max = {};\n    }\n    return std::make_tuple(max, min);",
  "\t//your code here\n\tstd::optional<long> largest_negative = std::nullopt;\n\t\
    std::optional<long> smallest_positive = std::nullopt;\n\tlong temp;\n\tfor (long\
    \ l : lst) {\n\t\tif (l < 0) {\n\t\t\tif (largest_negative == std::nullopt) {\n\
    \t\t\t\tlargest_negative = l;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (l > largest_negative)\
    \ {\n\t\t\t\t\tlargest_negative = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (l\
    \ > 0) {\n\t\t\tif (smallest_positive == std::nullopt) {\n\t\t\t\tsmallest_positive\
    \ = l;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (l < smallest_positive) {\n\t\t\t\t\t\
    smallest_positive = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> largest_neg, smallest_pos;\n\
    \    for (long elem : lst) {\n        if (elem < 0) {\n            if (!largest_neg\
    \ || elem > *largest_neg) {\n                largest_neg = elem;\n           \
    \ }\n        } else if (elem > 0) {\n            if (!smallest_pos || elem < *smallest_pos)\
    \ {\n                smallest_pos = elem;\n            }\n        }\n    }\n \
    \   return std::make_tuple(largest_neg, smallest_pos);", "    // Put your code\
    \ here\n    long max = -999999999999;\n    long min = 999999999999;\n    bool\
    \ fmin = false;\n    bool fmax = false;\n    for(long a : lst){\n        if(a\
    \ < 0){\n            if(a > max){\n                max = a;\n                fmax\
    \ = true;\n            }\n        }\n        else{\n            if(a < min){\n\
    \                min = a;\n                fmin = true;\n            }\n     \
    \   }\n    }\n    if(fmax){\n        return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));\n    }\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));", "\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ ret;\n    long min = INT_MAX;\n    long max = INT_MIN;\n    for (auto num :\
    \ lst) {\n        if (num > 0) {\n            if (num < min) {\n             \
    \   min = num;\n            }\n        } else if (num < 0) {\n            if (num\
    \ > max) {\n                max = num;\n            }\n        }\n    }\n    if\
    \ (min == INT_MAX) {\n        std::get<1>(ret) = std::nullopt;\n    } else {\n\
    \        std::get<1>(ret) = min;\n    }\n    if (max == INT_MIN) {\n        std::get<0>(ret)\
    \ = std::nullopt;\n    } else {\n        std::get<0>(ret) = max;\n    }\n    return\
    \ ret;", "  std::optional<long> a, b;\n  for (auto e : lst) {\n    if (e > 0)\
    \ {\n      if (!b || e < *b) {\n        b = e;\n      }\n    } else if (e < 0)\
    \ {\n      if (!a || e > *a) {\n        a = e;\n      }\n    }\n  }\n  return\
    \ std::make_tuple(a, b);", "  std::optional<long> largest = std::nullopt;\n  std::optional<long>\
    \ smallest = std::nullopt;\n  for (long value : lst) {\n    if (value < 0) {\n\
    \      if (!largest.has_value() || *largest < value) {\n        largest = value;\n\
    \      }\n    } else if (value > 0) {\n      if (!smallest.has_value() || *smallest\
    \ > value) {\n        smallest = value;\n      }\n    }\n  }\n  return std::make_tuple(largest,\
    \ smallest);", "  std::optional<long> negative;\n  std::optional<long> positive;\n\
    \  for (auto item : lst) {\n    if (item > 0) {\n      if (!positive.has_value())\
    \ {\n        positive = item;\n      } else {\n        positive = std::min(positive.value(),\
    \ item);\n      }\n    } else if (item < 0) {\n      if (!negative.has_value())\
    \ {\n        negative = item;\n      } else {\n        negative = std::max(negative.value(),\
    \ item);\n      }\n    }\n  }\n  return std::make_tuple(negative, positive);",
  "  if (lst.size() == 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  }\n  long max = LONG_MIN;\n  long min\
    \ = LONG_MAX;\n  for (long i = 0; i < lst.size(); i++) {\n    if (lst[i] < 0)\
    \ {\n      if (lst[i] > max) {\n        max = lst[i];\n      }\n    }\n    if\
    \ (lst[i] > 0) {\n      if (lst[i] < min) {\n        min = lst[i];\n      }\n\
    \    }\n  }\n  if (max == LONG_MIN) {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min));\n  }\n  if (min == LONG_MAX) {\n    return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(std::nullopt));\n  }\n  return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));", "    long min = 0;\n    long max = 0;\n    int\
    \ count = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(lst[i] > 0){\n\
    \            if(count == 0)\n                min = lst[i];\n            if(lst[i]\
    \ < min)\n                min = lst[i];\n            count++;\n        }\n   \
    \     if(lst[i] < 0){\n            if(count == 0)\n                max = lst[i];\n\
    \            if(lst[i] > max)\n                max = lst[i];\n            count++;\n\
    \        }\n    }\n    std::optional<long> om;\n    std::optional<long> op;\n\
    \    if(count == 0){\n        om = {};\n        op = {};\n    }\n    else if(count\
    \ == 1){\n        if(min > 0)\n            om = {};\n        else\n          \
    \  op = {};\n    }\n    else{\n        om = max;\n        op = min;\n    }\n \
    \   return std::make_tuple(om, op);", "\t// To be completed\n    std::vector<long>\
    \ arr ;\n    for(auto i : lst){\n        if(i<0){\n            arr.push_back(i);\n\
    \        }\n    }\n    std::optional<long> a ;\n    std::optional<long> b ;\n\
    \    if(arr.size()>0){\n        std::sort(arr.begin(),arr.end());\n        a =\
    \ arr[0];\n    }\n    else\n        a = std::nullopt;\n    arr.clear();\n    for(auto\
    \ i : lst){\n        if(i>0){\n            arr.push_back(i);\n        }\n    }\n\
    \    if(arr.size()>0){\n        std::sort(arr.begin(),arr.end());\n        b =\
    \ arr[0];\n    }\n    else\n        b = std::nullopt;\n    return std::make_tuple(a,b);",
  "    long maxN=0,minP=0;\n    std::optional<long>maxN1,minP1;\n    if(lst.size()==0)\n\
    \        return std::make_tuple(maxN1,minP1);\n    std::sort(lst.begin(),lst.end());\n\
    \    for(int i=0;i<lst.size();i++)\n    {\n        if(lst[i]<0)\n            maxN=lst[i];\n\
    \        else\n            break;\n    }\n    for(int i=lst.size()-1;i>=0;i--)\n\
    \    {\n        if(lst[i]>0)\n            minP=lst[i];\n        else\n       \
    \     break;\n    }\n    if(maxN<0)\n        maxN1=maxN;\n    if(minP>0)\n   \
    \     minP1=minP;\n    return std::make_tuple(maxN1,minP1);", "    std::optional<long>\
    \ largest = std::nullopt;\n    std::optional<long> smallest = std::nullopt;\n\
    \    int count = 0;\n    for (auto i = lst.begin(); i != lst.end(); i++) {\n \
    \       if (count == 0) {\n            if (*i < 0) {\n                largest\
    \ = *i;\n            } else if (*i > 0) {\n                smallest = *i;\n  \
    \          }\n            count++;\n        } else {\n            if (*i < 0)\
    \ {\n                if (largest != std::nullopt) {\n                    if (*i\
    \ > *largest) {\n                        largest = *i;\n                    }\n\
    \                } else {\n                    largest = *i;\n               \
    \ }\n            } else if (*i > 0) {\n                if (smallest != std::nullopt)\
    \ {\n                    if (*i < *smallest) {\n                        smallest\
    \ = *i;\n                    }\n                } else {\n                   \
    \ smallest = *i;\n                }\n            }\n        }\n    }\n    return\
    \ std::make_tuple(largest, smallest);", "    if(lst.size() == 0)\n        return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    auto max = std::numeric_limits<long>::min();\n    auto min = std::numeric_limits<long>::max();\n\
    \    std::sort(lst.begin(), lst.end());\n    if(lst[0] > 0)\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(lst[0]));\n    else if(lst[lst.size() - 1] < 0)\n      \
    \  return std::make_tuple(std::optional<long>(lst[lst.size() - 1]), std::optional<long>(std::nullopt));\n\
    \    else\n        return std::make_tuple(std::optional<long>(lst[lst.size() -\
    \ 1]), std::optional<long>(lst[0]));", "  std::optional<long> maxn;\n  std::optional<long>\
    \ minp;\n  for (auto i: lst) {\n    if (i < 0) {\n      if (!maxn.has_value()\
    \ || i > maxn.value()) {\n        maxn = i;\n      }\n    } else if (i > 0) {\n\
    \      if (!minp.has_value() || i < minp.value()) {\n        minp = i;\n     \
    \ }\n    }\n  }\n  return std::make_tuple(maxn, minp);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>>  tup;\n    bool flag = true;\n    long small = INT_MAX;\n\
    \    long large = INT_MIN;\n    for(auto i: lst){\n        if(i>0 && i<small){\n\
    \            small = i;\n            flag = false;\n        }\n        if(i<0\
    \ && i>large){\n            large = i;\n            flag = false;\n        }\n\
    \    }\n    if(flag){\n        std::get<0>(tup) = std::nullopt;\n        std::get<1>(tup)\
    \ = std::nullopt;\n    }\n    else{\n        std::get<0>(tup) = large;\n     \
    \   std::get<1>(tup) = small;\n    }\n    return tup;", "    long max = LONG_MIN;\n\
    \    long min = LONG_MAX;\n    bool found_negative = false;\n    bool found_positive\
    \ = false;\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] <\
    \ 0) {\n            found_negative = true;\n            if (lst[i] > max) {\n\
    \                max = lst[i];\n            }\n        }\n        if (lst[i] >\
    \ 0) {\n            found_positive = true;\n            if (lst[i] < min) {\n\
    \                min = lst[i];\n            }\n        }\n    }\n    std::optional<long>\
    \ a = (found_negative) ? std::optional<long>(max) : std::optional<long>(std::nullopt);\n\
    \    std::optional<long> b = (found_positive) ? std::optional<long>(min) : std::optional<long>(std::nullopt);\n\
    \    return std::make_tuple(a, b);", "\tstd::vector<long> lst_positive, lst_negative;\n\
    \tif (lst.size() == 0) {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\t}\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tlst_positive.push_back(lst[i]);\n\t\t}\n\
    \t\telse if (lst[i] < 0) {\n\t\t\tlst_negative.push_back(lst[i]);\n\t\t}\n\t}\n\
    \tlong largest = INT_MIN, smallest = INT_MAX;\n\tif (lst_positive.size() == 0)\
    \ {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \t}\n\tfor (int i = 0; i < lst_positive.size(); i++) {\n\t\tif (lst_positive[i]\
    \ < smallest) {\n\t\t\tsmallest = lst_positive[i];\n\t\t}\n\t}\n\tfor (int i =\
    \ 0; i < lst_negative.size(); i++) {\n\t\tif (lst_negative[i] > largest) {\n\t\
    \t\tlargest = lst_negative[i];\n\t\t}\n\t}\n\tif (largest == INT_MIN) {\n\t\t\
    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(smallest));\n\
    \t}\n\treturn std::make_tuple(std::optional<long>(largest), std::optional<long>(smallest));",
  "        std::optional<long> smallest_pos;\n        std::optional<long> largest_neg;\n\
    \        for (long el : lst) {\n                if (el > 0) {\n              \
    \          if (!smallest_pos.has_value() || el < smallest_pos.value()) {\n   \
    \                             smallest_pos = el;\n                        }\n\
    \                } else if (el < 0) {\n                        if (!largest_neg.has_value()\
    \ || el > largest_neg.value()) {\n                                largest_neg\
    \ = el;\n                        }\n                }\n        }\n        return\
    \ std::make_tuple(largest_neg, smallest_pos);", "\t// print(lst)\n\t// print(min(lst))\n\
    \t// print(max(lst))\n\t// # if no elements, return None\n\t// print(len(lst))\n\
    \tstd::optional<long> x(std::nullopt);\n\tstd::optional<long> y(std::nullopt);\n\
    \tif (lst.size() == 0)\n\t\treturn std::make_tuple(x, y);\n\t// # if all elements\
    \ are 0, return None\n\t// if all(el == 0 for el in lst):\n\t//     return (None,\
    \ None)\n\t// # if all elements are positive, return None for first\n\t// if all(el\
    \ > 0 for el in lst):\n\t//     return (None, min(lst))\n\t// # if all elements\
    \ are negative, return None for second\n\t// if all(el < 0 for el in lst):\n\t\
    //     return (max(lst), None)\n\t// # if there are both positive and negative\
    \ numbers\n\t// else:\n\t//     return (max(lst), min(lst))\n\treturn std::make_tuple(x,\
    \ y);", "  std::tuple<std::optional<long>, std::optional<long>> list;\n  std::optional<long>\
    \ temp1 = std::nullopt;\n  std::optional<long> temp2 = std::nullopt;\n  for(auto\
    \ i : lst){\n    if(i < 0 && i > temp1){\n      temp1 = i;\n    }else if(i > 0\
    \ && temp2 == std::nullopt){\n      temp2 = i;\n    }else if(i > 0 && i < temp2){\n\
    \      temp2 = i;\n    }\n  }\n  return std::make_tuple(temp1, temp2);", "\tlong\
    \ min = 0;\n\tlong max = 0;\n\tstd::vector<long> pos;\n\tstd::vector<long> neg;\n\
    \tfor (auto i : lst) {\n\t\tif (i < 0)\n\t\t\tneg.push_back(i);\n\t\telse if (i\
    \ > 0)\n\t\t\tpos.push_back(i);\n\t}\n\tif (pos.size() == 0)\n\t\treturn { std::nullopt,\
    \ std::nullopt };\n\telse {\n\t\tmin = *std::min_element(pos.begin(), pos.end());\n\
    \t\tif (neg.size() == 0)\n\t\t\treturn { std::nullopt, min };\n\t\telse {\n\t\t\
    \tmax = *std::max_element(neg.begin(), neg.end());\n\t\t\treturn { max, min };\n\
    \t\t}\n\t}", "\tstd::optional<long> a, b;\n\tfor (int i = 0; i < lst.size(); i++)\
    \ {\n\t\tif (lst[i] >= 0) {\n\t\t\tif (b) {\n\t\t\t\tif (lst[i] < *b) {\n\t\t\t\
    \t\tb = lst[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = lst[i];\n\t\t\t\
    }\n\t\t}\n\t\telse {\n\t\t\tif (a) {\n\t\t\t\tif (lst[i] > *a) {\n\t\t\t\t\ta\
    \ = lst[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = lst[i];\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn std::make_tuple(a, b);", "\tstd::optional<long> neg;\n\tstd::optional<long>\
    \ pos;\n\tint i=0;\n\tint size=lst.size();\n\twhile(lst[i]<0)\n\t{\n\t\ti++;\n\
    \t}\n\tif(i<size)\n\t{\n\t\tpos=lst[i];\n\t}\n\ti=size-1;\n\twhile(lst[i]>0)\n\
    \t{\n\t\ti--;\n\t}\n\tif(i>=0)\n\t{\n\t\tneg=lst[i];\n\t}\n\treturn std::make_tuple(neg,pos);",
  "\tif(lst.size() == 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\tlong min = std::numeric_limits<long>::max();\n\
    \tlong max = std::numeric_limits<long>::min();\n\tfor(long i : lst) {\n\t\tif(i\
    \ < 0 && i > max)\n\t\t\tmax = i;\n\t\tif(i > 0 && i < min)\n\t\t\tmin = i;\n\t\
    }\n\tif(min == std::numeric_limits<long>::max())\n\t\tmin = std::nullopt;\n\t\
    if(max == std::numeric_limits<long>::min())\n\t\tmax = std::nullopt;\n\treturn\
    \ std::make_tuple(std::optional<long>(max), std::optional<long>(min));", "   \
    \ if(lst.size() == 0)\n    {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }\n    long min=lst[0];\n    long max=lst[0];\n\
    \    std::vector<long> max_list;\n    std::vector<long> min_list;\n    for(int\
    \ i=0;i<lst.size();i++)\n    {\n        if(lst[i]>=0)\n        {\n           \
    \ if(lst[i]<min)\n            {\n                min = lst[i];\n            }\n\
    \        }\n        else\n        {\n            if(lst[i]>max)\n            {\n\
    \                max = lst[i];\n            }\n        }\n    }\n    for(int i=0;i<lst.size();i++)\n\
    \    {\n        if(lst[i]>=0)\n        {\n            if(lst[i]==min)\n      \
    \      {\n                min_list.push_back(lst[i]);\n            }\n       \
    \ }\n        else\n        {\n            if(lst[i]==max)\n            {\n   \
    \             max_list.push_back(lst[i]);\n            }\n        }\n    }\n \
    \   // std::cout<<min_list.size()<<\" \"<<max_list.size()<<std::endl;\n    if(min_list.size()==0)\n\
    \    {\n        min = std::nullopt;\n    }\n    if(max_list.size()==0)\n    {\n\
    \        max = std::nullopt;\n    }\n    return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));", "    auto a = std::max_element(lst.begin(), lst.end());\n\
    \    auto b = std::min_element(lst.begin(), lst.end());\n    if (a == lst.end()\
    \ || b == lst.end())\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    else\n        return std::make_tuple(std::optional<long>(*a),\
    \ std::optional<long>(*b));", "\tauto negative = std::max_element(lst.begin(),\
    \ lst.end());\n\tauto positive = std::min_element(lst.begin(), lst.end());\n\t\
    if(negative==lst.end()&&positive==lst.end())\n\t{\n\t\tstd::optional<long>null_var;\n\
    \t\treturn std::make_tuple(null_var,null_var);\n\t}\n\telse if(negative==lst.end())\n\
    \t{\n\t\tstd::optional<long>null_var;\n\t\treturn std::make_tuple(null_var,*positive);\n\
    \t}\n\telse if(positive==lst.end())\n\t{\n\t\tstd::optional<long>null_var;\n\t\
    \treturn std::make_tuple(*negative,null_var);\n\t}\n\telse\n\t\treturn std::make_tuple(*negative,*positive);",
  "\tbool hasPositive = false;\n\tbool hasNegative = false;\n\tlong smallestPositive\
    \ = INT_MAX;\n\tlong largestNegative = INT_MIN;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] > 0) {\n\t\t\thasPositive = true;\n\t\t\tif (lst[i] <\
    \ smallestPositive) {\n\t\t\t\tsmallestPositive = lst[i];\n\t\t\t}\n\t\t}\n\t\t\
    else if (lst[i] < 0) {\n\t\t\thasNegative = true;\n\t\t\tif (lst[i] > largestNegative)\
    \ {\n\t\t\t\tlargestNegative = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(hasNegative\
    \ ? std::optional<long>(largestNegative) : std::optional<long>(std::nullopt),\
    \ hasPositive ? std::optional<long>(smallestPositive) : std::optional<long>(std::nullopt));",
  "    std::optional<long> a = {}, b = {};\n    for (auto i : lst) {\n        if (i\
    \ > 0)\n            if (!b || i < *b)\n                b = i;\n        if (i <\
    \ 0)\n            if (!a || i > *a)\n                a = i;\n    }\n    return\
    \ {a, b};", "    std::optional<long> largest, smallest;\n    bool has_negative\
    \ = false, has_positive = false;\n    for (auto const& num : lst) {\n        if\
    \ (num < 0) {\n            if (!has_negative || num > largest.value())\n     \
    \           largest = num;\n            has_negative = true;\n        } else if\
    \ (num > 0) {\n            if (!has_positive || num < smallest.value())\n    \
    \            smallest = num;\n            has_positive = true;\n        }\n  \
    \  }\n    return std::make_tuple(largest, smallest);", "//  return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\tstd::optional<long> a,b;\n\t\n\tstd::sort(lst.begin(),lst.end());\n\
    \tint s = lst.size();\n\t\n\tif(s==0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\t\n\tlong max = lst[s-1];\n\tlong min\
    \ = lst[0];\n\t\n\tif(min>0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min));\n\t\n\tif(max<0)\n\t\treturn std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(std::nullopt));\n\t\n\tfor(int i=0;i<s;i++)\n\t{\n\t\tif(lst[i]<0)\n\
    \t\t\ta = lst[i];\n\t\tif(lst[i]>0)\n\t\t{\n\t\t\tb = lst[i];\n\t\t\tbreak;\n\t\
    \t}\n\t}\n\t\n\treturn std::make_tuple(a,b);", "    long largestNegative = 0;\n\
    \    long smallestPositive = 0;\n    if(lst.size() == 0) {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }\n    if(lst.size() == 1) {\n    \
    \    if(lst[0] > 0) {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(lst[0]));\n        }\n        else if(lst[0] < 0) {\n  \
    \          return std::make_tuple(std::optional<long>(lst[0]), std::optional<long>(std::nullopt));\n\
    \        }\n        else {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n        }\n    }\n    std::sort(lst.begin(),\
    \ lst.end());\n    if(lst[0] > 0) {\n        smallestPositive = lst[0];\n    }\n\
    \    if(lst[lst.size() - 1] < 0) {\n        largestNegative = lst[lst.size() -\
    \ 1];\n    }\n    if(smallestPositive == 0 && largestNegative == 0) {\n      \
    \  return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    }\n    else if(smallestPositive == 0) {\n        return std::make_tuple(std::optional<long>(largestNegative),\
    \ std::optional<long>(std::nullopt));\n    }\n    else if(largestNegative == 0)\
    \ {\n        return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(smallestPositive));\n\
    \    }\n    else {\n        return std::make_tuple(std::optional<long>(largestNegative),\
    \ std::optional<long>(smallestPositive));\n    }", "    if(lst.size() == 0) {\n\
    \        return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    }\n    std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for(auto i : lst) {\n        if(i < 0) {\n            if(!largest_negative)\
    \ {\n                largest_negative = i;\n            }\n            if(i >\
    \ *largest_negative) {\n                largest_negative = i;\n            }\n\
    \        }\n        if(i > 0) {\n            if(!smallest_positive) {\n      \
    \          smallest_positive = i;\n            }\n            if(i < *smallest_positive)\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ mx, mn;\n    for (auto i: lst) {\n        if (i > 0) {\n            if (!mn.has_value()\
    \ || i < mn.value()) {\n                mn = i;\n            }\n        } else\
    \ if (i < 0) {\n            if (!mx.has_value() || i > mx.value()) {\n       \
    \         mx = i;\n            }\n        }\n    }\n    return std::make_tuple(mx,\
    \ mn);", "  std::optional<long> max, min;\n  for (auto i : lst) {\n    if (i >\
    \ 0) {\n      if (!min || i < *min) {\n        min = i;\n      }\n    } else if\
    \ (i < 0) {\n      if (!max || i > *max) {\n        max = i;\n      }\n    }\n\
    \  }\n  return std::make_tuple(max, min);", "    std::optional<long> largest_neg;\n\
    \    std::optional<long> smallest_pos;\n    for (auto &i : lst) {\n        if\
    \ (i < 0) {\n            if (!largest_neg.has_value() || i > largest_neg.value())\
    \ {\n                largest_neg = i;\n            }\n        } else if (i > 0)\
    \ {\n            if (!smallest_pos.has_value() || i < smallest_pos.value()) {\n\
    \                smallest_pos = i;\n            }\n        }\n    }\n    return\
    \ std::make_tuple(largest_neg, smallest_pos);", "\tif (lst.size() == 0) {\n\t\t\
    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \t}\n\telse {\n\t\tauto p = std::minmax_element(lst.begin(), lst.end());\n\t\t\
    std::optional<long> a, b;\n\t\tif (*p.first > 0) {\n\t\t\ta = std::nullopt;\n\t\
    \t}\n\t\telse {\n\t\t\ta = *p.first;\n\t\t}\n\t\tif (*p.second < 0) {\n\t\t\t\
    b = std::nullopt;\n\t\t}\n\t\telse {\n\t\t\tb = *p.second;\n\t\t}\n\t\treturn\
    \ std::make_tuple(a, b);\n\t}", "    int mx = INT_MIN, mn = INT_MAX;\n    int\
    \ n = lst.size();\n    bool is_pos = false, is_neg = false;\n    for(int i = 0;\
    \ i < n; i++) {\n        if(lst[i] > 0) {\n            is_pos = true;\n      \
    \      mn = std::min(mn, lst[i]);\n        }\n        if(lst[i] < 0) {\n     \
    \       is_neg = true;\n            mx = std::max(mx, lst[i]);\n        }\n  \
    \  }\n    std::optional<long> a, b;\n    if(is_neg) {\n        a = mx;\n    }\n\
    \    if(is_pos) {\n        b = mn;\n    }\n    return std::make_tuple(a, b);",
  "    std::optional<long> l1 = std::nullopt;\n    std::optional<long> l2 = std::nullopt;\n\
    \    bool found1 = false;\n    bool found2 = false;\n    for (long l : lst) {\n\
    \        if (l < 0 && (!found1 || l > l1.value())) {\n            l1 = l;\n  \
    \          found1 = true;\n        }\n        if (l > 0 && (!found2 || l < l2.value()))\
    \ {\n            l2 = l;\n            found2 = true;\n        }\n    }\n    return\
    \ std::make_tuple(l1, l2);", "\t// your code here\n\tint negMax = INT_MIN;\n\t\
    int posMin = INT_MAX;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i]\
    \ < 0) {\n\t\t\tnegMax = std::max(negMax, lst[i]);\n\t\t}\n\t\telse if (lst[i]\
    \ > 0) {\n\t\t\tposMin = std::min(posMin, lst[i]);\n\t\t}\n\t}\n\tstd::optional<long>\
    \ negVal = std::nullopt;\n\tstd::optional<long> posVal = std::nullopt;\n\tif (negMax\
    \ != INT_MIN) {\n\t\tnegVal = negMax;\n\t}\n\tif (posMin != INT_MAX) {\n\t\tposVal\
    \ = posMin;\n\t}\n\treturn std::make_tuple(negVal, posVal);", "        std::optional<long>\
    \ largest;\n        std::optional<long> smallest;\n        for (auto v : lst)\
    \ {\n            if (v > 0) {\n                if (!smallest.has_value() || v\
    \ < smallest.value())\n                    smallest = v;\n            } else if\
    \ (v < 0) {\n                if (!largest.has_value() || v > largest.value())\n\
    \                    largest = v;\n            }\n        }\n        return std::make_tuple(largest,\
    \ smallest);", "    std::optional<long> positive = std::nullopt;\n    std::optional<long>\
    \ negative = std::nullopt;\n    for (auto i : lst) {\n        if (i > 0 && (!positive\
    \ || i < *positive)) {\n            positive = i;\n        }\n        if (i <\
    \ 0 && (!negative || i > *negative)) {\n            negative = i;\n        }\n\
    \    }\n    return std::make_tuple(negative, positive);", "  if (lst.size() ==\
    \ 0)\n  {\n    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \  }\n  long a = INT_MIN;\n  long b = INT_MAX;\n  for (long i = 0; i < lst.size();\
    \ i++)\n  {\n    if (lst[i] < 0 && lst[i] > a)\n    {\n      a = lst[i];\n   \
    \ }\n    if (lst[i] > 0 && lst[i] < b)\n    {\n      b = lst[i];\n    }\n  }\n\
    \  if (a == INT_MIN && b == INT_MAX)\n  {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  }\n  else if (a == INT_MIN)\n  {\n  \
    \  return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(b));\n\
    \  }\n  else if (b == INT_MAX)\n  {\n    return std::make_tuple(std::optional<long>(a),\
    \ std::optional<long>(std::nullopt));\n  }\n  else\n  {\n    return std::make_tuple(std::optional<long>(a),\
    \ std::optional<long>(b));\n  }", "\t// Your code goes here\n\tif (lst.size()\
    \ == 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \tint max = lst[0], min = lst[0];\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\
    \tif (lst[i] < 0) {\n\t\t\tif (lst[i] > max)\n\t\t\t\tmax = lst[i];\n\t\t}\n\t\
    \telse {\n\t\t\tif (lst[i] < min)\n\t\t\t\tmin = lst[i];\n\t\t}\n\t}\n\tif (max\
    \ >= 0 && min >= 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min));\n\telse if (max < 0 && min < 0)\n\t\treturn std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(std::nullopt));\n\telse\n\t\treturn std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));", "\tbool is_first_neg = false;\n\tbool is_first_pos\
    \ = false;\n\tlong first_neg = 0;\n\tlong first_pos = 0;\n\tstd::optional<long>\
    \ first_neg_opt;\n\tstd::optional<long> first_pos_opt;\n\tif (lst.size() == 0)\n\
    \t\treturn std::make_tuple(first_neg_opt, first_pos_opt);\n\tfor (auto i = lst.begin();\
    \ i != lst.end(); i++) {\n\t\tif (*i < 0) {\n\t\t\tif (!is_first_neg) {\n\t\t\t\
    \tfirst_neg = *i;\n\t\t\t\tis_first_neg = true;\n\t\t\t}\n\t\t\telse if (*i >\
    \ first_neg)\n\t\t\t\tfirst_neg = *i;\n\t\t}\n\t\telse if (*i > 0) {\n\t\t\tif\
    \ (!is_first_pos) {\n\t\t\t\tfirst_pos = *i;\n\t\t\t\tis_first_pos = true;\n\t\
    \t\t}\n\t\t\telse if (*i < first_pos)\n\t\t\t\tfirst_pos = *i;\n\t\t}\n\t}\n\t\
    if (is_first_neg)\n\t\tfirst_neg_opt = first_neg;\n\tif (is_first_pos)\n\t\tfirst_pos_opt\
    \ = first_pos;\n\treturn std::make_tuple(first_neg_opt, first_pos_opt);", "  \
    \  // TODO: Implement this function!\n    std::tuple<std::optional<long>, std::optional<long>>\
    \ tup;\n    long max = INT_MIN;\n    long min = INT_MAX;\n    if(lst.size() ==\
    \ 0){\n        std::get<0>(tup) = std::nullopt;\n        std::get<1>(tup) = std::nullopt;\n\
    \        return tup;\n    }\n    for(int i = 0; i < lst.size(); i++){\n      \
    \  if(lst[i] > 0){\n            if(lst[i] < min){\n                min = lst[i];\n\
    \            }\n        }\n        else if(lst[i] < 0){\n            if(lst[i]\
    \ > max){\n                max = lst[i];\n            }\n        }\n    }\n  \
    \  if(max == INT_MIN){\n        std::get<0>(tup) = std::nullopt;\n    }\n    else{\n\
    \        std::get<0>(tup) = max;\n    }\n    if(min == INT_MAX){\n        std::get<1>(tup)\
    \ = std::nullopt;\n    }\n    else{\n        std::get<1>(tup) = min;\n    }\n\
    \    return tup;", "\tstd::optional<long> smallest = std::nullopt;\n\tstd::optional<long>\
    \ largest = std::nullopt;\n\tlong temp;\n\tstd::vector<long> pos;\n\tstd::vector<long>\
    \ neg;\n\tfor (auto i : lst) {\n\t\tif (i > 0) {\n\t\t\tpos.push_back(i);\n\t\t\
    }\n\t\telse if (i < 0) {\n\t\t\tneg.push_back(i);\n\t\t}\n\t}\n\tif (pos.size()\
    \ > 0) {\n\t\tsmallest = pos[0];\n\t\tfor (auto i : pos) {\n\t\t\tif (i < smallest)\
    \ {\n\t\t\t\tsmallest = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (neg.size() > 0) {\n\t\t\
    largest = neg[0];\n\t\tfor (auto i : neg) {\n\t\t\tif (i > largest) {\n\t\t\t\t\
    largest = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(largest, smallest);",
  "  long minn = LONG_MAX;\n  long maxx = LONG_MIN;\n  int flag1 = 0, flag2 = 0;\n\
    \  if(lst.size() == 0) {\n    std::tuple<std::optional<long>, std::optional<long>>\
    \ x = std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    return x;\n  }\n  for(int i = 0; i < lst.size(); i++) {\n    if(lst[i] <\
    \ 0) {\n      if(maxx < lst[i]) {\n        maxx = lst[i];\n        flag1 = 1;\n\
    \      }\n    }\n    if(lst[i] > 0) {\n      if(minn > lst[i]) {\n        minn\
    \ = lst[i];\n        flag2 = 1;\n      }\n    }\n  }\n  if(flag1 == 0)\n    maxx\
    \ = std::nullopt;\n  if(flag2 == 0)\n    minn = std::nullopt;\n  std::tuple<std::optional<long>,\
    \ std::optional<long>> x = std::make_tuple(std::optional<long>(maxx), std::optional<long>(minn));\n\
    \  return x;", "  std::optional<long> largest;\n  std::optional<long> smallest;\n\
    \  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] < 0) {\n      if (!largest)\
    \ largest = lst[i];\n      else if (lst[i] > *largest) largest = lst[i];\n   \
    \ }\n    else if (lst[i] > 0) {\n      if (!smallest) smallest = lst[i];\n   \
    \   else if (lst[i] < *smallest) smallest = lst[i];\n    }\n  }\n  return std::make_tuple(largest,\
    \ smallest);", "    //C++ implementation of the code\n    long largestNegativeNumber=INT64_MIN;\n\
    \    long smallestPositiveNumber=INT64_MAX;\n    bool isNegativePresent=false;\n\
    \    bool isPositivePresent=false;\n    for(auto i:lst){\n        if(i<0){\n \
    \           isNegativePresent=true;\n            if(i>largestNegativeNumber){\n\
    \                largestNegativeNumber=i;\n            }\n        }\n        else\
    \ if(i>0){\n            isPositivePresent=true;\n            if(i<smallestPositiveNumber){\n\
    \                smallestPositiveNumber=i;\n            }\n        }\n    }\n\
    \    if(isNegativePresent){\n        return std::make_tuple(std::optional<long>(largestNegativeNumber),\
    \ std::optional<long>(smallestPositiveNumber));\n    }\n    else if(isPositivePresent){\n\
    \        return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(smallestPositiveNumber));\n\
    \    }\n    else{\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }", "    std::optional<long> omax,\
    \ omin;\n    for (long a : lst) {\n        if (a >= 0) {\n            if (!omin\
    \ || a < *omin) {\n                omin = a;\n            }\n        } else {\n\
    \            if (!omax || a > *omax) {\n                omax = a;\n          \
    \  }\n        }\n    }\n    return std::make_tuple(omax, omin);", "    std::optional<long>\
    \ largest = std::nullopt;\n    std::optional<long> smallest = std::nullopt;\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        if(lst[i] >= 0 && !smallest.has_value())\
    \ {\n            smallest = lst[i];\n        } else if (lst[i] >= 0 && lst[i]\
    \ < smallest.value()) {\n            smallest = lst[i];\n        }\n        if(lst[i]\
    \ < 0 && !largest.has_value()) {\n            largest = lst[i];\n        } else\
    \ if (lst[i] < 0 && lst[i] > largest.value()) {\n            largest = lst[i];\n\
    \        }\n    }\n    return std::make_tuple(largest, smallest);", "  std::vector<long>\
    \ negatives, positives;\n  for (auto i : lst) {\n    if (i < 0) {\n      negatives.push_back(i);\n\
    \    } else if (i > 0) {\n      positives.push_back(i);\n    }\n  }\n  if (negatives.size()\
    \ > 0) {\n    std::sort(negatives.begin(), negatives.end());\n  }\n  if (positives.size()\
    \ > 0) {\n    std::sort(positives.begin(), positives.end());\n  }\n  std::optional<long>\
    \ largest_negative;\n  if (negatives.size() > 0) {\n    largest_negative = negatives[negatives.size()\
    \ - 1];\n  }\n  std::optional<long> smallest_positive;\n  if (positives.size()\
    \ > 0) {\n    smallest_positive = positives[0];\n  }\n  return std::make_tuple(largest_negative,\
    \ smallest_positive);", "\tstd::optional<long> a, b;\n\tif (lst.size() == 0)\n\
    \t\treturn std::make_tuple(a, b);\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\
    \tif (lst[i] < 0) {\n\t\t\tif (a == std::nullopt)\n\t\t\t\ta = lst[i];\n\t\t\t\
    else if (lst[i] > *a)\n\t\t\t\ta = lst[i];\n\t\t}\n\t\telse if (lst[i] > 0) {\n\
    \t\t\tif (b == std::nullopt)\n\t\t\t\tb = lst[i];\n\t\t\telse if (lst[i] < *b)\n\
    \t\t\t\tb = lst[i];\n\t\t}\n\t}\n\treturn std::make_tuple(a, b);", "    long max_of_neg\
    \ = INT_MIN;\n    long min_of_pos = INT_MAX;\n    int neg = 0;\n    int pos =\
    \ 0;\n    for(int i = 0; i < lst.size(); i++) {\n        if(lst[i] < 0) {\n  \
    \          neg++;\n            if(lst[i] > max_of_neg) {\n                max_of_neg\
    \ = lst[i];\n            }\n        }\n        else if(lst[i] > 0) {\n       \
    \     pos++;\n            if(lst[i] < min_of_pos) {\n                min_of_pos\
    \ = lst[i];\n            }\n        }\n    }\n    std::optional<long> max_of_neg_opt;\n\
    \    std::optional<long> min_of_pos_opt;\n    if(neg == 0) {\n        max_of_neg_opt\
    \ = std::nullopt;\n    }\n    else {\n        max_of_neg_opt = max_of_neg;\n \
    \   }\n    if(pos == 0) {\n        min_of_pos_opt = std::nullopt;\n    }\n   \
    \ else {\n        min_of_pos_opt = min_of_pos;\n    }\n    return std::make_tuple(max_of_neg_opt,\
    \ min_of_pos_opt);", "    // Write your implementation here\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "  std::vector<long> pos_lst = {};\n  std::vector<long> neg_lst\
    \ = {};\n  for (long num : lst) {\n    if (num > 0) {\n      pos_lst.push_back(num);\n\
    \    } else if (num < 0) {\n      neg_lst.push_back(num);\n    }\n  }\n  if (pos_lst.size()\
    \ == 0 && neg_lst.size() == 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  } else if (pos_lst.size() == 0) {\n \
    \   return std::make_tuple(std::optional<long>(*std::max_element(neg_lst.begin(),\
    \ neg_lst.end())), std::optional<long>(std::nullopt));\n  } else if (neg_lst.size()\
    \ == 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(*std::min_element(pos_lst.begin(),\
    \ pos_lst.end())));\n  } else {\n    return std::make_tuple(std::optional<long>(*std::max_element(neg_lst.begin(),\
    \ neg_lst.end())), std::optional<long>(*std::min_element(pos_lst.begin(), pos_lst.end())));\n\
    \  }", "    long min, max;\n    if(lst.size()!=0){\n        min = lst[0];\n  \
    \      max = lst[0];\n        for(int i=0; i<lst.size(); i++){\n            if(lst[i]>max){\n\
    \                max = lst[i];\n            }\n            if(lst[i]<min){\n \
    \               min = lst[i];\n            }\n        }\n        return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));\n    }\n    else{\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }", "\tstd::optional<long> largest,\
    \ smallest;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > 0) {\n\
    \t\t\tif (!smallest) {\n\t\t\t\tsmallest = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i]\
    \ < smallest) {\n\t\t\t\tsmallest = lst[i];\n\t\t\t}\n\t\t}\n\t\telse if (lst[i]\
    \ < 0) {\n\t\t\tif (!largest) {\n\t\t\t\tlargest = lst[i];\n\t\t\t}\n\t\t\telse\
    \ if (lst[i] > largest) {\n\t\t\t\tlargest = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\t\
    return std::make_tuple(largest, smallest);", "    long p_min = 0, n_max = 0;\n\
    \    int p_flag = 0, n_flag = 0;\n    for(auto i : lst) {\n        if(i > 0) {\n\
    \            if(p_flag == 0) {\n                p_min = i;\n                p_flag\
    \ = 1;\n            }\n            else {\n                p_min = std::min(p_min,\
    \ i);\n            }\n        }\n        else if(i < 0) {\n            if(n_flag\
    \ == 0) {\n                n_max = i;\n                n_flag = 1;\n         \
    \   }\n            else {\n                n_max = std::max(n_max, i);\n     \
    \       }\n        }\n    }\n    if(p_flag) {\n        if(n_flag) {\n        \
    \    return std::make_tuple(std::optional<long>(n_max), std::optional<long>(p_min));\n\
    \        }\n        else {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(p_min));\n        }\n    }\n    else {\n        if(n_flag)\
    \ {\n            return std::make_tuple(std::optional<long>(n_max), std::optional<long>(std::nullopt));\n\
    \        }\n        else {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n        }\n    }", "\tstd::optional<long>\
    \ maxNegative = std::nullopt;\n\tstd::optional<long> minPositive = std::nullopt;\n\
    \tfor (long item : lst) {\n\t\tif (item < 0) {\n\t\t\tif (!maxNegative || item\
    \ > *maxNegative)\n\t\t\t\tmaxNegative = item;\n\t\t}\n\t\telse if (item > 0)\
    \ {\n\t\t\tif (!minPositive || item < *minPositive)\n\t\t\t\tminPositive = item;\n\
    \t\t}\n\t}\n\treturn std::make_tuple(maxNegative, minPositive);", "    if(lst.size()==0)\n\
    \        return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    int negmax=INT_MIN,posmin=INT_MAX;\n    for(int i=0;i<lst.size();i++)\n \
    \   {\n        if(lst[i]<0&&lst[i]>negmax)\n            negmax=lst[i];\n     \
    \   if(lst[i]>0&&lst[i]<posmin)\n            posmin=lst[i];\n    }\n    if(negmax==INT_MIN)\n\
    \        negmax=std::nullopt;\n    if(posmin==INT_MAX)\n        posmin=std::nullopt;\n\
    \    return std::make_tuple(std::optional<long>(negmax), std::optional<long>(posmin));",
  "  std::vector<long> positive;\n  std::vector<long> negative;\n  for (auto &i :\
    \ lst) {\n    if (i < 0) {\n      negative.push_back(i);\n    } else if (i > 0)\
    \ {\n      positive.push_back(i);\n    }\n  }\n  std::optional<long> largestNegative(std::nullopt);\n\
    \  std::optional<long> smallestPositive(std::nullopt);\n  if (negative.size()\
    \ > 0) {\n    std::sort(negative.begin(), negative.end());\n    largestNegative\
    \ = negative[negative.size() - 1];\n  }\n  if (positive.size() > 0) {\n    std::sort(positive.begin(),\
    \ positive.end());\n    smallestPositive = positive[0];\n  }\n  return std::make_tuple(largestNegative,\
    \ smallestPositive);", "  std::optional<long> largest_negative;\n  std::optional<long>\
    \ smallest_positive;\n  int negative_num = 0;\n  int positive_num = 0;\n  for\
    \ (long i = 0; i < lst.size(); i++) {\n    if (lst[i] < 0) {\n      negative_num\
    \ += 1;\n      if (largest_negative == std::nullopt || lst[i] > *largest_negative)\
    \ {\n        largest_negative = lst[i];\n      }\n    } else if (lst[i] > 0) {\n\
    \      positive_num += 1;\n      if (smallest_positive == std::nullopt || lst[i]\
    \ < *smallest_positive) {\n        smallest_positive = lst[i];\n      }\n    }\n\
    \  }\n  if (negative_num == 0) {\n    largest_negative = std::nullopt;\n  }\n\
    \  if (positive_num == 0) {\n    smallest_positive = std::nullopt;\n  }\n  return\
    \ std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (long\
    \ num : lst) {\n        if (num < 0 && (largest_negative == std::nullopt || num\
    \ > *largest_negative)) {\n            largest_negative = num;\n        }\n  \
    \      if (num > 0 && (smallest_positive == std::nullopt || num < *smallest_positive))\
    \ {\n            smallest_positive = num;\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    using std::optional;\n    using std::nullopt;\n \
    \   using std::make_tuple;\n    using std::max;\n    using std::min;\n    optional<long>\
    \ largest = nullopt;\n    optional<long> smallest = nullopt;\n    for (auto i:\
    \ lst) {\n        if (i < 0) {\n            largest = max(largest.value_or(i),\
    \ i);\n        } else if (i > 0) {\n            smallest = min(smallest.value_or(i),\
    \ i);\n        }\n    }\n    return make_tuple(largest, smallest);", "  // write\
    \ your code here\n  std::vector<long> a,b;\n  for(auto x:lst)\n  {\n    if(x>0)\n\
    \    {\n      b.push_back(x);\n    }\n    else if(x<0)\n    {\n      a.push_back(x);\n\
    \    }\n  }\n  std::optional<long> oa,ob;\n  if(a.size()==0 && b.size()==0)\n\
    \  {\n    return std::make_tuple(oa,ob);\n  }\n  if(a.size()==0)\n  {\n    return\
    \ std::make_tuple(oa,*std::min_element(b.begin(),b.end()));\n  }\n  if(b.size()==0)\n\
    \  {\n    return std::make_tuple(*std::max_element(a.begin(),a.end()),ob);\n \
    \ }\n  return std::make_tuple(*std::max_element(a.begin(),a.end()),*std::min_element(b.begin(),b.end()));",
  "\tlong a,b;\n\tauto it=std::min_element(lst.begin(),lst.end());\n\tauto it1=std::max_element(lst.begin(),lst.end());\n\
    \tif(*it>0){\n\t\tb=*it;\n\t}\n\telse{\n\t\tb=*std::find_if(lst.begin(),lst.end(),[](long\
    \ x){return x>0;});\n\t}\n\tif(*it1<0){\n\t\ta=*it1;\n\t}\n\telse{\n\t\ta=*std::find_if(lst.begin(),lst.end(),[](long\
    \ x){return x<0;});\n\t}\n\treturn std::make_tuple(a,b);", "    // Assume that\
    \ the given vector is not empty\n    assert(lst.size() != 0);\n    int maximum\
    \ = INT_MIN;\n    int minimum = INT_MAX;\n    for (auto x : lst) {\n        if\
    \ (x < 0) {\n            maximum = std::max(maximum, x);\n        }\n        if\
    \ (x > 0) {\n            minimum = std::min(minimum, x);\n        }\n    }\n \
    \   std::optional<long> op_max;\n    std::optional<long> op_min;\n    if (maximum\
    \ == INT_MIN) {\n        op_max = std::nullopt;\n    } else {\n        op_max\
    \ = maximum;\n    }\n    if (minimum == INT_MAX) {\n        op_min = std::nullopt;\n\
    \    } else {\n        op_min = minimum;\n    }\n    return std::make_tuple(op_max,\
    \ op_min);", "    std::optional<long> larg, smal;\n    for(auto i: lst){\n   \
    \     if(i>0){\n            if(!smal) smal = i;\n            else if(i<*smal)\
    \ smal = i;\n        }\n        else if(i<0){\n            if(!larg) larg = i;\n\
    \            else if(i>*larg) larg = i;\n        }\n    }\n    return std::make_tuple(larg,\
    \ smal);", "\tbool has_neg = false;\n\tbool has_pos = false;\n\tlong max_neg =\
    \ 0;\n\tlong min_pos = 0;\n\tfor (auto item : lst) {\n\t\tif (item < 0) {\n\t\t\
    \thas_neg = true;\n\t\t\tif (item > max_neg) {\n\t\t\t\tmax_neg = item;\n\t\t\t\
    }\n\t\t}\n\t\telse if (item > 0) {\n\t\t\thas_pos = true;\n\t\t\tif (item < min_pos\
    \ || min_pos == 0) {\n\t\t\t\tmin_pos = item;\n\t\t\t}\n\t\t}\n\t}\n\tif (has_neg\
    \ && has_pos) {\n\t\treturn std::make_tuple(std::optional<long>(max_neg), std::optional<long>(min_pos));\n\
    \t}\n\telse if (has_neg) {\n\t\treturn std::make_tuple(std::optional<long>(max_neg),\
    \ std::optional<long>(std::nullopt));\n\t}\n\telse if (has_pos) {\n\t\treturn\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(min_pos));\n\
    \t}\n\telse {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \t}", "\t// Set the largest negative to 0 and smallest positive to 0\n\tlong largest_negative\
    \ = 0;\n\tlong smallest_positive = 0;\n\t// Check if the list is empty\n\tif (lst.size()\
    \ == 0) {\n\t\t// Make and return the tuple\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\t}\n\t// Iterate through the list\n\t\
    for (long i = 0; i < lst.size(); i++) {\n\t\t// Check if this is the largest negative\n\
    \t\tif (lst[i] < 0 && lst[i] > largest_negative) {\n\t\t\t// Set the largest negative\n\
    \t\t\tlargest_negative = lst[i];\n\t\t}\n\t\t// Check if this is the smallest\
    \ positive\n\t\tif (lst[i] > 0 && (lst[i] < smallest_positive || smallest_positive\
    \ == 0)) {\n\t\t\t// Set the smallest positive\n\t\t\tsmallest_positive = lst[i];\n\
    \t\t}\n\t}\n\t// Make and return the tuple\n\treturn std::make_tuple(std::optional<long>(largest_negative),\
    \ std::optional<long>(smallest_positive));", "\t\tbool positive = false;\n\t\t\
    bool negative = false;\n\t\tlong min_positive = 0;\n\t\tlong max_negative = 0;\n\
    \t\t\n\t\tfor(long x : lst){\n\t\t\t\tif(x > 0){\n\t\t\t\t\t\tpositive = true;\n\
    \t\t\t\t\t\tif(min_positive == 0)\n\t\t\t\t\t\t\t\tmin_positive = x;\n\t\t\t\t\
    \t\telse\n\t\t\t\t\t\t\t\tmin_positive = std::min(min_positive, x);\n\t\t\t\t\
    }\n\t\t\t\tif(x < 0){\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tif(max_negative\
    \ == 0)\n\t\t\t\t\t\t\t\tmax_negative = x;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\
    max_negative = std::max(max_negative, x);\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tif(positive\
    \ && negative)\n\t\t\t\treturn std::make_tuple(std::optional<long>(max_negative),\
    \ std::optional<long>(min_positive));\n\t\telse if(positive)\n\t\t\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min_positive));\n\t\telse if(negative)\n\t\t\t\treturn std::make_tuple(std::optional<long>(max_negative),\
    \ std::optional<long>(std::nullopt));\n\t\telse\n\t\t\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));", "\tlong a,b;\n\tint n = lst.size();\n\t\
    bool found = false;\n\tfor(int i=0;i<n;i++){\n\t\tif(lst[i]<0){\n\t\t\ta = lst[i];\n\
    \t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!found){\n\t\ta = std::nullopt;\n\
    \t}\n\tfound = false;\n\tfor(int i=0;i<n;i++){\n\t\tif(lst[i]>0){\n\t\t\tb = lst[i];\n\
    \t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!found){\n\t\tb = std::nullopt;\n\
    \t}\n\tstd::tuple<std::optional<long>, std::optional<long>> result = std::make_tuple(a,b);\n\
    \treturn result;", "    // 'largest' is the largest of negative integers\n   \
    \ // 'smallest' is the smallest of positive integers\n    // Do not remove the\
    \ default keyword\n    long largest = 0;\n    long smallest = 0;\n    // Write\
    \ your code here\n    // ...\n    int l = 1;\n    for(int i = 0; i < lst.size();\
    \ i++){\n        if(lst[i] >= 0){\n            if(l){\n                smallest\
    \ = lst[i];\n                l = 0;\n            }\n            else{\n      \
    \          if(lst[i] < smallest)\n                    smallest = lst[i];\n   \
    \         }\n        }\n        else{\n            if(lst[i] > largest)\n    \
    \            largest = lst[i];\n        }\n    }\n    if(l){\n        smallest\
    \ = 0;\n    }\n    return std::make_tuple(std::optional<long>(largest), std::optional<long>(smallest));",
  "    using namespace std;\n    long min = INT_MAX;\n    long max = INT_MIN;\n  \
    \  bool hasNegative = false;\n    bool hasPositive = false;\n    for (long x :\
    \ lst) {\n        if (x >= 0) {\n            if (x < min) {\n                min\
    \ = x;\n            }\n            hasPositive = true;\n        } else {\n   \
    \         if (x > max) {\n                max = x;\n            }\n          \
    \  hasNegative = true;\n        }\n    }\n    if (hasNegative && hasPositive)\
    \ {\n        return make_tuple(max, min);\n    } else if (hasNegative) {\n   \
    \     return make_tuple(max, nullopt);\n    } else if (hasPositive) {\n      \
    \  return make_tuple(nullopt, min);\n    } else {\n        return make_tuple(nullopt,\
    \ nullopt);\n    }", "  using namespace std;\n  optional<long> a = nullopt;\n\
    \  optional<long> b = nullopt;\n  for (long l : lst) {\n    if (l < 0 && (!a.has_value()\
    \ || l > *a)) {\n      a = l;\n    }\n    if (l > 0 && (!b.has_value() || l <\
    \ *b)) {\n      b = l;\n    }\n  }\n  return make_tuple(a, b);", "\tif (lst.size()\
    \ == 0) {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \t}\n\tstd::sort(lst.begin(), lst.end());\n\tstd::reverse(lst.begin(), lst.end());\n\
    \tstd::vector<long> pos;\n\tstd::vector<long> neg;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tpos.push_back(lst[i]);\n\t\t}\n\t\telse\
    \ {\n\t\t\tneg.push_back(lst[i]);\n\t\t}\n\t}\n\tif (pos.size() == 0) {\n\t\t\
    return std::make_tuple(std::optional<long>(neg[0]), std::optional<long>(std::nullopt));\n\
    \t}\n\telse if (neg.size() == 0) {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(pos[0]));\n\t}\n\telse {\n\t\treturn std::make_tuple(std::optional<long>(neg[0]),\
    \ std::optional<long>(pos[0]));\n\t}", "    // write your code here\n    long\
    \ max = 0, min = 0;\n    bool isFirst = true;\n    std::tuple<std::optional<long>,\
    \ std::optional<long>> o;\n    for (auto i = lst.begin(); i != lst.end(); i++)\
    \ {\n        if (*i < 0) {\n            if (isFirst) {\n                max =\
    \ *i;\n                isFirst = false;\n            }\n            else {\n \
    \               if (*i > max) {\n                    max = *i;\n             \
    \   }\n            }\n        }\n        else if (*i > 0) {\n            if (isFirst)\
    \ {\n                min = *i;\n                isFirst = false;\n           \
    \ }\n            else {\n                if (*i < min) {\n                   \
    \ min = *i;\n                }\n            }\n        }\n    }\n    o = std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));\n    return o;", "  bool b=false;\n  long lrg, sml;\n\
    \  lrg=sml=0;\n  std::vector<long>neg;\n  std::vector<long>pos;\n  for(auto x:lst){\n\
    \      if(x<0){\n        neg.push_back(x);\n      }\n      else if(x>0){\n   \
    \     pos.push_back(x);\n      }\n  }\n  if(!neg.empty()){\n    b=true;\n    lrg=*max_element(neg.begin(),neg.end());\n\
    \  }\n  if(!pos.empty()){\n    b=true;\n    sml=*min_element(pos.begin(),pos.end());\n\
    \  }\n  if(b==true){\n    return std::make_tuple(std::optional<long>(lrg), std::optional<long>(sml));\n\
    \  }\n  else{\n    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \  }", "    int c1 = 0, c2 = 0;\n    long a = INT_MIN, b = INT_MAX;\n    for (int\
    \ i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n            c1++;\n\
    \            if (lst[i] > a) {\n                a = lst[i];\n            }\n \
    \       }\n        if (lst[i] > 0) {\n            c2++;\n            if (lst[i]\
    \ < b) {\n                b = lst[i];\n            }\n        }\n    }\n    std::optional<long>\
    \ t1, t2;\n    if (c1 > 0)\n        t1 = a;\n    if (c2 > 0)\n        t2 = b;\n\
    \    return std::make_tuple(t1, t2);", "\tlong largest = -1000;\n\tlong smallest\
    \ = 1000;\n\tstd::optional<long> a = std::nullopt;\n\tstd::optional<long> b =\
    \ std::nullopt;\n\tfor (long i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (i > largest)\
    \ {\n\t\t\t\tlargest = i;\n\t\t\t}\n\t\t}\n\t\tif (i > 0) {\n\t\t\tif (i < smallest)\
    \ {\n\t\t\t\tsmallest = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (largest != -1000) {\n\t\
    \ta = largest;\n\t}\n\tif (smallest != 1000) {\n\t\tb = smallest;\n\t}\n\treturn\
    \ std::make_tuple(a, b);", "    auto max = std::max_element(lst.begin(), lst.end());\n\
    \    auto min = std::min_element(lst.begin(), lst.end());\n    if (*max < 0) {\n\
    \        return std::make_tuple(std::optional<long>(*max), std::optional<long>(*min));\n\
    \    }\n    if (*min > 0) {\n        return std::make_tuple(std::optional<long>(*max),\
    \ std::optional<long>(*min));\n    }\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));", "    auto negative_max_it = std::min_element(lst.begin(),\
    \ lst.end());\n    auto positive_min_it = std::max_element(lst.begin(), lst.end());\n\
    \    std::optional<long> negative_max = negative_max_it != lst.end() && *negative_max_it\
    \ < 0 ? *negative_max_it : std::nullopt;\n    std::optional<long> positive_min\
    \ = positive_min_it != lst.end() && *positive_min_it > 0 ? *positive_min_it :\
    \ std::nullopt;\n    return std::make_tuple(negative_max, positive_min);", " \
    \   int maxn=INT_MIN,minp=INT_MAX;\n    int maxf=0,minf=0;\n    for(auto x:lst){\n\
    \        if(x<0 && x>maxn){\n            maxn=x;\n            maxf=1;\n      \
    \  }\n        if(x>0 && x<minp){\n            minp=x;\n            minf=1;\n \
    \       }\n    }\n    if(maxf==0)\n        maxn=0;\n    if(minf==0)\n        minp=0;\n\
    \    std::optional<long> a;\n    std::optional<long> b;\n    if(maxn!=0)\n   \
    \     a=maxn;\n    if(minp!=0)\n        b=minp;\n    return std::make_tuple(a,b);",
  "    std::vector<long> positive, negative;\n    std::optional<long> largest_neg\
    \ = std::nullopt, smallest_pos = std::nullopt;\n    for (long i : lst) {\n   \
    \     if (i < 0) {\n            negative.push_back(i);\n        } else if (i >\
    \ 0) {\n            positive.push_back(i);\n        }\n    }\n    std::sort(negative.begin(),\
    \ negative.end());\n    std::sort(positive.begin(), positive.end());\n    if (negative.size()\
    \ > 0) {\n        largest_neg = negative[0];\n    }\n    if (positive.size() >\
    \ 0) {\n        smallest_pos = positive[0];\n    }\n    return std::make_tuple(largest_neg,\
    \ smallest_pos);", "    std::tuple<std::optional<long>, std::optional<long>> tuple(std::nullopt,\
    \ std::nullopt);\n    std::optional<long> negative;\n    std::optional<long> positive;\n\
    \    for (auto i = lst.begin(); i != lst.end(); i++) {\n        if (*i < 0) {\n\
    \            if (!negative.has_value()) {\n                negative = *i;\n  \
    \          } else if (*i > negative.value()) {\n                negative = *i;\n\
    \            }\n        } else if (*i > 0) {\n            if (!positive.has_value())\
    \ {\n                positive = *i;\n            } else if (*i < positive.value())\
    \ {\n                positive = *i;\n            }\n        }\n    }\n    return\
    \ std::make_tuple(negative, positive);", "  if (lst.size() == 0) {\n    return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] > 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(lst[0]));\n  }\n  if (lst[lst.size() - 1] < 0) {\n    return\
    \ std::make_tuple(std::optional<long>(lst[lst.size() - 1]), std::optional<long>(std::nullopt));\n\
    \  }\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] >= 0) {\n     \
    \ return std::make_tuple(std::optional<long>(lst[i - 1]), std::optional<long>(lst[i]));\n\
    \    }\n  }\n  return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));",
  "  if (lst.size() == 0)\n  {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  }\n  long high = 0;\n  long low = 0;\n\
    \  int flag = 0;\n  for (int i = 0; i < lst.size(); i++)\n  {\n    if (lst[i]\
    \ > 0)\n    {\n      if (flag == 0)\n      {\n        low = lst[i];\n        flag\
    \ = 1;\n      }\n      else\n      {\n        if (lst[i] < low)\n        {\n \
    \         low = lst[i];\n        }\n      }\n    }\n    else\n    {\n      if\
    \ (lst[i] > high)\n      {\n        high = lst[i];\n      }\n    }\n  }\n  if\
    \ (flag == 0)\n  {\n    return std::make_tuple(std::optional<long>(high), std::optional<long>(std::nullopt));\n\
    \  }\n  else\n  {\n    return std::make_tuple(std::optional<long>(high), std::optional<long>(low));\n\
    \  }", "  using namespace std;\n  optional<long> a = nullopt;\n  optional<long>\
    \ b = nullopt;\n  for (auto i: lst) {\n    if (i > 0) {\n      if (b) {\n    \
    \    b = min(b.value(), i);\n      } else {\n        b = i;\n      }\n    } else\
    \ if (i < 0) {\n      if (a) {\n        a = max(a.value(), i);\n      } else {\n\
    \        a = i;\n      }\n    }\n  }\n  return make_tuple(a, b);", '', '    return
    {};', "    std::optional<long> smallest;\n    std::optional<long> largest;\n \
    \   for (auto x : lst) {\n        if (x > 0) {\n            if (!smallest || x\
    \ < *smallest) {\n                smallest = x;\n            }\n        } else\
    \ if (x < 0) {\n            if (!largest || x > *largest) {\n                largest\
    \ = x;\n            }\n        }\n    }\n    return std::make_tuple(largest, smallest);",
  "    std::vector<long> list;\n    for(int i=0;i<lst.size();i++){\n        if(lst[i]>0){\n\
    \            list.push_back(lst[i]);\n        }\n    }\n    if(list.size()==0){\n\
    \        return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    }\n    else{\n        std::sort(list.begin(),list.end());\n        return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(list[0]));\n\
    \    }", "    if(lst.size()==0) return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    if(lst.size()==1 && lst[0]==0) return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    int maxN = INT_MIN, minP = INT_MAX;\n    for(int i=0;i<lst.size();i++){\n\
    \        if(lst[i]>0 && lst[i]<minP) minP = lst[i];\n        if(lst[i]<0 && lst[i]>maxN)\
    \ maxN = lst[i];\n    }\n    if(maxN==INT_MIN) return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(minP));\n    if(minP==INT_MAX) return std::make_tuple(std::optional<long>(maxN),\
    \ std::optional<long>(std::nullopt));\n    return std::make_tuple(std::optional<long>(maxN),\
    \ std::optional<long>(minP));", "\tstd::optional<long> largestOfNegative = std::nullopt;\n\
    \tstd::optional<long> smallestOfPositive = std::nullopt;\n\tfor (long i : lst)\
    \ {\n\t\tif (i < 0) {\n\t\t\tif (largestOfNegative == std::nullopt)\n\t\t\t\t\
    largestOfNegative = i;\n\t\t\telse\n\t\t\t\tlargestOfNegative = std::max(largestOfNegative.value(),\
    \ i);\n\t\t}\n\t\telse if (i > 0) {\n\t\t\tif (smallestOfPositive == std::nullopt)\n\
    \t\t\t\tsmallestOfPositive = i;\n\t\t\telse\n\t\t\t\tsmallestOfPositive = std::min(smallestOfPositive.value(),\
    \ i);\n\t\t}\n\t}\n\treturn std::make_tuple(largestOfNegative, smallestOfPositive);",
  "    std::tuple<std::optional<long>, std::optional<long>> ans(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    for (auto n : lst) {\n        if (n\
    \ < 0) {\n            if (std::get<0>(ans) == std::nullopt) {\n              \
    \  std::get<0>(ans) = n;\n            } else {\n                std::get<0>(ans)\
    \ = std::max(std::get<0>(ans).value(), n);\n            }\n        } else if (n\
    \ > 0) {\n            if (std::get<1>(ans) == std::nullopt) {\n              \
    \  std::get<1>(ans) = n;\n            } else {\n                std::get<1>(ans)\
    \ = std::min(std::get<1>(ans).value(), n);\n            }\n        }\n    }\n\
    \    return ans;", "    bool has_negative = false;\n    bool has_positive = false;\n\
    \    long max_neg = 0;\n    long min_pos = 0;\n    if (lst.size() == 0) {\n  \
    \      return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    }\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n\
    \            if (!has_negative) {\n                max_neg = lst[i];\n       \
    \         has_negative = true;\n            } else {\n                if (lst[i]\
    \ > max_neg) {\n                    max_neg = lst[i];\n                }\n   \
    \         }\n        } else if (lst[i] > 0) {\n            if (!has_positive)\
    \ {\n                min_pos = lst[i];\n                has_positive = true;\n\
    \            } else {\n                if (lst[i] < min_pos) {\n             \
    \       min_pos = lst[i];\n                }\n            }\n        }\n    }\n\
    \    if (has_negative) {\n        if (has_positive) {\n            return std::make_tuple(std::optional<long>(max_neg),\
    \ std::optional<long>(min_pos));\n        } else {\n            return std::make_tuple(std::optional<long>(max_neg),\
    \ std::optional<long>(std::nullopt));\n        }\n    } else {\n        if (has_positive)\
    \ {\n            return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(min_pos));\n\
    \        } else {\n            return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n        }\n    }", "  if (lst.size() ==\
    \ 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \  }\n  else {\n    std::vector<long> pos;\n    std::vector<long> neg;\n    for\
    \ (int i = 0; i < lst.size(); i++) {\n      if (lst[i] < 0) {\n        neg.push_back(lst[i]);\n\
    \      }\n      else if (lst[i] > 0) {\n        pos.push_back(lst[i]);\n     \
    \ }\n    }\n    if (pos.size() == 0 && neg.size() == 0) {\n      return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }\n    else if (pos.size() == 0) {\n\
    \      return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    }\n    else if (neg.size() == 0) {\n      return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(pos[0]));\n    }\n    else {\n      std::sort(pos.begin(),\
    \ pos.end());\n      std::sort(neg.begin(), neg.end());\n      return std::make_tuple(std::optional<long>(neg[neg.size()\
    \ - 1]), std::optional<long>(pos[0]));\n    }\n  }", "// Write your code here\n\
    \    std::optional<long> a=std::nullopt;\n    std::optional<long> b=std::nullopt;\n\
    \    for(int i=0;i<lst.size();i++){\n        if(lst[i]>0){\n            if(b==std::nullopt){\n\
    \                b=lst[i];\n            }\n            else if(lst[i]<b){\n  \
    \              b=lst[i];\n            }\n        }\n        else if(lst[i]<0){\n\
    \            if(a==std::nullopt){\n                a=lst[i];\n            }\n\
    \            else if(lst[i]>a){\n                a=lst[i];\n            }\n  \
    \      }\n    }\n    return std::make_tuple(a,b);", "    if(lst.size()==0)\n \
    \       return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    long mx=INT_MIN,mn=INT_MAX;\n    for(int i=0;i<lst.size();i++)\n    {\n \
    \       if(lst[i]>0)\n            mn=std::min(mn,lst[i]);\n        else\n    \
    \        mx=std::max(mx,lst[i]);\n    }\n    return std::make_tuple(std::optional<long>(mx),\
    \ std::optional<long>(mn));", "    long mx = INT_MIN, mn = INT_MAX;\n    int flag1\
    \ = 0, flag2 = 0;\n    for(auto x : lst) {\n        if(x < 0) {\n            flag1\
    \ = 1;\n            mx = std::max(mx, x);\n        }\n        if(x > 0) {\n  \
    \          flag2 = 1;\n            mn = std::min(mn, x);\n        }\n    }\n \
    \   std::optional<long> a, b;\n    if(flag1)\n        a = mx;\n    if(flag2)\n\
    \        b = mn;\n    return std::make_tuple(a, b);", "    if(lst.size()>0){\n\
    \    std::optional<long> max_neg_int;\n    std::optional<long> min_pos_int;\n\
    \    for(int i=0;i<lst.size();i++){\n        if(lst[i]<0 && (max_neg_int==std::nullopt\
    \ || lst[i]>*max_neg_int)){\n            max_neg_int=lst[i];\n        }\n    \
    \    if(lst[i]>0 && (min_pos_int==std::nullopt || lst[i]<*min_pos_int)){\n   \
    \         min_pos_int=lst[i];\n        }\n    }\n    return std::make_tuple(max_neg_int,min_pos_int);\n\
    \    }\n    else{\n        return std::make_tuple(std::nullopt,std::nullopt);\n\
    \    }", "  std::optional<long> a, b;\n  for (auto i: lst) {\n    if (i < 0) {\n\
    \      if (!a || i > *a) {\n        a = i;\n      }\n    } else if (i > 0) {\n\
    \      if (!b || i < *b) {\n        b = i;\n      }\n    }\n  }\n  return std::make_tuple(a,\
    \ b);", "\tstd::optional<long> largest_negative;\n\tstd::optional<long> smallest_positive;\n\
    \tfor (auto x : lst) {\n\t\tif (x < 0) {\n\t\t\tif (!largest_negative.has_value())\
    \ {\n\t\t\t\tlargest_negative = x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlargest_negative\
    \ = std::max(largest_negative.value(), x);\n\t\t\t}\n\t\t}\n\t\telse if (x > 0)\
    \ {\n\t\t\tif (!smallest_positive.has_value()) {\n\t\t\t\tsmallest_positive =\
    \ x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmallest_positive = std::min(smallest_positive.value(),\
    \ x);\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(largest_negative, smallest_positive);",
  "    long lmax=0, smin=0;\n    std::optional<long> x, y;\n    for(auto &i: lst){\n\
    \        if(i<0 && lmax<i){\n            lmax=i;\n            x=lmax;\n      \
    \  }\n        if(i>0 && smin>i){\n            smin=i;\n            y=smin;\n \
    \       }\n    }\n    return std::make_tuple(x, y);", "    std::optional<long>\
    \ a = std::nullopt;\n    std::optional<long> b = std::nullopt;\n    std::vector<long>\
    \ positiveNumbers;\n    std::vector<long> negativeNumbers;\n    if (lst.size()\
    \ == 0)\n        return std::make_tuple(a, b);\n    std::copy_if(lst.begin(),\
    \ lst.end(), std::back_inserter(positiveNumbers), [](int i) { return i > 0; });\n\
    \    std::copy_if(lst.begin(), lst.end(), std::back_inserter(negativeNumbers),\
    \ [](int i) { return i < 0; });\n    if (positiveNumbers.size() > 0)\n       \
    \ b = std::optional<long>(*std::min_element(positiveNumbers.begin(), positiveNumbers.end()));\n\
    \    if (negativeNumbers.size() > 0)\n        a = std::optional<long>(*std::max_element(negativeNumbers.begin(),\
    \ negativeNumbers.end()));\n    return std::make_tuple(a, b);", "\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> tup;\n\tif(lst.size() == 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\t\n\tif(lst.size() == 1 && lst[0] == 0)\n\
    \t\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \t\n\tlong max = lst[0];\n\tfor(long i = 0; i < lst.size(); i++)\n\t{\n\t\tif(lst[i]\
    \ > max)\n\t\t\tmax = lst[i];\n\t}\n\t\n\tlong min = lst[0];\n\tfor(long i = 0;\
    \ i < lst.size(); i++)\n\t{\n\t\tif(lst[i] < min)\n\t\t\tmin = lst[i];\n\t}\n\t\
    \n\treturn std::make_tuple(std::optional<long>(max), std::optional<long>(min));",
  "  if (lst.size() == 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  }\n  long maxNeg = -9999999999;\n  long\
    \ minPos = 9999999999;\n  bool hasPos = false;\n  bool hasNeg = false;\n  for\
    \ (long i = 0; i < lst.size(); i++) {\n    if (lst[i] < 0) {\n      if (lst[i]\
    \ > maxNeg) {\n        maxNeg = lst[i];\n      }\n      hasNeg = true;\n    }\n\
    \    if (lst[i] > 0) {\n      if (lst[i] < minPos) {\n        minPos = lst[i];\n\
    \      }\n      hasPos = true;\n    }\n  }\n  if (hasNeg && hasPos) {\n    return\
    \ std::make_tuple(std::optional<long>(maxNeg), std::optional<long>(minPos));\n\
    \  }\n  if (hasNeg) {\n    return std::make_tuple(std::optional<long>(maxNeg),\
    \ std::optional<long>(std::nullopt));\n  }\n  if (hasPos) {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(minPos));\n  }\n  return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));", '  return std::make_tuple(std::optional<long>(std::nullopt),
    std::optional<long>(std::nullopt));', "\tstd::tuple<std::optional<long>, std::optional<long>>\
    \ tuple;\n\tstd::optional<long> res1, res2;\n\tint flag1 = 0, flag2 = 0;\n\tstd::sort(lst.begin(),\
    \ lst.end());\n\tfor (auto el : lst) {\n\t\tif (el > 0) {\n\t\t\tres2 = el;\n\t\
    \t\tflag2 = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstd::reverse(lst.begin(), lst.end());\n\
    \tfor (auto el : lst) {\n\t\tif (el < 0) {\n\t\t\tres1 = el;\n\t\t\tflag1 = 1;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\tif (flag1 == 0) {\n\t\tres1 = std::nullopt;\n\t}\n\
    \tif (flag2 == 0) {\n\t\tres2 = std::nullopt;\n\t}\n\ttuple = std::make_tuple(res1,\
    \ res2);\n\treturn tuple;", "  auto it = std::find_if(lst.begin(), lst.end(),\
    \ [](long i) { return i >= 0; });\n  auto smallest = std::min_element(it, lst.end());\n\
    \  auto largest = std::max_element(lst.begin(), it);\n  return std::make_tuple(*largest,\
    \ *smallest);", "    bool has_neg = false;\n    bool has_pos = false;\n    long\
    \ max_neg = std::numeric_limits<long>::min();\n    long min_pos = std::numeric_limits<long>::max();\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n     \
    \       has_neg = true;\n            max_neg = std::max(max_neg, lst[i]);\n  \
    \      }\n        if (lst[i] > 0) {\n            has_pos = true;\n           \
    \ min_pos = std::min(min_pos, lst[i]);\n        }\n    }\n    if (has_neg && has_pos)\
    \ {\n        return std::make_tuple(std::optional<long>(max_neg), std::optional<long>(min_pos));\n\
    \    }\n    if (has_neg) {\n        return std::make_tuple(std::optional<long>(max_neg),\
    \ std::optional<long>(std::nullopt));\n    }\n    if (has_pos) {\n        return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(min_pos));\n\
    \    }\n    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));",
  "\t\tstd::vector<long> pos;\n\t\tstd::vector<long> neg;\n\t\tfor(auto i:lst){\n\t\
    \t\tif(i<0){\n\t\t\t\tneg.push_back(i);\n\t\t\t}\n\t\t\telse if(i>0){\n\t\t\t\t\
    pos.push_back(i);\n\t\t\t}\n\t\t}\n\t\tif(neg.size()==0&&pos.size()==0){\n\t\t\
    \treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \t\t}\n\t\telse if(neg.size()==0){\n\t\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(pos[0]));\n\t\t}\n\t\telse if(pos.size()==0){\n\t\t\treturn\
    \ std::make_tuple(std::optional<long>(neg[neg.size()-1]), std::optional<long>(std::nullopt));\n\
    \t\t}\n\t\treturn std::make_tuple(std::optional<long>(neg[neg.size()-1]), std::optional<long>(pos[0]));",
  "\tstd::optional<long> a;\n\tstd::optional<long> b;\n\tint n=lst.size();\n\tif(n==0)\n\
    \t\treturn std::make_tuple(a,b);\n\telse\n\t{\n\t\tlong m1=INT_MIN;\n\t\tlong\
    \ m2=INT_MAX;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(lst[i]<0)\n\t\t\t{\n\t\
    \t\t\tif(lst[i]>m1)\n\t\t\t\t\tm1=lst[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\
    \tif(lst[i]<m2)\n\t\t\t\t\tm2=lst[i];\n\t\t\t}\n\t\t}\n\t\tif(m1==INT_MIN)\n\t\
    \t\ta=std::nullopt;\n\t\telse\n\t\t\ta=m1;\n\t\tif(m2==INT_MAX)\n\t\t\tb=std::nullopt;\n\
    \t\telse\n\t\t\tb=m2;\n\t\treturn std::make_tuple(a,b);\n\t}", "\nstd::optional<long>\
    \ max;\nstd::optional<long> min;\n\nfor(int i=0;i<lst.size();i++)\n{\n    if(lst[i]<0)\n\
    \    {\n        if(!max)\n        {\n            max=lst[i];\n        }\n    \
    \    else if(lst[i]>max)\n        {\n            max=lst[i];\n        }\n    }\n\
    \    else if(lst[i]>0)\n    {\n        if(!min)\n        {\n            min=lst[i];\n\
    \        }\n        else if(lst[i]<min)\n        {\n            min=lst[i];\n\
    \        }\n    }", "\treturn { std::nullopt, std::nullopt };", "\tlong int len\
    \ = lst.size();\n\t\n\tlong int max;\n\tlong int min;\n\tstd::optional<long> maxn;\n\
    \tstd::optional<long> minn;\n\tstd::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n\t\n\tif(len == 0) {\n\t\tmaxn = std::nullopt;\n\t\tminn = std::nullopt;\n\
    \t\tresult = std::make_tuple(maxn, minn);\n\t\treturn result;\n\t}\n\t\n\tmax\
    \ = lst[0];\n\tmin = lst[0];\n\tfor(long int i = 0; i < len; i++) {\n\t\tif(lst[i]\
    \ < 0) {\n\t\t\tif(lst[i] > max) {\n\t\t\t\tmax = lst[i];\n\t\t\t}\n\t\t}\n\t\t\
    else if(lst[i] > 0) {\n\t\t\tif(lst[i] < min) {\n\t\t\t\tmin = lst[i];\n\t\t\t\
    }\n\t\t}\n\t}\n\t\n\tif(max >= 0) {\n\t\tmaxn = std::nullopt;\n\t}\n\telse {\n\
    \t\tmaxn = max;\n\t}\n\t\n\tif(min <= 0) {\n\t\tminn = std::nullopt;\n\t}\n\t\
    else {\n\t\tminn = min;\n\t}\n\t\n\tresult = std::make_tuple(maxn, minn);\n\t\
    return result;", "    std::tuple<std::optional<long>, std::optional<long>> a =\
    \ std::make_tuple(std::optional<long>(std::nullopt),std::optional<long>(std::nullopt));\n\
    \    return a;", "\tlong lar=0, sma=0;\n\tbool start = true;\n\tfor(auto itr=lst.begin();\
    \ itr!=lst.end(); itr++) {\n\t\tif(*itr>0) {\n\t\t\tif(start) {\n\t\t\t\tsma =\
    \ *itr;\n\t\t\t\tstart = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(*itr<sma) {\n\
    \t\t\t\t\tsma = *itr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(*itr<0) {\n\t\t\t\
    if(start) {\n\t\t\t\tlar = *itr;\n\t\t\t\tstart = false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\tif(*itr>lar) {\n\t\t\t\t\tlar = *itr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t}\n\tif(start) {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\t}\n\treturn std::make_tuple(std::optional<long>(lar),\
    \ std::optional<long>(sma));", "    long v1 = std::numeric_limits<long>::min();\n\
    \    long v2 = std::numeric_limits<long>::max();\n    std::optional<long> opl\
    \ = std::nullopt;\n    std::optional<long> ops = std::nullopt;\n    std::cout\
    \ << v1 << \" \" << v2 << \"\\n\";\n    for (long v : lst) {\n        if (v <\
    \ 0 && v > v1) {\n            v1 = v;\n            opl = v1;\n        }\n    \
    \    if (v > 0 && v < v2) {\n            v2 = v;\n            ops = v2;\n    \
    \    }\n    }\n    return std::make_tuple(opl, ops);", "\tlong max = INT_MIN;\n\
    \tlong min = INT_MAX;\n\tbool b = true;\n\tfor (int i = 0; i < lst.size(); i++)\
    \ {\n\t\tif (lst[i] > 0) {\n\t\t\tb = false;\n\t\t\tif (lst[i] < min)\n\t\t\t\t\
    min = lst[i];\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\tif (lst[i] > max)\n\t\t\
    \t\tmax = lst[i];\n\t\t}\n\t}\n\tif (b)\n\t\treturn { {},{} };\n\telse\n\t\treturn\
    \ { max,min };", "    std::optional<long> smallest_positive;\n    std::optional<long>\
    \ largest_negative;\n    for (auto x : lst) {\n        if (x < 0 && (largest_negative\
    \ == std::nullopt || x > *largest_negative)) {\n            largest_negative =\
    \ x;\n        }\n        if (x > 0 && (smallest_positive == std::nullopt || x\
    \ < *smallest_positive)) {\n            smallest_positive = x;\n        }\n  \
    \  }\n    return std::make_tuple(largest_negative, smallest_positive);", "   \
    \ std::tuple<std::optional<long>, std::optional<long>> ans;\n    if(lst.size()==0)return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    int min = INT_MAX, max = INT_MIN;\n    for(int i=0;i<lst.size();i++){\n \
    \       if(lst[i]>0){\n            if(lst[i]<min)min = lst[i];\n        }\n  \
    \      else{\n            if(lst[i]>max)max = lst[i];\n        }\n    }\n    if(min\
    \ == INT_MAX)return std::make_tuple(std::optional<long>(max), std::optional<long>(std::nullopt));\n\
    \    if(max == INT_MIN)return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min));\n    return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));", "    std::optional<long> a = std::nullopt;\n  \
    \  std::optional<long> b = std::nullopt;\n    for (long i : lst) {\n        if\
    \ (i > 0) {\n            if (b == std::nullopt || i < *b) {\n                b\
    \ = i;\n            }\n        } else if (i < 0) {\n            if (a == std::nullopt\
    \ || i > *a) {\n                a = i;\n            }\n        }\n    }\n    return\
    \ std::make_tuple(a, b);", "    std::optional<long> largestNegative, smallestPositive;\n\
    \    for (long l : lst) {\n        if (l < 0) {\n            if (!largestNegative\
    \ || l > *largestNegative) {\n                largestNegative = l;\n         \
    \   }\n        } else if (l > 0) {\n            if (!smallestPositive || l < *smallestPositive)\
    \ {\n                smallestPositive = l;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largestNegative, smallestPositive);", "  long max\
    \ = std::numeric_limits<long>::min();\n  long min = std::numeric_limits<long>::max();\n\
    \  for (auto i : lst) {\n    if (i < 0) {\n      max = std::max(max, i);\n   \
    \ } else if (i > 0) {\n      min = std::min(min, i);\n    }\n  }\n  std::optional<long>\
    \ a = max;\n  std::optional<long> b = min;\n  if (a == max) {\n    a = std::nullopt;\n\
    \  }\n  if (b == min) {\n    b = std::nullopt;\n  }\n  return std::make_tuple(a,\
    \ b);", "        long largest = 0;\n        long smallest = 0;\n        bool first\
    \ = true;\n        int a_flag = 0;\n        int b_flag = 0;\n        for (auto\
    \ i = lst.begin(); i != lst.end(); i++) {\n            if (*i > 0 && a_flag ==\
    \ 0) {\n                if (first == true) {\n                    smallest = *i;\n\
    \                    first = false;\n                }\n                if (*i\
    \ < smallest) {\n                    smallest = *i;\n                }\n     \
    \       }\n            if (*i < 0 && b_flag == 0) {\n                if (first\
    \ == true) {\n                    largest = *i;\n                    first = false;\n\
    \                }\n                if (*i > largest) {\n                    largest\
    \ = *i;\n                }\n            }\n            if (*i == 0) {\n      \
    \          a_flag = 1;\n                b_flag = 1;\n            }\n        }\n\
    \        std::optional<long> a = largest;\n        std::optional<long> b = smallest;\n\
    \        if (a_flag == 1 && b_flag == 1) {\n            a = std::nullopt;\n  \
    \          b = std::nullopt;\n        }\n        if (a_flag == 1 && b_flag ==\
    \ 0) {\n            a = std::nullopt;\n        }\n        if (a_flag == 0 && b_flag\
    \ == 1) {\n            b = std::nullopt;\n        }\n        return std::make_tuple(a,\
    \ b);", "    std::tuple<std::optional<long>, std::optional<long>> a = std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    std::optional<long> x = std::nullopt;\n\
    \    std::optional<long> y = std::nullopt;\n    if(lst.size()!=0){\n        for(int\
    \ i=0;i<lst.size();i++){\n            if(lst[i]>0){\n                if(y==std::nullopt){\n\
    \                    y = lst[i];\n                }\n                else if(lst[i]<y){\n\
    \                    y = lst[i];\n                }\n            }\n         \
    \   else if(lst[i]<0){\n                if(x==std::nullopt){\n               \
    \     x = lst[i];\n                }\n                else if(lst[i]>x){\n   \
    \                 x = lst[i];\n                }\n            }\n        }\n \
    \       a = std::make_tuple(x,y);\n    }\n    return a;", "  std::tuple<std::optional<long>,\
    \ std::optional<long>> smallest_biggest =\n    std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  for (long value : lst) {\n    if (value\
    \ >= 0) {\n      if (!std::get<1>(smallest_biggest) ||\n          value < *std::get<1>(smallest_biggest))\
    \ {\n        std::get<1>(smallest_biggest) = value;\n      }\n    } else {\n \
    \     if (!std::get<0>(smallest_biggest) ||\n          value > *std::get<0>(smallest_biggest))\
    \ {\n        std::get<0>(smallest_biggest) = value;\n      }\n    }\n  }\n  return\
    \ smallest_biggest;", "    bool first=false, second=false;\n    long least=0,\
    \ highest=0;\n    for(long i=0; i<lst.size(); i++){\n        if(lst[i]>0){\n \
    \           if(second==false){\n                least=lst[i];\n              \
    \  second=true;\n            }\n            else{\n                if(lst[i]<least){\n\
    \                    least=lst[i];\n                }\n            }\n       \
    \ }\n        else if(lst[i]<0){\n            if(first==false){\n             \
    \   highest=lst[i];\n                first=true;\n            }\n            else{\n\
    \                if(lst[i]>highest){\n                    highest=lst[i];\n  \
    \              }\n            }\n        }\n    }\n    if(first==false){\n   \
    \     highest=std::nullopt;\n    }\n    if(second==false){\n        least=std::nullopt;\n\
    \    }\n    return std::make_tuple(highest, least);", "\tstd::optional<long> a,\
    \ b;\n\tlong max = 0, min = 0;\n\tint count_pos = 0, count_neg = 0;\n\tfor (int\
    \ i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tcount_pos++;\n\t\
    \t\tif (count_pos == 1)\n\t\t\t\tmin = lst[i];\n\t\t\telse if (lst[i] < min)\n\
    \t\t\t\tmin = lst[i];\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\tcount_neg++;\n\
    \t\t\tif (count_neg == 1)\n\t\t\t\tmax = lst[i];\n\t\t\telse if (lst[i] > max)\n\
    \t\t\t\tmax = lst[i];\n\t\t}\n\t}\n\tif (count_pos != 0)\n\t\tb = min;\n\tif (count_neg\
    \ != 0)\n\t\ta = max;\n\treturn std::make_tuple(a, b);", "\tlong l1, l2;\n\tl1\
    \ = INT_MIN;\n\tl2 = INT_MAX;\n\tif (lst.size() == 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\tfor (auto i : lst) {\n\t\tif (i >= 0\
    \ && i < l2)\n\t\t\tl2 = i;\n\t\tif (i < 0 && i > l1)\n\t\t\tl1 = i;\n\t}\n\t\
    if (l1 == INT_MIN)\n\t\tl1 = std::nullopt;\n\tif (l2 == INT_MAX)\n\t\tl2 = std::nullopt;\n\
    \treturn std::make_tuple(l1, l2);", "\tstd::optional<long> largest;\n\tstd::optional<long>\
    \ smallest;\n\tbool positive = false;\n\tbool negative = false;\n\tlong max =\
    \ 0;\n\tlong min = 0;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i]\
    \ > 0) {\n\t\t\tpositive = true;\n\t\t\tif (min > lst[i] || min == 0) {\n\t\t\t\
    \tmin = lst[i];\n\t\t\t}\n\t\t}\n\t\tif (lst[i] < 0) {\n\t\t\tnegative = true;\n\
    \t\t\tif (max < lst[i] || max == 0) {\n\t\t\t\tmax = lst[i];\n\t\t\t}\n\t\t}\n\
    \t}\n\tif (positive) {\n\t\tsmallest = min;\n\t}\n\tif (negative) {\n\t\tlargest\
    \ = max;\n\t}\n\treturn std::make_tuple(largest, smallest);", "\tlong max_neg=0,\
    \ min_pos=0;\n\tint neg=0, pos=0;\n\tfor(int i=0; i<lst.size(); i++){\n\t\tif(lst[i]<0){\n\
    \t\t\tif(neg==0){\n\t\t\t\tmax_neg=lst[i];\n\t\t\t\tneg=1;\n\t\t\t}\n\t\t\telse{\n\
    \t\t\t\tif(lst[i]>max_neg)\n\t\t\t\t\tmax_neg=lst[i];\n\t\t\t}\n\t\t}\n\t\telse\
    \ if(lst[i]>0){\n\t\t\tif(pos==0){\n\t\t\t\tmin_pos=lst[i];\n\t\t\t\tpos=1;\n\t\
    \t\t}\n\t\t\telse{\n\t\t\t\tif(lst[i]<min_pos)\n\t\t\t\t\tmin_pos=lst[i];\n\t\t\
    \t}\n\t\t}\n\t}\n\tif(neg==0)\n\t\tmax_neg=-1;\n\tif(pos==0)\n\t\tmin_pos=-1;\n\
    \tif(neg==0 && pos==0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\telse if(neg==0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min_pos));\n\telse if(pos==0)\n\t\treturn std::make_tuple(std::optional<long>(max_neg),\
    \ std::optional<long>(std::nullopt));\n\telse\n\t\treturn std::make_tuple(std::optional<long>(max_neg),\
    \ std::optional<long>(min_pos));", '  return std::make_tuple(std::optional<long>(std::nullopt),
    std::optional<long>(std::nullopt));', "    if(lst.size()==0)return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    std::sort(lst.begin(),lst.end());\n\
    \    int index=0;\n    int index2=lst.size()-1;\n    if(lst[index]>=0){\n    \
    \    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(lst[index]));\n\
    \    }\n    if(lst[index2]<=0){\n        return std::make_tuple(std::optional<long>(lst[index2]),\
    \ std::optional<long>(std::nullopt));\n    }\n    return std::make_tuple(std::optional<long>(lst[index2]),\
    \ std::optional<long>(lst[index]));", "\t// your code goes here\n\treturn {};",
  "  long negMax = LONG_MIN;\n  long posMin = LONG_MAX;\n  bool negExists = false;\n\
    \  bool posExists = false;\n  for (long n : lst) {\n    if (n < 0) {\n      negExists\
    \ = true;\n      if (n > negMax) {\n        negMax = n;\n      }\n    } else if\
    \ (n > 0) {\n      posExists = true;\n      if (n < posMin) {\n        posMin\
    \ = n;\n      }\n    }\n  }\n  std::optional<long> neg(negExists ? negMax : std::nullopt);\n\
    \  std::optional<long> pos(posExists ? posMin : std::nullopt);\n  return std::make_tuple(neg,\
    \ pos);", "\tint a=INT_MIN,b=INT_MAX;\n\tbool flag=false;\n\tfor(int i=0;i<lst.size();i++)\n\
    \t{\n\t\tif(lst[i]<0)\n\t\t{\n\t\t\ta=max(a,lst[i]);\n\t\t\tflag=true;\n\t\t}\n\
    \t\telse\n\t\t{\n\t\t\tb=min(b,lst[i]);\n\t\t}\n\t}\n\tif(flag)\n\t\treturn make_tuple(a,b);\n\
    \telse\n\t\treturn make_tuple(NULL,NULL);", "\tlong largest_negative = std::numeric_limits<long>::min();\n\
    \tlong smallest_positive = std::numeric_limits<long>::max();\n\tif (lst.size()\
    \ == 0)\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \tfor (const auto& elem : lst) {\n\t\tif (elem < 0 && elem > largest_negative)\n\
    \t\t\tlargest_negative = elem;\n\t\tif (elem > 0 && elem < smallest_positive)\n\
    \t\t\tsmallest_positive = elem;\n\t}\n\tif (largest_negative == std::numeric_limits<long>::min())\n\
    \t\tlargest_negative = std::nullopt;\n\tif (smallest_positive == std::numeric_limits<long>::max())\n\
    \t\tsmallest_positive = std::nullopt;\n\treturn std::make_tuple(std::optional<long>(largest_negative),\
    \ std::optional<long>(smallest_positive));", "    long s_pos=0, s_neg=0;\n   \
    \ bool flag_pos=false, flag_neg=false;\n    for(int i=0; i<lst.size(); i++){\n\
    \        if(lst[i]<0){\n            if(!flag_neg){\n                s_neg=lst[i];\n\
    \                flag_neg=true;\n            }\n            if(s_neg<lst[i]){\n\
    \                s_neg=lst[i];\n            }\n        }\n        if(lst[i]>0){\n\
    \            if(!flag_pos){\n                s_pos=lst[i];\n                flag_pos=true;\n\
    \            }\n            if(s_pos>lst[i]){\n                s_pos=lst[i];\n\
    \            }\n        }\n    }\n    if(flag_pos && flag_neg){\n        return\
    \ std::make_tuple(std::optional<long>(s_neg), std::optional<long>(s_pos));\n \
    \   }\n    else if(flag_pos && !flag_neg){\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(s_pos));\n    }\n    else if(!flag_pos && flag_neg){\n \
    \       return std::make_tuple(std::optional<long>(s_neg), std::optional<long>(std::nullopt));\n\
    \    }\n    else{\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }", "    std::optional<long> min(std::nullopt);\n\
    \    std::optional<long> max(std::nullopt);\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < 0) {\n            if (max.has_value()) {\n    \
    \            if (lst[i] > max.value()) {\n                    max = lst[i];\n\
    \                }\n            } else {\n                max = lst[i];\n    \
    \        }\n        } else if (lst[i] > 0) {\n            if (min.has_value())\
    \ {\n                if (lst[i] < min.value()) {\n                    min = lst[i];\n\
    \                }\n            } else {\n                min = lst[i];\n    \
    \        }\n        }\n    }\n    return std::make_tuple(max, min);", "\tstd::optional<long>\
    \ a, b;\n\tlong tmp = lst[0];\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\t\
    if (lst[i] > 0) {\n\t\t\tif (b == std::nullopt) {\n\t\t\t\tb = lst[i];\n\t\t\t\
    }\n\t\t\telse if (lst[i] < b) {\n\t\t\t\tb = lst[i];\n\t\t\t}\n\t\t}\n\t\telse\
    \ if (lst[i] < 0) {\n\t\t\tif (a == std::nullopt) {\n\t\t\t\ta = lst[i];\n\t\t\
    \t}\n\t\t\telse if (lst[i] > a) {\n\t\t\t\ta = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\t\
    return std::make_tuple(a, b);", "\t//Your code here\n\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> none = std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\tif (lst.size() == 0) {\n\t\treturn none;\n\
    \t}\n\tstd::vector<long> negative;\n\tstd::vector<long> positive;\n\tfor (int\
    \ i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] >= 0) {\n\t\t\tpositive.push_back(lst[i]);\n\
    \t\t}\n\t\telse {\n\t\t\tnegative.push_back(lst[i]);\n\t\t}\n\t}\n\tif (negative.size()\
    \ == 0 && positive.size() == 0) {\n\t\treturn none;\n\t}\n\tif (negative.size()\
    \ == 0) {\n\t\tstd::tuple<std::optional<long>, std::optional<long>> positivenone\
    \ = std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(*min_element(positive.begin(),\
    \ positive.end())));\n\t\treturn positivenone;\n\t}\n\tif (positive.size() ==\
    \ 0) {\n\t\tstd::tuple<std::optional<long>, std::optional<long>> negativenone\
    \ = std::make_tuple(std::optional<long>(*max_element(negative.begin(), negative.end())),\
    \ std::optional<long>(std::nullopt));\n\t\treturn negativenone;\n\t}\n\telse {\n\
    \t\tstd::tuple<std::optional<long>, std::optional<long>> both = std::make_tuple(std::optional<long>(*max_element(negative.begin(),\
    \ negative.end())), std::optional<long>(*min_element(positive.begin(), positive.end())));\n\
    \t\treturn both;\n\t}", "    long largest = INT_MIN;\n    long smallest = INT_MAX;\n\
    \    bool is_neg = false;\n    bool is_pos = false;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < 0) {\n            is_neg = true;\n            if\
    \ (lst[i] > largest) {\n                largest = lst[i];\n            }\n   \
    \     }\n        if (lst[i] > 0) {\n            is_pos = true;\n            if\
    \ (lst[i] < smallest) {\n                smallest = lst[i];\n            }\n \
    \       }\n    }\n    if (is_neg) {\n        return std::make_tuple(std::optional<long>(largest),\
    \ std::optional<long>(smallest));\n    }\n    if (is_pos) {\n        return std::make_tuple(std::optional<long>(largest),\
    \ std::optional<long>(smallest));\n    }\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));", "  auto v=lst;\n    if(!v.empty()){\n\
    \        std::sort(v.begin(),v.end());\n        if(v[0]>=0){\n            return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(v[0]));\n\
    \        }\n        if(v[v.size()-1]<=0){\n            return std::make_tuple(std::optional<long>(v[v.size()-1]),\
    \ std::optional<long>(std::nullopt));\n        }\n        return std::make_tuple(std::optional<long>(v[v.size()-1]),\
    \ std::optional<long>(v[0]));\n    }\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));", "    int n = lst.size();\n    if(n ==\
    \ 0)\n    {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }\n    long max = 0;\n    long min\
    \ = 0;\n    int flag = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i]\
    \ < 0)\n        {\n            if(lst[i] > max)\n            {\n             \
    \   max = lst[i];\n            }\n            flag = 1;\n        }\n        else\
    \ if(lst[i] > 0)\n        {\n            if(flag == 0)\n            {\n      \
    \          min = lst[i];\n            }\n            else if(lst[i] < min)\n \
    \           {\n                min = lst[i];\n            }\n        }\n    }\n\
    \    if(flag == 0)\n    {\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    }\n    return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));", "\tstd::optional<long> a;\n\tstd::optional<long>\
    \ b;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > 0) {\n\t\t\t\
    if (b == std::nullopt) {\n\t\t\t\tb = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i]\
    \ < b) {\n\t\t\t\tb = lst[i];\n\t\t\t}\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\
    \tif (a == std::nullopt) {\n\t\t\t\ta = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i]\
    \ > a) {\n\t\t\t\ta = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(a,\
    \ b);", "    // Write your code here\n    int n = lst.size();\n    int max = INT_MIN;\n\
    \    int min = INT_MAX;\n    int c = 0;\n    int d = 0;\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i] < 0)\n        {\n            if(lst[i] >\
    \ max)\n            {\n                max = lst[i];\n                c = 1;\n\
    \            }\n        }\n        else if(lst[i] > 0)\n        {\n          \
    \  if(lst[i] < min)\n            {\n                min = lst[i];\n          \
    \      d = 1;\n            }\n        }\n    }\n    if(c == 0)\n    {\n      \
    \  std::optional<long>x{std::nullopt};\n        return std::make_tuple(x, min);\n\
    \    }\n    else if(d == 0)\n    {\n        std::optional<long>y{std::nullopt};\n\
    \        return std::make_tuple(max, y);\n    }\n    else\n    {\n        return\
    \ std::make_tuple(max, min);\n    }", "  if (lst.size() == 0) {\n    return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  }\n  long largest_negative = INT_MIN;\n\
    \  long smallest_positive = INT_MAX;\n  for (int i = 0; i < lst.size(); i++) {\n\
    \    if (lst[i] < 0) {\n      largest_negative = std::max(largest_negative, lst[i]);\n\
    \    } else {\n      smallest_positive = std::min(smallest_positive, lst[i]);\n\
    \    }\n  }\n  if (largest_negative == INT_MIN) {\n    largest_negative = std::nullopt;\n\
    \  }\n  if (smallest_positive == INT_MAX) {\n    smallest_positive = std::nullopt;\n\
    \  }\n  return std::make_tuple(std::optional<long>(largest_negative), std::optional<long>(smallest_positive));",
  '    return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));',
  "    std::optional<long> a;\n    std::optional<long> b;\n    for (long i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else if (i > 0) {\n        \
    \    if (!b.has_value() || i < b.value()) {\n                b = i;\n        \
    \    }\n        }\n    }\n    return std::make_tuple(a, b);", "\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> result = std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\tlong a = 0;\n\tlong b = 0;\n\tbool first_a\
    \ = true;\n\tbool first_b = true;\n\tfor (long i : lst) {\n\t\tif (i < 0) {\n\t\
    \t\tif (first_a) {\n\t\t\t\ta = i;\n\t\t\t\tfirst_a = false;\n\t\t\t}\n\t\t\t\
    else if (i > a) {\n\t\t\t\ta = i;\n\t\t\t}\n\t\t}\n\t\telse if (i > 0) {\n\t\t\
    \tif (first_b) {\n\t\t\t\tb = i;\n\t\t\t\tfirst_b = false;\n\t\t\t}\n\t\t\telse\
    \ if (i < b) {\n\t\t\t\tb = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (!first_a) {\n\t\tstd::get<0>(result)\
    \ = a;\n\t}\n\tif (!first_b) {\n\t\tstd::get<1>(result) = b;\n\t}\n\treturn result;",
  "\t// Write your code here\n\tstd::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n\tstd::optional<long> first=std::nullopt;\n\tstd::optional<long> second=std::nullopt;\n\
    \t\n\tstd::vector<long>::iterator itr = lst.begin();\n\tfor(;itr!=lst.end();itr++)\n\
    \t{\n\t\tif(*itr>0)\n\t\t{\n\t\t\tif(second==std::nullopt)\n\t\t\t\tsecond=*itr;\n\
    \t\t\telse if(*itr<second)\n\t\t\t\tsecond=*itr;\n\t\t}\n\t\tif(*itr<0)\n\t\t\
    {\n\t\t\tif(first==std::nullopt)\n\t\t\t\tfirst=*itr;\n\t\t\telse if(*itr>first)\n\
    \t\t\t\tfirst=*itr;\n\t\t}\n\t}\n\tresult=std::make_tuple(first,second);\n\treturn\
    \ result;", "\t// write your code here\n\tint positive_count = 0;\n\tint negative_count\
    \ = 0;\n\tint positive_min = INT_MAX;\n\tint negative_max = INT_MIN;\n\tfor (auto\
    \ &x : lst) {\n\t\tif (x < 0) {\n\t\t\tnegative_count++;\n\t\t\tif (x > negative_max)\
    \ {\n\t\t\t\tnegative_max = x;\n\t\t\t}\n\t\t}\n\t\telse if (x > 0) {\n\t\t\t\
    positive_count++;\n\t\t\tif (x < positive_min) {\n\t\t\t\tpositive_min = x;\n\t\
    \t\t}\n\t\t}\n\t}\n\tstd::optional<long> biggest_negative;\n\tstd::optional<long>\
    \ smallest_positive;\n\tif (negative_count == 0) {\n\t\tbiggest_negative = std::nullopt;\n\
    \t}\n\telse {\n\t\tbiggest_negative = negative_max;\n\t}\n\tif (positive_count\
    \ == 0) {\n\t\tsmallest_positive = std::nullopt;\n\t}\n\telse {\n\t\tsmallest_positive\
    \ = positive_min;\n\t}\n\treturn std::make_tuple(biggest_negative, smallest_positive);",
  "\t", "    std::optional<long> l, s;\n    for (auto& it : lst) {\n        if (it\
    \ > 0) {\n            if (!s.has_value() || it < s.value())\n                s\
    \ = it;\n        } else if (it < 0) {\n            if (!l.has_value() || it >\
    \ l.value())\n                l = it;\n        }\n    }\n    return std::make_tuple(l,\
    \ s);", "\tauto compare = [](long a, long b) -> bool{\n\t\treturn a > b;\n\t};\n\
    \tauto largest = std::max_element(lst.begin(), lst.end(), compare);\n\tauto smallest\
    \ = std::min_element(lst.begin(), lst.end(), compare);\n\tlong largest_d = std::distance(lst.begin(),\
    \ largest);\n\tlong smallest_d = std::distance(lst.begin(), smallest);\n\tif(largest_d\
    \ == lst.size() || smallest_d == lst.size()){\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\t}\n\tif(*largest < 0){\n\t\treturn std::make_tuple(std::optional<long>(*largest),\
    \ std::optional<long>(std::nullopt));\n\t}\n\tif(*smallest > 0){\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(*smallest));\n\t}\n\tif(*largest > 0 && *smallest < 0){\n\
    \t\treturn std::make_tuple(std::optional<long>(*largest), std::optional<long>(*smallest));\n\
    \t}", "\tlong min = INT_MAX;\n\tlong max = INT_MIN;\n\tlong n = lst.size();\n\t\
    for (int i = 0; i < n; i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tif (lst[i] < min)\
    \ {\n\t\t\t\tmin = lst[i];\n\t\t\t}\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\t\
    if (lst[i] > max) {\n\t\t\t\tmax = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (min ==\
    \ INT_MAX && max == INT_MIN) {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\t}\n\telse if (min == INT_MAX) {\n\t\t\
    return std::make_tuple(std::optional<long>(max), std::optional<long>(std::nullopt));\n\
    \t}\n\telse if (max == INT_MIN) {\n\t\treturn std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min));\n\t}\n\telse {\n\t\treturn std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));\n\t}", "    std::optional<long> biggest;\n    std::optional<long>\
    \ smallest;\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] >\
    \ 0) {\n            if (!smallest.has_value()) {\n                smallest = lst[i];\n\
    \            } else if (lst[i] < smallest.value()) {\n                smallest\
    \ = lst[i];\n            }\n        } else if (lst[i] < 0) {\n            if (!biggest.has_value())\
    \ {\n                biggest = lst[i];\n            } else if (lst[i] > biggest.value())\
    \ {\n                biggest = lst[i];\n            }\n        }\n    }\n    return\
    \ std::make_tuple(biggest, smallest);", "\tlong a,b;\n\ta=b=0;\n\tstd::optional<long>\
    \ opt1,opt2;\n\topt1=opt2=std::nullopt;\n\tif(lst.size()==0)\n\t\treturn std::make_tuple(opt1,opt2);\n\
    \tint m=INT_MIN,n=INT_MAX;\n\tfor(int i=0;i<lst.size();i++)\n\t{\n\t\tif(lst[i]>0)\n\
    \t\t{\n\t\t\tif(lst[i]<n)\n\t\t\t\tn=lst[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(lst[i]>m)\n\
    \t\t\t\tm=lst[i];\n\t\t}\n\t}\n\tif(m==INT_MIN)\n\t\topt1=std::nullopt;\n\telse\n\
    \t\topt1=m;\n\tif(n==INT_MAX)\n\t\topt2=std::nullopt;\n\telse\n\t\topt2=n;\n\t\
    return std::make_tuple(opt1,opt2);", "  auto res = std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n  if(lst.size() == 0)\n    return res;\n\
    \  if(lst.size() == 1)\n    if(lst[0] < 0)\n      return std::make_tuple(std::optional<long>(lst[0]),\
    \ std::optional<long>(std::nullopt));\n    else if(lst[0] > 0)\n      return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(lst[0]));\n    else\n      return res;\n  else{\n    std::sort(lst.begin(),\
    \ lst.end());\n    auto min = std::numeric_limits<long>::max();\n    auto max\
    \ = std::numeric_limits<long>::min();\n    for(auto e : lst){\n      if(e > 0){\n\
    \        min = std::min(min, e);\n      }\n      else if(e < 0){\n        max\
    \ = std::max(max, e);\n      }\n    }\n    if(min == std::numeric_limits<long>::max())\n\
    \      return std::make_tuple(std::optional<long>(max), std::optional<long>(std::nullopt));\n\
    \    else if(max == std::numeric_limits<long>::min())\n      return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(min));\n    else\n      return std::make_tuple(std::optional<long>(max),\
    \ std::optional<long>(min));\n  }", "\t//return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n\tstd::tuple<std::optional<long>, std::optional<long>>\
    \ tup(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \tint count = 0;\n\tfor (auto num : lst) {\n\t\tif (num > 0) {\n\t\t\tcount +=\
    \ 1;\n\t\t}\n\t}\n\tint max = INT_MIN;\n\tint min = INT_MAX;\n\tfor (auto num\
    \ : lst) {\n\t\tif (num < 0) {\n\t\t\tif (num > max) {\n\t\t\t\tmax = num;\n\t\
    \t\t}\n\t\t}\n\t\tif (num > 0) {\n\t\t\tif (num < min) {\n\t\t\t\tmin = num;\n\
    \t\t\t}\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn tup;\n\t}\n\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> tup2(std::optional<long>(max), std::optional<long>(min));\n\
    \treturn tup2;", "\tstd::optional<long> largest, smallest;\n\tfor (long l : lst)\
    \ {\n\t\tif (l > 0) {\n\t\t\tif (!smallest.has_value() || l < smallest.value())\
    \ {\n\t\t\t\tsmallest = l;\n\t\t\t}\n\t\t}\n\t\telse if (l < 0) {\n\t\t\tif (!largest.has_value()\
    \ || l > largest.value()) {\n\t\t\t\tlargest = l;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ std::make_tuple(largest, smallest);", "  if (lst.size() == 0) {\n    return\
    \ std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \  }\n\n  std::vector<long> positive, negative;\n  for (const auto &value : lst)\
    \ {\n    if (value < 0) {\n      negative.push_back(value);\n    } else if (value\
    \ > 0) {\n      positive.push_back(value);\n    }\n  }\n\n  std::sort(negative.begin(),\
    \ negative.end());\n  std::sort(positive.begin(), positive.end());\n\n  long a,\
    \ b;\n  if (negative.size() > 0) {\n    a = negative[negative.size() - 1];\n \
    \ } else {\n    a = std::nullopt;\n  }\n\n  if (positive.size() > 0) {\n    b\
    \ = positive[0];\n  } else {\n    b = std::nullopt;\n  }\n\n  return std::make_tuple(a,\
    \ b);", "\t// long smallest = std::numeric_limits<long>::max();\n\t// long largest\
    \ = std::numeric_limits<long>::min();\n\tint val = 0;\n\tstd::optional<long> ans\
    \ = 0;\n\t// if(lst.size() == 0) return std::make_tuple(ans, ans);\n\t// for(int\
    \ i=0; i<lst.size(); i++){\n\t// \tif(lst[i] < 0 && lst[i] > largest) largest\
    \ = lst[i];\n\t// \tif(lst[i] > 0 && lst[i] < smallest) smallest = lst[i];\n\t\
    // }\n\t// if(smallest != std::numeric_limits<long>::max()) ans = smallest;\n\t\
    // if(largest != std::numeric_limits<long>::min()) ans = largest;\n\t// return\
    \ std::make_tuple(ans, ans);\n\tif(lst.size() == 0) return std::make_tuple(ans,\
    \ ans);\n\tstd::sort(lst.begin(), lst.end());\n\tif(lst[0] < 0 && lst[lst.size()-1]\
    \ > 0) return std::make_tuple(lst[lst.size()-1], lst[0]);\n\telse if(lst[0] >\
    \ 0) return std::make_tuple(ans, lst[0]);\n\telse if(lst[lst.size()-1] < 0) return\
    \ std::make_tuple(lst[lst.size()-1], ans);\n\telse return std::make_tuple(ans,\
    \ ans);", "    std::optional<long> minVal, maxVal;\n    if(lst.size()>0){\n  \
    \      maxVal = lst[0];\n        minVal = lst[0];\n        for(int i=0;i<lst.size();i++){\n\
    \            if(lst[i]<0){\n                if(lst[i]>*maxVal){\n            \
    \        maxVal = lst[i];\n                }\n            }\n            else{\n\
    \                if(lst[i]<*minVal){\n                    minVal = lst[i];\n \
    \               }\n            }\n        }\n    }\n    return std::make_tuple(maxVal,\
    \ minVal);", "  std::tuple<std::optional<long>, std::optional<long>> result;\n\
    \  std::optional<long> large, small;\n  std::optional<long> h;\n  for (auto&&\
    \ i : lst) {\n    if (i > 0) {\n      if (small == std::nullopt) {\n        small\
    \ = i;\n      } else if (i < small) {\n        small = i;\n      }\n    } else\
    \ if (i < 0) {\n      if (large == std::nullopt) {\n        large = i;\n     \
    \ } else if (i > large) {\n        large = i;\n      }\n    }\n  }\n  return std::make_tuple(large,\
    \ small);", "\tstd::tuple<std::optional<long>, std::optional<long>> tpl(std::nullopt,\
    \ std::nullopt);\n\tint size = lst.size();\n\tint max = INT_MIN;\n\tint min =\
    \ INT_MAX;\n\tfor (int i = 0; i < size; i++) {\n\t\tif (lst[i] < 0) {\n\t\t\t\
    if (lst[i] > max)\n\t\t\t\tmax = lst[i];\n\t\t}\n\t\telse if (lst[i] > 0) {\n\t\
    \t\tif (lst[i] < min)\n\t\t\t\tmin = lst[i];\n\t\t}\n\t}\n\tif (max == INT_MIN)\n\
    \t\ttpl = std::make_tuple(std::nullopt, std::nullopt);\n\telse if (min == INT_MAX)\n\
    \t\ttpl = std::make_tuple(std::optional<long>(max), std::nullopt);\n\telse\n\t\
    \ttpl = std::make_tuple(std::optional<long>(max), std::optional<long>(min));\n\
    \treturn tpl;", "    std::optional<long> maximum = std::nullopt;\n    std::optional<long>\
    \ minimum = std::nullopt;\n    for (int i = 0; i < lst.size(); i++) {\n      \
    \  if (lst[i] < 0) {\n            if (maximum == std::nullopt || lst[i] > *maximum)\
    \ {\n                maximum = lst[i];\n            }\n        } else if (lst[i]\
    \ > 0) {\n            if (minimum == std::nullopt || lst[i] < *minimum) {\n  \
    \              minimum = lst[i];\n            }\n        }\n    }\n    return\
    \ std::make_tuple(maximum, minimum);", "    std::optional<long> a, b;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || a.value()\
    \ < i) {\n                a = i;\n            }\n        } else if (i > 0) {\n\
    \            if (!b.has_value() || b.value() > i) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    int\
    \ smallest = 0;\n    int largest = 0;\n    int first = 0;\n    int last = 0;\n\
    \    int number_of_positive = 0;\n    int number_of_negative = 0;\n    std::vector<long>\
    \ negative;\n    std::vector<long> positive;\n    int size = lst.size();\n   \
    \ if (size == 0) {\n        std::tuple<std::optional<long>, std::optional<long>>\
    \ t;\n        std::get<0>(t) = std::nullopt;\n        std::get<1>(t) = std::nullopt;\n\
    \        return t;\n    }\n    for (int i = 0; i < size; i++) {\n        if (lst[i]\
    \ < 0) {\n            negative.push_back(lst[i]);\n            number_of_negative++;\n\
    \        }\n        if (lst[i] > 0) {\n            positive.push_back(lst[i]);\n\
    \            number_of_positive++;\n        }\n    }\n    std::sort(negative.begin(),\
    \ negative.end());\n    std::sort(positive.begin(), positive.end());\n    if (number_of_negative\
    \ == 0) {\n        std::tuple<std::optional<long>, std::optional<long>> t;\n \
    \       std::get<0>(t) = std::nullopt;\n        std::get<1>(t) = positive[0];\n\
    \        return t;\n    }\n    if (number_of_positive == 0) {\n        std::tuple<std::optional<long>,\
    \ std::optional<long>> t;\n        std::get<0>(t) = negative[number_of_negative\
    \ - 1];\n        std::get<1>(t) = std::nullopt;\n        return t;\n    }\n  \
    \  if (number_of_negative != 0 && number_of_positive != 0) {\n        std::tuple<std::optional<long>,\
    \ std::optional<long>> t;\n        std::get<0>(t) = negative[number_of_negative\
    \ - 1];\n        std::get<1>(t) = positive[0];\n        return t;\n    }", "\t\
    std::optional<long> largest_neg;\n\tstd::optional<long> smallest_pos;\n\tfor (int\
    \ i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tif (!largest_neg.has_value())\
    \ {\n\t\t\t\tlargest_neg = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i] > largest_neg.value())\
    \ {\n\t\t\t\tlargest_neg = lst[i];\n\t\t\t}\n\t\t}\n\t\telse if (lst[i] > 0) {\n\
    \t\t\tif (!smallest_pos.has_value()) {\n\t\t\t\tsmallest_pos = lst[i];\n\t\t\t\
    }\n\t\t\telse if (lst[i] < smallest_pos.value()) {\n\t\t\t\tsmallest_pos = lst[i];\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(largest_neg, smallest_pos);", " \
    \   std::optional<long> oa, ob;\n    long a = 0, b = 0;\n    int c = 0, d = 0;\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n     \
    \       a = lst[i];\n            c++;\n        }\n        if (lst[i] > 0) {\n\
    \            b = lst[i];\n            d++;\n        }\n    }\n    if (c == 0)\n\
    \        oa = std::nullopt;\n    else\n        oa = a;\n    if (d == 0)\n    \
    \    ob = std::nullopt;\n    else\n        ob = b;\n    return std::make_tuple(oa,\
    \ ob);", "\tauto a=std::max_element(lst.begin(),lst.end());\n\tauto b=std::min_element(lst.begin(),lst.end());\n\
    \tstd::optional<long> m(std::nullopt);\n\tstd::optional<long> n(std::nullopt);\n\
    \tif(lst.size()==0){\n\t\treturn std::make_tuple(m,n);\n\t}\n\telse if((*a>0)&&(*b>0)){\n\
    \t\treturn std::make_tuple(m,*b);\n\t}\n\telse if((*a<0)&&(*b<0)){\n\t\treturn\
    \ std::make_tuple(*a,n);\n\t}\n\telse{\n\t\treturn std::make_tuple(m,n);\n\t}",
  "    if(lst.size()==0)\n        return std::make_tuple(std::optional<long>(std::nullopt),\
    \ std::optional<long>(std::nullopt));\n    long min=lst[0],max=lst[0];\n    bool\
    \ found=false;\n    for(long i=0;i<lst.size();i++)\n    {\n        if(lst[i]>0)\n\
    \        {\n            if(found==false)\n            {\n                min=lst[i];\n\
    \                found=true;\n            }\n            if(lst[i]<min)\n    \
    \            min=lst[i];\n        }\n        else\n        {\n            if(lst[i]>max)\n\
    \                max=lst[i];\n        }\n    }\n    if(found==false)\n       \
    \ return std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt));\n\
    \    else\n        return std::make_tuple(std::optional<long>(max), std::optional<long>(min));",
  "\tint i,l,r;\n\ti=l=r=0;\n\tif(lst.size()>0)\n\t{\n\t\tr=lst[0];\n\t\tl=lst[0];\n\
    \t\ti=1;\n\t}\n\tfor(i;i<lst.size();i++)\n\t{\n\t\tif(lst[i]>0)\n\t\t{\n\t\t\t\
    if(lst[i]<r)\n\t\t\t{\n\t\t\t\tr=lst[i];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \tif(lst[i]>l)\n\t\t\t{\n\t\t\t\tl=lst[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(std::optional<long>(l),\
    \ std::optional<long>(r));", "\tlong largest = LONG_MIN;\n\tlong smallest = LONG_MAX;\n\
    \tstd::tuple<std::optional<long>, std::optional<long>> t;\n\tstd::get<0>(t) =\
    \ std::nullopt;\n\tstd::get<1>(t) = std::nullopt;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] >= 0 && lst[i] < smallest)\n\t\t\tsmallest = lst[i];\n\
    \t\tif (lst[i] < 0 && lst[i] > largest)\n\t\t\tlargest = lst[i];\n\t}\n\tif (largest\
    \ == LONG_MIN && smallest == LONG_MAX)\n\t\treturn t;\n\tif (largest == LONG_MIN)\n\
    \t\tstd::get<0>(t) = std::nullopt;\n\telse\n\t\tstd::get<0>(t) = largest;\n\t\
    if (smallest == LONG_MAX)\n\t\tstd::get<1>(t) = std::nullopt;\n\telse\n\t\tstd::get<1>(t)\
    \ = smallest;\n\treturn t;", "\tstd::optional<long> a;\n\tstd::optional<long>\
    \ b;\n\tfor (long i : lst) {\n\t\tif (i > 0) {\n\t\t\tif (!b.has_value()) {\n\t\
    \t\t\tb = i;\n\t\t\t}\n\t\t\telse if (i < b.value()) {\n\t\t\t\tb = i;\n\t\t\t\
    }\n\t\t}\n\t\telse if (i < 0) {\n\t\t\tif (!a.has_value()) {\n\t\t\t\ta = i;\n\
    \t\t\t}\n\t\t\telse if (i > a.value()) {\n\t\t\t\ta = i;\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn std::make_tuple(a, b);"]
stop_tokens:
- "\n}"
