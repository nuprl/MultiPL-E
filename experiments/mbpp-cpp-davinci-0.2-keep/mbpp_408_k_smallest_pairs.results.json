{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpeh6y4eof: /tmp/tmpeh6y4eof.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpcw50lspv: /tmp/tmpcw50lspv.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while(k--) {\n        if(pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmp778hmjbe: /tmp/tmp778hmjbe.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpck64tvoj: /tmp/tmpck64tvoj.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        }\n    );\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpvs_29xjf: /tmp/tmpvs_29xjf.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpn7oa4pin: /tmp/tmpn7oa4pin.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpmcspzwn4: /tmp/tmpmcspzwn4.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmp77rdorij: /tmp/tmp77rdorij.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> res;\n    if(nums1.empty() || nums2.empty()) return res;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto [sum, [i, j]] = pq.top();\n        pq.pop();\n        res.push_back({nums1[i], nums2[j]});\n        if(j + 1 < nums2.size()) {\n            pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "/tmp/tmpmsl4j3j0.cpp: In function \u2018std::vector<std::vector<long int> > k_smallest_pairs(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmpmsl4j3j0.cpp:12:20: error: expected identifier before \u2018[\u2019 token\n   12 |         auto [sum, [i, j]] = pq.top();\n      |                    ^\n/tmp/tmpmsl4j3j0.cpp:12:19: error: expected \u2018]\u2019 before \u2018[\u2019 token\n   12 |         auto [sum, [i, j]] = pq.top();\n      |                   ^~\n      |                   ]\n/tmp/tmpmsl4j3j0.cpp:12:14: error: only 1 name provided for structured binding\n   12 |         auto [sum, [i, j]] = pq.top();\n      |              ^\n/tmp/tmpmsl4j3j0.cpp:12:14: note: while \u2018std::pair<long int, std::pair<long int, long int> >\u2019 decomposes into 2 elements\n/tmp/tmpmsl4j3j0.cpp:14:30: error: \u2018i\u2019 was not declared in this scope\n   14 |         res.push_back({nums1[i], nums2[j]});\n      |                              ^\n/tmp/tmpmsl4j3j0.cpp:14:40: error: \u2018j\u2019 was not declared in this scope\n   14 |         res.push_back({nums1[i], nums2[j]});\n      |                                        ^\n/tmp/tmpmsl4j3j0.cpp:14:43: error: no matching function for call to \u2018std::vector<std::vector<long int> >::push_back(<brace-enclosed initializer list>)\u2019\n   14 |         res.push_back({nums1[i], nums2[j]});\n      |                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:62,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/pstl/glue_algorithm_defs.h:13,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:71,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n                 from /tmp/tmpmsl4j3j0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7: note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> res;\n\tif (nums1.size() == 0 || nums2.size() == 0)\n\t\treturn res;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tres.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpvmbfjuc3: /tmp/tmpvmbfjuc3.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpdx8kgyql: /tmp/tmpdx8kgyql.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmp86gcq_i4: /tmp/tmp86gcq_i4.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>> max_heap;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- && !max_heap.empty()) {\n\t\tresult.push_back({max_heap.top()[1], max_heap.top()[2]});\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpfdztyvf5: /tmp/tmpfdztyvf5.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while(k-- > 0 && !max_heap.empty()) {\n        std::vector<long> current = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[current[0]], nums2[current[1]]});\n        if(current[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{current[0] + 1, current[1]});\n        }\n        if(current[0] == 0 && current[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{current[0], current[1] + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpgk35yssh: /tmp/tmpgk35yssh.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for(long i = 0; i < k; i++) {\n        if(max_heap.empty()) {\n            break;\n        }\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmp9wxi290c: /tmp/tmp9wxi290c.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k--) {\n        if(pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpzqqz9moe: /tmp/tmpzqqz9moe.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n\t\treturn result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpqb10lw82: /tmp/tmpqb10lw82.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmph29rlyvx: /tmp/tmph29rlyvx.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpw72qj4nl: /tmp/tmpw72qj4nl.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpi51k7xtx: /tmp/tmpi51k7xtx.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tpq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmp5ok059a8: /tmp/tmp5ok059a8.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmp97xl3225: /tmp/tmp97xl3225.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmp9iv0dydr: /tmp/tmp9iv0dydr.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpqbgoi1uv: /tmp/tmpqbgoi1uv.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) return result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpbuqkaxa8: /tmp/tmpbuqkaxa8.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmp48qleaki: /tmp/tmp48qleaki.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmpe4c9a_u5: /tmp/tmpe4c9a_u5.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmpjxo8n9v7: /tmp/tmpjxo8n9v7.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    for(int i = 0; i < k && !max_heap.empty(); i++) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpx2q84mw8: /tmp/tmpx2q84mw8.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpa5qzneru: /tmp/tmpa5qzneru.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmp1r02jd5q: /tmp/tmp1r02jd5q.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmpj4i5bejw: /tmp/tmpj4i5bejw.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); ++i) {\n\t\tfor (long j = 0; j < nums2.size(); ++j) {\n\t\t\tpq.push({nums1[i] + nums2[j], {i, j}});\n\t\t}\n\t}\n\twhile (k--) {\n\t\tif (pq.empty()) {\n\t\t\tbreak;\n\t\t}\n\t\tauto temp = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmpzvoreorx: /tmp/tmpzvoreorx.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmpx8n_yl5h: /tmp/tmpx8n_yl5h.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpjgrufmkj: /tmp/tmpjgrufmkj.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) return result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpxmr92umq: /tmp/tmpxmr92umq.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n\t\t}\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tresult.push_back({pq.top().second.first, pq.top().second.second});\n\t\tpq.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmplb401tzg: /tmp/tmplb401tzg.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmp9f_4llk1: /tmp/tmp9f_4llk1.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    for(long i = 0; i < k; i++) {\n        if(pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpa0zrtus9: /tmp/tmpa0zrtus9.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpc65safgy: /tmp/tmpc65safgy.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmph_4b7b77: /tmp/tmph_4b7b77.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty())\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b){\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n            if(pq.size() > k)\n                pq.pop();\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpwe0wendf: /tmp/tmpwe0wendf.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpocelf_ai: /tmp/tmpocelf_ai.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmp8ruo5ukt: /tmp/tmp8ruo5ukt.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push({num1, num2});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmphzattca5: /tmp/tmphzattca5.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpeh6y4eof: /tmp/tmpeh6y4eof.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push({num1, num2});\n            if (pq.size() > k) pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmphy_3pgaz: /tmp/tmphy_3pgaz.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    pq.push({nums1[0] + nums2[0], {0, 0}});\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        if (top.second.second == 0 && top.second.first + 1 < nums1.size()) {\n            pq.push({nums1[top.second.first + 1] + nums2[top.second.second], {top.second.first + 1, top.second.second}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpf2tivcf0: /tmp/tmpf2tivcf0.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!max_heap.empty() && k-- > 0) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({temp.second.first, temp.second.second});\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmph6azd6h6: /tmp/tmph6azd6h6.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(!pq.empty() && k > 0) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back(std::vector<long>{nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpkm8_vt4l: /tmp/tmpkm8_vt4l.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmp4s9u4ivb: /tmp/tmp4s9u4ivb.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpsx0nli92: /tmp/tmpsx0nli92.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.empty() || nums2.empty()) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n    }\n  }\n  while (k-- && !pq.empty()) {\n    result.push_back({pq.top().second.first, pq.top().second.second});\n    pq.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmplzl8esc4: /tmp/tmplzl8esc4.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k > 0 && !pq.empty()) {\n\t\tauto temp = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n\t\tif (temp.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[temp.second.first] + nums2[temp.second.second + 1], {temp.second.first, temp.second.second + 1}});\n\t\t}\n\t\tk--;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpr2xubvvv: /tmp/tmpr2xubvvv.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpc65safgy: /tmp/tmpc65safgy.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpmcspzwn4: /tmp/tmpmcspzwn4.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(!max_heap.empty() && k--) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpoqw68h04: /tmp/tmpoqw68h04.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpcytav5ec: /tmp/tmpcytav5ec.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpk73ij3r6: /tmp/tmpk73ij3r6.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpcwog3icy: /tmp/tmpcwog3icy.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp789_bjuh: /tmp/tmp789_bjuh.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n  for (long i = 0; i < nums1.size(); i++) {\n    max_heap.push({nums1[i] + nums2[0], {i, 0}});\n  }\n  while (k-- > 0 && !max_heap.empty()) {\n    auto top = max_heap.top();\n    max_heap.pop();\n    result.push_back({nums1[top.second.first], nums2[top.second.second]});\n    if (top.second.second + 1 < nums2.size()) {\n      max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp7wd1au3j: /tmp/tmp7wd1au3j.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size() && i < k; i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto idx_pair = max_heap.top().second;\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[idx_pair.first], nums2[idx_pair.second]});\n        if (idx_pair.second + 1 < nums2.size()) {\n            max_heap.push({nums1[idx_pair.first] + nums2[idx_pair.second + 1], {idx_pair.first, idx_pair.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpydwriw9k: /tmp/tmpydwriw9k.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpdhbslj2t: /tmp/tmpdhbslj2t.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp8gfmi7co: /tmp/tmp8gfmi7co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto num : nums1) {\n        max_heap.push({num, nums2[0], 0});\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({top[0], top[1]});\n        if(top[2] == nums2.size() - 1) {\n            continue;\n        }\n        max_heap.push({top[0], nums2[top[2] + 1], top[2] + 1});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp6b4h2dus: /tmp/tmp6b4h2dus.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpsjk9t204: /tmp/tmpsjk9t204.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top[1], top[2]});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpl03zcymw: /tmp/tmpl03zcymw.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpeh6y4eof: /tmp/tmpeh6y4eof.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpbb0wxfrj: /tmp/tmpbb0wxfrj.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> pair = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpl0ayfbtz: /tmp/tmpl0ayfbtz.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp282vd5hv: /tmp/tmp282vd5hv.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i] + nums2[j], {i, j}});\n    }\n  }\n  while (k--) {\n    if (pq.empty()) {\n      break;\n    }\n    auto p = pq.top();\n    pq.pop();\n    result.push_back({nums1[p.second.first], nums2[p.second.second]});\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpqaird04s: /tmp/tmpqaird04s.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp0uhs9tp6: /tmp/tmp0uhs9tp6.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpvz4damsz: /tmp/tmpvz4damsz.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpcytav5ec: /tmp/tmpcytav5ec.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n\t\treturn result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (int i = 0; i < nums1.size(); i++) {\n\t\tfor (int j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); ++i) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpgv1sk4by: /tmp/tmpgv1sk4by.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "tmpj4i5bejw: /tmp/tmpj4i5bejw.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(!pq.empty() && k > 0) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp789_bjuh: /tmp/tmp789_bjuh.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push({num1, num2});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmp6b9hazfe: /tmp/tmp6b9hazfe.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.emplace(std::vector<long>{i, j});\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.emplace_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpn7r26gtn: /tmp/tmpn7r26gtn.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmp69fnyvmw: /tmp/tmp69fnyvmw.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpua31cbec: /tmp/tmpua31cbec.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpnfj7d3ce: /tmp/tmpnfj7d3ce.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmpw72qj4nl: /tmp/tmpw72qj4nl.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmp9iv0dydr: /tmp/tmp9iv0dydr.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpik1lcquw: /tmp/tmpik1lcquw.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpgv1_m3hn: /tmp/tmpgv1_m3hn.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpz8lm_egb: /tmp/tmpz8lm_egb.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmph4km87yr: /tmp/tmph4km87yr.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpuf3jos_g: /tmp/tmpuf3jos_g.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpmbtx006f: /tmp/tmpmbtx006f.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size() && i < k; i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpa2h0sv0e: /tmp/tmpa2h0sv0e.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmp5dfgze4x: /tmp/tmp5dfgze4x.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i], nums2[0], 0});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top[0], top[1]});\n        if (top[2] + 1 < nums2.size()) {\n            pq.push({top[0], nums2[top[2] + 1], top[2] + 1});\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122966,
      "stdout": "",
      "stderr": "tmptbl5vgsk: /tmp/tmptbl5vgsk.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpxksnt3pa: /tmp/tmpxksnt3pa.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmp0e6vq1z0: /tmp/tmp0e6vq1z0.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            min_heap.push({i, j});\n        }\n    }\n    while (k-- && !min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpeeld9t4j: /tmp/tmpeeld9t4j.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpcw50lspv: /tmp/tmpcw50lspv.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmp6e795zbk: /tmp/tmp6e795zbk.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (max_heap.empty()) {\n            break;\n        }\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpm9pt3aw0: /tmp/tmpm9pt3aw0.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i], nums2[0], 0});\n    }\n    while (!pq.empty() && k-- > 0) {\n        auto [x, y, index] = pq.top();\n        pq.pop();\n        result.push_back({x, y});\n        if (index + 1 < nums2.size()) {\n            pq.push({x, nums2[index + 1], index + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpqppbg1ik.cpp: In function \u2018std::vector<std::vector<long int> > k_smallest_pairs(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmpqppbg1ik.cpp:16:14: error: 3 names provided for structured binding\n   16 |         auto [x, y, index] = pq.top();\n      |              ^~~~~~~~~~~~~\n/tmp/tmpqppbg1ik.cpp:16:14: note: while \u2018std::vector<long int>\u2019 decomposes into 1 element\n/tmp/tmpqppbg1ik.cpp:18:32: error: no matching function for call to \u2018std::vector<std::vector<long int> >::push_back(<brace-enclosed initializer list>)\u2019\n   18 |         result.push_back({x, y});\n      |                                ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:62,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/pstl/glue_algorithm_defs.h:13,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:71,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n                 from /tmp/tmpqppbg1ik.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7: note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::vector<long int>; _Alloc = std::allocator<std::vector<long int> >; std::vector<_Tp, _Alloc>::value_type = std::vector<long int>]\u2019\n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35: note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer list>\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::vector<long int>&\u2019}\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpgv1_m3hn: /tmp/tmpgv1_m3hn.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmp5dfgze4x: /tmp/tmp5dfgze4x.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpp1f38ejq: /tmp/tmpp1f38ejq.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tif (max_heap.size() < k) {\n\t\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t\t} else {\n\t\t\t\tif (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n\t\t\t\t\tmax_heap.pop();\n\t\t\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpwllxqmnc: /tmp/tmpwllxqmnc.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmplcsf43_7: /tmp/tmplcsf43_7.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpokfm7uuw: /tmp/tmpokfm7uuw.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpkzc9jjzd: /tmp/tmpkzc9jjzd.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpuuu4cr14: /tmp/tmpuuu4cr14.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k--) {\n        if (!pq.empty()) {\n            result.push_back(pq.top());\n            pq.pop();\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmps12pwvqi: /tmp/tmps12pwvqi.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpcytav5ec: /tmp/tmpcytav5ec.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpooigshmc: /tmp/tmpooigshmc.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpqwv95zjb: /tmp/tmpqwv95zjb.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpdhbslj2t: /tmp/tmpdhbslj2t.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "tmpfy80uqlz: /tmp/tmpfy80uqlz.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); ++i) {\n\t\tfor (long j = 0; j < nums2.size(); ++j) {\n\t\t\tpq.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i = 0; i < nums1.size(); i++) {\n        for (auto j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "tmpcisjy4tt: /tmp/tmpcisjy4tt.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122961,
      "stdout": "",
      "stderr": "tmpsx0nli92: /tmp/tmpsx0nli92.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for (long i = 0; i < k && !max_heap.empty(); i++) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "tmp4_x0o0od: /tmp/tmp4_x0o0od.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (!max_heap.empty() && k--) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "tmpmdjxswr2: /tmp/tmpmdjxswr2.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmp0uhs9tp6: /tmp/tmp0uhs9tp6.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmph4km87yr: /tmp/tmph4km87yr.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::vector<std::vector<long>> heap;\n    std::vector<long> first_pair = {nums1[0] + nums2[0], 0, 0};\n    heap.push_back(first_pair);\n    std::unordered_set<std::string> visited;\n    visited.insert(\"0-0\");\n    for (long i = 0; i < k && heap.size() > 0; i++) {\n        std::vector<long> current_pair = heap[0];\n        result.push_back({nums1[current_pair[1]], nums2[current_pair[2]]});\n        if (current_pair[1] + 1 < nums1.size() && visited.find(std::to_string(current_pair[1] + 1) + \"-\" + std::to_string(current_pair[2])) == visited.end()) {\n            visited.insert(std::to_string(current_pair[1] + 1) + \"-\" + std::to_string(current_pair[2]));\n            heap.push_back({nums1[current_pair[1] + 1] + nums2[current_pair[2]], current_pair[1] + 1, current_pair[2]});\n        }\n        if (current_pair[2] + 1 < nums2.size() && visited.find(std::to_string(current_pair[1]) + \"-\" + std::to_string(current_pair[2] + 1)) == visited.end()) {\n            visited.insert(std::to_string(current_pair[1]) + \"-\" + std::to_string(current_pair[2] + 1));\n            heap.push_back({nums1[current_pair[1]] + nums2[current_pair[2] + 1], current_pair[1], current_pair[2] + 1});\n        }\n        std::pop_heap(heap.begin\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "/tmp/tmpy1hk4z2_.cpp: In function \u2018std::vector<std::vector<long int> > k_smallest_pairs(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmpy1hk4z2_.cpp:25:33: error: expected \u2018)\u2019 before \u2018}\u2019 token\n   25 |         std::pop_heap(heap.begin\n      |                      ~          ^\n      |                                 )\n   26 | }\n      | ~                                \n/tmp/tmpy1hk4z2_.cpp:27:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   27 | int main() {\n      |            ^\n/tmp/tmpy1hk4z2_.cpp:32:1: error: expected \u2018}\u2019 at end of input\n   32 | }\n      | ^\n/tmp/tmpy1hk4z2_.cpp:4:107: note: to match this \u2018{\u2019\n    4 | std::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n      |                                                                                                           ^\n/tmp/tmpy1hk4z2_.cpp:32:1: warning: control reaches end of non-void function [-Wreturn-type]\n   32 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while(!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmpj21spz3j: /tmp/tmpj21spz3j.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpeh6y4eof: /tmp/tmpeh6y4eof.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmpiwh1t_b0: /tmp/tmpiwh1t_b0.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({top.second.first, top.second.second});\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmpy_rwtc7m: /tmp/tmpy_rwtc7m.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n  }\n  while (k-- > 0 && !pq.empty()) {\n    std::pair<long, std::pair<long, long>> p = pq.top();\n    pq.pop();\n    result.push_back({nums1[p.second.first], nums2[p.second.second]});\n    if (p.second.second + 1 < nums2.size()) {\n      pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmp_3ennbxc: /tmp/tmp_3ennbxc.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "tmpgv1_m3hn: /tmp/tmpgv1_m3hn.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmpd7aamyk3: /tmp/tmpd7aamyk3.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmp8evkz38g: /tmp/tmp8evkz38g.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second < nums2.size() - 1) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmppareo6a3: /tmp/tmppareo6a3.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "tmptp9ryu_2: /tmp/tmptp9ryu_2.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "tmp9iv0dydr: /tmp/tmp9iv0dydr.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122963,
      "stdout": "",
      "stderr": "tmpcytav5ec: /tmp/tmpcytav5ec.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k-- > 0 && !pq.empty()) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122970,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122971,
      "stdout": "",
      "stderr": "tmp04d_iaxx: /tmp/tmp04d_iaxx.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push({num1, num2});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122971,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510134,
      "stdout": "",
      "stderr": "tmpd4l252co: /tmp/tmpd4l252co.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tmax_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tstd::pair<long, std::pair<long, long>> temp = max_heap.top();\n\t\tmax_heap.pop();\n\t\tresult.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n\t\tif (temp.second.second + 1 < nums2.size()) {\n\t\t\tmax_heap.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122971,
      "stdout": "",
      "stderr": "tmpmdkxt_be: /tmp/tmpmdkxt_be.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (auto i : nums1) {\n\t\tfor (auto j : nums2) {\n\t\t\tmax_heap.push({ i,j });\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "tmpgeium5nu: /tmp/tmpgeium5nu.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return (a[0] + a[1]) > (b[0] + b[1]);\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122971,
      "stdout": "",
      "stderr": "tmpjpojg0he: /tmp/tmpjpojg0he.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "tmpqtj_flej: /tmp/tmpqtj_flej.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "tmp70z92syl: /tmp/tmp70z92syl.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}