{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while(k--) {\n        if(pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        }\n    );\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> res;\n    if(nums1.empty() || nums2.empty()) return res;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto [sum, [i, j]] = pq.top();\n        pq.pop();\n        res.push_back({nums1[i], nums2[j]});\n        if(j + 1 < nums2.size()) {\n            pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\n        }\n    }\n    return res;",
    "\tstd::vector<std::vector<long>> res;\n\tif (nums1.size() == 0 || nums2.size() == 0)\n\t\treturn res;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tres.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn res;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>> max_heap;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- && !max_heap.empty()) {\n\t\tresult.push_back({max_heap.top()[1], max_heap.top()[2]});\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while(k-- > 0 && !max_heap.empty()) {\n        std::vector<long> current = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[current[0]], nums2[current[1]]});\n        if(current[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{current[0] + 1, current[1]});\n        }\n        if(current[0] == 0 && current[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{current[0], current[1] + 1});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for(long i = 0; i < k; i++) {\n        if(max_heap.empty()) {\n            break;\n        }\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k--) {\n        if(pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;"
  ]
}