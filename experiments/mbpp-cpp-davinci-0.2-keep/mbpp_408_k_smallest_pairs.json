{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while(k--) {\n        if(pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        }\n    );\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> res;\n    if(nums1.empty() || nums2.empty()) return res;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto [sum, [i, j]] = pq.top();\n        pq.pop();\n        res.push_back({nums1[i], nums2[j]});\n        if(j + 1 < nums2.size()) {\n            pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\n        }\n    }\n    return res;",
    "\tstd::vector<std::vector<long>> res;\n\tif (nums1.size() == 0 || nums2.size() == 0)\n\t\treturn res;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tres.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn res;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>> max_heap;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- && !max_heap.empty()) {\n\t\tresult.push_back({max_heap.top()[1], max_heap.top()[2]});\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while(k-- > 0 && !max_heap.empty()) {\n        std::vector<long> current = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[current[0]], nums2[current[1]]});\n        if(current[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{current[0] + 1, current[1]});\n        }\n        if(current[0] == 0 && current[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{current[0], current[1] + 1});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for(long i = 0; i < k; i++) {\n        if(max_heap.empty()) {\n            break;\n        }\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k--) {\n        if(pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n\t\treturn result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tpq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) return result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    for(int i = 0; i < k && !max_heap.empty(); i++) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); ++i) {\n\t\tfor (long j = 0; j < nums2.size(); ++j) {\n\t\t\tpq.push({nums1[i] + nums2[j], {i, j}});\n\t\t}\n\t}\n\twhile (k--) {\n\t\tif (pq.empty()) {\n\t\t\tbreak;\n\t\t}\n\t\tauto temp = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) return result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn result;",
    "\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n\t\t}\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tresult.push_back({pq.top().second.first, pq.top().second.second});\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    for(long i = 0; i < k; i++) {\n        if(pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty())\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b){\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n            if(pq.size() > k)\n                pq.pop();\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push({num1, num2});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push({num1, num2});\n            if (pq.size() > k) pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    pq.push({nums1[0] + nums2[0], {0, 0}});\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        if (top.second.second == 0 && top.second.first + 1 < nums1.size()) {\n            pq.push({nums1[top.second.first + 1] + nums2[top.second.second], {top.second.first + 1, top.second.second}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!max_heap.empty() && k-- > 0) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({temp.second.first, temp.second.second});\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(!pq.empty() && k > 0) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back(std::vector<long>{nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.empty() || nums2.empty()) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n    }\n  }\n  while (k-- && !pq.empty()) {\n    result.push_back({pq.top().second.first, pq.top().second.second});\n    pq.pop();\n  }\n  return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k > 0 && !pq.empty()) {\n\t\tauto temp = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n\t\tif (temp.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[temp.second.first] + nums2[temp.second.second + 1], {temp.second.first, temp.second.second + 1}});\n\t\t}\n\t\tk--;\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(!max_heap.empty() && k--) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n  for (long i = 0; i < nums1.size(); i++) {\n    max_heap.push({nums1[i] + nums2[0], {i, 0}});\n  }\n  while (k-- > 0 && !max_heap.empty()) {\n    auto top = max_heap.top();\n    max_heap.pop();\n    result.push_back({nums1[top.second.first], nums2[top.second.second]});\n    if (top.second.second + 1 < nums2.size()) {\n      max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n    }\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size() && i < k; i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto idx_pair = max_heap.top().second;\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[idx_pair.first], nums2[idx_pair.second]});\n        if (idx_pair.second + 1 < nums2.size()) {\n            max_heap.push({nums1[idx_pair.first] + nums2[idx_pair.second + 1], {idx_pair.first, idx_pair.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto num : nums1) {\n        max_heap.push({num, nums2[0], 0});\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({top[0], top[1]});\n        if(top[2] == nums2.size() - 1) {\n            continue;\n        }\n        max_heap.push({top[0], nums2[top[2] + 1], top[2] + 1});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top[1], top[2]});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> pair = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i] + nums2[j], {i, j}});\n    }\n  }\n  while (k--) {\n    if (pq.empty()) {\n      break;\n    }\n    auto p = pq.top();\n    pq.pop();\n    result.push_back({nums1[p.second.first], nums2[p.second.second]});\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n\t\treturn result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (int i = 0; i < nums1.size(); i++) {\n\t\tfor (int j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); ++i) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[p.second.first], nums2[p.second.second]});\n\t\tif (p.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(!pq.empty() && k > 0) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push({num1, num2});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.emplace(std::vector<long>{i, j});\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.emplace_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size() && i < k; i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i], nums2[0], 0});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top[0], top[1]});\n        if (top[2] + 1 < nums2.size()) {\n            pq.push({top[0], nums2[top[2] + 1], top[2] + 1});\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            min_heap.push({i, j});\n        }\n    }\n    while (k-- && !min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (max_heap.empty()) {\n            break;\n        }\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i], nums2[0], 0});\n    }\n    while (!pq.empty() && k-- > 0) {\n        auto [x, y, index] = pq.top();\n        pq.pop();\n        result.push_back({x, y});\n        if (index + 1 < nums2.size()) {\n            pq.push({x, nums2[index + 1], index + 1});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tif (max_heap.size() < k) {\n\t\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t\t} else {\n\t\t\t\tif (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n\t\t\t\t\tmax_heap.pop();\n\t\t\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k--) {\n        if (!pq.empty()) {\n            result.push_back(pq.top());\n            pq.pop();\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); ++i) {\n\t\tfor (long j = 0; j < nums2.size(); ++j) {\n\t\t\tpq.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i = 0; i < nums1.size(); i++) {\n        for (auto j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for (long i = 0; i < k && !max_heap.empty(); i++) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (!max_heap.empty() && k--) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::vector<std::vector<long>> heap;\n    std::vector<long> first_pair = {nums1[0] + nums2[0], 0, 0};\n    heap.push_back(first_pair);\n    std::unordered_set<std::string> visited;\n    visited.insert(\"0-0\");\n    for (long i = 0; i < k && heap.size() > 0; i++) {\n        std::vector<long> current_pair = heap[0];\n        result.push_back({nums1[current_pair[1]], nums2[current_pair[2]]});\n        if (current_pair[1] + 1 < nums1.size() && visited.find(std::to_string(current_pair[1] + 1) + \"-\" + std::to_string(current_pair[2])) == visited.end()) {\n            visited.insert(std::to_string(current_pair[1] + 1) + \"-\" + std::to_string(current_pair[2]));\n            heap.push_back({nums1[current_pair[1] + 1] + nums2[current_pair[2]], current_pair[1] + 1, current_pair[2]});\n        }\n        if (current_pair[2] + 1 < nums2.size() && visited.find(std::to_string(current_pair[1]) + \"-\" + std::to_string(current_pair[2] + 1)) == visited.end()) {\n            visited.insert(std::to_string(current_pair[1]) + \"-\" + std::to_string(current_pair[2] + 1));\n            heap.push_back({nums1[current_pair[1]] + nums2[current_pair[2] + 1], current_pair[1], current_pair[2] + 1});\n        }\n        std::pop_heap(heap.begin",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while(!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({top.second.first, top.second.second});\n        k--;\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n  }\n  while (k-- > 0 && !pq.empty()) {\n    std::pair<long, std::pair<long, long>> p = pq.top();\n    pq.pop();\n    result.push_back({nums1[p.second.first], nums2[p.second.second]});\n    if (p.second.second + 1 < nums2.size()) {\n      pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n    }\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second < nums2.size() - 1) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k-- > 0 && !pq.empty()) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push({num1, num2});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tmax_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tstd::pair<long, std::pair<long, long>> temp = max_heap.top();\n\t\tmax_heap.pop();\n\t\tresult.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n\t\tif (temp.second.second + 1 < nums2.size()) {\n\t\t\tmax_heap.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n\t\t}\n\t}\n\treturn result;",
    "\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (auto i : nums1) {\n\t\tfor (auto j : nums2) {\n\t\t\tmax_heap.push({ i,j });\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return (a[0] + a[1]) > (b[0] + b[1]);\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;"
  ]
}