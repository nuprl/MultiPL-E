{
  "name": "mbpp_463_max_subarray_product",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here)\n      max_so_far = max_ending_here;\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n\tlong max_ending_here = 1;\n\tlong min_ending_here = 1;\n\tlong max_so_far = 1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tmax_ending_here = max_ending_here * arr[i];\n\t\t\tmin_ending_here = std::min(min_ending_here * arr[i], 1);\n\t\t} else if (arr[i] == 0) {\n\t\t\tmax_ending_here = 1;\n\t\t\tmin_ending_here = 1;\n\t\t} else {\n\t\t\tlong temp = max_ending_here;\n\t\t\tmax_ending_here = std::max(min_ending_here * arr[i], 1);\n\t\t\tmin_ending_here = temp * arr[i];\n\t\t}\n\t\tif (max_so_far < max_ending_here) {\n\t\t\tmax_so_far = max_ending_here;\n\t\t}\n\t}\n\treturn max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpwvc3qfqq.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpwvc3qfqq.cpp:11:58: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |    min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpwvc3qfqq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpwvc3qfqq.cpp:11:58: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |    min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpwvc3qfqq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1);\n        } else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1);\n            min_product = temp * arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpj7xcc4s7.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpj7xcc4s7.cpp:11:59: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_product = std::min(min_product * arr[i], 1);\n      |                                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpj7xcc4s7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpj7xcc4s7.cpp:11:59: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_product = std::min(min_product * arr[i], 1);\n      |                                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpj7xcc4s7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution fai",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here*arr[i];\n            min_ending_here = std::min(min_ending_here*arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here*arr[i], 1L);\n            min_ending_here = temp*arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmplha0t9f6.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmplha0t9f6.cpp:11:57: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmplha0t9f6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmplha0t9f6.cpp:11:57: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmplha0t9f6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_product = 1;\n  long min_product = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_product = max_product * arr[i];\n      min_product = std::min(min_product * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_product = 1;\n      min_product = 1;\n    } else {\n      long temp = max_product;\n      max_product = std::max(min_product * arr[i], 1L);\n      min_product = temp * arr[i];\n    }\n    if (max_so_far < max_product) {\n      max_so_far = max_product;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpgq9rmxhj.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpgq9rmxhj.cpp:11:57: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpgq9rmxhj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpgq9rmxhj.cpp:11:57: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpgq9rmxhj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n\tlong max_so_far = 1;\n\tlong min_so_far = 1;\n\tlong max_product = 1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tmax_so_far = max_so_far * arr[i];\n\t\t\tmin_so_far = std::min(min_so_far * arr[i], 1L);\n\t\t} else if (arr[i] == 0) {\n\t\t\tmax_so_far = 1;\n\t\t\tmin_so_far = 1;\n\t\t} else {\n\t\t\tlong temp = max_so_far;\n\t\t\tmax_so_far = std::max(min_so_far * arr[i], 1L);\n\t\t\tmin_so_far = temp * arr[i];\n\t\t}\n\t\tif (max_product < max_so_far) {\n\t\t\tmax_product = max_so_far;\n\t\t}\n\t}\n\treturn max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n        if (min_so_far > min_ending_here) {\n            min_so_far = min_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmppt3hxth7.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmppt3hxth7.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmppt3hxth7.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n\tlong max_product = 1;\n\tlong min_product = 1;\n\tlong max_so_far = 1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tmax_product = max_product * arr[i];\n\t\t\tmin_product = std::min(min_product * arr[i], 1L);\n\t\t} else if (arr[i] == 0) {\n\t\t\tmax_product = 1;\n\t\t\tmin_product = 1;\n\t\t} else {\n\t\t\tlong temp = max_product;\n\t\t\tmax_product = std::max(min_product * arr[i], 1L);\n\t\t\tmin_product = temp * arr[i];\n\t\t}\n\t\tif (max_so_far < max_product) {\n\t\t\tmax_so_far = max_product;\n\t\t}\n\t}\n\treturn max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if (max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_product = arr[0];\n  long min_product = arr[0];\n  long max_so_far = arr[0];\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] < 0) {\n      std::swap(max_product, min_product);\n    }\n    max_product = std::max(arr[i], max_product * arr[i]);\n    min_product = std::min(arr[i], min_product * arr[i]);\n    max_so_far = std::max(max_so_far, max_product);\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmp_keyyrr0.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmp_keyyrr0.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp_keyyrr0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp_keyyrr0.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp_keyyrr0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        }\n        else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1);\n            min_product = temp * arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmpr22lo7cc.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpr22lo7cc.cpp:11:59: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_product = std::min(min_product * arr[i], 1);\n      |                                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpr22lo7cc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpr22lo7cc.cpp:11:59: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_product = std::min(min_product * arr[i], 1);\n      |                                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpr22lo7cc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution fai",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here*arr[i];\n            min_ending_here = std::min(min_ending_here*arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here*arr[i], 1L);\n            min_ending_here = temp*arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i=0; i<arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1, min_so_far = 1, max_end_here = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_end_here = max_end_here * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_end_here = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_end_here;\n            max_end_here = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far < max_end_here)\n            max_so_far = max_end_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++) {\n        if(arr[i] > 0) {\n            max_product = max_product*arr[i];\n            min_product = std::min(min_product*arr[i],1);\n        }\n        else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        }\n        else {\n            long temp = max_product;\n            max_product = std::max(min_product*arr[i],1);\n            min_product = temp*arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmpmo6g3geo.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpmo6g3geo.cpp:11:56: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_product = std::min(min_product*arr[i],1);\n      |                                                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpmo6g3geo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpmo6g3geo.cpp:11:56: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_product = std::min(min_product*arr[i],1);\n      |                                                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpmo6g3geo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1);\n            min_so_far = temp * arr[i];\n        }\n        if (max_product < max_so_far) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmp7b3lfqgd.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmp7b3lfqgd.cpp:11:57: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp7b3lfqgd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp7b3lfqgd.cpp:11:57: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp7b3lfqgd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long result = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long curr_max = max_product;\n        long curr_min = min_product;\n        max_product = std::max(std::max(curr_max * arr[i], curr_min * arr[i]), arr[i]);\n        min_product = std::min(std::min(curr_max * arr[i], curr_min * arr[i]), arr[i]);\n        result = std::max(result, max_product);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n        if (min_so_far > min_ending_here) {\n            min_so_far = min_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if (max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long result = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        result = std::max(result, max_product);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0], max_ending_here = arr[0], min_ending_here = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_ending_here, min_ending_here);\n        }\n        max_ending_here = std::max(arr[i], max_ending_here * arr[i]);\n        min_ending_here = std::min(arr[i], min_ending_here * arr[i]);\n        max_so_far = std::max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmppt3hxth7.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmppt3hxth7.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmppt3hxth7.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long res = INT_MIN;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1l);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1l);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_ending_here = arr[0];\n    long min_ending_here = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        max_ending_here = std::max(std::max(max_ending_here * arr[i], min_ending_here * arr[i]), arr[i]);\n        min_ending_here = std::min(std::min(max_ending_here * arr[i], min_ending_here * arr[i]), arr[i]);\n        max_product = std::max(max_product, max_ending_here);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "tmpb83_iduh: /tmp/tmpb83_iduh.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_ending_here = 1;\n    long flag = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here*arr[i];\n            min_so_far = std::min(min_so_far*arr[i], 1);\n            flag = 1;\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_so_far*arr[i], 1);\n            min_so_far = temp*arr[i];\n            if(max_ending_here == 1) {\n                flag = 0;\n            }\n        }\n        if(flag == 1) {\n            max_so_far = std::max(max_so_far, max_ending_here);\n        }\n    }\n    if(max_so_far == 1) {\n        return 0;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmp9b5kxxjq.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmp9b5kxxjq.cpp:12:55: error: no matching function for call to \u2018min(long int, int)\u2019\n   12 |             min_so_far = std::min(min_so_far*arr[i], 1);\n      |                                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp9b5kxxjq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp9b5kxxjq.cpp:12:55: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   12 |             min_so_far = std::min(min_so_far*arr[i], 1);\n      |                                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp9b5kxxjq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmp9b5",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here *= arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long result = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        result = std::max(result, max_product);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_so_far = 1;\n  long min_so_far = 1;\n  long max_product = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1);\n    } else if (arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    } else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1);\n      min_so_far = temp * arr[i];\n    }\n    if (max_product < max_so_far) {\n      max_product = max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmpgrdcui5m.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpgrdcui5m.cpp:11:51: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |       min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpgrdcui5m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpgrdcui5m.cpp:11:51: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |       min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpgrdcui5m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmpgrdcui5m.cpp:11:51:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    long flag = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n            flag = 1;\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    if(flag == 0 && max_so_far == 1) {\n        return 0;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++) {\n        if(arr[i]>0) {\n            max_ending_here = max_ending_here*arr[i];\n            min_ending_here = std::min(min_ending_here*arr[i],1L);\n        }\n        else if(arr[i]==0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here*arr[i],1L);\n            min_ending_here = temp*arr[i];\n        }\n        if(max_so_far<max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here)\n      max_so_far = max_ending_here;\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i=0;i<arr.size();i++) {\n        if(arr[i]>0) {\n            max_so_far = max_so_far*arr[i];\n            min_so_far = std::min(min_so_far*arr[i],1);\n        }\n        else if(arr[i]==0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far*arr[i],1);\n            min_so_far = temp*arr[i];\n        }\n        if(max_product<max_so_far) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmp6gjerd0i.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmp6gjerd0i.cpp:11:54: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp6gjerd0i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp6gjerd0i.cpp:11:54: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp6gjerd0i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmp6gjerd0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmpko_b13sp.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpko_b13sp.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpko_b13sp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpko_b13sp.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpko_b13sp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long temp = max_product;\n        max_product = std::max(std::max(max_product*arr[i], min_product*arr[i]), arr[i]);\n        min_product = std::min(std::min(temp*arr[i], min_product*arr[i]), arr[i]);\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long result = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        result = std::max(result, max_product);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmpbjeuo4j5.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpbjeuo4j5.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpbjeuo4j5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpbjeuo4j5.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpbjeuo4j5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_product = arr[0];\n  long min_product = arr[0];\n  long max_so_far = arr[0];\n  for(int i = 1; i < arr.size(); i++) {\n    if(arr[i] < 0) {\n      std::swap(max_product, min_product);\n    }\n    max_product = std::max(arr[i], max_product * arr[i]);\n    min_product = std::min(arr[i], min_product * arr[i]);\n    max_so_far = std::max(max_so_far, max_product);\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long temp = max_product;\n        max_product = std::max(std::max(max_product * arr[i], min_product * arr[i]), arr[i]);\n        min_product = std::min(std::min(temp * arr[i], min_product * arr[i]), arr[i]);\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_ending_here = arr[0];\n    long min_ending_here = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = std::max(arr[i], max_ending_here * arr[i]);\n            min_ending_here = std::min(arr[i], min_ending_here * arr[i]);\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(arr[i], min_ending_here * arr[i]);\n            min_ending_here = std::min(arr[i], temp * arr[i]);\n        }\n        max_product = std::max(max_product, max_ending_here);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here)\n      max_so_far = max_ending_here;\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmpp3wt_rin.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpp3wt_rin.cpp:11:57: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpp3wt_rin.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpp3wt_rin.cpp:11:57: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpp3wt_rin.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmp1zq190b7.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmp1zq190b7.cpp:11:61: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |       min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp1zq190b7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp1zq190b7.cpp:11:61: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |       min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp1zq190b7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far*arr[i]);\n        min_so_far = std::min(arr[i], min_so_far*arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here*arr[i];\n            min_ending_here = std::min(min_ending_here*arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here*arr[i], 1);\n            min_ending_here = temp*arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "/tmp/tmp1rstpyb2.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmp1rstpyb2.cpp:11:65: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here*arr[i], 1);\n      |                                                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp1rstpyb2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp1rstpyb2.cpp:11:65: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here*arr[i], 1);\n      |                                                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp1rstpyb2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument de",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if(max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long temp = max_so_far;\n        max_so_far = std::max(std::max(arr[i]*max_so_far, arr[i]*min_so_far), arr[i]);\n        min_so_far = std::min(std::min(arr[i]*temp, arr[i]*min_so_far), arr[i]);\n        max_product = std::max(max_so_far, max_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_product = arr[0];\n  long min_product = arr[0];\n  long max_so_far = arr[0];\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] < 0) {\n      std::swap(max_product, min_product);\n    }\n    max_product = std::max(arr[i], max_product * arr[i]);\n    min_product = std::min(arr[i], min_product * arr[i]);\n    max_so_far = std::max(max_so_far, max_product);\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here)\n      max_so_far = max_ending_here;\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here*arr[i];\n            min_ending_here = std::min(min_ending_here*arr[i], 1);\n        }\n        else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here*arr[i], 1);\n            min_ending_here = temp*arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "/tmp/tmpvykmjqps.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpvykmjqps.cpp:11:65: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here*arr[i], 1);\n      |                                                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpvykmjqps.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpvykmjqps.cpp:11:65: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here*arr[i], 1);\n      |                                                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpvykmjqps.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument de",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "/tmp/tmpp3wt_rin.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpp3wt_rin.cpp:11:57: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpp3wt_rin.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpp3wt_rin.cpp:11:57: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpp3wt_rin.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_ending_here = 1;\n  long min_ending_here = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_ending_here = max_ending_here * arr[i];\n      min_ending_here = std::min(min_ending_here * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_ending_here = 1;\n      min_ending_here = 1;\n    } else {\n      long temp = max_ending_here;\n      max_ending_here = std::max(min_ending_here * arr[i], 1L);\n      min_ending_here = temp * arr[i];\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here;\n    }\n  }\n  return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        long temp = max_product;\n        max_product = std::max(std::max(max_product * arr[i], min_product * arr[i]), arr[i]);\n        min_product = std::min(std::min(temp * arr[i], min_product * arr[i]), arr[i]);\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_ending_here = arr[0];\n    long min_ending_here = arr[0];\n    long max_product = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = std::max(arr[i], max_ending_here * arr[i]);\n            min_ending_here = std::min(arr[i], min_ending_here * arr[i]);\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(arr[i], min_ending_here * arr[i]);\n            min_ending_here = std::min(arr[i], temp * arr[i]);\n        }\n        max_product = std::max(max_product, max_ending_here);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "/tmp/tmpd0dhdsqp.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpd0dhdsqp.cpp:13:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   13 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpd0dhdsqp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpd0dhdsqp.cpp:13:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   13 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpd0dhdsqp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long temp = max_so_far;\n        max_so_far = std::max(std::max(max_so_far * arr[i], min_so_far * arr[i]), arr[i]);\n        min_so_far = std::min(std::min(temp * arr[i], min_so_far * arr[i]), arr[i]);\n        max_product = std::max(max_so_far, max_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n        if (min_so_far > min_ending_here) {\n            min_so_far = min_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long result = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        result = std::max(result, max_product);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i=0;i<arr.size();i++) {\n        if(arr[i]>0) {\n            max_so_far = max_so_far*arr[i];\n            min_so_far = std::min(min_so_far*arr[i],1);\n        } else if(arr[i]==0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far*arr[i],1);\n            min_so_far = temp*arr[i];\n        }\n        if(max_so_far>max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "/tmp/tmpnctnc_cg.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpnctnc_cg.cpp:11:54: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpnctnc_cg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpnctnc_cg.cpp:11:54: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpnctnc_cg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmpnctnc_c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmppt3hxth7.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmppt3hxth7.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmppt3hxth7.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long result = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        result = std::max(result, max_so_far);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_ending_here = 1;\n    long flag = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here*arr[i];\n            min_so_far = std::min(min_so_far*arr[i], 1);\n            flag = 1;\n        } else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_so_far*arr[i], 1);\n            min_so_far = temp*arr[i];\n            if(max_ending_here == 1) {\n                flag = 0;\n            }\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    if(flag == 0 && max_so_far == 1) {\n        return 0;\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "/tmp/tmp9g7stxm9.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmp9g7stxm9.cpp:12:55: error: no matching function for call to \u2018min(long int, int)\u2019\n   12 |             min_so_far = std::min(min_so_far*arr[i], 1);\n      |                                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp9g7stxm9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp9g7stxm9.cpp:12:55: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   12 |             min_so_far = std::min(min_so_far*arr[i], 1);\n      |                                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp9g7stxm9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmp9g7",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_prod = arr[0];\n    long min_prod = arr[0];\n    long result = arr[0];\n    for(int i=1;i<arr.size();i++) {\n        if(arr[i] < 0) {\n            std::swap(max_prod, min_prod);\n        }\n        max_prod = std::max(arr[i], max_prod*arr[i]);\n        min_prod = std::min(arr[i], min_prod*arr[i]);\n        result = std::max(result, max_prod);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if (max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123130,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n\tlong max_ending_here = 1;\n\tlong min_ending_here = 1;\n\tlong max_so_far = 1;\n\tfor(int i = 0; i < arr.size(); i++) {\n\t\tif(arr[i] > 0) {\n\t\t\tmax_ending_here = max_ending_here * arr[i];\n\t\t\tmin_ending_here = std::min(min_ending_here * arr[i], 1);\n\t\t}\n\t\telse if(arr[i] == 0) {\n\t\t\tmax_ending_here = 1;\n\t\t\tmin_ending_here = 1;\n\t\t}\n\t\telse {\n\t\t\tlong temp = max_ending_here;\n\t\t\tmax_ending_here = std::max(min_ending_here * arr[i], 1);\n\t\t\tmin_ending_here = temp * arr[i];\n\t\t}\n\t\tif(max_so_far < max_ending_here) {\n\t\t\tmax_so_far = max_ending_here;\n\t\t}\n\t}\n\treturn max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "/tmp/tmpo38lw5h3.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpo38lw5h3.cpp:11:58: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |    min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpo38lw5h3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpo38lw5h3.cpp:11:58: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |    min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpo38lw5h3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_product, min_product);\n        }\n        max_product = std::max(arr[i], max_product * arr[i]);\n        min_product = std::min(arr[i], min_product * arr[i]);\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n  long max_so_far = arr[0];\n  long min_so_far = arr[0];\n  long max_product = arr[0];\n  for(int i = 1; i < arr.size(); i++) {\n    if(arr[i] < 0) {\n      std::swap(max_so_far, min_so_far);\n    }\n    max_so_far = std::max(arr[i], max_so_far * arr[i]);\n    min_so_far = std::min(arr[i], min_so_far * arr[i]);\n    max_product = std::max(max_product, max_so_far);\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123133,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] < 0) {\n            std::swap(max_so_far, min_so_far);\n        }\n        max_so_far = std::max(arr[i], max_so_far * arr[i]);\n        min_so_far = std::min(arr[i], min_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123131,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510256,
      "stdout": "",
      "stderr": "/tmp/tmpatwnbx6o.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmpatwnbx6o.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpatwnbx6o.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpatwnbx6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_so_far = 1;\n    long min_so_far = 1;\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if(max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1666123129,
      "stdout": "",
      "stderr": "/tmp/tmppt3hxth7.cpp: In function \u2018long int max_subarray_product(std::vector<long int>)\u2019:\n/tmp/tmppt3hxth7.cpp:11:67: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmppt3hxth7.cpp:11:67: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_ending_here = std::min(min_ending_here * arr[i], 1);\n      |                                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmppt3hxth7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template arg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subarray of the given array.\nlong max_subarray_product(std::vector<long> arr) {\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = std::min(min_ending_here * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], 1L);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n",
      "timestamp": 1665510257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}