{
  "name": "mbpp_301_dict_depth",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the depth of a dictionary.\nlong dict_depth(std::any d) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = dict_depth;\n    assert(candidate((std::any({{\"a\", 1}, {\"b\", std::map<std::string,std::map<std::string,std::map<long,long>>>({{\"c\", std::map<std::string,std::map<long,long>>({{\"d\", std::map<long,long>()}})}})}}))) == (4));\n    assert(candidate((std::any({{\"a\", 1}, {\"b\", std::map<std::string,std::string>({{\"c\", \"python\"}})}}))) == (2));\n    assert(candidate((std::any({{1, \"Sun\"}, {2, std::map<long,std::map<long,std::string>>({{3, std::any({{4, \"Mon\"}})}})}}))) == (3));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    if (d.type() != typeid(std::map<std::string, std::any>)) {\n        return 0;\n    }\n    long max_depth = 0;\n    for (auto &[key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;",
    "    long depth = 0;\n    if(d.type() == typeid(std::map<std::string, std::any>)) {\n        std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(d);\n        for(auto it = m.begin(); it != m.end(); it++) {\n            depth = std::max(depth, dict_depth(it->second));\n        }\n        return depth + 1;\n    }\n    return 0;",
    "    long depth = 0;\n    if (d.type() == typeid(std::map<std::string, std::any>)) {\n        for (auto &it : std::any_cast<std::map<std::string, std::any>>(d)) {\n            depth = std::max(depth, dict_depth(it.second));\n        }\n        return depth + 1;\n    } else {\n        return 0;\n    }",
    "    if (d.type() != typeid(std::map<std::string, std::any>)) {\n        return 0;\n    }\n    long max_depth = 0;\n    for (auto& [key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;",
    "    if(d.type() == typeid(std::map<std::string, std::any>)){\n        std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(d);\n        long max = 0;\n        for(auto it = m.begin(); it != m.end(); it++){\n            long depth = dict_depth(it->second);\n            if(depth > max)\n                max = depth;\n        }\n        return max + 1;\n    }\n    else\n        return 0;",
    "    // your code here\n    return 0;",
    "    // your code here\n    long depth = 0;\n    if(d.type() == typeid(std::map<std::string, std::any>)){\n        std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(d);\n        for(auto it = m.begin(); it != m.end(); ++it){\n            if(it->second.type() == typeid(std::map<std::string, std::any>)){\n                depth = std::max(depth, dict_depth(it->second));\n            }\n        }\n        return depth + 1;\n    }\n    return depth;",
    "    // your code here\n    long depth = 0;\n    std::any temp = d;\n    while(temp.type() == typeid(std::map<std::string, std::any>)) {\n        depth++;\n        temp = temp.any_cast<std::map<std::string, std::any>>().begin()->second;\n    }\n    return depth;",
    "    // your code here\n    long depth = 0;\n    if(d.type() == typeid(std::map<std::string, std::any>)){\n        std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(d);\n        for(auto i : m){\n            depth = std::max(depth, dict_depth(i.second));\n        }\n        return depth + 1;\n    }\n    else{\n        return 0;\n    }",
    "    if (d.type() != typeid(std::map<std::string, std::any>)) {\n        return 0;\n    }\n    long max_depth = 0;\n    for (auto& [key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;",
    "    if (d.type() != typeid(std::map<std::string, std::any>)) {\n        return 0;\n    }\n    long max_depth = 0;\n    for (auto& [key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;",
    "    if (d.type() != typeid(std::map<std::string, std::any>)) {\n        return 0;\n    }\n    std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(d);\n    long max_depth = 0;\n    for (auto it = m.begin(); it != m.end(); ++it) {\n        long depth = dict_depth(it->second);\n        if (depth > max_depth) {\n            max_depth = depth;\n        }\n    }\n    return max_depth + 1;",
    "    if (!d.has_value()) {\n        return 0;\n    }\n    if (d.type() == typeid(int)) {\n        return 1;\n    }\n    long max_depth = 0;\n    for (auto& [key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;",
    "    if (d.type() != typeid(std::map<std::string, std::any>))\n        return 0;\n    long max_depth = 0;\n    for (auto& [key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;",
    "    long depth = 0;\n    if (d.type() == typeid(std::map<std::string, std::any>)) {\n        for (auto &it : std::any_cast<std::map<std::string, std::any>>(d)) {\n            depth = std::max(depth, dict_depth(it.second));\n        }\n        return depth + 1;\n    }\n    return 0;",
    "    if(d.type() != typeid(std::map<std::string, std::any>))\n        return 0;\n    std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(d);\n    long max = 0;\n    for(auto it = m.begin(); it != m.end(); it++) {\n        long depth = dict_depth(it->second);\n        if(depth > max)\n            max = depth;\n    }\n    return max + 1;",
    "    if (d.type() != typeid(std::map<std::string, std::any>))\n        return 0;\n    long max_depth = 0;\n    for (auto& [key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;",
    "    // your code here\n    long depth = 0;\n    if(d.type() == typeid(std::map<std::string, std::any>)){\n        std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(d);\n        for(auto it = m.begin(); it != m.end(); it++){\n            depth = std::max(depth, dict_depth(it->second));\n        }\n        return depth + 1;\n    }\n    return depth;",
    "    if (d.type() != typeid(std::map<std::any, std::any>)) {\n        return 0;\n    }\n    std::map<std::any, std::any> m = std::any_cast<std::map<std::any, std::any>>(d);\n    long max_depth = 0;\n    for (auto it = m.begin(); it != m.end(); it++) {\n        max_depth = std::max(max_depth, dict_depth(it->second));\n    }\n    return max_depth + 1;",
    "    if (d.type() != typeid(std::map<std::string, std::any>)) {\n        return 0;\n    }\n    long max_depth = 0;\n    for (auto& [key, value] : std::any_cast<std::map<std::string, std::any>>(d)) {\n        max_depth = std::max(max_depth, dict_depth(value));\n    }\n    return max_depth + 1;"
  ]
}