{
  "name": "mbpp_468_max_product",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long max_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far, max_so_far * arr[i]);\n        max_prod = std::max(max_prod, max_so_far);\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpj68kx9eg: /tmp/tmpj68kx9eg.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if (max_product < max_so_far) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpl2i4k3oj: /tmp/tmpl2i4k3oj.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long prev_max_product = 1;\n    long prev_min_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_product = std::max(max_product, prev_max_product * arr[i]);\n            prev_max_product = prev_max_product * arr[i];\n            prev_min_product = prev_min_product * arr[i];\n        } else if (arr[i] < 0) {\n            long temp = prev_max_product;\n            prev_max_product = std::max(prev_min_product * arr[i], 1L);\n            prev_min_product = temp * arr[i];\n        } else {\n            prev_max_product = 1;\n            prev_min_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmps_4fcqbw: /tmp/tmps_4fcqbw.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpgp4in6d4: /tmp/tmpgp4in6d4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpos_a5eh5: /tmp/tmpos_a5eh5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpgp4in6d4: /tmp/tmpgp4in6d4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_prod(arr.size(), 0);\n    max_prod[0] = arr[0];\n    for(int i=1; i<arr.size(); i++) {\n        max_prod[i] = arr[i];\n        for(int j=0; j<i; j++) {\n            if(arr[j] < arr[i]) {\n                max_prod[i] = std::max(max_prod[i], max_prod[j]*arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_prod.begin(), max_prod.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpdr9_drt2: /tmp/tmpdr9_drt2.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpdzavcvzw: /tmp/tmpdzavcvzw.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpld0rf4vz: /tmp/tmpld0rf4vz.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long curr_product = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] > arr[i - 1]) {\n            curr_product *= arr[i];\n        } else {\n            max_product = std::max(max_product, curr_product);\n            curr_product = arr[i];\n        }\n    }\n    return std::max(max_product, curr_product);\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else if(arr[i] == 0) {\n            curr_prod = 1;\n        } else {\n            curr_prod = 1;\n            for(int j = i; j < arr.size(); j++) {\n                if(arr[j] < 0) {\n                    curr_prod *= arr[j];\n                } else {\n                    break;\n                }\n            }\n            max_prod = std::max(max_prod, curr_prod);\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpvs_ocn_p: /tmp/tmpvs_ocn_p.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpsgxtdv9q: /tmp/tmpsgxtdv9q.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpvj8ybufl: /tmp/tmpvj8ybufl.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpvj8ybufl: /tmp/tmpvj8ybufl.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmp2c3cbhaw: /tmp/tmp2c3cbhaw.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  long min_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1);\n    } else if (arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    } else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1);\n      min_so_far = temp * arr[i];\n    }\n    if (max_so_far > max_product) {\n      max_product = max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "/tmp/tmp7tt6_4zb.cpp: In function \u2018long int max_product(std::vector<long int>)\u2019:\n/tmp/tmp7tt6_4zb.cpp:11:51: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |       min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp7tt6_4zb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp7tt6_4zb.cpp:11:51: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |       min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp7tt6_4zb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmp7tt6_4zb.cpp:11:51: note:   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpe5s2pxh6: /tmp/tmpe5s2pxh6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpdpjpvyig: /tmp/tmpdpjpvyig.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max = arr[0];\n    long product = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] > max) {\n            max = arr[i];\n            product *= max;\n        }\n    }\n    return product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpbfv64snf: /tmp/tmpbfv64snf.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpe5s2pxh6: /tmp/tmpe5s2pxh6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > max_so_far) {\n            max_so_far = arr[i];\n            max_product = max_product * max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpbjlc6dnn: /tmp/tmpbjlc6dnn.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "/tmp/tmp8p_ai_fc.cpp: In function \u2018long int max_product(std::vector<long int>)\u2019:\n/tmp/tmp8p_ai_fc.cpp:11:57: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp8p_ai_fc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp8p_ai_fc.cpp:11:57: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp8p_ai_fc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmp8p_a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpsgxtdv9q: /tmp/tmpsgxtdv9q.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if (product > max_product) {\n            max_product = product;\n        }\n        if (product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp4u3g219n: /tmp/tmp4u3g219n.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp0dl7xlfu: /tmp/tmp0dl7xlfu.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            current_product *= arr[i];\n            max_product = std::max(max_product, current_product);\n        } else {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp1e7ymso9: /tmp/tmp1e7ymso9.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpfnxdeexc: /tmp/tmpfnxdeexc.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > max_so_far) {\n            max_so_far = arr[i];\n            max_product = max_product * max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpu6f2le1s: /tmp/tmpu6f2le1s.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpdzavcvzw: /tmp/tmpdzavcvzw.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_product_so_far = std::max(max_product_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_product_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpqauzrlvm: /tmp/tmpqauzrlvm.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    curr_prod = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpw92moegb: /tmp/tmpw92moegb.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    std::vector<long> dp(n, 0);\n    dp[0] = arr[0];\n    for(int i = 1; i < n; i++) {\n        dp[i] = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpahp8y17v: /tmp/tmpahp8y17v.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmp2c3cbhaw: /tmp/tmp2c3cbhaw.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_prod = std::max(max_prod, max_so_far);\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpi2lp8u60: /tmp/tmpi2lp8u60.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for (long i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpmk_dv2ut: /tmp/tmpmk_dv2ut.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if(current_product > max_product) {\n            max_product = current_product;\n        }\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpgso4ty3y: /tmp/tmpgso4ty3y.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i=0; i<arr.size(); i++) {\n        max_product_so_far = max_product_so_far * arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpzs3uu3nx: /tmp/tmpzs3uu3nx.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product){\n            max_product = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp89kxo8wh: /tmp/tmp89kxo8wh.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if(current_product > max_product) {\n            max_product = current_product;\n        }\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpgso4ty3y: /tmp/tmpgso4ty3y.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> dp(arr.size(), 1);\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, dp[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpg9uc9f25: /tmp/tmpg9uc9f25.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpsgxtdv9q: /tmp/tmpsgxtdv9q.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp5xiwuewb: /tmp/tmp5xiwuewb.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n  long max_prod = 1;\n  long curr_prod = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    curr_prod *= arr[i];\n    if (curr_prod > max_prod) {\n      max_prod = curr_prod;\n    }\n    if (curr_prod == 0) {\n      curr_prod = 1;\n    }\n  }\n  curr_prod = 1;\n  for (int i = arr.size() - 1; i >= 0; i--) {\n    curr_prod *= arr[i];\n    if (curr_prod > max_prod) {\n      max_prod = curr_prod;\n    }\n    if (curr_prod == 0) {\n      curr_prod = 1;\n    }\n  }\n  return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmphf2bes3l: /tmp/tmphf2bes3l.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long n = arr.size();\n    std::vector<long> dp(n,1);\n    for(long i = 1; i < n; i++) {\n        for(long j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                dp[i] = std::max(dp[i], dp[j]*arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpys0grfy5: /tmp/tmpys0grfy5.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if(arr[i] == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if(arr[i] == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpse9y4j80: /tmp/tmpse9y4j80.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp0gtggvz2: /tmp/tmp0gtggvz2.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if (product > max_product) {\n            max_product = product;\n        }\n        if (product == 0) {\n            product = 1;\n        }\n    }\n    product = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        product *= arr[i];\n        if (product > max_product) {\n            max_product = product;\n        }\n        if (product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpw593ihz8: /tmp/tmpw593ihz8.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long min_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_product = max_product * arr[i];\n            min_product = std::min(min_product * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_product = 1;\n            min_product = 1;\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], 1L);\n            min_product = temp * arr[i];\n        }\n        if (max_so_far < max_product) {\n            max_so_far = max_product;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp99h8jds0: /tmp/tmp99h8jds0.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpgxy5oivh: /tmp/tmpgxy5oivh.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_product_so_far *= arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpntyxoa2n: /tmp/tmpntyxoa2n.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i=0;i<arr.size();i++) {\n        max_product_so_far *= arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpdt_juazu: /tmp/tmpdt_juazu.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_till_now = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_till_now *= arr[i];\n        if(max_till_now > max_product) {\n            max_product = max_till_now;\n        }\n        if(max_till_now == 0) {\n            max_till_now = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpuhjc1kif: /tmp/tmpuhjc1kif.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 0;\n    long prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        prod *= arr[i];\n        if (prod > max_prod) {\n            max_prod = prod;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpfw0vct7i: /tmp/tmpfw0vct7i.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_prod(arr.size());\n    max_prod[0] = arr[0];\n    for(int i=1;i<arr.size();i++) {\n        max_prod[i] = arr[i];\n        for(int j=0;j<i;j++) {\n            if(arr[i] > arr[j]) {\n                max_prod[i] = std::max(max_prod[i], max_prod[j]*arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_prod.begin(), max_prod.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmp1sijm05y: /tmp/tmp1sijm05y.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    product = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpctecdkns: /tmp/tmpctecdkns.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp5xiwuewb: /tmp/tmp5xiwuewb.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product_array(arr.size(),0);\n    max_product_array[0] = arr[0];\n    for(int i=1;i<arr.size();i++) {\n        max_product_array[i] = arr[i];\n        for(int j=0;j<i;j++) {\n            if(arr[i] > arr[j]) {\n                max_product_array[i] = std::max(max_product_array[i], max_product_array[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_product_array.begin(), max_product_array.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpgsvzh5ie: /tmp/tmpgsvzh5ie.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmp4o8we3i4: /tmp/tmp4o8we3i4.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product_arr(arr.size(),0);\n    max_product_arr[0] = arr[0];\n    for(int i=1;i<arr.size();i++) {\n        max_product_arr[i] = arr[i];\n        for(int j=0;j<i;j++) {\n            if(arr[i] > arr[j]) {\n                max_product_arr[i] = std::max(max_product_arr[i], max_product_arr[j]*arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_product_arr.begin(), max_product_arr.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpa7d56l3k: /tmp/tmpa7d56l3k.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product(arr.size(), 1);\n    max_product[0] = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[j] < arr[i]) {\n                max_product[i] = std::max(max_product[i], max_product[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_product.begin(), max_product.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpgh5rbot1: /tmp/tmpgh5rbot1.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> dp(arr.size(), 1);\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, dp[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpnpdkmkif: /tmp/tmpnpdkmkif.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    // Write your code here\n    long max_prod = 1;\n    long prod = 1;\n    for(int i = 0; i < arr.size(); i++){\n        prod = prod * arr[i];\n        if(prod > max_prod){\n            max_prod = prod;\n        }\n        if(prod == 0){\n            prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpox52z2pn: /tmp/tmpox52z2pn.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpe5s2pxh6: /tmp/tmpe5s2pxh6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            current_product *= arr[i];\n            max_product = std::max(max_product, current_product);\n        } else {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpk9tnb31x: /tmp/tmpk9tnb31x.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0; i<arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpctte38w3: /tmp/tmpctte38w3.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpld0rf4vz: /tmp/tmpld0rf4vz.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_so_far *= arr[i];\n      max_product = std::max(max_product, max_so_far);\n    } else {\n      max_so_far = 1;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpzg23xeq9: /tmp/tmpzg23xeq9.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmppbu622ml: /tmp/tmppbu622ml.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(long i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmp6antlx3n: /tmp/tmp6antlx3n.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    curr_product = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpby8ws2qq: /tmp/tmpby8ws2qq.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpe1blsxcb: /tmp/tmpe1blsxcb.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    if(arr.size()==0)\n        return 0;\n    if(arr.size()==1)\n        return arr[0];\n    long max_product_so_far=arr[0];\n    long max_product_ending_here=arr[0];\n    long min_product_ending_here=arr[0];\n    for(int i=1;i<arr.size();i++){\n        long temp=max_product_ending_here;\n        max_product_ending_here=std::max(std::max(max_product_ending_here*arr[i],min_product_ending_here*arr[i]),arr[i]);\n        min_product_ending_here=std::min(std::min(temp*arr[i],min_product_ending_here*arr[i]),arr[i]);\n        max_product_so_far=std::max(max_product_so_far,max_product_ending_here);\n    }\n    return max_product_so_far;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpcg35b5zq: /tmp/tmpcg35b5zq.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpx62blntb: /tmp/tmpx62blntb.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); ++i) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmputrf2_w3: /tmp/tmputrf2_w3.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    max_so_far = max_so_far * arr[i];\n    if (max_so_far == 0) {\n      max_so_far = 1;\n    }\n    max_product = std::max(max_product, max_so_far);\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpwmkye3ih: /tmp/tmpwmkye3ih.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    curr_prod = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpw92moegb: /tmp/tmpw92moegb.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_product = std::max(max_so_far, max_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpfs0z69qx: /tmp/tmpfs0z69qx.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> dp(arr.size(), 1);\n    for(int i = 1; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp193ltrn3: /tmp/tmp193ltrn3.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > max_so_far) {\n            max_so_far = arr[i];\n            max_product = max_so_far;\n        }\n        else {\n            max_product *= arr[i];\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpzrbi61vo: /tmp/tmpzrbi61vo.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far*arr[i], arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpfgnt9jhv: /tmp/tmpfgnt9jhv.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        max_product = std::max(max_product, product);\n        if(arr[i] == 0) product = 1;\n    }\n    product = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        product *= arr[i];\n        max_product = std::max(max_product, product);\n        if(arr[i] == 0) product = 1;\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpb9t17a9y: /tmp/tmpb9t17a9y.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp869c492f: /tmp/tmp869c492f.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    std::vector<long> max_product_arr(arr.size(), 1);\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                max_product_arr[i] = std::max(max_product_arr[i], max_product_arr[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, max_product_arr[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpvd_duuyq: /tmp/tmpvd_duuyq.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    int max_product_index = 0;\n    int max_product_length = 0;\n    int max_product_start_index = 0;\n    int max_product_end_index = 0;\n    int max_product_start_index_temp = 0;\n    int max_product_end_index_temp = 0;\n    int max_product_length_temp = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > max_product) {\n            max_product = arr[i];\n            max_product_index = i;\n            max_product_length = 1;\n            max_product_start_index = i;\n            max_product_end_index = i;\n        }\n        else if (arr[i] == max_product) {\n            max_product_length = 1;\n            max_product_start_index = i;\n            max_product_end_index = i;\n        }\n        else {\n            max_product_length_temp = 1;\n            max_product_start_index_temp = i;\n            max_product_end_index_temp = i;\n            for (int j = i + 1; j < arr.size(); j++) {\n                if (arr[j] > arr[i]) {\n                    max_product_length_temp++;\n                    max_product_end_index_temp = j;\n                }\n                else {\n                    break;\n                }\n            }\n            if (max_product_length_temp > max_product_length) {\n                max_product_length = max_product_length_temp;\n                max_product_start_index = max_product_start_index_temp;\n                max_product_end_index = max_product_end_index_temp;\n            }\n        }\n    }\n    long product = 1;\n    for (int i = max_product_start_index; i <= max_product_end_index; i++) {\n        product *= arr[i];\n    }\n    return product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpgozq_d97: /tmp/tmpgozq_d97.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpos_a5eh5: /tmp/tmpos_a5eh5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpgxy5oivh: /tmp/tmpgxy5oivh.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far *= arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpin74xi4c: /tmp/tmpin74xi4c.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = std::max(max_so_far * arr[i], arr[i]);\n            min_so_far = std::min(min_so_far * arr[i], arr[i]);\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], arr[i]);\n            min_so_far = std::min(temp * arr[i], arr[i]);\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp9rhtajv_: /tmp/tmp9rhtajv_.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpgxy5oivh: /tmp/tmpgxy5oivh.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    curr_product = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122488,
      "stdout": "",
      "stderr": "tmpby8ws2qq: /tmp/tmpby8ws2qq.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpdzavcvzw: /tmp/tmpdzavcvzw.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far *= arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpffdvmxp6: /tmp/tmpffdvmxp6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpjexm9yrt: /tmp/tmpjexm9yrt.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    int n = arr.size();\n    std::vector<long> dp(n, 1);\n    for(int i = 1; i < n; i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, dp[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp76tsmp8x: /tmp/tmp76tsmp8x.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for(long i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpakxp77n0: /tmp/tmpakxp77n0.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long n = arr.size();\n    std::vector<long> dp(n, 1);\n    for (long i = 1; i < n; i++) {\n        for (long j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpib4yvikl: /tmp/tmpib4yvikl.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(auto i : arr) {\n        curr_prod *= i;\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp8wvz76o6: /tmp/tmp8wvz76o6.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(curr_prod, max_prod);\n        } else {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpgbfex16b: /tmp/tmpgbfex16b.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    std::vector<long> max_product_arr(arr.size(), 0);\n    max_product_arr[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        max_product_arr[i] = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j] && max_product_arr[i] < max_product_arr[j] * arr[i]) {\n                max_product_arr[i] = max_product_arr[j] * arr[i];\n            }\n        }\n        if(max_product < max_product_arr[i]) {\n            max_product = max_product_arr[i];\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp4ggbyy7e: /tmp/tmp4ggbyy7e.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long prev_max = 1;\n    long prev_min = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            prev_max = prev_max * arr[i];\n            prev_min = std::min(prev_min * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            prev_max = 1;\n            prev_min = 1;\n        } else {\n            long temp = prev_max;\n            prev_max = std::max(prev_min * arr[i], 1L);\n            prev_min = temp * arr[i];\n        }\n        if (prev_max > max_product) {\n            max_product = prev_max;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpix2fua7g: /tmp/tmpix2fua7g.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else {\n            curr_prod = 1;\n        }\n    }\n    curr_prod = 1;\n    for (long i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp4f_zorz1: /tmp/tmp4f_zorz1.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp5xiwuewb: /tmp/tmp5xiwuewb.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long current_product = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    current_product *= arr[i];\n    if (current_product > max_product) {\n      max_product = current_product;\n    }\n    if (current_product == 0) {\n      current_product = 1;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpym28_sc5: /tmp/tmpym28_sc5.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpgp4in6d4: /tmp/tmpgp4in6d4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1l);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1l);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp6tvyflzf: /tmp/tmp6tvyflzf.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpe5s2pxh6: /tmp/tmpe5s2pxh6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpvj8ybufl: /tmp/tmpvj8ybufl.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product_arr(arr.size());\n    max_product_arr[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        max_product_arr[i] = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                max_product_arr[i] = std::max(max_product_arr[i], max_product_arr[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_product_arr.begin(), max_product_arr.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpmpjsvzj0: /tmp/tmpmpjsvzj0.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpjexm9yrt: /tmp/tmpjexm9yrt.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpsgxtdv9q: /tmp/tmpsgxtdv9q.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product,max_so_far);\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product,max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpi76zpsof: /tmp/tmpi76zpsof.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpos_a5eh5: /tmp/tmpos_a5eh5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(long i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmp43y5s1rn: /tmp/tmp43y5s1rn.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpgp4in6d4: /tmp/tmpgp4in6d4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product_arr(arr.size(), 0);\n    max_product_arr[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long max_product = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                max_product = std::max(max_product, max_product_arr[j] * arr[i]);\n            }\n        }\n        max_product_arr[i] = max_product;\n    }\n    return *std::max_element(max_product_arr.begin(), max_product_arr.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmp1r23b7ne: /tmp/tmp1r23b7ne.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else if(arr[i] == 0) {\n            curr_prod = 1;\n        } else {\n            if(curr_prod == 1) {\n                curr_prod = arr[i];\n                max_prod = std::max(max_prod, curr_prod);\n            } else {\n                curr_prod *= arr[i];\n                long temp = curr_prod;\n                curr_prod = 1;\n                max_prod = std::max(max_prod, temp);\n            }\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmppjhs645e: /tmp/tmppjhs645e.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    int i = 0;\n    while(i < arr.size()) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        i++;\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmp67y2gq0u: /tmp/tmp67y2gq0u.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far, max_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpvxcjcq5_: /tmp/tmpvxcjcq5_.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    // Write your code here\n    long n = arr.size();\n    std::vector<long> dp(n,1);\n    for(long i=1;i<n;i++){\n        for(long j=0;j<i;j++){\n            if(arr[i]>arr[j]){\n                dp[i] = std::max(dp[i],dp[j]*arr[i]);\n            }\n        }\n    }\n    long max = dp[0];\n    for(long i=1;i<n;i++){\n        if(max<dp[i]){\n            max = dp[i];\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmp0ojdr56z: /tmp/tmp0ojdr56z.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmp2c3cbhaw: /tmp/tmp2c3cbhaw.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long prev_max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_product = std::max(max_product, prev_max_product * arr[i]);\n            prev_max_product *= arr[i];\n        } else if (arr[i] < 0) {\n            max_product = std::max(max_product, prev_max_product * arr[i]);\n            prev_max_product = 1;\n        } else {\n            max_product = std::max(max_product, prev_max_product * arr[i]);\n            prev_max_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpxw1t8pg6: /tmp/tmpxw1t8pg6.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmplmy0afou: /tmp/tmplmy0afou.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpe5s2pxh6: /tmp/tmpe5s2pxh6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            current_product *= arr[i];\n            max_product = std::max(max_product, current_product);\n        }\n        else {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpce21fzqh: /tmp/tmpce21fzqh.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpu9pccm2e: /tmp/tmpu9pccm2e.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long prev_max = 1;\n    long prev_min = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            prev_max = prev_max * arr[i];\n            prev_min = std::min(prev_min * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            prev_max = 1;\n            prev_min = 1;\n        } else {\n            long temp = prev_max;\n            prev_max = std::max(prev_min * arr[i], 1L);\n            prev_min = temp * arr[i];\n        }\n        if (prev_max > max_product) {\n            max_product = prev_max;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpix2fua7g: /tmp/tmpix2fua7g.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpcufai_n_: /tmp/tmpcufai_n_.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (auto i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far, max_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmps6jr_rpd: /tmp/tmps6jr_rpd.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        }\n        else {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpvaw0azzx: /tmp/tmpvaw0azzx.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp0dl7xlfu: /tmp/tmp0dl7xlfu.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long prev_max = 1;\n    long prev_min = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            prev_max = prev_max * arr[i];\n            prev_min = std::min(prev_min * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            prev_max = 1;\n            prev_min = 1;\n        }\n        else {\n            long temp = prev_max;\n            prev_max = std::max(prev_min * arr[i], 1L);\n            prev_min = temp * arr[i];\n        }\n        if(max_prod < prev_max) {\n            max_prod = prev_max;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpgv7n9zv4: /tmp/tmpgv7n9zv4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if (curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if (curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpkr1d51ix: /tmp/tmpkr1d51ix.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long n = arr.size();\n    std::vector<long> dp(n, 1);\n    for(int i = 1; i < n; i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmp_rgfgwpc: /tmp/tmp_rgfgwpc.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmprs6j4vxw: /tmp/tmprs6j4vxw.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> dp(arr.size(),1);\n    for(int i=1;i<arr.size();i++) {\n        for(int j=0;j<i;j++) {\n            if(arr[j]<arr[i]) {\n                dp[i]=std::max(dp[i],dp[j]*arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(),dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmp6506mcdu: /tmp/tmp6506mcdu.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpgjpv6594: /tmp/tmpgjpv6594.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    std::vector<long> dp(arr.size(), 1);\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, dp[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmprgal3tby: /tmp/tmprgal3tby.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpgp4in6d4: /tmp/tmpgp4in6d4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmp7aouq6mt: /tmp/tmp7aouq6mt.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpjexm9yrt: /tmp/tmpjexm9yrt.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpsgxtdv9q: /tmp/tmpsgxtdv9q.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    std::vector<long> max_product_arr(arr.size(), 1);\n    for (int i = 0; i < arr.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                max_product_arr[i] = std::max(max_product_arr[i], max_product_arr[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, max_product_arr[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmplrboly9a: /tmp/tmplrboly9a.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    std::vector<long> max_prod_arr(arr.size());\n    max_prod_arr[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        max_prod_arr[i] = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                max_prod_arr[i] = std::max(max_prod_arr[i], max_prod_arr[j] * arr[i]);\n            }\n        }\n        max_prod = std::max(max_prod, max_prod_arr[i]);\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpzxujr8p3: /tmp/tmpzxujr8p3.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp5xiwuewb: /tmp/tmp5xiwuewb.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long prev_product = arr[0];\n    long prev_max = arr[0];\n    long prev_min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long curr_max = std::max(std::max(prev_max * arr[i], prev_min * arr[i]), arr[i]);\n        long curr_min = std::min(std::min(prev_max * arr[i], prev_min * arr[i]), arr[i]);\n        max_product = std::max(max_product, curr_max);\n        prev_max = curr_max;\n        prev_min = curr_min;\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmp97gbdx2i: /tmp/tmp97gbdx2i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far *= arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpffdvmxp6: /tmp/tmpffdvmxp6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product,max_so_far);\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product,max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmp15zbd9f1: /tmp/tmp15zbd9f1.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max = 1;\n    long product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        product = product * arr[i];\n        if (product > max) {\n            max = product;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmp9rq74hd5: /tmp/tmp9rq74hd5.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n  int n = arr.size();\n  std::vector<long> max_product(n);\n  max_product[0] = arr[0];\n  for (int i = 1; i < n; i++) {\n    max_product[i] = arr[i];\n    for (int j = 0; j < i; j++) {\n      if (arr[i] > arr[j]) {\n        max_product[i] = std::max(max_product[i], max_product[j] * arr[i]);\n      }\n    }\n  }\n  return *std::max_element(max_product.begin(), max_product.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpu6x6d71a: /tmp/tmpu6x6d71a.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far = std::max(max_product_so_far, max_product_so_far * arr[i]);\n        max_product = std::max(max_product, max_product_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmppf_0gb9e: /tmp/tmppf_0gb9e.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmphz9wjv5r: /tmp/tmphz9wjv5r.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far = std::max(max_product_so_far*arr[i], arr[i]);\n        max_product = std::max(max_product_so_far, max_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpgnk_nide: /tmp/tmpgnk_nide.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        long product = 1;\n        for(int j = i; j < arr.size(); j++) {\n            product *= arr[j];\n            if(product > max_product) {\n                max_product = product;\n            }\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpfvuxyumi: /tmp/tmpfvuxyumi.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else if (arr[i] == 0) {\n            curr_prod = 1;\n        } else {\n            long temp = curr_prod;\n            curr_prod = 1;\n            for (long j = i; j < arr.size(); j++) {\n                if (arr[j] < 0) {\n                    curr_prod *= arr[j];\n                } else {\n                    break;\n                }\n            }\n            max_prod = std::max(max_prod, curr_prod);\n            curr_prod = temp;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpohjitlde: /tmp/tmpohjitlde.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if (curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if (curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpkr1d51ix: /tmp/tmpkr1d51ix.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmpjexm9yrt: /tmp/tmpjexm9yrt.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if (curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if (curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "tmpkr1d51ix: /tmp/tmpkr1d51ix.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if (arr[i] == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmptzgxw0rt: /tmp/tmptzgxw0rt.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    std::vector<long> max_prod_arr(arr.size(), 1);\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                max_prod_arr[i] = std::max(max_prod_arr[i], max_prod_arr[j] * arr[i]);\n            }\n        }\n        max_prod = std::max(max_prod, max_prod_arr[i]);\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpob2vykkr: /tmp/tmpob2vykkr.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far==0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_so_far,max_product);\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far==0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_so_far,max_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmptb0y2q0h: /tmp/tmptb0y2q0h.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmp9xqga367: /tmp/tmp9xqga367.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if(current_product > max_product) {\n            max_product = current_product;\n        }\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmp5w7j3h6y: /tmp/tmp5w7j3h6y.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product_arr(arr.size(), 0);\n    std::vector<long> min_product_arr(arr.size(), 0);\n    max_product_arr[0] = arr[0];\n    min_product_arr[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        max_product_arr[i] = std::max(arr[i], std::max(arr[i] * max_product_arr[i - 1], arr[i] * min_product_arr[i - 1]));\n        min_product_arr[i] = std::min(arr[i], std::min(arr[i] * max_product_arr[i - 1], arr[i] * min_product_arr[i - 1]));\n    }\n    return *std::max_element(max_product_arr.begin(), max_product_arr.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpo5g32gc_: /tmp/tmpo5g32gc_.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpgp4in6d4: /tmp/tmpgp4in6d4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpsgxtdv9q: /tmp/tmpsgxtdv9q.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_so_far, max_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpr7nd83hn: /tmp/tmpr7nd83hn.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpp2op7ywp: /tmp/tmpp2op7ywp.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if(current_product > max_product) {\n            max_product = current_product;\n        }\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmpgso4ty3y: /tmp/tmpgso4ty3y.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmphpl6t17b: /tmp/tmphpl6t17b.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = arr[0];\n    long curr_prod = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        curr_prod = std::max(curr_prod * arr[i], arr[i]);\n        max_prod = std::max(max_prod, curr_prod);\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmp1yviwanq: /tmp/tmp1yviwanq.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_prod(arr.size(),0);\n    max_prod[0]=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        long max=0;\n        for(int j=0;j<i;j++)\n        {\n            if(arr[j]<arr[i])\n            {\n                if(max_prod[j]>max)\n                {\n                    max=max_prod[j];\n                }\n            }\n        }\n        max_prod[i]=max*arr[i];\n    }\n    long max=0;\n    for(int i=0;i<max_prod.size();i++)\n    {\n        if(max_prod[i]>max)\n        {\n            max=max_prod[i];\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpx__dqmoo: /tmp/tmpx__dqmoo.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    // Write your code here\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_product_so_far = max_product_so_far * arr[i];\n        if(max_product_so_far > max_product){\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0){\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmpg6yrveg7: /tmp/tmpg6yrveg7.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] > 0) {\n            curr_product *= arr[i];\n            if (curr_product > max_product) {\n                max_product = curr_product;\n            }\n        } else {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmp11tgs0gl: /tmp/tmp11tgs0gl.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_element = arr[0];\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > max_element) {\n            max_product *= arr[i];\n            max_element = arr[i];\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmp95b_1zdf: /tmp/tmp95b_1zdf.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpe5s2pxh6: /tmp/tmpe5s2pxh6.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122494,
      "stdout": "",
      "stderr": "tmphz9wjv5r: /tmp/tmphz9wjv5r.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    // Write your code here\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]>0){\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod,curr_prod);\n        }\n        else{\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmpjvxv3jiu: /tmp/tmpjvxv3jiu.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_product_so_far *= arr[i];\n        if (max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if (max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmp23_qyxg0: /tmp/tmp23_qyxg0.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122486,
      "stdout": "",
      "stderr": "tmp0dl7xlfu: /tmp/tmp0dl7xlfu.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122490,
      "stdout": "",
      "stderr": "tmp869c492f: /tmp/tmp869c492f.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        long product = 1;\n        for(int j = i; j < arr.size(); j++) {\n            product *= arr[j];\n            max_product = std::max(max_product, product);\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmp9kfp_lkp: /tmp/tmp9kfp_lkp.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpos_a5eh5: /tmp/tmpos_a5eh5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]>0){\n            max_so_far = max_so_far*arr[i];\n            min_so_far = std::min(min_so_far*arr[i],1L);\n        }\n        else if(arr[i]==0){\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else{\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far*arr[i],1L);\n            min_so_far = temp*arr[i];\n        }\n        if(max_so_far>max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmphgw5ehff: /tmp/tmphgw5ehff.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpos_a5eh5: /tmp/tmpos_a5eh5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpxxz61hoz: /tmp/tmpxxz61hoz.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        max_product = std::max(max_product, product);\n        if (product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmpe1miul3b: /tmp/tmpe1miul3b.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmpkmq9p9r_: /tmp/tmpkmq9p9r_.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpgp4in6d4: /tmp/tmpgp4in6d4.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_product *= arr[i];\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122496,
      "stdout": "",
      "stderr": "tmp37h6jc71: /tmp/tmp37h6jc71.cpp:13: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long max_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far, max_so_far * arr[i]);\n        max_prod = std::max(max_prod, max_so_far);\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpj68kx9eg: /tmp/tmpj68kx9eg.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509754,
      "stdout": "",
      "stderr": "tmpdpjpvyig: /tmp/tmpdpjpvyig.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}