{
  "name": "mbpp_308_large_product",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::unordered_set<std::string> visited;\n    visited.insert(\"0,0\");\n    for (long i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int x = top.second.first, y = top.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::to_string(x + 1) + \",\" + std::to_string(y)) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert(std::to_string(x + 1) + \",\" + std::to_string(y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::to_string(x) + \",\" + std::to_string(y + 1)) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert(std::to_string(x) + \",\" + std::to_string(y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long cur = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(cur);\n            } else {\n                if (pq.top() < cur) {\n                    pq.pop();\n                    pq.push(cur);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::vector<long> temp;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            temp.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n    for(int i = temp.size() - 1; i >= temp.size() - N; i--) {\n        result.push_back(temp[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push(num1 * num2);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> products;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            products.push_back(num1 * num2);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (long i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push(num1 * num2);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> max_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push(num1 * num2);\n            if (max_heap.size() > N) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> map;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            map.insert(std::make_pair(i * j, std::make_pair(i, j)));\n        }\n    }\n    auto it = map.rbegin();\n    for (long i = 0; i < N; i++) {\n        result.push_back(it->first);\n        it++;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    std::vector<long>::iterator it1 = nums1.begin();\n    std::vector<long>::iterator it2 = nums2.begin();\n    while(N--) {\n        if(*it1 > *it2) {\n            result.push_back(*it1);\n            it1++;\n        } else {\n            result.push_back(*it2);\n            it2++;\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long num1 : nums1) {\n        for (long num2 : nums2) {\n            pq.push(num1 * num2);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "  std::vector<long> result;\n  std::vector<long> nums1_copy = nums1;\n  std::vector<long> nums2_copy = nums2;\n  std::sort(nums1_copy.begin(), nums1_copy.end());\n  std::sort(nums2_copy.begin(), nums2_copy.end());\n  std::vector<long>::iterator it1 = nums1_copy.begin();\n  std::vector<long>::iterator it2 = nums2_copy.begin();\n  while(N--) {\n    long product1 = (*it1) * (*it2);\n    long product2 = (*it1) * (*(it2 + 1));\n    long product3 = (*(it1 + 1)) * (*it2);\n    if(product1 > product2 && product1 > product3) {\n      result.push_back(product1);\n      it2++;\n    }\n    else if(product2 > product1 && product2 > product3) {\n      result.push_back(product2);\n      it1++;\n    }\n    else {\n      result.push_back(product3);\n      it1++;\n      it2++;\n    }\n  }\n  return result;",
    "    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::set<long> s;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            s.insert(nums1[i] * nums2[j]);\n        }\n    }\n    std::set<long>::reverse_iterator it = s.rbegin();\n    for (int i = 0; i < N; i++) {\n        result.push_back(*it);\n        it++;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if(pq.size() < N) {\n                pq.push(product);\n            } else {\n                if(product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;"
  ]
}