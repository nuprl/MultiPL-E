{
  "name": "mbpp_4_heap_queue_largest",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = heap_queue_largest;\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (3)) == (std::vector<long>({(long)85, (long)75, (long)65})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (2)) == (std::vector<long>({(long)85, (long)75})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (5)) == (std::vector<long>({(long)85, (long)75, (long)65, (long)58, (long)35})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (long i = 0; i < n; i++) {\n        min_heap.push(nums[i]);\n    }\n    for (long i = n; i < nums.size(); i++) {\n        if (nums[i] > min_heap.top()) {\n            min_heap.pop();\n            min_heap.push(nums[i]);\n        }\n    }\n    std::vector<long> result;\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long> > pq;\n    for (auto num : nums) {\n        pq.push(num);\n        if (pq.size() > n) {\n            pq.pop();\n        }\n    }\n    std::vector<long> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (auto num : nums) {\n        if (min_heap.size() < n) {\n            min_heap.push(num);\n        } else {\n            if (num > min_heap.top()) {\n                min_heap.pop();\n                min_heap.push(num);\n            }\n        }\n    }\n    std::vector<long> result;\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (auto num : nums) {\n        pq.push(num);\n        if (pq.size() > n) {\n            pq.pop();\n        }\n    }\n    std::vector<long> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> heap;\n    for (long i = 0; i < nums.size(); i++) {\n        if (heap.size() < n) {\n            heap.push(nums[i]);\n        } else {\n            if (nums[i] > heap.top()) {\n                heap.pop();\n                heap.push(nums[i]);\n            }\n        }\n    }\n    std::vector<long> result;\n    while (!heap.empty()) {\n        result.push_back(heap.top());\n        heap.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < n; i++) {\n        pq.push(nums[i]);\n    }\n    for (long i = n; i < nums.size(); i++) {\n        if (nums[i] > pq.top()) {\n            pq.pop();\n            pq.push(nums[i]);\n        }\n    }\n    std::vector<long> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < n; i++) {\n        pq.push(nums[i]);\n    }\n    for (long i = n; i < nums.size(); i++) {\n        if (nums[i] > pq.top()) {\n            pq.pop();\n            pq.push(nums[i]);\n        }\n    }\n    std::vector<long> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> heap;\n    std::vector<long> result;\n    for (auto num : nums) {\n        heap.push(num);\n        if (heap.size() > n) {\n            heap.pop();\n        }\n    }\n    while (!heap.empty()) {\n        result.push_back(heap.top());\n        heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;",
    "  std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n  for (auto num : nums) {\n    if (pq.size() < n) {\n      pq.push(num);\n    } else {\n      if (num > pq.top()) {\n        pq.pop();\n        pq.push(num);\n      }\n    }\n  }\n  std::vector<long> res;\n  while (!pq.empty()) {\n    res.push_back(pq.top());\n    pq.pop();\n  }\n  return res;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    std::vector<long> result;\n    for (long i = 0; i < nums.size(); i++) {\n        if (min_heap.size() < n) {\n            min_heap.push(nums[i]);\n        } else {\n            if (min_heap.top() < nums[i]) {\n                min_heap.pop();\n                min_heap.push(nums[i]);\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    std::vector<long> result;\n    for (auto num : nums) {\n        if (pq.size() < n) {\n            pq.push(num);\n        } else {\n            if (num > pq.top()) {\n                pq.pop();\n                pq.push(num);\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::priority_queue<long> pq;\n    for (long i = 0; i < nums.size(); i++) {\n        pq.push(nums[i]);\n    }\n    std::vector<long> res;\n    for (long i = 0; i < n; i++) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < n; i++) {\n        pq.push(nums[i]);\n    }\n    for (long i = n; i < nums.size(); i++) {\n        if (nums[i] > pq.top()) {\n            pq.pop();\n            pq.push(nums[i]);\n        }\n    }\n    std::vector<long> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> heap;\n    for (auto num : nums) {\n        if (heap.size() < n) {\n            heap.push(num);\n        } else {\n            if (num > heap.top()) {\n                heap.pop();\n                heap.push(num);\n            }\n        }\n    }\n    std::vector<long> result;\n    while (!heap.empty()) {\n        result.push_back(heap.top());\n        heap.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < n; i++) {\n        pq.push(nums[i]);\n    }\n    for (long i = n; i < nums.size(); i++) {\n        if (nums[i] > pq.top()) {\n            pq.pop();\n            pq.push(nums[i]);\n        }\n    }\n    std::vector<long> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < n; i++) {\n        pq.push(nums[i]);\n    }\n    for (long i = n; i < nums.size(); i++) {\n        if (nums[i] > pq.top()) {\n            pq.pop();\n            pq.push(nums[i]);\n        }\n    }\n    std::vector<long> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < n; i++) {\n        pq.push(nums[i]);\n    }\n    for (long i = n; i < nums.size(); i++) {\n        if (nums[i] > pq.top()) {\n            pq.pop();\n            pq.push(nums[i]);\n        }\n    }\n    std::vector<long> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    std::vector<long> result;\n    for(auto num : nums) {\n        pq.push(num);\n        if(pq.size() > n) {\n            pq.pop();\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::priority_queue<long> pq;\n\tstd::vector<long> result;\n\tfor (long i = 0; i < nums.size(); i++) {\n\t\tpq.push(nums[i]);\n\t}\n\tfor (long i = 0; i < n; i++) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (auto num : nums) {\n        if (pq.size() < n) {\n            pq.push(num);\n        } else {\n            if (pq.top() < num) {\n                pq.pop();\n                pq.push(num);\n            }\n        }\n    }\n    std::vector<long> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;"
  ]
}