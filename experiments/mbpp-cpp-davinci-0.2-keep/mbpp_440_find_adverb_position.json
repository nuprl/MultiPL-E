{
  "name": "mbpp_440_find_adverb_position",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Write a function to find the first adverb and their positions in a given sentence.\nUnion_std_string_long find_adverb_position(std::string text) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = find_adverb_position;\n    assert(candidate((\"clearly!! we can see the sky\")) == std::make_tuple(0, 7, \"clearly\"));\n    assert(candidate((\"seriously!! there are many roses\")) == std::make_tuple(0, 9, \"seriously\"));\n    assert(candidate((\"unfortunately!! sita is going to home\")) == std::make_tuple(0, 13, \"unfortunately\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), m, r)) {\n        return Union_std_string_long(m.str());\n        searchStart += m.position() + m.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return adverb_match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"\\\\w*ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(0);\n    }\n    return -1;",
    "    std::regex reg(\"\\\\w+ly\");\n    std::smatch match;\n    if (std::regex_search(text, match, reg)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::vector<std::string> words = split(text, ' ');\n    std::vector<std::string> adverbs = { \"quickly\", \"slowly\", \"hastily\", \"calmly\", \"passionately\", \"carefully\", \"lazily\", \"happily\", \"sadly\", \"quietly\", \"noisily\", \"excitedly\", \"angrily\", \"jovially\", \"joyfully\", \"optimistically\", \"pessimistically\", \"powerfully\", \"mysteriously\", \"mystically\", \"magically\", \"foolishly\", \"carelessly\", \"cautiously\", \"eagerly\", \"elegantly\", \"gracefully\", \"merrily\", \"nervously\", \"noiselessly\", \"obediently\", \"obnoxiously\", \"perfectly\", \"politely\", \"proudly\", \"quickly\", \"rapidly\", \"rarely\", \"rudely\", \"sadly\", \"seldom\", \"selfishly\", \"seriously\", \"shakily\", \"sharply\", \"silently\", \"sleepily\", \"slowly\", \"smoothly\", \"softly\", \"solemnly\", \"speedily\", \"stealthily\", \"sternly\", \"strangely\", \"strictly\", \"strongly\", \"stubbornly\", \"suddenly\", \"surprisingly\", \"suspiciously\", \"swiftly\", \"tenderly\", \"tensely\", \"thoughtfully\", \"tightly\", \"tomorrow\", \"triumphantly\", \"truthfully\", \"unexpectedly\", \"victoriously\", \"vivaciously\", \"warmly\", \"wearily\", \"well\", \"wildly\", \"yearly\", \"zealously\", \"zestfully\" };\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < adverbs.size(); j++) {\n            if (words[i] == adverbs[j]) {\n                return Union_std_string_long(i);\n            }\n        }\n    }\n    return Union_std_string_long(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        std::cout << \"Adverb found: \" << adverb_match[0] << \" at position: \" << adverb_match.position(0) << std::endl;\n        searchStart += adverb_match.position(0) + adverb_match.length(0);\n        return Union_std_string_long(adverb_match[0]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 2) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverb_list[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"silently\", \"happily\", \"sadly\", \"angrily\", \"anxiously\", \"cheerfully\", \"eagerly\", \"elegantly\", \"frantically\", \"gracefully\", \"merrily\", \"nervously\", \"obediently\", \"politely\", \"proudly\", \"quietly\", \"rapidly\", \"shakily\", \"sharply\", \"sheepishly\", \"smoothly\", \"softly\", \"swiftly\", \"victoriously\", \"vivaciously\", \"warmly\", \"wearily\", \"wickedly\", \"wildly\", \"worriedly\", \"zealously\"};\n    std::string word_list[100];\n    int word_count = 0;\n    std::string word = \"\";\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] == ' ') {\n            word_list[word_count] = word;\n            word_count++;\n            word = \"\";\n        } else {\n            word = word + text[i];\n        }\n    }\n    word_list[word_count] = word;\n    word_count++;\n    for (int i = 0; i < word_count; i++) {\n        for (int j = 0; j < sizeof(adverb_list) / sizeof(adverb_list[0]); j++) {\n            if (word_list[i] == adverb_list[j]) {\n                return Union_std_string_long(word_list[i]);\n            }\n        }\n    }\n    return Union_std_string_long(-1);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"silently\"};\n    std::string text_copy = text;\n    std::transform(text_copy.begin(), text_copy.end(), text_copy.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        size_t found = text_copy.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    else {\n        return Union_std_string_long(adverb_match.str());\n    }"
  ]
}