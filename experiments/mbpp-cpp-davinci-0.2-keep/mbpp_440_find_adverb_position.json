{
  "name": "mbpp_440_find_adverb_position",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Write a function to find the first adverb and their positions in a given sentence.\nUnion_std_string_long find_adverb_position(std::string text) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py",
  "prompt_terminology": "verbatim",
  "tests": "}\nint main() {\n    auto candidate = find_adverb_position;\n    assert(candidate((\"clearly!! we can see the sky\")) == std::make_tuple(0, 7, \"clearly\"));\n    assert(candidate((\"seriously!! there are many roses\")) == std::make_tuple(0, 9, \"seriously\"));\n    assert(candidate((\"unfortunately!! sita is going to home\")) == std::make_tuple(0, 13, \"unfortunately\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), m, r)) {\n        return Union_std_string_long(m.str());\n        searchStart += m.position() + m.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return adverb_match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"\\\\w*ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(0);\n    }\n    return -1;",
    "    std::regex reg(\"\\\\w+ly\");\n    std::smatch match;\n    if (std::regex_search(text, match, reg)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::vector<std::string> words = split(text, ' ');\n    std::vector<std::string> adverbs = { \"quickly\", \"slowly\", \"hastily\", \"calmly\", \"passionately\", \"carefully\", \"lazily\", \"happily\", \"sadly\", \"quietly\", \"noisily\", \"excitedly\", \"angrily\", \"jovially\", \"joyfully\", \"optimistically\", \"pessimistically\", \"powerfully\", \"mysteriously\", \"mystically\", \"magically\", \"foolishly\", \"carelessly\", \"cautiously\", \"eagerly\", \"elegantly\", \"gracefully\", \"merrily\", \"nervously\", \"noiselessly\", \"obediently\", \"obnoxiously\", \"perfectly\", \"politely\", \"proudly\", \"quickly\", \"rapidly\", \"rarely\", \"rudely\", \"sadly\", \"seldom\", \"selfishly\", \"seriously\", \"shakily\", \"sharply\", \"silently\", \"sleepily\", \"slowly\", \"smoothly\", \"softly\", \"solemnly\", \"speedily\", \"stealthily\", \"sternly\", \"strangely\", \"strictly\", \"strongly\", \"stubbornly\", \"suddenly\", \"surprisingly\", \"suspiciously\", \"swiftly\", \"tenderly\", \"tensely\", \"thoughtfully\", \"tightly\", \"tomorrow\", \"triumphantly\", \"truthfully\", \"unexpectedly\", \"victoriously\", \"vivaciously\", \"warmly\", \"wearily\", \"well\", \"wildly\", \"yearly\", \"zealously\", \"zestfully\" };\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < adverbs.size(); j++) {\n            if (words[i] == adverbs[j]) {\n                return Union_std_string_long(i);\n            }\n        }\n    }\n    return Union_std_string_long(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        std::cout << \"Adverb found: \" << adverb_match[0] << \" at position: \" << adverb_match.position(0) << std::endl;\n        searchStart += adverb_match.position(0) + adverb_match.length(0);\n        return Union_std_string_long(adverb_match[0]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 2) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverb_list[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"silently\", \"happily\", \"sadly\", \"angrily\", \"anxiously\", \"cheerfully\", \"eagerly\", \"elegantly\", \"frantically\", \"gracefully\", \"merrily\", \"nervously\", \"obediently\", \"politely\", \"proudly\", \"quietly\", \"rapidly\", \"shakily\", \"sharply\", \"sheepishly\", \"smoothly\", \"softly\", \"swiftly\", \"victoriously\", \"vivaciously\", \"warmly\", \"wearily\", \"wickedly\", \"wildly\", \"worriedly\", \"zealously\"};\n    std::string word_list[100];\n    int word_count = 0;\n    std::string word = \"\";\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] == ' ') {\n            word_list[word_count] = word;\n            word_count++;\n            word = \"\";\n        } else {\n            word = word + text[i];\n        }\n    }\n    word_list[word_count] = word;\n    word_count++;\n    for (int i = 0; i < word_count; i++) {\n        for (int j = 0; j < sizeof(adverb_list) / sizeof(adverb_list[0]); j++) {\n            if (word_list[i] == adverb_list[j]) {\n                return Union_std_string_long(word_list[i]);\n            }\n        }\n    }\n    return Union_std_string_long(-1);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"silently\"};\n    std::string text_copy = text;\n    std::transform(text_copy.begin(), text_copy.end(), text_copy.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        size_t found = text_copy.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    else {\n        return Union_std_string_long(adverb_match.str());\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string text_copy = text;\n    std::transform(text_copy.begin(), text_copy.end(), text_copy.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        size_t pos = text_copy.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'ly') {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match[0];\n    }\n    return -1;",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex_adverb)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"quietly\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        std::string adverb = adverbs[i];\n        std::size_t found = text_lower.find(adverb);\n        if (found != std::string::npos) {\n            return found;\n        }\n    }\n    return \"Adverb not found\";",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(1);\n    } else {\n        return -1;\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex r(\"[a-zA-Z]+ly\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() != 0) {\n        return Union_std_string_long(m.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.str();\n    }\n    return -1;",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.empty()) {\n        return -1;\n    }\n    return m.str(1);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return std::string(\"\");",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"silently\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        size_t pos = text_lower.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return pos;\n        }\n    }\n    return \"Not found\";",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match[0]);\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[^\\\\W\\\\d_]+ly\\\\b\");\n    std::smatch match;\n    if(std::regex_search(text, match, adverb_regex)){\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverb_list[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"angrily\", \"loudly\", \"quietly\", \"sadly\", \"joyfully\", \"sleepily\", \"noisily\", \"hungrily\", \"thirstily\", \"lazily\", \"greedily\", \"foolishly\", \"madly\", \"calmly\", \"humbly\", \"gracefully\", \"bravely\", \"politely\", \"cheerfully\", \"loyally\", \"faithfully\", \"fondly\", \"warmly\", \"courageously\", \"foolishly\", \"generously\", \"kindly\", \"lovingly\", \"patiently\", \"playfully\", \"tenderly\", \"wickedly\", \"wonderfully\", \"zealously\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"zestfully\", \"zestily\", \"",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::vector<std::string> words = split(text, ' ');\n    std::vector<std::string> adverbs = {\"quickly\", \"slowly\", \"well\", \"badly\"};\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < adverbs.size(); j++) {\n            if (words[i] == adverbs[j]) {\n                return Union_std_string_long(words[i]);\n            }\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"((\\\\w+ly))\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match[0]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return \"No adverb found\";\n    }\n    else {\n        return adverb_match.position(1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(match.str());",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        std::string adverb = adverb_match.str(0);\n        long position = adverb_match.position(0);\n        return Union_std_string_long(adverb);\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'y') {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"sadly\", \"angrily\", \"loudly\", \"quietly\", \"noisily\", \"silently\", \"badly\", \"well\", \"hard\", \"softly\", \"fast\", \"slow\", \"early\", \"late\", \"boldly\", \"bravely\", \"calmly\", \"cautiously\", \"eagerly\", \"elegantly\", \"firmly\", \"gracefully\", \"hastily\", \"lazily\", \"politely\", \"roughly\", \"sharply\", \"smoothly\", \"steadily\", \"strongly\", \"tenderly\", \"vigorously\", \"warmly\", \"weakly\", \"wisely\", \"annually\", \"daily\", \"hourly\", \"monthly\", \"nightly\", \"quarterly\", \"weekly\", \"yearly\", \"nearly\", \"almost\", \"completely\", \"entirely\", \"halfway\", \"partly\", \"slightly\", \"somewhat\", \"almost\", \"barely\", \"hardly\", \"scarcely\", \"barely\", \"hardly\", \"scarcely\", \"completely\", \"entirely\", \"totally\", \"utterly\", \"wholly\", \"absolutely\", \"altogether\", \"completely\", \"decidedly\", \"deeply\", \"perfectly\", \"positively\", \"thoroughly\", \"utterly\", \"very\", \"altogether\", \"completely\", \"decidedly\", \"deeply\", \"perfectly\", \"positively\", \"thoroughly\", \"utterly\", \"very\", \"altogether\", \"completely\", \"decidedly\", \"deeply\", \"perfectly\", \"positively\", \"thoroughly\", \"utterly\", \"very\", \"altogether\", \"completely\", \"decidedly\", \"deeply\", \"perfectly\", \"positively\", \"thoroughly\", \"utterly\", \"very\", \"altogether\", \"completely\", \"decidedly\", \"deeply\", \"perfectly\", \"positively\", \"thoroughly\", \"utterly\", \"very\", \"altogether\", \"completely\", \"decidedly\", \"deeply\", \"perfectly\", \"positively\", \"thoroughly\", \"utterly\", \"",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.empty()) {\n        return -1;\n    }\n    return m.position(1);",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"angrily\", \"loudly\", \"quietly\", \"sadly\", \"madly\", \"badly\", \"suddenly\", \"gently\", \"finally\", \"kindly\", \"politely\", \"lazily\", \"lately\", \"early\", \"eagerly\", \"easily\", \"elegantly\", \"equally\", \"especially\", \"evenly\", \"eventually\", \"exactly\", \"faithfully\", \"famously\", \"far\", \"fast\", \"fatally\", \"favorably\", \"fearfully\", \"fervently\", \"fiercely\", \"fondly\", \"foolishly\", \"fortunately\", \"frankly\", \"frantically\", \"freely\", \"frequently\", \"frightfully\", \"fully\", \"furiously\", \"generally\", \"generously\", \"gently\", \"gladly\", \"gracefully\", \"gratefully\", \"greatly\", \"greedily\", \"happily\", \"hastily\", \"healthily\", \"heavily\", \"helpfully\", \"highly\", \"honestly\", \"hopelessly\", \"hourly\", \"hungrily\", \"immediately\", \"innocently\", \"inquisitively\", \"irritably\", \"jaggedly\", \"jealously\", \"jovially\", \"joyfully\", \"joyously\", \"jubilantly\", \"judgementally\", \"justly\", \"keenly\", \"kiddingly\", \"kindheartedly\", \"kindly\", \"kissingly\", \"knavishly\", \"knottily\", \"knowingly\", \"knowledgeably\", \"kookily\", \"lazily\", \"less\", \"lightly\", \"likely\", \"limply\", \"lively\", \"loftily\", \"longingly\", \"loosely\", \"loudly\", \"lovingly\", \"loyally\", \"madly\", \"majestically\", \"meaningfully\", \"mechanically\", \"merrily\", \"miserably\", \"mockingly\", \"monthly\", \"more\", \"mortally\", \"mostly\", \"mysteriously\", \"naturally\", \"nearly\", \"neatly\", \"needily\", \"nervously\", \"",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string text_copy = text;\n    std::transform(text_copy.begin(), text_copy.end(), text_copy.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        std::size_t found = text_copy.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(-1);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0L);",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if(std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex adverb(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return match.str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    if(std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return \"No adverb found\";",
    "    std::regex r(\"(\\\\w+)ly\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 1) {\n        return m[1].str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.position());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(\"No adverb found\");",
    "    std::string adverb = \"\";\n    long position = -1;\n    std::stringstream ss(text);\n    std::string word;\n    long i = 0;\n    while (ss >> word) {\n        if (word.back() == 'y' && word.size() > 3) {\n            adverb = word;\n            position = i;\n            break;\n        }\n        i++;\n    }\n    if (adverb == \"\") {\n        return Union_std_string_long(position);\n    }\n    return Union_std_string_long(adverb);",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match[0];\n    }\n    return -1;",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i] == \"quickly\" || words[i] == \"slowly\" || words[i] == \"happily\" || words[i] == \"sadly\") {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 1) {\n        return Union_std_string_long(m.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    } else {\n        return Union_std_string_long(adverb_match.str());\n    }",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"quietly\"};\n    for (int i = 0; i < 5; i++) {\n        size_t pos = text.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return adverbs[i];\n        }\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position();\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return match.str(0);\n    }\n    return -1;",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(0);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if(adverb_match.size() > 0) {\n        return adverb_match[0];\n    } else {\n        return -1;\n    }",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match[1].str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]*ly\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    int pos = 0;\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        std::cout << \"Adverb found at position \" << adverb_match.position(0) << \": \" << adverb_match[0] << '\\n';\n        pos = adverb_match.position(0);\n        searchStart += adverb_match.position(0) + adverb_match.length(0);\n    }\n    return Union_std_string_long(pos);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(0);\n    }\n    return -1;",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if(adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::string adverbs[5] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string::size_type pos = text.find(adverbs[0]);\n    if (pos != std::string::npos) {\n        return pos;\n    }\n    pos = text.find(adverbs[1]);\n    if (pos != std::string::npos) {\n        return pos;\n    }\n    pos = text.find(adverbs[2]);\n    if (pos != std::string::npos) {\n        return pos;\n    }\n    pos = text.find(adverbs[3]);\n    if (pos != std::string::npos) {\n        return pos;\n    }\n    pos = text.find(adverbs[4]);\n    if (pos != std::string::npos) {\n        return pos;\n    }\n    return \"Not found\";",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"sadly\", \"happily\"};\n    std::string adverb;\n    long position = -1;\n    for (int i = 0; i < 5; i++) {\n        if (text.find(adverbs[i]) != std::string::npos) {\n            adverb = adverbs[i];\n            position = text.find(adverbs[i]);\n            break;\n        }\n    }\n    if (position == -1) {\n        return Union_std_string_long(adverb);\n    } else {\n        return Union_std_string_long(position);\n    }",
    "    std::regex regex(R\"((\\w+ly))\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"\";",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(0);\n    } else {\n        return -1;\n    }",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex regex(\"((\\\\w+\\\\s){0,3}(\\\\w+ly))\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), match, regex)) {\n        return Union_std_string_long(match[0]);\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'y' && words[i].back() != 'a' && words[i].back() != 'e' && words[i].back() != 'i' && words[i].back() != 'o' && words[i].back() != 'u') {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"[a-zA-Z]+ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i][words[i].size() - 1] == 'y') {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return adverb_match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"((\\\\w+\\\\s+){0,5}(quickly|slowly|well|badly))\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m[0].str();\n    } else {\n        return -1;\n    }",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'ly') {\n            return Union_std_string_long(i);\n        }\n    }\n    return Union_std_string_long(\"Not found\");",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        size_t found = text_lower.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::vector<std::string> words = split(text, ' ');\n    std::vector<std::string> adverbs = {\"quickly\", \"slowly\", \"well\", \"badly\", \"happily\", \"sadly\"};\n    std::vector<std::string>::iterator it;\n    for (int i = 0; i < words.size(); i++) {\n        it = std::find(adverbs.begin(), adverbs.end(), words[i]);\n        if (it != adverbs.end()) {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::regex regex_adverb(\"\\\\w*ly\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), match, regex_adverb)) {\n        return match.str();\n        searchStart += match.position() + match.length();\n    }\n    return -1;",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"quietly\", \"happily\", \"sadly\", \"loudly\", \"well\", \"badly\"};\n    std::string adverb;\n    int position = 0;\n    for(int i = 0; i < text.length(); i++) {\n        for(int j = 0; j < 9; j++) {\n            if(text.substr(i, adverbs[j].length()) == adverbs[j]) {\n                adverb = adverbs[j];\n                position = i;\n                return Union_std_string_long(adverb);\n            }\n        }\n    }\n    return Union_std_string_long(position);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex reg(\"\\\\w+ly\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), match, reg)) {\n        return Union_std_string_long(match.str());\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\w+ly\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), match, regex)) {\n        return Union_std_string_long(match.str());\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\w+ly\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[10] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\", \"loudly\", \"quietly\", \"angrily\", \"cheerfully\", \"merrily\"};\n    std::string adverb;\n    for (int i = 0; i < 10; i++) {\n        if (text.find(adverbs[i]) != std::string::npos) {\n            adverb = adverbs[i];\n            break;\n        }\n    }\n    if (adverb == \"\") {\n        return Union_std_string_long(0);\n    }\n    else {\n        return Union_std_string_long(adverb);\n    }",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 1) {\n        return Union_std_string_long(m.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex regex(\"\\\\b(\\\\w*ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), match, adverb_regex)) {\n        return Union_std_string_long(match[0]);\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\w*ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match[0].str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\b(\\\\w*ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, re);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str());",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.position(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.position();\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return adverb_match.str(0);\n    } else {\n        return -1;\n    }",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'y') {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"calmly\", \"eagerly\", \"noisily\", \"happily\", \"sadly\", \"quietly\", \"greedily\", \"politely\", \"angrily\", \"cheerfully\", \"foolishly\", \"merrily\", \"annoyingly\", \"crazily\", \"lazily\", \"loudly\", \"madly\", \"nervously\", \"obnoxiously\", \"powerfully\", \"rudely\", \"shyly\", \"tenderly\", \"violently\", \"wildly\", \"anxiously\", \"bashfully\", \"carefully\", \"cautiously\", \"elegantly\", \"frantically\", \"gracefully\", \"hastily\", \"jealously\", \"joyfully\", \"kindly\", \"mysteriously\", \"patiently\", \"perfectly\", \"playfully\", \"precisely\", \"quickly\", \"rapidly\", \"recklessly\", \"roughly\", \"rudely\", \"sadly\", \"selfishly\", \"seriously\", \"shakily\", \"sharply\", \"silently\", \"sleepily\", \"smoothly\", \"softly\", \"strongly\", \"suddenly\", \"suspiciously\", \"tenderly\", \"tensely\", \"thoughtfully\", \"tightly\", \"vivaciously\", \"warmly\", \"wearily\", \"wickedly\", \"wisely\", \"zealously\", \"zestfully\"};\n    std::string text_lower = \"\";\n    for (int i = 0; i < text.length(); i++) {\n        text_lower += tolower(text[i]);\n    }\n    for (int i = 0; i < sizeof(adverbs) / sizeof(adverbs[0]); i++) {\n        if (text_lower.find(adverbs[i]) != std::string::npos) {\n            return adverbs[i];\n        }\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(-1);",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex_adverb)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex_adverb)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\w+ly\");\n    std::smatch match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), match, regex)) {\n        return Union_std_string_long(match.str());\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch matches;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), matches, adverb_regex)) {\n        return Union_std_string_long(matches[0]);\n        searchStart += matches.position() + matches.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"eagerly\", \"happily\", \"sadly\", \"angrily\", \"cheerfully\", \"quietly\", \"loudly\", \"honestly\", \"politely\", \"faithfully\", \"foolishly\", \"merrily\", \"hungrily\", \"sleepily\", \"noisily\", \"hungrily\", \"sleepily\", \"noisily\", \"annoyingly\", \"excitedly\", \"jealously\", \"kindly\", \"obediently\", \"obnoxiously\", \"powerfully\", \"rudely\", \"selfishly\", \"stubbornly\", \"suspiciously\", \"tenderly\", \"vivaciously\", \"warmly\", \"wickedly\", \"worriedly\", \"zealously\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    std::stringstream ss(text_lower);\n    std::string word;\n    int position = 0;\n    while (ss >> word) {\n        for (int i = 0; i < sizeof(adverbs) / sizeof(adverbs[0]); i++) {\n            if (word == adverbs[i]) {\n                return Union_std_string_long(word);\n            }\n        }\n        position += word.length() + 1;\n    }\n    return Union_std_string_long(position);",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::vector<std::string> words = split(text, ' ');\n    std::vector<std::string> adverbs = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < adverbs.size(); j++) {\n            if (words[i] == adverbs[j]) {\n                return Union_std_string_long(adverbs[j]);\n            }\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\", \"lazily\", \"loudly\", \"quietly\", \"angrily\", \"cheerfully\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 10; i++) {\n        size_t found = text_lower.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if(m.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(m.str(1));",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m.position(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 2) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"[a-zA-Z]+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::string adverb_list[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"angrily\", \"sadly\"};\n    std::string text_list[] = {};\n    std::string word_list[] = {};\n    std::string word = \"\";\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.str(0);\n    }\n    return -1;",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(m.str(1));",
    "    std::regex r(\"\\\\b[^\\\\s]+\\\\b\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), m, r)) {\n        std::string word = m.str();\n        if (word.back() == 'ly') {\n            return m.position();\n        }\n        searchStart += m.position() + m.length();\n    }\n    return -1;",
    "    std::vector<std::string> words = split(text, ' ');\n    std::vector<int> positions;\n    for (int i = 0; i < words.size(); i++) {\n        if (is_adverb(words[i])) {\n            positions.push_back(i);\n        }\n    }\n    if (positions.size() == 0) {\n        return Union_std_string_long(std::string(\"\"));\n    }\n    return Union_std_string_long(positions[0]);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string::size_type pos = 0;\n    for (int i = 0; i < 5; i++) {\n        pos = text.find(adverbs[i], pos);\n        if (pos != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'y' && words[i].size() > 3) {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.str();\n    } else {\n        return -1;\n    }",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex_adverb)) {\n        return match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"eagerly\", \"happily\", \"sadly\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 6; i++) {\n        size_t found = text_lower.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[\\\\w]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"quietly\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        if (text_lower.find(adverbs[i]) != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(?:[a-zA-Z]+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\w*ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return Union_std_string_long(m.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(-1);",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i][words[i].size() - 1] == 'y') {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 2) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\w*ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position();\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match[0]);\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    auto words_begin = std::sregex_iterator(text.begin(), text.end(), adverb_regex);\n    auto words_end = std::sregex_iterator();\n    std::vector<std::string> adverbs;\n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;\n        std::string match_str = match.str();\n        adverbs.push_back(match_str);\n    }\n    if (adverbs.size() > 0) {\n        return Union_std_string_long(adverbs[0]);\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return -1;\n    }\n    return adverb_match.str(1);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"angrily\", \"sadly\", \"loudly\", \"quietly\", \"noisily\", \"silently\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 12; i++) {\n        if (text_lower.find(adverbs[i]) != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex) && match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return std::string(\"\");",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\w+ly\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 0) {\n        return Union_std_string_long(m.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 0) {\n        return Union_std_string_long(m[0].str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverb = \"\";\n    std::string adverb_pos = \"\";\n    std::string adverb_pos_list = \"\";\n    std::string adverb_pos_list_temp = \"\";\n    std::string adverb_pos_list_temp_2 = \"\";\n    std::string adverb_pos_list_temp_3 = \"\";\n    std::string adverb_pos_list_temp_4 = \"\";\n    std::string adverb_pos_list_temp_5 = \"\";\n    std::string adverb_pos_list_temp_6 = \"\";\n    std::string adverb_pos_list_temp_7 = \"\";\n    std::string adverb_pos_list_temp_8 = \"\";\n    std::string adverb_pos_list_temp_9 = \"\";\n    std::string adverb_pos_list_temp_10 = \"\";\n    std::string adverb_pos_list_temp_11 = \"\";\n    std::string adverb_pos_list_temp_12 = \"\";\n    std::string adverb_pos_list_temp_13 = \"\";\n    std::string adverb_pos_list_temp_14 = \"\";\n    std::string adverb_pos_list_temp_15 = \"\";\n    std::string adverb_pos_list_temp_16 = \"\";\n    std::string adverb_pos_list_temp_17 = \"\";\n    std::string adverb_pos_list_temp_18 = \"\";\n    std::string adverb_pos_list_temp_19 = \"\";\n    std::string adverb_pos_list_temp_20 = \"\";\n    std::string adverb_pos_list_temp_21 = \"\";\n    std::string adverb_pos_list_temp_22 = \"\";\n    std::string adverb_pos_list_temp_23 = \"\";\n    std::string adverb_pos_list_temp_24 = \"\";\n    std::string adverb_pos_list_temp_25 = \"\";\n    std::string adverb_pos_list_temp_26 = \"\";\n    std::string adverb_pos_",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\", \"loudly\", \"quietly\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 7; i++) {\n        size_t found = text_lower.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);"
  ]
}