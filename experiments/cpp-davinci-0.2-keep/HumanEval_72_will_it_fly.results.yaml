name: HumanEval_72_will_it_fly
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (long i = 0; i < q.size() / 2; i++) {\n\t\t\t\
    if (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tfor(int i=0;i<q.size()/2;i++)\n\t\t{\n\t\t\tif(q[i]!=q[q.size()-1-i])\n\
    \t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tfor(int i=0;i<q.size()/2;i++)\n\t\t{\n\t\t\tif(q[i]!=q[q.size()-1-i])\n\
    \t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q) {\n\t\tsum += i;\n\t}\n\tif (sum >\
    \ w) {\n\t\treturn false;\n\t}\n\tstd::vector<long> temp = q;\n\tstd::reverse(temp.begin(),\
    \ temp.end());\n\tif (temp == q) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q) {\n\t\tsum += i;\n\t}\n\tif (sum >\
    \ w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\
    \tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tint sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tint\
    \ i = 0;\n\t\tint j = q.size() - 1;\n\t\twhile (i < j)\n\t\t{\n\t\t\tif (q[i]\
    \ != q[j])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\
    \t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\t// Your code here\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size();\
    \ i++) {\n\t\tsum += q[i];\n\t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\t\
    else {\n\t\tint i = 0;\n\t\tint j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\t\
    if (q[i] != q[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\
    \t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q)\n\t\tsum += i;\n\tif (sum > w)\n\t\
    \treturn false;\n\tint i = 0, j = q.size() - 1;\n\twhile (i < j) {\n\t\tif (q[i]\
    \ != q[j])\n\t\t\treturn false;\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tfor(int i=0;i<q.size()/2;i++)\n\t\t{\n\t\t\tif(q[i]!=q[q.size()-1-i])\n\
    \t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tstd::vector<long>\
    \ temp;\n\t\tfor (int i = q.size() - 1; i >= 0; i--) {\n\t\t\ttemp.push_back(q[i]);\n\
    \t\t}\n\t\tfor (int i = 0; i < q.size(); i++) {\n\t\t\tif (q[i] != temp[i]) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (long i = 0; i < q.size() / 2; i++) {\n\t\t\t\
    if (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tfor\
    \ (int i = 0; i < q.size() / 2; i++)\n\t\t{\n\t\t\tif (q[i] != q[q.size() - 1\
    \ - i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q) {\n\t\tsum += i;\n\t}\n\tif (sum >\
    \ w) {\n\t\treturn false;\n\t}\n\tlong n = q.size();\n\tfor (int i = 0; i < n\
    \ / 2; i++) {\n\t\tif (q[i] != q[n - i - 1]) {\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q)\n\t\tsum += i;\n\tif (sum > w)\n\t\
    \treturn false;\n\tfor (int i = 0; i < q.size() / 2; i++)\n\t\tif (q[i] != q[q.size()\
    \ - i - 1])\n\t\t\treturn false;\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tfor\
    \ (int i = 0; i < q.size() / 2; i++)\n\t\t{\n\t\t\tif (q[i] != q[q.size() - 1\
    \ - i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tfor(int i=0;i<q.size()/2;i++)\n\t\t{\n\t\t\tif(q[i]!=q[q.size()-1-i])\n\
    \t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tstd::vector<long>\
    \ q_rev;\n\t\tfor (int i = q.size() - 1; i >= 0; i--) {\n\t\t\tq_rev.push_back(q[i]);\n\
    \t\t}\n\t\tfor (int i = 0; i < q.size(); i++) {\n\t\t\tif (q[i] != q_rev[i]) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(long i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tlong i=0,j=q.size()-1;\n\t\twhile(i<j)\n\t\t{\n\t\t\t\
    if(q[i]!=q[j])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\
    \t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tint sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\treturn\
    \ true;\n\t}\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: "tmptvn191zt: /tmp/tmptvn191zt.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q) {\n\t\tsum += i;\n\t}\n\tif (sum >\
    \ w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\
    \tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tint flag=0;\n\t\tfor(int i=0;i<q.size()/2;i++)\n\t\t\
    {\n\t\t\tif(q[i]!=q[q.size()-1-i])\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif(flag==0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\
    \t{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tlong sum1 = 0;\n\t\
    \tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tsum1 += q[i];\n\t\t}\n\t\tlong\
    \ sum2 = 0;\n\t\tfor (int i = q.size() - 1; i >= q.size() / 2; i--) {\n\t\t\t\
    sum2 += q[i];\n\t\t}\n\t\tif (sum1 == sum2) {\n\t\t\treturn true;\n\t\t}\n\t\t\
    else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: "tmpvyp1nw3s: /tmp/tmpvyp1nw3s.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (long i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tint sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tfor\
    \ (int i = 0; i < q.size() / 2; i++)\n\t\t{\n\t\t\tif (q[i] != q[q.size() - 1\
    \ - i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (long i = 0; i < q.size() / 2; i++) {\n\t\t\t\
    if (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tstd::vector<long>\
    \ q2 = q;\n\t\tstd::reverse(q2.begin(), q2.end());\n\t\tif (q == q2) {\n\t\t\t\
    return true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tstd::vector<long> q_copy = q;\n\
    \tstd::reverse(q_copy.begin(), q_copy.end());\n\tif (q == q_copy) {\n\t\treturn\
    \ true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n    long sum = 0;\n    for(int i = 0; i < q.size(); i++){\n        sum\
    \ += q[i];\n    }\n    if(sum > w){\n        return false;\n    }\n    else{\n\
    \        for(int i = 0; i < q.size()/2; i++){\n            if(q[i] != q[q.size()-1-i]){\n\
    \                return false;\n            }\n        }\n        return true;\n\
    \    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (long i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q)\n\t\tsum += i;\n\tif (sum > w)\n\t\
    \treturn false;\n\tstd::vector<long> q2 = q;\n\tstd::reverse(q2.begin(), q2.end());\n\
    \tif (q == q2)\n\t\treturn true;\n\treturn false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tfor\
    \ (int i = 0; i < q.size() / 2; i++)\n\t\t{\n\t\t\tif (q[i] != q[q.size() - 1\
    \ - i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn\
    \ false;\n\t}\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: "tmpdxuu9bv4: /tmp/tmpdxuu9bv4.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tstd::vector<long>\
    \ q2 = q;\n\t\tstd::reverse(q2.begin(), q2.end());\n\t\tif (q == q2) {\n\t\t\t\
    return true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tlong left = 0;\n\t\tlong right = q.size() - 1;\n\t\
    \twhile (left < right) {\n\t\t\tif (q[left] != q[right]) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\tleft++;\n\t\t\tright--;\n\t\t}\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tfor(int i=0;i<q.size()/2;i++)\n\t\t{\n\t\t\tif(q[i]!=q[q.size()-1-i])\n\
    \t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q)\n\t\tsum += i;\n\tif (sum > w)\n\t\
    \treturn false;\n\tfor (int i = 0; i < q.size() / 2; i++)\n\t\tif (q[i] != q[q.size()\
    \ - i - 1])\n\t\t\treturn false;\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q)\n\t\tsum += i;\n\tif (sum > w)\n\t\
    \treturn false;\n\telse\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\t\t\
    {\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t\treturn false;\n\t\t}\n\t\t\
    return true;\n\t}\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (long i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tint sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t}\n\
    \tif(sum<=w)\n\t{\n\t\tstd::vector<long>::iterator it;\n\t\tstd::vector<long>::iterator\
    \ it1;\n\t\tit=q.begin();\n\t\tit1=q.end()-1;\n\t\twhile(it<it1)\n\t\t{\n\t\t\t\
    if(*it!=*it1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tit++;\n\t\t\tit1--;\n\
    \t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (long i = 0; i < q.size() / 2; i++) {\n\t\t\t\
    if (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\t// Write your code here\n\tlong sum = 0;\n\tfor(int i = 0; i < q.size();\
    \ i++)\n\t{\n\t\tsum += q[i];\n\t}\n\tif(sum > w)\n\t{\n\t\treturn false;\n\t\
    }\n\telse\n\t{\n\t\tfor(int i = 0; i < q.size()/2; i++)\n\t\t{\n\t\t\tif(q[i]\
    \ != q[q.size()-1-i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ true;\n\t}\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tfor\
    \ (int i = 0; i < q.size() / 2; i++)\n\t\t{\n\t\t\tif (q[i] != q[q.size() - 1\
    \ - i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum=0;\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tsum+=q[i];\n\t\
    }\n\tif(sum<=w)\n\t{\n\t\tfor(int i=0;i<q.size()/2;i++)\n\t\t{\n\t\t\tif(q[i]!=q[q.size()-1-i])\n\
    \t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum <= w)\n\t{\n\t\tfor (int i = 0; i < q.size() / 2; i++)\n\
    \t\t{\n\t\t\tif (q[i] != q[q.size() - 1 - i])\n\t\t\t{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tfor\
    \ (int i = 0; i < q.size() / 2; i++)\n\t\t{\n\t\t\tif (q[i] != q[q.size() - 1\
    \ - i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tstd::vector<long>\
    \ temp = q;\n\t\tstd::reverse(temp.begin(), temp.end());\n\t\tif (temp == q) {\n\
    \t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q) {\n\t\tsum += i;\n\t}\n\tif (sum >\
    \ w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tlong n = q.size();\n\t\tfor (long\
    \ i = 0; i < n / 2; i++) {\n\t\t\tif (q[i] != q[n - i - 1]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (auto i : q)\n\t\tsum += i;\n\tif (sum > w)\n\t\
    \treturn false;\n\tlong n = q.size();\n\tfor (int i = 0; i < n / 2; i++)\n\t\t\
    if (q[i] != q[n - i - 1])\n\t\t\treturn false;\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (long i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tint sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (long i = 0; i < q.size() / 2; i++) {\n\t\t\t\
    if (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tstd::vector<long>\
    \ temp = q;\n\t\tstd::reverse(temp.begin(), temp.end());\n\t\tif (temp == q) {\n\
    \t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) return false;\n\tfor (int i = 0; i < q.size() / 2; i++) {\n\
    \t\tif (q[i] != q[q.size() - 1 - i]) return false;\n\t}\n\treturn true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (long i = 0;\
    \ i < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tif (q.size() == 1)\n\t\treturn true;\n\tlong sum = 0;\n\tfor (int i\
    \ = 0; i < q.size(); i++)\n\t\tsum += q[i];\n\tif (sum > w)\n\t\treturn false;\n\
    \tint i = 0, j = q.size() - 1;\n\twhile (i < j) {\n\t\tif (q[i] != q[j])\n\t\t\
    \treturn false;\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\nint main() {\n  \
    \  auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: "tmpct2j3rue: /tmp/tmpct2j3rue.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tstd::vector<long>::iterator\
    \ it = q.begin();\n\t\tstd::vector<long>::iterator it1 = q.end() - 1;\n\t\twhile\
    \ (it < it1)\n\t\t{\n\t\t\tif (*it != *it1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\
    \t\t}\n\t\t\tit++;\n\t\t\tit1--;\n\t\t}\n\t\treturn true;\n\t}\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tint i = 0;\n\t\t\
    int j = q.size() - 1;\n\t\twhile (i < j) {\n\t\t\tif (q[i] != q[j]) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++)\n\t{\n\t\tsum +=\
    \ q[i];\n\t}\n\tif (sum > w)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tfor\
    \ (int i = 0; i < q.size() / 2; i++)\n\t\t{\n\t\t\tif (q[i] != q[q.size() - 1\
    \ - i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum <= w) {\n\t\tfor (int i = 0; i < q.size() / 2; i++) {\n\t\t\tif\
    \ (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\
    return true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1,\
    \ 2], 5) \u279E False \n// # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279E False\n// # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3],\
    \ 9) \u279E True\n// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n// will_it_fly([3], 5) \u279E True\n// # 3 is less than the maximum\
    \ possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long\
    \ w) {\n\tlong sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\
    \t}\n\tif (sum > w) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (int i = 0; i\
    \ < q.size() / 2; i++) {\n\t\t\tif (q[i] != q[q.size() - 1 - i]) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
