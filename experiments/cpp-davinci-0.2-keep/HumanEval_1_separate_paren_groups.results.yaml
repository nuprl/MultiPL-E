language: cpp
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                return result;\n            }\n            st.pop();\n  \
    \          if(st.empty()) {\n                result.push_back(temp);\n       \
    \         temp = \"\";\n            }\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpnyor0bki: /tmp/tmpnyor0bki.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp.push_back(paren_string[i]);\n            if(stk.empty()) {\n\
    \                result.push_back(temp);\n                temp.clear();\n    \
    \        }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpd28oomzj: /tmp/tmpd28oomzj.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += '(';\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += ')';\n        }\n        if (open == 0 && temp.size() > 0) {\n   \
    \         result.push_back(temp);\n            temp = \"\";\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                return result;\n            }\n            st.pop();\n  \
    \          if(st.empty()) {\n                result.push_back(temp);\n       \
    \         temp = \"\";\n            }\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpnyor0bki: /tmp/tmpnyor0bki.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            if(stk.empty()) {\n                result.push_back(temp);\n    \
    \            temp.clear();\n            }\n        }\n        else {\n       \
    \     temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmppe7akkum: /tmp/tmppe7akkum.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int open_count =\
    \ 0;\n    int close_count = 0;\n    std::string temp;\n    for (int i = 0; i <\
    \ paren_string.length(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       open_count++;\n            temp += paren_string[i];\n        } else if\
    \ (paren_string[i] == ')') {\n            close_count++;\n            temp +=\
    \ paren_string[i];\n        }\n        if (open_count == close_count) {\n    \
    \        result.push_back(temp);\n            temp = \"\";\n            open_count\
    \ = 0;\n            close_count = 0;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdmaxjcy4: /tmp/tmpdmaxjcy4.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            count--;\n        }\n   \
    \     if (count == 0) {\n            end = i;\n            result.push_back(paren_string.substr(start,\
    \ end-start+1));\n            start = i+1;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpj8yrfpmq: /tmp/tmpj8yrfpmq.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  int open = 0;\n  int\
    \ close = 0;\n  std::string temp = \"\";\n  for (int i = 0; i < paren_string.length();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      open++;\n      temp += paren_string[i];\n\
    \    } else if (paren_string[i] == ')') {\n      close++;\n      temp += paren_string[i];\n\
    \    }\n    if (open == close) {\n      result.push_back(temp);\n      temp =\
    \ \"\";\n      open = 0;\n      close = 0;\n    }\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmprcgnfyvv: /tmp/tmprcgnfyvv.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                return result;\n            }\n            st.pop();\n  \
    \          if(st.empty()) {\n                result.push_back(temp);\n       \
    \         temp = \"\";\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp40_7m2av: /tmp/tmp40_7m2av.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int counter = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            counter++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    counter--;\n            temp += paren_string[i];\n        }\n        if (counter\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int count = 0;\n\
    \    std::string temp = \"\";\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ continue;\n        }\n        if(stk.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdv6jmq0x: /tmp/tmpdv6jmq0x.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(s.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp6k4kpgxm: /tmp/tmp6k4kpgxm.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            if(stk.empty()) {\n                result.push_back(temp);\n    \
    \            temp.clear();\n            }\n        }\n        temp += paren_string[i];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpq_ua23_u: /tmp/tmpq_ua23_u.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpg7_rtx4t: /tmp/tmpg7_rtx4t.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> ret;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            ret.push_back(temp);\n            temp\
    \ = \"\";\n        }\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  std::string temp;\n \
    \ int count = 0;\n  for (int i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      count++;\n      temp += paren_string[i];\n    } else if (paren_string[i]\
    \ == ')') {\n      count--;\n      temp += paren_string[i];\n    }\n    if (count\
    \ == 0 && temp.size() > 0) {\n      result.push_back(temp);\n      temp = \"\"\
    ;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += paren_string[i];\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpg7_rtx4t: /tmp/tmpg7_rtx4t.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ continue;\n        }\n        if(stk.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdv6jmq0x: /tmp/tmpdv6jmq0x.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                return result;\n            }\n            else {\n     \
    \           st.pop();\n                temp += paren_string[i];\n            }\n\
    \        }\n        else {\n            continue;\n        }\n        if(st.empty())\
    \ {\n            result.push_back(temp);\n            temp = \"\";\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmplxkpqof4: /tmp/tmplxkpqof4.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ continue;\n        }\n        if(st.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp2xvk0m2k: /tmp/tmp2xvk0m2k.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else {\n        \
    \    temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp_ecc_j51: /tmp/tmp_ecc_j51.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            temp += paren_string[i];\n        } else if (paren_string[i]\
    \ == ')') {\n            temp += paren_string[i];\n            result.push_back(temp);\n\
    \            temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpxhp87h4l: /tmp/tmpxhp87h4l.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(stk.empty())\
    \ {\n                return result;\n            }\n            stk.pop();\n \
    \           if(stk.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else {\n        \
    \    temp.push_back(paren_string[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpmj18f17g: /tmp/tmpmj18f17g.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            open_count++;\n            temp += c;\n        } else if\
    \ (c == ')') {\n            open_count--;\n            temp += c;\n        }\n\
    \        if (open_count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n\
    \            temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpcpxhdcub: /tmp/tmpcpxhdcub.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            open_count++;\n          \
    \  temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n  \
    \          open_count--;\n            temp += paren_string[i];\n        }\n  \
    \      if (open_count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ paren_stack;\n    std::string temp;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_stack.push(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            if (paren_stack.empty())\
    \ {\n                return result;\n            }\n            paren_stack.pop();\n\
    \        }\n        if (paren_stack.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        } else {\n            temp += paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp94ka9abg: /tmp/tmp94ka9abg.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(stk.empty())\
    \ {\n                return result;\n            }\n            else {\n     \
    \           stk.pop();\n                temp += paren_string[i];\n           \
    \     if(stk.empty()) {\n                    result.push_back(temp);\n       \
    \             temp.clear();\n                }\n            }\n        }\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpvddgr07z: /tmp/tmpvddgr07z.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp.push_back(paren_string[i]);\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp7_og_crr: /tmp/tmp7_og_crr.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(char c : paren_string) {\n        if(c ==\
    \ ' ') continue;\n        if(c == '(') {\n            st.push(c);\n        } else\
    \ {\n            if(st.size() == 1) {\n                st.pop();\n           \
    \     result.push_back(temp);\n                temp = \"\";\n            } else\
    \ {\n                st.pop();\n                temp += c;\n            }\n  \
    \      }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpylzp5rxv: /tmp/tmpylzp5rxv.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            count--;\n        }\n   \
    \     if (count == 0) {\n            end = i;\n            result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            start = i + 1;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmppnnpm_ol: /tmp/tmppnnpm_ol.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    int start = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            st.pop();\n       \
    \ }\n        if (st.empty()) {\n            result.push_back(paren_string.substr(start,\
    \ i - start + 1));\n            start = i + 1;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmptswb7mjn: /tmp/tmptswb7mjn.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1b7d0szo: /tmp/tmp1b7d0szo.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int open_paren_count\
    \ = 0;\n    std::string current_paren_group;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            open_paren_count++;\n\
    \            current_paren_group += paren_string[i];\n        } else if (paren_string[i]\
    \ == ')') {\n            open_paren_count--;\n            current_paren_group\
    \ += paren_string[i];\n            if (open_paren_count == 0) {\n            \
    \    result.push_back(current_paren_group);\n                current_paren_group\
    \ = \"\";\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stack;\n    std::string temp;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            stack.push(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            if (stack.empty())\
    \ {\n                return result;\n            }\n            stack.pop();\n\
    \        }\n        if (stack.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        } else {\n            temp += paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpmdtc5dwm: /tmp/tmpmdtc5dwm.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  std::stack<char> st;\n\
    \  std::string temp;\n  for(int i = 0; i < paren_string.size(); i++) {\n    if(paren_string[i]\
    \ == '(') {\n      st.push(paren_string[i]);\n    }\n    else if(paren_string[i]\
    \ == ')') {\n      st.pop();\n      temp += paren_string[i];\n    }\n    else\
    \ if(paren_string[i] == ' ') {\n      if(st.empty()) {\n        result.push_back(temp);\n\
    \        temp = \"\";\n      }\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpahr7xoxs: /tmp/tmpahr7xoxs.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                return result;\n            }\n            else {\n     \
    \           st.pop();\n                temp += paren_string[i];\n            \
    \    if(st.empty()) {\n                    result.push_back(temp);\n         \
    \           temp = \"\";\n                }\n            }\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpmejl9e9e: /tmp/tmpmejl9e9e.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            if(s.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpnhlv7iyi: /tmp/tmpnhlv7iyi.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpcpxhdcub: /tmp/tmpcpxhdcub.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            open_count++;\n          \
    \  temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n  \
    \          open_count--;\n            temp += paren_string[i];\n        }\n  \
    \      if (open_count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int count = 0;\n\
    \    std::string temp;\n    for (int i = 0; i < paren_string.length(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(st.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp0j5y906c: /tmp/tmp0j5y906c.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += paren_string[i];\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += paren_string[i];\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(!s.empty())\
    \ {\n                s.pop();\n                temp += paren_string[i];\n    \
    \        }\n            if(s.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp2p1mnova: /tmp/tmp2p1mnova.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                return result;\n            }\n            st.pop();\n  \
    \          if(st.empty()) {\n                result.push_back(temp);\n       \
    \         temp = \"\";\n            }\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpnyor0bki: /tmp/tmpnyor0bki.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            if(stk.empty()) {\n                result.push_back(temp);\n    \
    \            temp.clear();\n            }\n        }\n        else {\n       \
    \     temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmppe7akkum: /tmp/tmppe7akkum.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  int start = 0;\n  int\
    \ end = 0;\n  int open_paren_count = 0;\n  int close_paren_count = 0;\n  for (int\
    \ i = 0; i < paren_string.length(); i++) {\n    if (paren_string[i] == '(') {\n\
    \      open_paren_count++;\n    } else if (paren_string[i] == ')') {\n      close_paren_count++;\n\
    \    }\n    if (open_paren_count == close_paren_count) {\n      end = i;\n   \
    \   result.push_back(paren_string.substr(start, end - start + 1));\n      start\
    \ = end + 1;\n      open_paren_count = 0;\n      close_paren_count = 0;\n    }\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpc4k6u5gy: /tmp/tmpc4k6u5gy.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        if (paren_string[i] ==\
    \ '(') {\n            temp.push_back(paren_string[i]);\n        }\n        if\
    \ (paren_string[i] == ')') {\n            temp.push_back(paren_string[i]);\n \
    \           result.push_back(temp);\n            temp.clear();\n        }\n  \
    \  }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp9_8e3vlg: /tmp/tmp9_8e3vlg.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(stk.empty())\
    \ {\n                continue;\n            }\n            else {\n          \
    \      stk.pop();\n                temp += paren_string[i];\n            }\n \
    \       }\n        else {\n            continue;\n        }\n        if(stk.empty())\
    \ {\n            result.push_back(temp);\n            temp.clear();\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp8fvndj2m: /tmp/tmp8fvndj2m.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') continue;\n        if(paren_string[i]\
    \ == '(') {\n            st.push(paren_string[i]);\n        } else {\n       \
    \     if(st.empty()) {\n                result.push_back(temp);\n            \
    \    temp = \"\";\n            } else {\n                st.pop();\n         \
    \   }\n        }\n        temp += paren_string[i];\n    }\n    if(!temp.empty())\
    \ result.push_back(temp);\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp38hr9hy1: /tmp/tmp38hr9hy1.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp = \"\";\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ continue;\n        }\n        if(s.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp53aerfwe: /tmp/tmp53aerfwe.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(s.empty())\
    \ {\n                return result;\n            }\n            else {\n     \
    \           temp += s.top();\n                s.pop();\n                temp +=\
    \ paren_string[i];\n                if(s.empty()) {\n                    result.push_back(temp);\n\
    \                    temp = \"\";\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpczq1q_pk: /tmp/tmpczq1q_pk.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stack;\n    std::string temp;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            stack.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stack.pop();\n\
    \            if(stack.empty()) {\n                result.push_back(temp);\n  \
    \              temp = \"\";\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmplvopx745: /tmp/tmplvopx745.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(s.top()\
    \ == '(') {\n                s.pop();\n                temp += ')';\n        \
    \    }\n            if(s.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp0mbuissu: /tmp/tmp0mbuissu.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else {\n        \
    \    temp.push_back(paren_string[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpigzxf20c: /tmp/tmpigzxf20c.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpcpxhdcub: /tmp/tmpcpxhdcub.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp7m4jlgke: /tmp/tmp7m4jlgke.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp = \"\";\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp2xsrl2t7: /tmp/tmp2xsrl2t7.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            count++;\n            temp += c;\n        } else if (c == ')')\
    \ {\n            count--;\n            temp += c;\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else {\n        \
    \    temp.push_back(paren_string[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpigzxf20c: /tmp/tmpigzxf20c.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> groups;\n    std::string group\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      group += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            group += paren_string[i];\n        }\n    \
    \    if (count == 0 && group != \"\") {\n            groups.push_back(group);\n\
    \            group = \"\";\n        }\n    }\n    return groups;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            open_count++;\n          \
    \  temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n  \
    \          open_count--;\n            temp += paren_string[i];\n        }\n  \
    \      if (open_count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else {\n         \
    \   temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp3rtztlt2: /tmp/tmp3rtztlt2.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(stk.empty())\
    \ {\n                return result;\n            }\n            else {\n     \
    \           stk.pop();\n                if(stk.empty()) {\n                  \
    \  result.push_back(temp);\n                    temp.clear();\n              \
    \  }\n            }\n        }\n        else if(paren_string[i] != ' ') {\n  \
    \          temp += paren_string[i];\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp9vs7ijh7: /tmp/tmp9vs7ijh7.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            open_count++;\n          \
    \  temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n  \
    \          open_count--;\n            temp += paren_string[i];\n        }\n  \
    \      if (open_count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1b7d0szo: /tmp/tmp1b7d0szo.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += '(';\n        }\n        else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += ')';\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n\
    \            open++;\n            temp += c;\n        } else if (c == ')') {\n\
    \            open--;\n            temp += c;\n        }\n        if (open == 0\
    \ && temp.size() > 0) {\n            result.push_back(temp);\n            temp\
    \ = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            open_count++;\n            temp += c;\n        } else if\
    \ (c == ')') {\n            open_count--;\n            temp += c;\n        }\n\
    \        if (open_count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else {\n         \
    \   temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpd0e7hlj8: /tmp/tmpd0e7hlj8.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(s.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp6k4kpgxm: /tmp/tmp6k4kpgxm.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int open = 0;\n    for (int i = 0; i < paren_string.length(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            open++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    open--;\n            temp += paren_string[i];\n        }\n        if (open\
    \ == 0 && temp != \"\") {\n            result.push_back(temp);\n            temp\
    \ = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            if(s.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpnhlv7iyi: /tmp/tmpnhlv7iyi.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1b7d0szo: /tmp/tmp1b7d0szo.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                return result;\n            }\n            else {\n     \
    \           st.pop();\n                temp += paren_string[i];\n            \
    \    if(st.empty()) {\n                    result.push_back(temp);\n         \
    \           temp = \"\";\n                }\n            }\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpmejl9e9e: /tmp/tmpmejl9e9e.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        else {\n            temp\
    \ += paren_string[i];\n        }\n        if(st.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp6fzzudk2: /tmp/tmp6fzzudk2.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1b7d0szo: /tmp/tmp1b7d0szo.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.top()\
    \ == '(') {\n                st.pop();\n                temp += ')';\n       \
    \     }\n            if(st.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpzsbjd6rc: /tmp/tmpzsbjd6rc.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            count++;\n            temp += c;\n        } else if (c == ')')\
    \ {\n            count--;\n            temp += c;\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            if(st.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp_e1g2jux: /tmp/tmp_e1g2jux.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp.push_back(paren_string[i]);\n            if(stk.empty()) {\n\
    \                result.push_back(temp);\n                temp.clear();\n    \
    \        }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpd28oomzj: /tmp/tmpd28oomzj.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1b7d0szo: /tmp/tmp1b7d0szo.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            if(st.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp_e1g2jux: /tmp/tmp_e1g2jux.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp = \"\";\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(s.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpz39fk8b3: /tmp/tmpz39fk8b3.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else {\n         \
    \   temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpd0e7hlj8: /tmp/tmpd0e7hlj8.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            if(s.empty()) {\n                result.push_back(temp);\n\
    \                temp = \"\";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpnhlv7iyi: /tmp/tmpnhlv7iyi.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ continue;\n        }\n        if(s.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp_mgpp_39: /tmp/tmp_mgpp_39.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822756
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ continue;\n        }\n        if(stk.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdv6jmq0x: /tmp/tmpdv6jmq0x.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            count++;\n            temp += c;\n        } else if (c == ')')\
    \ {\n            count--;\n            temp += c;\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(stk.empty())\
    \ {\n                return result;\n            }\n            stk.pop();\n \
    \           if(stk.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else {\n        \
    \    temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpcu39se98: /tmp/tmpcu39se98.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822756
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            count--;\n        }\n   \
    \     if (count == 0) {\n            end = i;\n            result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            start = i + 1;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmppnnpm_ol: /tmp/tmppnnpm_ol.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(st.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp0j5y906c: /tmp/tmp0j5y906c.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            if (count == 0) {\n\
    \                start = i;\n            }\n            count++;\n        } else\
    \ if (paren_string[i] == ')') {\n            count--;\n            if (count ==\
    \ 0) {\n                end = i;\n                result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            }\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp2h5eemff: /tmp/tmp2h5eemff.cpp:35: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822756
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpg7_rtx4t: /tmp/tmpg7_rtx4t.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (auto i : paren_string) {\n        if (i == '(')\
    \ {\n            count++;\n            temp += i;\n        } else if (i == ')')\
    \ {\n            count--;\n            temp += i;\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822756
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.top()\
    \ == '(') {\n                st.pop();\n                if(st.empty()) {\n   \
    \                 result.push_back(temp);\n                    temp = \"\";\n\
    \                }\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpcrvp34do: /tmp/tmpcrvp34do.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822756
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        else {\n            temp\
    \ += paren_string[i];\n        }\n        if(st.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp6fzzudk2: /tmp/tmp6fzzudk2.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int count = 0;\n\
    \    std::string temp;\n    for (int i = 0; i < paren_string.length(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else {\n         \
    \   temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpd0e7hlj8: /tmp/tmpd0e7hlj8.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        else {\n            temp\
    \ += paren_string[i];\n        }\n        if(st.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp6fzzudk2: /tmp/tmp6fzzudk2.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp = \"\";\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp2xsrl2t7: /tmp/tmp2xsrl2t7.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == ' ') {\n            continue;\n        }\n\
    \        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp = \"\";\n            }\n        }\n        else {\n         \
    \   temp += paren_string[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpd0e7hlj8: /tmp/tmpd0e7hlj8.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int count = 0;\n\
    \    std::string temp;\n    for (int i = 0; i < paren_string.length(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822752
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp = \"\";\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp2xsrl2t7: /tmp/tmp2xsrl2t7.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822755
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(stk.empty())\
    \ {\n                return result;\n            }\n            stk.pop();\n \
    \           if(stk.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp.push_back(paren_string[i]);\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpva8q38rs: /tmp/tmpva8q38rs.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822756
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i = 0; i < paren_string.size(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            st.pop();\n\
    \            if(st.empty()) {\n                result.push_back(temp);\n     \
    \           temp.clear();\n            }\n        }\n        else if(paren_string[i]\
    \ != ' ') {\n            temp += paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpg7_rtx4t: /tmp/tmpg7_rtx4t.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            result.push_back(temp);\n          \
    \  temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822750
