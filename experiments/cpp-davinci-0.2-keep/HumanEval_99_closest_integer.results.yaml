language: cpp
name: HumanEval_99_closest_integer
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::round(val);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble d = std::stod(value);\n\treturn std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::round(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::lround(val);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  long l = std::lround(d);\n  return\
    \ l;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  return std::round(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  if (d < 0) {\n    return std::ceil(d);\n\
    \  }\n  return std::floor(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkgrk6c_s: /tmp/tmpkgrk6c_s.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::round(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    return std::ceil(num);\n\
    \  } else {\n    return std::floor(num);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpiehwwywd: /tmp/tmpiehwwywd.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  long l = std::lround(d);\n  return\
    \ l;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return (long)std::ceil(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpijjdr1_t: /tmp/tmpijjdr1_t.cpp:24: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::lround(val);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  if (num < 0) {\n    return std::ceil(num);\n\
    \  }\n  return std::floor(num);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcwxyp2gs: /tmp/tmpcwxyp2gs.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  long num = std::stol(value);\n  if(num < 0)\n\
    \  {\n    num = num - 0.5;\n  }\n  else\n  {\n    num = num + 0.5;\n  }\n  return\
    \ num;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0u05z15q: /tmp/tmp0u05z15q.cpp:32: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double num = std::stod(value);\n  if(num <\
    \ 0){\n    return (long)num - 1;\n  }\n  return (long)num;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp68sw3uhi: /tmp/tmp68sw3uhi.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double num = std::stod(value);\n    long int_num = std::lround(num);\n\
    \    return int_num;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return (long)std::round(d);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // your code here\n    double num = std::stod(value);\n    if(num\
    \ >= 0){\n        return std::ceil(num);\n    }\n    else{\n        return std::floor(num);\n\
    \    }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpng2pob2a: /tmp/tmpng2pob2a.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::lround(val);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  double floor_num = std::floor(num);\n\
    \  double ceil_num = std::ceil(num);\n  if (num - floor_num > ceil_num - num)\
    \ {\n    return ceil_num;\n  } else {\n    return floor_num;\n  }\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_imek17e: /tmp/tmp_imek17e.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  if (val >= 0) {\n    return std::ceil(val);\n\
    \  } else {\n    return std::floor(val);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqbz3_t4p: /tmp/tmpqbz3_t4p.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    return std::ceil(num);\n\
    \  } else {\n    return std::floor(num);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpiehwwywd: /tmp/tmpiehwwywd.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::round(val);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  if (d < 0) {\n    d = std::ceil(d);\n\
    \  } else {\n    d = std::floor(d);\n  }\n  return d;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmbf3y_gg: /tmp/tmpmbf3y_gg.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  long int_val = std::lround(val);\n\
    \  return int_val;\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return d > 0 ? (long)std::ceil(d)\
    \ : (long)std::floor(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpp09v8gk9: /tmp/tmpp09v8gk9.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::round(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return (long)num;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpr0povyxq: /tmp/tmpr0povyxq.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  return (long)std::round(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double val = std::stod(value);\n  int res =\
    \ (int)val;\n  if(val - res >= 0.5)\n    return res + 1;\n  else\n    return res;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphga2uf3d: /tmp/tmphga2uf3d.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  if(d>0)\n \
    \   return std::ceil(d);\n  else\n    return std::floor(d);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_h4pudz0: /tmp/tmp_h4pudz0.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  if (d < 0) {\n    return std::ceil(d);\n\
    \  }\n  return std::floor(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkgrk6c_s: /tmp/tmpkgrk6c_s.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = stod(value);\n  return round(d);\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return (long)round(val);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = stod(value);\n  if (d < 0) {\n    return (long)d - 1;\n\
    \  }\n  return (long)d;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpz3vlbpdj: /tmp/tmpz3vlbpdj.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double num = std::stod(value);\n  return std::round(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  if (d >= 0) {\n    return std::ceil(d);\n\
    \  } else {\n    return std::floor(d);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkmk7plql: /tmp/tmpkmk7plql.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::round(val);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  long l = std::lround(d);\n  return\
    \ l;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  if (val > 0) {\n    return std::ceil(val);\n\
    \  } else {\n    return std::floor(val);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyoafh3wg: /tmp/tmpyoafh3wg.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  return 0;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmptgoaxfce: /tmp/tmptgoaxfce.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble d = std::stod(value);\n\treturn std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble val = std::stod(value);\n\treturn (long)val;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfk3qup3h: /tmp/tmpfk3qup3h.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long num = std::stol(value);\n  long decimal = num - (long)num;\n\
    \  if (decimal >= 0.5) {\n    return (long)num + 1;\n  } else {\n    return (long)num;\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6fu7xs7p: /tmp/tmp6fu7xs7p.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::lround(num);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  return std::round(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  return std::lround(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double num = std::stod(value);\n  if(num <\
    \ 0)\n    return (long)num - 1;\n  else\n    return (long)num + 1;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmppxov_inw: /tmp/tmppxov_inw.cpp:26: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int num = std::stoi(value);\n  int decimal = std::stoi(value.substr(value.find(\"\
    .\")));\n  if (decimal >= 5) {\n    return num + 1;\n  } else {\n    return num;\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 18446744073709551615) > this->size()\
    \ (which is 2)\n"
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::round(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double num = std::stod(value);\n  if(num >\
    \ 0)\n    return std::ceil(num);\n  else\n    return std::floor(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmptax_07r7: /tmp/tmptax_07r7.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  if (num < 0) {\n    return std::ceil(num);\n\
    \  }\n  return std::floor(num);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcwxyp2gs: /tmp/tmpcwxyp2gs.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return (long)round(num);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return (long) (d > 0 ? std::floor(d)\
    \ : std::ceil(d));\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp07dsn042: /tmp/tmp07dsn042.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  if(d<0)\n \
    \   return std::ceil(d);\n  else\n    return std::floor(d);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp77kdxj8q: /tmp/tmp77kdxj8q.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::round(val);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int i = 0;\n  double d = 0;\n  std::stringstream ss(value);\n  ss\
    \ >> d;\n  if (d < 0) {\n    d = d - 0.5;\n  } else {\n    d = d + 0.5;\n  }\n\
    \  ss.str(\"\");\n  ss << d;\n  ss >> i;\n  return i;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpea0myuqi: /tmp/tmpea0myuqi.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tstd::stringstream ss(value);\n\tdouble d;\n\tss >> d;\n\tif (d >\
    \ 0) {\n\t\treturn std::ceil(d);\n\t}\n\telse {\n\t\treturn std::floor(d);\n\t\
    }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpv4uahffw: /tmp/tmpv4uahffw.cpp:32: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  if (d < 0) {\n    return std::ceil(d);\n\
    \  }\n  return std::floor(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkgrk6c_s: /tmp/tmpkgrk6c_s.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream ss(value);\n  double d;\n  ss >> d;\n  return\
    \ round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return (d > 0) ? std::ceil(d)\
    \ : std::floor(d);\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp7dmn1b8g: /tmp/tmp7dmn1b8g.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  if (num < 0) {\n    return std::ceil(num);\n\
    \  }\n  return std::floor(num);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcwxyp2gs: /tmp/tmpcwxyp2gs.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double num = std::stod(value);\n  if (num >=\
    \ 0) {\n    return std::ceil(num);\n  } else {\n    return std::floor(num);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpovpttfh7: /tmp/tmpovpttfh7.cpp:30: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return d > 0 ? std::ceil(d) : std::floor(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjjrus6y7: /tmp/tmpjjrus6y7.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double num = std::stod(value);\n    return (long)std::round(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return (long)std::ceil(d);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpdxta8ezj: /tmp/tmpdxta8ezj.cpp:24: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  long l = std::lround(d);\n\
    \  return l;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::round(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream ss(value);\n  double val;\n  ss >> val;\n  if\
    \ (val > 0) {\n    return std::ceil(val);\n  } else {\n    return std::floor(val);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpj6g3hww2: /tmp/tmpj6g3hww2.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // Your code here\n  double d = std::stod(value);\n  return std::lround(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    int decimal_index = value.find('.');\n    if (decimal_index ==\
    \ std::string::npos) {\n        return std::stol(value);\n    }\n    int decimal_part\
    \ = std::stoi(value.substr(decimal_index + 1));\n    int integer_part = std::stoi(value.substr(0,\
    \ decimal_index));\n    if (decimal_part >= 5) {\n        return integer_part\
    \ + 1;\n    }\n    return integer_part;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_792jm56: /tmp/tmp_792jm56.cpp:32: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::round(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::lround(val);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long result = 0;\n  double d = std::stod(value);\n  if (d > 0) {\n\
    \    result = std::ceil(d);\n  } else {\n    result = std::floor(d);\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpg3cwsvqj: /tmp/tmpg3cwsvqj.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double val = std::stod(value);\n  if (val <\
    \ 0) {\n    return std::ceil(val);\n  }\n  return std::floor(val);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnp77c62c: /tmp/tmpnp77c62c.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m =\
    \ 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n \
    \ int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x\
    \ = 0;\n  int y = 0;\n  int z = 0;\n  int aa = 0;\n  int ab = 0;\n  int ac = 0;\n\
    \  int ad = 0;\n  int ae = 0;\n  int af = 0;\n  int ag = 0;\n  int ah = 0;\n \
    \ int ai = 0;\n  int aj = 0;\n  int ak = 0;\n  int al = 0;\n  int am = 0;\n  int\
    \ an = 0;\n  int ao = 0;\n  int ap = 0;\n  int aq = 0;\n  int ar = 0;\n  int as\
    \ = 0;\n  int at = 0;\n  int au = 0;\n  int av = 0;\n  int aw = 0;\n  int ax =\
    \ 0;\n  int ay = 0;\n  int az = 0;\n  int ba = 0;\n  int bb = 0;\n  int bc = 0;\n\
    \  int bd = 0;\n  int be = 0;\n  int bf = 0;\n  int bg = 0;\n  int bh = 0;\n \
    \ int bi = 0;\n  int bj = 0;\n  int bk = 0;\n  int bl = 0;\n  int bm = 0;\n  int\
    \ bn = 0;\n  int bo = 0;\n  int bp = 0;\n  int bq = 0;\n  int br = 0;\n  int bs\
    \ = 0;\n  int bt = 0;\n  int bu = 0;\n  int bv = 0;\n  int bw = 0;\n  int bx =\
    \ 0;\n  int by = 0;\n  int bz = 0\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpogi52qhe.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpogi52qhe.cpp:87:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmpogi52qhe.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::round(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::round(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return (d > 0) ? std::ceil(d) :\
    \ std::floor(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5edce2hr: /tmp/tmp5edce2hr.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  if (val > 0) {\n    return std::ceil(val);\n\
    \  } else {\n    return std::floor(val);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyoafh3wg: /tmp/tmpyoafh3wg.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return (long)num;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpr0povyxq: /tmp/tmpr0povyxq.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  long int_num = std::lround(num);\n\
    \  return int_num;\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return d > 0 ? std::ceil(d) : std::floor(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjjrus6y7: /tmp/tmpjjrus6y7.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int i = 0;\n  int j = value.size() - 1;\n  int k = 0;\n  int l =\
    \ 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n \
    \ int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w\
    \ = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int aa = 0;\n  int ab = 0;\n\
    \  int ac = 0;\n  int ad = 0;\n  int ae = 0;\n  int af = 0;\n  int ag = 0;\n \
    \ int ah = 0;\n  int ai = 0;\n  int aj = 0;\n  int ak = 0;\n  int al = 0;\n  int\
    \ am = 0;\n  int an = 0;\n  int ao = 0;\n  int ap = 0;\n  int aq = 0;\n  int ar\
    \ = 0;\n  int as = 0;\n  int at = 0;\n  int au = 0;\n  int av = 0;\n  int aw =\
    \ 0;\n  int ax = 0;\n  int ay = 0;\n  int az = 0;\n  int ba = 0;\n  int bb = 0;\n\
    \  int bc = 0;\n  int bd = 0;\n  int be = 0;\n  int bf = 0;\n  int bg = 0;\n \
    \ int bh = 0;\n  int bi = 0;\n  int bj = 0;\n  int bk = 0;\n  int bl = 0;\n  int\
    \ bm = 0;\n  int bn = 0;\n  int bo = 0;\n  int bp = 0;\n  int bq = 0;\n  int br\
    \ = 0;\n  int bs = 0;\n  int bt = 0;\n  int bu = 0;\n  int bv = 0;\n  int bw =\
    \ 0;\n  int bx = 0;\n  int by = 0;\n \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjrsyozwk: /tmp/tmpjrsyozwk.cpp:90: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // Your code here\n  double val = std::stod(value);\n  double intpart;\n\
    \  double fracpart = modf(val, &intpart);\n  if (fracpart >= 0.5) {\n    return\
    \ intpart + 1;\n  } else {\n    return intpart;\n  }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3r6bcz16: /tmp/tmp3r6bcz16.cpp:31: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble val = std::stod(value);\n\tlong int_val = std::lround(val);\n\
    \treturn int_val;\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream ss(value);\n  double d;\n  ss >> d;\n  return\
    \ (long)round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int i = 0;\n  int len = value.length();\n  int sign = 1;\n  if (value[0]\
    \ == '-') {\n    sign = -1;\n    i++;\n  }\n  long int_part = 0;\n  while (i <\
    \ len && value[i] != '.') {\n    int_part = int_part * 10 + (value[i] - '0');\n\
    \    i++;\n  }\n  if (i == len) {\n    return int_part * sign;\n  }\n  i++;\n\
    \  long frac_part = 0;\n  int frac_len = 0;\n  while (i < len) {\n    frac_part\
    \ = frac_part * 10 + (value[i] - '0');\n    frac_len++;\n    i++;\n  }\n  if (frac_part\
    \ * 10 >= pow(10, frac_len)) {\n    int_part++;\n  }\n  return int_part * sign;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfqzktcon: /tmp/tmpfqzktcon.cpp:50: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double num = std::stod(value);\n    if(num > 0)\n        return\
    \ std::ceil(num);\n    else\n        return std::floor(num);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpthh5kjg3: /tmp/tmpthh5kjg3.cpp:28: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::lround(num);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  if (d > 0) {\n    return std::ceil(d);\n\
    \  } else {\n    return std::floor(d);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpi30yavkt: /tmp/tmpi30yavkt.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return (val > 0) ? std::ceil(val)\
    \ : std::floor(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkuqhhhsr: /tmp/tmpkuqhhhsr.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int\
    \ l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n\
    \  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w\
    \ = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int aa = 0;\n  int bb = 0;\n\
    \  int cc = 0;\n  int dd = 0;\n  int ee = 0;\n  int ff = 0;\n  int gg = 0;\n \
    \ int hh = 0;\n  int ii = 0;\n  int jj = 0;\n  int kk = 0;\n  int ll = 0;\n  int\
    \ mm = 0;\n  int nn = 0;\n  int oo = 0;\n  int pp = 0;\n  int qq = 0;\n  int rr\
    \ = 0;\n  int ss = 0;\n  int tt = 0;\n  int uu = 0;\n  int vv = 0;\n  int ww =\
    \ 0;\n  int xx = 0;\n  int yy = 0;\n  int zz = 0;\n  int aaa = 0;\n  int bbb =\
    \ 0;\n  int ccc = 0;\n  int ddd = 0;\n  int eee = 0;\n  int fff = 0;\n  int ggg\
    \ = 0;\n  int hhh = 0;\n  int iii = 0;\n  int jjj = 0;\n  int kkk = 0;\n  int\
    \ lll = 0;\n  int mmm = 0;\n  int nnn = 0;\n  int ooo = 0;\n  int ppp = 0;\n \
    \ int qqq = 0;\n  int rrr = 0;\n  int sss = 0;\n  int ttt = 0;\n  int uuu = 0;\n\
    \  int vvv = 0;\n  int www = 0\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyknh9gnp.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpyknh9gnp.cpp:85:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   85 | }\n      | ^\n/tmp/tmpyknh9gnp.cpp:85:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  double floor = std::floor(num);\n\
    \  double ceil = std::ceil(num);\n  if (num - floor < ceil - num) {\n    return\
    \ floor;\n  } else {\n    return ceil;\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp9xb_z2f9: /tmp/tmp9xb_z2f9.cpp:30: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return (long)std::round(d);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long num = std::stol(value);\n    long num_floor = std::floor(num);\n\
    \    long num_ceil = std::ceil(num);\n    if (num - num_floor < num_ceil - num)\
    \ {\n        return num_floor;\n    } else {\n        return num_ceil;\n    }\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpl5r31_0l: /tmp/tmpl5r31_0l.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return (long) (d > 0 ? std::floor(d\
    \ + 0.5) : std::ceil(d - 0.5));\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::round(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return d > 0 ? std::ceil(d) : std::floor(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjjrus6y7: /tmp/tmpjjrus6y7.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  int i = 0;\n  int len = value.length();\n \
    \ int sign = 1;\n  if(value[0] == '-')\n  {\n    sign = -1;\n    i++;\n  }\n \
    \ int num = 0;\n  while(i < len && value[i] != '.')\n  {\n    num = num * 10 +\
    \ (value[i] - '0');\n    i++;\n  }\n  if(i == len)\n    return num;\n  i++;\n\
    \  int dec = 0;\n  int j = 1;\n  while(i < len)\n  {\n    dec = dec * 10 + (value[i]\
    \ - '0');\n    i++;\n    j *= 10;\n  }\n  if(dec * 2 >= j)\n    num++;\n  return\
    \ num * sign;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078842
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  double intpart;\n  double fracpart\
    \ = modf(val, &intpart);\n  if (fracpart > 0.5) {\n    return intpart + 1;\n \
    \ } else if (fracpart < -0.5) {\n    return intpart - 1;\n  } else {\n    return\
    \ intpart;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmsrsbql3: /tmp/tmpmsrsbql3.cpp:31: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long result = 0;\n  double value_double = std::stod(value);\n  if\
    \ (value_double > 0) {\n    result = std::ceil(value_double);\n  } else {\n  \
    \  result = std::floor(value_double);\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpoqln30p6: /tmp/tmpoqln30p6.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::lround(num);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return (long)val;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkebrjt7w: /tmp/tmpkebrjt7w.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  return std::round(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  if (val > 0) {\n    return std::ceil(val);\n\
    \  } else {\n    return std::floor(val);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyoafh3wg: /tmp/tmpyoafh3wg.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream ss(value);\n  double d;\n  ss >> d;\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::lround(d);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  return std::round(val);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  if (val < 0) {\n    val = ceil(val);\n\
    \  } else {\n    val = floor(val);\n  }\n  return val;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpe8rd4qic: /tmp/tmpe8rd4qic.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  long num = std::stol(value);\n  long num_decimal\
    \ = num - (long)num;\n  if (num_decimal >= 0.5) {\n    return num + 1;\n  }\n\
    \  else {\n    return num;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1iruqbwi: /tmp/tmp1iruqbwi.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double d = std::stod(value);\n  if (d < 0)\
    \ {\n    return (long)std::ceil(d);\n  }\n  return (long)std::floor(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1h7uspjx: /tmp/tmp1h7uspjx.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return d > 0 ? std::ceil(d) : std::floor(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjjrus6y7: /tmp/tmpjjrus6y7.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble d = std::stod(value);\n\treturn std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double num = std::stod(value);\n    return (long)std::round(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078840
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble d = std::stod(value);\n\treturn std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  if (num > 0) {\n    return std::ceil(num);\n\
    \  } else {\n    return std::floor(num);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpuck28u7_: /tmp/tmpuck28u7_.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078842
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  if (val > 0) {\n    return std::ceil(val);\n\
    \  } else {\n    return std::floor(val);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyoafh3wg: /tmp/tmpyoafh3wg.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660078838
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::round(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::lround(d);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return std::round(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  long l = std::lround(d);\n  return\
    \ l;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078836
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::lround(d);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078842
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::lround(d);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078842
