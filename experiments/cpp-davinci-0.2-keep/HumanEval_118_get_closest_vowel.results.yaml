language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0xnzh0ya: /tmp/tmp0xnzh0ya.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // your code here\n  std::string vowels = \"aeiouAEIOU\";\n  std::string\
    \ result = \"\";\n  int index = -1;\n  for(int i = word.length() - 1; i >= 0;\
    \ i--) {\n    if(vowels.find(word[i]) != std::string::npos) {\n      index = i;\n\
    \      break;\n    }\n  }\n  if(index == -1) {\n    return result;\n  }\n  for(int\
    \ i = index - 1; i >= 0; i--) {\n    if(vowels.find(word[i]) == std::string::npos)\
    \ {\n      result = word[index];\n      break;\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp975m6e70: /tmp/tmp975m6e70.cpp:41: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int index = -1;\n  for (int i = word.length() - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ != std::string::npos) {\n      index = i;\n      break;\n    }\n  }\n  if (index\
    \ == -1) {\n    return result;\n  }\n  for (int i = index - 1; i >= 0; i--) {\n\
    \    if (vowels.find(word[i]) == std::string::npos) {\n      result = word[index];\n\
    \      break;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptqqplwyd: /tmp/tmptqqplwyd.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while(i >= 0) {\n        if(vowels.find(word[i]) !=\
    \ std::string::npos) {\n            if(i == len - 1) {\n                return\
    \ \"\";\n            }\n            if(vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi2pd1esg: /tmp/tmpi2pd1esg.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    int distance = 0;\n    for (int\
    \ i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            for (int j = i + 1; j < word.length(); j++) {\n             \
    \   if (consonants.find(word[j]) != std::string::npos) {\n                   \
    \ distance = j - i;\n                    if (distance < min_distance) {\n    \
    \                    min_distance = distance;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9gbbo3es: /tmp/tmp9gbbo3es.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if\
    \ (vowels.find(word[index]) != std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n        index--;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7ja_udv0: /tmp/tmp7ja_udv0.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = word.size() -\
    \ 1;\n    int j = i;\n    while (i > 0) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            while (j > 0) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    return word.substr(j, 1);\n   \
    \             }\n                j--;\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprr1c7ril: /tmp/tmprr1c7ril.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    if(len == 0) return \"\";\n    if(len\
    \ == 1) return \"\";\n    int i = len - 1;\n    while(i >= 0) {\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            if(i == len - 1) return \"\";\n            if(i == 0) return\
    \ \"\";\n            if(word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] == 'i'\
    \ || word[i-1] == 'o' || word[i-1] == 'u') {\n                return \"\";\n \
    \           }\n            if(word[i+1] == 'a' || word[i+1] == 'e' || word[i+1]\
    \ == 'i' || word[i+1] == 'o' || word[i+1] == 'u') {\n                return \"\
    \";\n            }\n            return word.substr(i, 1);\n        }\n       \
    \ i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpokg790xh: /tmp/tmpokg790xh.cpp:46: int main(): Assertion `candidate(("anime"))
    == ("i")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int vowel_index = -1;\n\
    \    int consonant_index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            vowel_index\
    \ = i;\n        }\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            consonant_index = i;\n            break;\n        }\n    }\n\
    \    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\";\n\
    \    }\n    if (vowel_index > consonant_index) {\n        return \"\";\n    }\n\
    \    return word.substr(vowel_index, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5at61ijd: /tmp/tmp5at61ijd.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0xnzh0ya: /tmp/tmp0xnzh0ya.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n  std::vector<char>\
    \ consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q',\
    \ 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'};\n  std::string result = \"\";\n  int\
    \ index = -1;\n  for (int i = word.length() - 1; i >= 0; i--) {\n    if (std::find(consonants.begin(),\
    \ consonants.end(), word[i]) != consonants.end()) {\n      if (i == word.length()\
    \ - 1) {\n        return result;\n      }\n      for (int j = i + 1; j < word.length();\
    \ j++) {\n        if (std::find(vowels.begin(), vowels.end(), word[j]) != vowels.end())\
    \ {\n          if (index == -1) {\n            index = j;\n          } else {\n\
    \            if (j < index) {\n              index = j;\n            }\n     \
    \     }\n        }\n      }\n      if (index != -1) {\n        result = word[index];\n\
    \      }\n      return result;\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphy39pm34: /tmp/tmphy39pm34.cpp:44: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int vowel_index = -1;\n\
    \    int consonant_index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            vowel_index\
    \ = i;\n        }\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            consonant_index = i;\n            break;\n        }\n    }\n\
    \    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\";\n\
    \    }\n    if (vowel_index > consonant_index) {\n        return \"\";\n    }\n\
    \    return word.substr(vowel_index, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5at61ijd: /tmp/tmp5at61ijd.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n\tstd::string result = \"\"\
    ;\n\tint index = -1;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\tif\
    \ (consonants.find(word[i]) != std::string::npos) {\n\t\t\tindex = i;\n\t\t\t\
    break;\n\t\t}\n\t}\n\tif (index == -1) {\n\t\treturn result;\n\t}\n\tfor (int\
    \ i = index - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos)\
    \ {\n\t\t\tresult = word[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmplbup3r8n: /tmp/tmplbup3r8n.cpp:39: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string closest_vowel\
    \ = \"\";\n    int closest_vowel_index = -1;\n    int closest_vowel_distance =\
    \ -1;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int distance = 0;\n            for (int\
    \ j = i; j < word.length(); j++) {\n                if (vowels.find(word[j]) !=\
    \ std::string::npos) {\n                    break;\n                }\n      \
    \          distance++;\n            }\n            if (distance > 0 && distance\
    \ < closest_vowel_distance) {\n                closest_vowel_distance = distance;\n\
    \                closest_vowel_index = i;\n            }\n        }\n    }\n \
    \   if (closest_vowel_index != -1) {\n        closest_vowel = word[closest_vowel_index];\n\
    \    }\n    return closest_vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpf502h8az: /tmp/tmpf502h8az.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    result = word[j];\n           \
    \         index = j;\n                    break;\n                }\n        \
    \    }\n            break;\n        }\n    }\n    if (index == -1) {\n       \
    \ return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (consonants.find(word[i]) != std::string::npos) {\n            return result;\n\
    \        }\n        if (vowels.find(word[i]) != std::string::npos) {\n       \
    \     result = word[i];\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd_a1fytm: /tmp/tmpd_a1fytm.cpp:47: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = word.size() -\
    \ 1;\n    while (i >= 0) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            int j = i - 1;\n            while (j >= 0) {\n              \
    \  if (vowels.find(word[j]) != std::string::npos) {\n                    return\
    \ word.substr(j, 1);\n                }\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    break;\n                }\n   \
    \             j--;\n            }\n        }\n        i--;\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_89v3a87: /tmp/tmp_89v3a87.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_dist = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            int dist\
    \ = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n            \
    \    if (vowels.find(word[j]) != std::string::npos) {\n                    break;\n\
    \                }\n                dist++;\n            }\n            if (dist\
    \ < min_dist) {\n                min_dist = dist;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvpuan88c: /tmp/tmpvpuan88c.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int index = -1;\n   \
    \ for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if (index == -1) {\n        return \"\";\n    }\n    for (int\
    \ i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word.substr(index, 1);\n        }\n    }\n    return \"\
    \";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbguz_bj6: /tmp/tmpbguz_bj6.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while(i >= 0) {\n        if(vowels.find(word[i]) !=\
    \ std::string::npos) {\n            if(i == len - 1) {\n                return\
    \ \"\";\n            }\n            if(vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi2pd1esg: /tmp/tmpi2pd1esg.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg9rbi3an: /tmp/tmpg9rbi3an.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int index = -1;\n  for (int i = word.length() - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ != std::string::npos) {\n      if (index == -1) {\n        index = i;\n    \
    \  } else {\n        if (i == 0) {\n          return \"\";\n        }\n      \
    \  if (vowels.find(word[i - 1]) == std::string::npos) {\n          return word[index];\n\
    \        }\n      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpai4e4az7.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpai4e4az7.cpp:26:28: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)index))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   26 |           return word[index];\n      |                            ^\n\
    \      |                            |\n      |                            __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            for (int j = i - 1; j >= 0; j--) {\n  \
    \              if (vowels.find(word[j]) != std::string::npos) {\n            \
    \        result = word[j];\n                    break;\n                }\n  \
    \          }\n            break;\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptho3ti_u: /tmp/tmptho3ti_u.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            int j =\
    \ i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                if (j - i < distance) {\n                    distance = j - i;\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbt0tayaf: /tmp/tmpbt0tayaf.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    int j = len - 1;\n    std::string res = \"\";\n   \
    \ while(i >= 0) {\n        if(vowels.find(word[i]) != std::string::npos) {\n \
    \           if(consonants.find(word[j]) != std::string::npos) {\n            \
    \    res = word[i];\n                break;\n            }\n        }\n      \
    \  i--;\n        j--;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmps63evga5: /tmp/tmps63evga5.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg9rbi3an: /tmp/tmpg9rbi3an.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int min_distance = INT_MAX;\n  for (int i = 0; i < word.size(); i++) {\n   \
    \ for (int j = 0; j < vowels.size(); j++) {\n      if (word[i] == vowels[j]) {\n\
    \        int distance = 0;\n        for (int k = i + 1; k < word.size(); k++)\
    \ {\n          if (vowels.find(word[k]) == std::string::npos) {\n            distance++;\n\
    \          } else {\n            break;\n          }\n        }\n        if (distance\
    \ < min_distance) {\n          min_distance = distance;\n          result = word[i];\n\
    \        }\n      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphwuir6dr: /tmp/tmphwuir6dr.cpp:39: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int n = word.length();\n\
    \    for(int i = n-1; i >= 0; i--) {\n        if(consonants.find(word[i]) != std::string::npos)\
    \ {\n            for(int j = i-1; j >= 0; j--) {\n                if(vowels.find(word[j])\
    \ != std::string::npos) {\n                    return word.substr(j, 1);\n   \
    \             }\n            }\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqoipibk9: /tmp/tmpqoipibk9.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            result = word[i];\n\
    \            pos = i;\n            break;\n        }\n    }\n    if (pos == -1)\
    \ {\n        return \"\";\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) == std::string::npos) {\n            return result;\n\
    \        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvnpdm9zd: /tmp/tmpvnpdm9zd.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = word.size() -\
    \ 1;\n    while (i >= 0) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            int j = i - 1;\n            while (j >= 0) {\n              \
    \  if (vowels.find(word[j]) != std::string::npos) {\n                    return\
    \ word.substr(j, 1);\n                }\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    break;\n                }\n   \
    \             j--;\n            }\n        }\n        i--;\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_89v3a87: /tmp/tmp_89v3a87.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n\tint len = word.length();\n\
    \tint i = len - 1;\n\twhile (i >= 0) {\n\t\tif (consonants.find(word[i]) != std::string::npos)\
    \ {\n\t\t\tint j = i - 1;\n\t\t\twhile (j >= 0) {\n\t\t\t\tif (vowels.find(word[j])\
    \ != std::string::npos) {\n\t\t\t\t\treturn word.substr(j, 1);\n\t\t\t\t}\n\t\t\
    \t\tj--;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\treturn \"\";\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2w4ohhoj: /tmp/tmp2w4ohhoj.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            index\
    \ = i;\n            break;\n        }\n    }\n    for (int i = index - 1; i >=\
    \ 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n      \
    \      result = word[index];\n            break;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpajqi9gan: /tmp/tmpajqi9gan.cpp:37: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int distance = word.size();\n  for (int i = 0; i < word.size(); i++) {\n   \
    \ if (vowels.find(word[i]) != std::string::npos) {\n      if (i > 0 && vowels.find(word[i\
    \ - 1]) == std::string::npos) {\n        if (i < distance) {\n          distance\
    \ = i;\n          result = word[i];\n        }\n      }\n      if (i < word.size()\
    \ - 1 && vowels.find(word[i + 1]) == std::string::npos) {\n        if (word.size()\
    \ - i < distance) {\n          distance = word.size() - i;\n          result =\
    \ word[i];\n        }\n      }\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcjshguet: /tmp/tmpcjshguet.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0xnzh0ya: /tmp/tmp0xnzh0ya.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = 0;\n    for (int i = word.length() - 1; i >= 0; i--) {\n  \
    \      if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            result\
    \ = word[index];\n            break;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2rzhibhp: /tmp/tmp2rzhibhp.cpp:37: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string closest_vowel;\n\
    \    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            int j =\
    \ i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    closest_vowel\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpplbjmulq: /tmp/tmpplbjmulq.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int min_distance = INT_MAX;\n  for (int i = 0; i < word.size(); i++) {\n   \
    \ if (vowels.find(word[i]) != std::string::npos) {\n      int distance = word.size()\
    \ - i - 1;\n      if (distance < min_distance) {\n        min_distance = distance;\n\
    \        result = word[i];\n      }\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpsqbwxdsp: /tmp/tmpsqbwxdsp.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = word.size() -\
    \ 1;\n    while (index >= 0) {\n        if (vowels.find(word[index]) != std::string::npos)\
    \ {\n            if (index == word.size() - 1) {\n                return \"\"\
    ;\n            }\n            if (vowels.find(word[index + 1]) == std::string::npos)\
    \ {\n                return word.substr(index, 1);\n            }\n        }\n\
    \        index--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpite0yp69: /tmp/tmpite0yp69.cpp:33: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int index = -1;\n  for (int i = word.length() - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ != std::string::npos) {\n      index = i;\n      break;\n    }\n  }\n  if (index\
    \ == -1) {\n    return result;\n  }\n  for (int i = index - 1; i >= 0; i--) {\n\
    \    if (vowels.find(word[i]) == std::string::npos) {\n      result = word[index];\n\
    \      break;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptqqplwyd: /tmp/tmptqqplwyd.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9cd8_uha: /tmp/tmp9cd8_uha.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int index = -1;\n   \
    \ for(int i = word.length() - 1; i >= 0; i--) {\n        if(consonants.find(word[i])\
    \ != std::string::npos) {\n            for(int j = i - 1; j >= 0; j--) {\n   \
    \             if(vowels.find(word[j]) != std::string::npos) {\n              \
    \      index = j;\n                    break;\n                }\n           \
    \ }\n            break;\n        }\n    }\n    if(index == -1) {\n        return\
    \ \"\";\n    }\n    return word.substr(index, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphp7m0j2z: /tmp/tmphp7m0j2z.cpp:37: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int index = -1;\n  for (int i\
    \ = word.size() - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos)\
    \ {\n      index = i;\n      break;\n    }\n  }\n  if (index == -1) return \"\"\
    ;\n  for (int i = index - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) == std::string::npos)\
    \ {\n      return word.substr(index, 1);\n    }\n  }\n  return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprcv33n__: /tmp/tmprcv33n__.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_dist = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            for\
    \ (int j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_dist) {\n     \
    \                   min_dist = j - i;\n                        result = word[i];\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpyvqubb4b: /tmp/tmpyvqubb4b.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int pos = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n\
    \        if (consonants.find(word[i]) != std::string::npos) {\n            if\
    \ (pos == -1) {\n                pos = i;\n            } else {\n            \
    \    for (int j = pos; j >= i; j--) {\n                    if (vowels.find(word[j])\
    \ != std::string::npos) {\n                        result = word[j];\n       \
    \                 break;\n                    }\n                }\n         \
    \       break;\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpenz7fjf8: /tmp/tmpenz7fjf8.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int index = -1;\n   \
    \ for(int i = word.length() - 1; i >= 0; i--) {\n        if(consonants.find(word[i])\
    \ != std::string::npos) {\n            if(i == word.length() - 1) {\n        \
    \        return \"\";\n            }\n            for(int j = i + 1; j < word.length();\
    \ j++) {\n                if(vowels.find(word[j]) != std::string::npos) {\n  \
    \                  index = j;\n                    break;\n                }\n\
    \            }\n            break;\n        }\n    }\n    if(index == -1) {\n\
    \        return \"\";\n    }\n    return word.substr(index, 1);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpooykxznt: /tmp/tmpooykxznt.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9cd8_uha: /tmp/tmp9cd8_uha.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int index = -1;\n   \
    \ for(int i = word.length() - 1; i >= 0; i--) {\n        if(consonants.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if(index == -1) return \"\";\n    for(int i = index + 1; i <\
    \ word.length(); i++) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            return word.substr(i, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbikxtl3o: /tmp/tmpbikxtl3o.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int pos = -1;\n  for (int i =\
    \ word.size() - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos)\
    \ {\n      pos = i;\n      break;\n    }\n  }\n  if (pos == -1) return \"\";\n\
    \  for (int i = pos - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) == std::string::npos)\
    \ {\n      return word.substr(pos, 1);\n    }\n  }\n  return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3f7916un: /tmp/tmp3f7916un.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int pos = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n\
    \        if (consonants.find(word[i]) != std::string::npos) {\n            for\
    \ (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j]) !=\
    \ std::string::npos) {\n                    pos = j;\n                    break;\n\
    \                }\n            }\n            break;\n        }\n    }\n    if\
    \ (pos != -1) {\n        result = word[pos];\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzjmoyhq1: /tmp/tmpzjmoyhq1.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int pos = -1;\n  for (int i =\
    \ word.size() - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos)\
    \ {\n      pos = i;\n      break;\n    }\n  }\n  if (pos == -1) {\n    return\
    \ \"\";\n  }\n  for (int i = pos - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ == std::string::npos) {\n      return word.substr(pos, 1);\n    }\n  }\n  return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8mysdr8n: /tmp/tmp8mysdr8n.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = word.size() -\
    \ 1;\n    int vowel_index = -1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            vowel_index = index;\n            break;\n\
    \        }\n        index--;\n    }\n    if (vowel_index == -1) {\n        return\
    \ \"\";\n    }\n    index = vowel_index - 1;\n    while (index >= 0) {\n     \
    \   if (vowels.find(word[index]) == std::string::npos) {\n            return word[vowel_index];\n\
    \        }\n        index--;\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp33yor73d.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp33yor73d.cpp:30:36: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)vowel_index))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   30 |             return word[vowel_index];\n      |                    \
    \                ^\n      |                                    |\n      |    \
    \                                __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string closest_vowel\
    \ = \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int j = i - 1;\n            while (j >= 0 && consonants.find(word[j]) == std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        int k = i + 1;\n                while (k < word.size() && consonants.find(word[k])\
    \ == std::string::npos) {\n                    k++;\n                }\n     \
    \           if (k < word.size()) {\n                    if (min_distance > k -\
    \ j) {\n                        min_distance = k - j;\n                      \
    \  closest_vowel = word[i];\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return closest_vowel;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpols6l0fy: /tmp/tmpols6l0fy.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    int min_index = 0;\n    int min_distance = INT_MAX;\n\
    \    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            for (int j = index\
    \ + 1; j < word.length(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    if (j - index < min_distance) {\n\
    \                        min_distance = j - index;\n                        min_index\
    \ = index;\n                    }\n                    break;\n              \
    \  }\n            }\n        }\n    }\n    if (min_distance != INT_MAX) {\n  \
    \      result = word[min_index];\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2c60o_fl: /tmp/tmp2c60o_fl.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0xnzh0ya: /tmp/tmp0xnzh0ya.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if\
    \ (vowels.find(word[index]) != std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n        index--;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7ja_udv0: /tmp/tmp7ja_udv0.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp91fpw4f3: /tmp/tmp91fpw4f3.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    for(int i = len - 1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i == len - 1) {\n                return \"\";\n          \
    \  }\n            if(vowels.find(word[i + 1]) == std::string::npos) {\n      \
    \          return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp4v1sytgb: /tmp/tmp4v1sytgb.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = word.size() -\
    \ 1;\n    while (i >= 0) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            break;\n        }\n        i--;\n    }\n    if (i == -1) {\n\
    \        return \"\";\n    }\n    int j = i - 1;\n    while (j >= 0) {\n     \
    \   if (vowels.find(word[j]) != std::string::npos) {\n            break;\n   \
    \     }\n        j--;\n    }\n    if (j == -1) {\n        return \"\";\n    }\n\
    \    return word.substr(j, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpot_23xht: /tmp/tmpot_23xht.cpp:42: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word[index];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3hdykn0z.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp3hdykn0z.cpp:28:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)index))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   28 |             return word[index];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n"
  stdout: ''
  timestamp: 1660077940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0xnzh0ya: /tmp/tmp0xnzh0ya.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n\tstd::string result = \"\"\
    ;\n\tint index = -1;\n\tint min_distance = INT_MAX;\n\tfor (int i = 0; i < word.length();\
    \ i++) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\t\tint distance\
    \ = 0;\n\t\t\tfor (int j = i; j < word.length(); j++) {\n\t\t\t\tif (consonants.find(word[j])\
    \ != std::string::npos) {\n\t\t\t\t\tdistance = j - i;\n\t\t\t\t\tbreak;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\tif (distance < min_distance) {\n\t\t\t\tmin_distance = distance;\n\
    \t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (index != -1) {\n\t\tresult = word[index];\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2r1f2tbv: /tmp/tmp2r1f2tbv.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg9rbi3an: /tmp/tmpg9rbi3an.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.length();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i + 1; j < word.length(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi8_r1hts: /tmp/tmpi8_r1hts.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    int pos = len - 1;\n    while(pos >= 0) {\n        if(vowels.find(word[pos])\
    \ != std::string::npos) {\n            if(pos == len - 1) return \"\";\n     \
    \       if(vowels.find(word[pos + 1]) == std::string::npos) return word.substr(pos,\
    \ 1);\n        }\n        pos--;\n    }\n    return \"\";\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmppegldv3c: /tmp/tmppegldv3c.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    for(int i = len - 1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i == len - 1) {\n                return \"\";\n          \
    \  }\n            if(vowels.find(word[i + 1]) == std::string::npos) {\n      \
    \          return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmxc3tec0: /tmp/tmpmxc3tec0.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg9rbi3an: /tmp/tmpg9rbi3an.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int min_distance = word.size();\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int j = i - 1;\n            while (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        int k = i + 1;\n                while (k < word.size() && vowels.find(word[k])\
    \ != std::string::npos) {\n                    k++;\n                }\n     \
    \           if (k < word.size()) {\n                    if (min_distance > k -\
    \ j) {\n                        min_distance = k - j;\n                      \
    \  result = word[i];\n                    }\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2jjhz1yj: /tmp/tmp2jjhz1yj.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9cd8_uha: /tmp/tmp9cd8_uha.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) return \"\";\n    for (int i = pos - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            return\
    \ std::string(1, word[i]);\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpx6jv1i8m: /tmp/tmpx6jv1i8m.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string result = \"\"\
    ;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i])\
    \ != std::string::npos) {\n\t\t\tresult = word[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\
    \treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd9rj0uqb: /tmp/tmpd9rj0uqb.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while(i >= 0) {\n        if(vowels.find(word[i]) !=\
    \ std::string::npos) {\n            if(i == len - 1) {\n                return\
    \ \"\";\n            }\n            if(vowels.find(word[i+1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpa7wd10xc: /tmp/tmpa7wd10xc.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) {\n        return \"\";\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n\
    \        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(pos, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1h2w_6d5: /tmp/tmp1h2w_6d5.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    for(int i = word.length() - 1; i >= 0; i--) {\n\
    \        if(consonants.find(word[i]) != std::string::npos) {\n            index\
    \ = i;\n            break;\n        }\n    }\n    for(int i = index - 1; i >=\
    \ 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos) {\n       \
    \     result = word[i];\n            break;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo2p3eek4: /tmp/tmpo2p3eek4.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.length() -\
    \ 1;\n    while (pos > 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (vowels.find(word[pos - 1]) == std::string::npos) {\n    \
    \            return word.substr(pos, 1);\n            }\n        }\n        pos--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpod0ua09s: /tmp/tmpod0ua09s.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    std::vector<char>\
    \ consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q',\
    \ 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'};\n    std::string result = \"\";\n \
    \   int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n    \
    \    if (std::find(consonants.begin(), consonants.end(), word[i]) != consonants.end())\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return result;\n    }\n    int min_index = -1;\n    int min_distance\
    \ = INT_MAX;\n    for (int i = index; i >= 0; i--) {\n        if (std::find(vowels.begin(),\
    \ vowels.end(), word[i]) != vowels.end()) {\n            if (min_distance > index\
    \ - i) {\n                min_distance = index - i;\n                min_index\
    \ = i;\n            }\n        }\n    }\n    if (min_index != -1) {\n        result\
    \ = word[min_index];\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9pjsewxw: /tmp/tmp9pjsewxw.cpp:46: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int word_size = word.size();\n\
    \    int vowel_pos = -1;\n    int consonant_pos = -1;\n    for (int i = word_size\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_pos = i;\n            break;\n        }\n    }\n    for\
    \ (int i = vowel_pos - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            consonant_pos = i;\n            break;\n\
    \        }\n    }\n    if (vowel_pos == -1 || consonant_pos == -1) {\n       \
    \ return \"\";\n    }\n    return word.substr(vowel_pos, 1);\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpu4brrdvk: /tmp/tmpu4brrdvk.cpp:42: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n  std::string result = \"\";\n  int index = 0;\n  for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n    if (consonants.find(word[i]) != std::string::npos)\
    \ {\n      index = i;\n      break;\n    }\n  }\n  for (int i = index; i >= 0;\
    \ i--) {\n    if (vowels.find(word[i]) != std::string::npos) {\n      result =\
    \ word[i];\n      break;\n    }\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwa333ubl: /tmp/tmpwa333ubl.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9cd8_uha: /tmp/tmp9cd8_uha.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    for (int k = j + 1; k < word.size();\
    \ k++) {\n                        if (vowels.find(word[k]) != std::string::npos)\
    \ {\n                            if (k - i < min_distance) {\n               \
    \                 min_distance = k - i;\n                                result\
    \ = word[k];\n                            }\n                        }\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcexfuryz: /tmp/tmpcexfuryz.cpp:39: int main(): Assertion `candidate(("full"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_index = word.size();\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if\
    \ (i > 0 && vowels.find(word[i - 1]) == std::string::npos) {\n               \
    \ if (i < min_index) {\n                    min_index = i;\n                 \
    \   result = word[i];\n                }\n            }\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbz50hvkk: /tmp/tmpbz50hvkk.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = word.size() -\
    \ 1;\n    while (i >= 0) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            break;\n        }\n        i--;\n    }\n    if (i < 0) {\n  \
    \      return \"\";\n    }\n    int j = i - 1;\n    while (j >= 0) {\n       \
    \ if (vowels.find(word[j]) != std::string::npos) {\n            break;\n     \
    \   }\n        j--;\n    }\n    if (j < 0) {\n        return \"\";\n    }\n  \
    \  return word.substr(j, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpnheyckyx: /tmp/tmpnheyckyx.cpp:42: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int i = len - 1;\n    while(i >=\
    \ 0) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            if(i == len - 1) {\n              \
    \  return \"\";\n            }\n            else if(word[i - 1] == 'a' || word[i\
    \ - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u')\
    \ {\n                return \"\";\n            }\n            else {\n       \
    \         return word.substr(i, 1);\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp18hixe0f: /tmp/tmp18hixe0f.cpp:37: int main(): Assertion `candidate(("eAsy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int n = word.length();\n\
    \    for(int i = n-1; i >= 0; i--) {\n        if(consonants.find(word[i]) != std::string::npos)\
    \ {\n            for(int j = i-1; j >= 0; j--) {\n                if(vowels.find(word[j])\
    \ != std::string::npos) {\n                    return std::string(1, word[j]);\n\
    \                }\n            }\n        }\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7xevvfe3: /tmp/tmp7xevvfe3.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp91fpw4f3: /tmp/tmp91fpw4f3.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            index\
    \ = i;\n            break;\n        }\n    }\n    if (index == -1) {\n       \
    \ return result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjoc821gp: /tmp/tmpjoc821gp.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    for(int i = n-1; i >= 0; i--) {\n   \
    \     if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u') {\n            if(i == n-1) {\n                return \"\"\
    ;\n            }\n            if(word[i+1] != 'a' && word[i+1] != 'e' && word[i+1]\
    \ != 'i' && word[i+1] != 'o' && word[i+1] != 'u') {\n                return word.substr(i,\
    \ 1);\n            }\n        }\n    }\n    return \"\";\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpb602c3rd: /tmp/tmpb602c3rd.cpp:31: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string result = \"\";\n\t\
    int index = -1;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i])\
    \ != std::string::npos) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index\
    \ != -1) {\n\t\tfor (int i = index - 1; i >= 0; i--) {\n\t\t\tif (vowels.find(word[i])\
    \ == std::string::npos) {\n\t\t\t\tresult = word[index];\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5_shp_1c: /tmp/tmp5_shp_1c.cpp:39: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi44lrywy: /tmp/tmpi44lrywy.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) {\n        return \"\";\n    }\n    for (int i = pos\
    \ + 1; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return word.substr(i, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmplq25jarr: /tmp/tmplq25jarr.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n\
    \    for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i == n-1) {\n                return \"\";\n            }\n\
    \            if(vowels.find(word[i+1]) == std::string::npos) {\n             \
    \   return word.substr(i, 1);\n            }\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpc2p7dch_: /tmp/tmpc2p7dch_.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n  std::string result = \"\"\
    ;\n  int index = -1;\n  for (int i = word.length() - 1; i >= 0; i--) {\n    if\
    \ (consonants.find(word[i]) != std::string::npos) {\n      for (int j = i; j >=\
    \ 0; j--) {\n        if (vowels.find(word[j]) != std::string::npos) {\n      \
    \    index = j;\n          break;\n        }\n      }\n      break;\n    }\n \
    \ }\n  if (index != -1) {\n    for (int i = index; i >= 0; i--) {\n      if (consonants.find(word[i])\
    \ != std::string::npos) {\n        result = word[index];\n        break;\n   \
    \   }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg_uo7ckh: /tmp/tmpg_uo7ckh.cpp:50: int main(): Assertion `candidate(("quick"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tint index = word.size() -\
    \ 1;\n\twhile (index >= 0) {\n\t\tif (vowels.find(word[index]) != std::string::npos)\
    \ {\n\t\t\tif (index == 0) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse if (vowels.find(word[index\
    \ - 1]) == std::string::npos) {\n\t\t\t\treturn word.substr(index, 1);\n\t\t\t\
    }\n\t\t}\n\t\tindex--;\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpfhvtalyu: /tmp/tmpfhvtalyu.cpp:35: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    int min_index = 0;\n    int min_distance = 0;\n\
    \    int distance = 0;\n    for (int i = 0; i < word.length(); i++) {\n      \
    \  if (consonants.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            for (int j = 0; j < vowels.length(); j++) {\n                if (word.find(vowels[j],\
    \ index) != std::string::npos) {\n                    distance = word.find(vowels[j],\
    \ index) - index;\n                    if (distance < min_distance || min_distance\
    \ == 0) {\n                        min_distance = distance;\n                \
    \        min_index = word.find(vowels[j], index);\n                        result\
    \ = vowels[j];\n                    }\n                }\n            }\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpx5a0kshu: /tmp/tmpx5a0kshu.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int min_distance = INT_MAX;\n\
    \    int min_index = -1;\n    for (int i = 0; i < word.size(); i++) {\n      \
    \  if (vowels.find(word[i]) != std::string::npos) {\n            int j = i + 1;\n\
    \            while (j < word.size() && consonants.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size() && vowels.find(word[j])\
    \ == std::string::npos) {\n                if (j - i < min_distance) {\n     \
    \               min_distance = j - i;\n                    min_index = i;\n  \
    \              }\n            }\n        }\n    }\n    if (min_index == -1) {\n\
    \        return \"\";\n    }\n    return word.substr(min_index, 1);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmps1sqkeyl: /tmp/tmps1sqkeyl.cpp:39: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) {\n        return \"\";\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n\
    \        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(pos, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1h2w_6d5: /tmp/tmp1h2w_6d5.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            if (i == 0) {\n                return result;\n\
    \            }\n            return word[index];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgbvk37w_.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpgbvk37w_.cpp:31:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)index))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   31 |             return word[index];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n"
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string consonants = \"\
    bcdfghjklmnpqrstvwxyz\";\n    std::string result = \"\";\n    int min_distance\
    \ = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            for (int j = i + 1; j < word.size(); j++)\
    \ {\n                if (consonants.find(word[j]) != std::string::npos) {\n  \
    \                  if (j - i < min_distance) {\n                        min_distance\
    \ = j - i;\n                        result = word[i];\n                    }\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3ijvug8b: /tmp/tmp3ijvug8b.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i; j >= 0; j--) {\n                if (vowels.find(word[j]) !=\
    \ std::string::npos) {\n                    index = j;\n                    break;\n\
    \                }\n            }\n            break;\n        }\n    }\n    if\
    \ (index != -1) {\n        result = word[index];\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpf9hq4qdf: /tmp/tmpf9hq4qdf.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i + 1; j < word.length(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    result = word[j];\n           \
    \         index = j;\n                    break;\n                }\n        \
    \    }\n            break;\n        }\n    }\n    for (int i = index + 1; i <\
    \ word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            result = \"\";\n            break;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpdkmo2pos: /tmp/tmpdkmo2pos.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string closest_vowel\
    \ = \"\";\n    int closest_vowel_index = -1;\n    for (int i = word.length() -\
    \ 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            for (int j = i; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (closest_vowel_index == -1 ||\
    \ i - j < closest_vowel_index) {\n                        closest_vowel_index\
    \ = i - j;\n                        closest_vowel = word[j];\n               \
    \     }\n                }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbfz6ygkv: /tmp/tmpbfz6ygkv.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.length() -\
    \ 1;\n    while (pos > 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (vowels.find(word[pos - 1]) == std::string::npos) {\n    \
    \            return word.substr(pos, 1);\n            }\n        }\n        pos--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpod0ua09s: /tmp/tmpod0ua09s.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0xnzh0ya: /tmp/tmp0xnzh0ya.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            index\
    \ = i;\n            break;\n        }\n    }\n    if (index == -1) {\n       \
    \ return result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjoc821gp: /tmp/tmpjoc821gp.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp91fpw4f3: /tmp/tmp91fpw4f3.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            index\
    \ = i;\n            break;\n        }\n    }\n    if (index == -1) {\n       \
    \ return result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjoc821gp: /tmp/tmpjoc821gp.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i\
    \ = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = 0;\n            for (int j = i; j < word.length();\
    \ j++) {\n                if (consonants.find(word[j]) != std::string::npos) {\n\
    \                    distance = j - i;\n                    break;\n         \
    \       }\n            }\n            if (distance < min_distance) {\n       \
    \         min_distance = distance;\n                index = i;\n            }\n\
    \        }\n    }\n    if (index != -1) {\n        result = word[index];\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5dt8qyj_: /tmp/tmp5dt8qyj_.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tint index = -1;\n\tfor (int i\
    \ = word.size() - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos)\
    \ {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index == -1) {\n\t\treturn\
    \ \"\";\n\t}\n\tfor (int i = index - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i])\
    \ == std::string::npos) {\n\t\t\treturn word.substr(index, 1);\n\t\t}\n\t}\n\t\
    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjgg1opp4: /tmp/tmpjgg1opp4.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    int distance = INT_MAX;\n    for (int i = 0;\
    \ i < word.length(); i++) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            for (int j = i + 1; j < word.length(); j++) {\n             \
    \   if (vowels.find(word[j]) != std::string::npos) {\n                    if (j\
    \ - i < distance) {\n                        distance = j - i;\n             \
    \           index = j;\n                    }\n                }\n           \
    \ }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcc06y2j7: /tmp/tmpcc06y2j7.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string res = \"\"\
    ;\n    int min_dist = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (consonants.find(word[i]) != std::string::npos) {\n            for\
    \ (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_dist) {\n     \
    \                   min_dist = j - i;\n                        res = word[j];\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmps5ixvvpn: /tmp/tmps5ixvvpn.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int vowel_index = -1;\n    int consonant_index = -1;\n    for (int\
    \ i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_index = i;\n            break;\n        }\n    }\n    for\
    \ (int i = vowel_index - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            consonant_index = i;\n            break;\n\
    \        }\n    }\n    if (vowel_index != -1 && consonant_index != -1) {\n   \
    \     result = word[vowel_index];\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2uhj4ke1: /tmp/tmp2uhj4ke1.cpp:42: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            result = word[i];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwleqiqq8: /tmp/tmpwleqiqq8.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i - 1;\n            while (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        int temp = i - j;\n                if (temp < distance) {\n         \
    \           distance = temp;\n                    result = word[i];\n        \
    \        }\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi495zp8z: /tmp/tmpi495zp8z.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg9rbi3an: /tmp/tmpg9rbi3an.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  int pos = word.size() - 1;\n\
    \  while (pos >= 0) {\n    if (vowels.find(word[pos]) != std::string::npos) {\n\
    \      if (pos == 0) {\n        return \"\";\n      }\n      if (vowels.find(word[pos\
    \ - 1]) == std::string::npos) {\n        return word.substr(pos, 1);\n      }\n\
    \    }\n    pos--;\n  }\n  return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxbcd3e4s: /tmp/tmpxbcd3e4s.cpp:35: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjlqq_k6d: /tmp/tmpjlqq_k6d.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            index\
    \ = i;\n            break;\n        }\n    }\n    if (index == -1) {\n       \
    \ return result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjoc821gp: /tmp/tmpjoc821gp.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg9rbi3an: /tmp/tmpg9rbi3an.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while(i >= 0) {\n        if(vowels.find(word[i]) !=\
    \ std::string::npos) {\n            if(i == len - 1) {\n                return\
    \ \"\";\n            }\n            if(vowels.find(word[i+1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp6z_m9i8i: /tmp/tmp6z_m9i8i.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while(i >= 0) {\n        if(consonants.find(word[i])\
    \ != std::string::npos) {\n            int j = i - 1;\n            while(j >=\
    \ 0) {\n                if(vowels.find(word[j]) != std::string::npos) {\n    \
    \                return word.substr(j, 1);\n                }\n              \
    \  j--;\n            }\n        }\n        i--;\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmplupfnisz: /tmp/tmplupfnisz.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int n = word.length();\n\
    \    for(int i = n-1; i >= 0; i--) {\n        if(consonants.find(word[i]) != std::string::npos)\
    \ {\n            for(int j = i-1; j >= 0; j--) {\n                if(vowels.find(word[j])\
    \ != std::string::npos) {\n                    return word.substr(j, 1);\n   \
    \             }\n            }\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqoipibk9: /tmp/tmpqoipibk9.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) {\n        return \"\";\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n\
    \        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(pos, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1h2w_6d5: /tmp/tmp1h2w_6d5.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = 0; j < vowels.size(); j++) {\n                if (word.find(vowels[j])\
    \ != std::string::npos) {\n                    int distance = abs(i - word.find(vowels[j]));\n\
    \                    if (distance < min_distance) {\n                        min_distance\
    \ = distance;\n                        result = vowels[j];\n                 \
    \   }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5uh3vzmy: /tmp/tmp5uh3vzmy.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  int index = -1;\n  for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos)\
    \ {\n      index = i;\n      break;\n    }\n  }\n  if (index == -1) {\n    return\
    \ \"\";\n  }\n  for (int i = index - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ == std::string::npos) {\n      return word.substr(index, 1);\n    }\n  }\n \
    \ return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2ckgm1wr: /tmp/tmp2ckgm1wr.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            index =\
    \ i;\n            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0xnzh0ya: /tmp/tmp0xnzh0ya.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int min_distance = word.size();\n  for (int i = 0; i < word.size(); i++) {\n\
    \    for (int j = 0; j < vowels.size(); j++) {\n      if (word[i] == vowels[j])\
    \ {\n        int distance = word.size() - i - 1;\n        if (distance < min_distance)\
    \ {\n          min_distance = distance;\n          result = word[i];\n       \
    \ }\n      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzt13z0ay: /tmp/tmpzt13z0ay.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) {\n        return \"\";\n    }\n    for (int i = pos\
    \ + 1; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return std::string(1, word[i]);\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprorj0vn7: /tmp/tmprorj0vn7.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            result = word[i];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwleqiqq8: /tmp/tmpwleqiqq8.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i + 1; j < word.length(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (index == -1) {\n          \
    \              index = j;\n                    } else {\n                    \
    \    if (j < index) {\n                            index = j;\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n    }\n    if (index != -1) {\n        result = word[index];\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg_y2hat8: /tmp/tmpg_y2hat8.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) !=\
    \ std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) {\n        return \"\";\n    }\n    for (int i = pos\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word.substr(pos, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg1i4vh9a: /tmp/tmpg1i4vh9a.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while(i >= 0) {\n        if(consonants.find(word[i])\
    \ != std::string::npos) {\n            break;\n        }\n        i--;\n    }\n\
    \    if(i < 0) {\n        return \"\";\n    }\n    int j = i - 1;\n    while(j\
    \ >= 0) {\n        if(vowels.find(word[j]) != std::string::npos) {\n         \
    \   break;\n        }\n        j--;\n    }\n    if(j < 0) {\n        return \"\
    \";\n    }\n    int k = i + 1;\n    while(k < len) {\n        if(vowels.find(word[k])\
    \ != std::string::npos) {\n            break;\n        }\n        k++;\n    }\n\
    \    if(k == len) {\n        return \"\";\n    }\n    if(k - i < i - j) {\n  \
    \      return word.substr(k, 1);\n    }\n    return word.substr(j, 1);\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpec4lsynm: /tmp/tmpec4lsynm.cpp:54: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) {\n        return \"\";\n    }\n    for (int i = pos\
    \ + 1; i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return std::string(1, word[i]);\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprorj0vn7: /tmp/tmprorj0vn7.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) return \"\";\n    int min_dist = INT_MAX;\n    int\
    \ min_pos = -1;\n    for (int i = 0; i < vowels.size(); i++) {\n        int pos_vowel\
    \ = word.find(vowels[i]);\n        if (pos_vowel != std::string::npos && pos_vowel\
    \ < pos) {\n            if (pos - pos_vowel < min_dist) {\n                min_dist\
    \ = pos - pos_vowel;\n                min_pos = pos_vowel;\n            }\n  \
    \      }\n    }\n    if (min_pos == -1) return \"\";\n    return word.substr(min_pos,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp63r7jv9d: /tmp/tmp63r7jv9d.cpp:42: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        for (int j = 0; j < vowels.size(); j++) {\n            if (word[i]\
    \ == vowels[j]) {\n                int distance = 0;\n                for (int\
    \ k = i; k < word.size(); k++) {\n                    if (consonants.find(word[k])\
    \ != std::string::npos) {\n                        distance++;\n             \
    \       } else {\n                        break;\n                    }\n    \
    \            }\n                if (distance < min_distance) {\n             \
    \       min_distance = distance;\n                    result = word[i];\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpu36cxgxy: /tmp/tmpu36cxgxy.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n\tstd::string result = \"\"\
    ;\n\tint index = -1;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\tif\
    \ (consonants.find(word[i]) != std::string::npos) {\n\t\t\tfor (int j = i - 1;\
    \ j >= 0; j--) {\n\t\t\t\tif (vowels.find(word[j]) != std::string::npos) {\n\t\
    \t\t\t\tindex = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\
    \t}\n\tif (index != -1) {\n\t\tresult = word[index];\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1t8rra4e: /tmp/tmp1t8rra4e.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int pos = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n\
    \        if (consonants.find(word[i]) != std::string::npos) {\n            for\
    \ (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j]) !=\
    \ std::string::npos) {\n                    pos = j;\n                    break;\n\
    \                }\n            }\n            break;\n        }\n    }\n    if\
    \ (pos != -1) {\n        result = word[pos];\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzjmoyhq1: /tmp/tmpzjmoyhq1.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    for (int k = j + 1; k < word.size();\
    \ k++) {\n                        if (vowels.find(word[k]) != std::string::npos)\
    \ {\n                            if (k - i < min_distance) {\n               \
    \                 min_distance = k - i;\n                                result\
    \ = word[k];\n                            }\n                        }\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcexfuryz: /tmp/tmpcexfuryz.cpp:39: int main(): Assertion `candidate(("full"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    for(int i = len - 1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i == len - 1)\n                return \"\";\n            if(vowels.find(word[i+1])\
    \ == std::string::npos)\n                return word.substr(i, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmph_up5aqw: /tmp/tmph_up5aqw.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg9rbi3an: /tmp/tmpg9rbi3an.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) return \"\";\n    int min_dist = INT_MAX;\n    int\
    \ min_pos = -1;\n    for (int i = 0; i < vowels.size(); i++) {\n        int pos_vowel\
    \ = word.find(vowels[i]);\n        if (pos_vowel != std::string::npos && pos_vowel\
    \ > pos) {\n            if (pos_vowel - pos < min_dist) {\n                min_dist\
    \ = pos_vowel - pos;\n                min_pos = pos_vowel;\n            }\n  \
    \      }\n    }\n    if (min_pos == -1) return \"\";\n    return word.substr(min_pos,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7nj374kb: /tmp/tmp7nj374kb.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int n = word.size();\n   \
    \ for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i > 0 && vowels.find(word[i-1]) == std::string::npos) {\n\
    \                return word.substr(i, 1);\n            }\n            if(i <\
    \ n-1 && vowels.find(word[i+1]) == std::string::npos) {\n                return\
    \ word.substr(i, 1);\n            }\n        }\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjlpge8k_: /tmp/tmpjlpge8k_.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string closest_vowel\
    \ = \"\";\n    int closest_vowel_index = -1;\n    for (int i = word.length() -\
    \ 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n\
    \            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n                closest_vowel = word[i];\n            } else {\n     \
    \           if (i < closest_vowel_index) {\n                    closest_vowel_index\
    \ = i;\n                    closest_vowel = word[i];\n                }\n    \
    \        }\n        } else {\n            if (closest_vowel_index != -1) {\n \
    \               return closest_vowel;\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpypdjvhm7: /tmp/tmpypdjvhm7.cpp:42: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int min_distance = INT_MAX;\n  for (int i = 0; i < word.size(); i++) {\n   \
    \ if (vowels.find(word[i]) != std::string::npos) {\n      int distance = 0;\n\
    \      for (int j = i + 1; j < word.size(); j++) {\n        if (vowels.find(word[j])\
    \ != std::string::npos) {\n          break;\n        }\n        distance++;\n\
    \      }\n      if (distance < min_distance) {\n        min_distance = distance;\n\
    \        result = word[i];\n      }\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_nrfhnc6: /tmp/tmp_nrfhnc6.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string closest_vowel\
    \ = \"\";\n    int closest_vowel_index = -1;\n    for (int i = word.length() -\
    \ 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n\
    \            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n                closest_vowel = word[i];\n            } else {\n     \
    \           if (i < closest_vowel_index) {\n                    closest_vowel_index\
    \ = i;\n                    closest_vowel = word[i];\n                }\n    \
    \        }\n        } else {\n            if (closest_vowel_index != -1) {\n \
    \               return closest_vowel;\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpypdjvhm7: /tmp/tmpypdjvhm7.cpp:42: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n\tstd::string result = \"\"\
    ;\n\tint index = -1;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\tif\
    \ (consonants.find(word[i]) != std::string::npos) {\n\t\t\tfor (int j = i - 1;\
    \ j >= 0; j--) {\n\t\t\t\tif (vowels.find(word[j]) != std::string::npos) {\n\t\
    \t\t\t\tindex = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\
    \t}\n\tif (index != -1) {\n\t\tresult = word[index];\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1t8rra4e: /tmp/tmp1t8rra4e.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077945
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string closest_vowel\
    \ = \"\";\n    int closest_vowel_index = -1;\n    for (int i = word.length() -\
    \ 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            for (int j = i + 1; j < word.length(); j++) {\n             \
    \   if (vowels.find(word[j]) != std::string::npos) {\n                    if (closest_vowel_index\
    \ == -1 || j < closest_vowel_index) {\n                        closest_vowel_index\
    \ = j;\n                        closest_vowel = word[j];\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpv1eoe16h: /tmp/tmpv1eoe16h.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int min_distance = INT_MAX;\n  for (int i = 0; i < word.size(); i++) {\n   \
    \ if (vowels.find(word[i]) != std::string::npos) {\n      int j = i + 1;\n   \
    \   while (j < word.size() && vowels.find(word[j]) != std::string::npos) {\n \
    \       j++;\n      }\n      if (j < word.size()) {\n        int distance = j\
    \ - i;\n        if (distance < min_distance) {\n          min_distance = distance;\n\
    \          result = word[i];\n        }\n      }\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpyf5p7fav: /tmp/tmpyf5p7fav.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int pos = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) !=\
    \ std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) return \"\";\n    for (int i = pos - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(pos, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmph4tpanr6: /tmp/tmph4tpanr6.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            for\
    \ (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpj60qo5vl: /tmp/tmpj60qo5vl.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int word_size = word.size();\n\
    \    int i = word_size - 1;\n    while(i >= 0) {\n        if(consonants.find(word[i])\
    \ != std::string::npos) {\n            int j = i - 1;\n            while(j >=\
    \ 0) {\n                if(vowels.find(word[j]) != std::string::npos) {\n    \
    \                return word.substr(j, 1);\n                }\n              \
    \  j--;\n            }\n        }\n        i--;\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0z42y3tx: /tmp/tmp0z42y3tx.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077946
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string result = \"\";\n\t\
    int index = word.length() - 1;\n\twhile (index >= 0) {\n\t\tif (vowels.find(word[index])\
    \ != std::string::npos) {\n\t\t\tresult = word[index];\n\t\t\tbreak;\n\t\t}\n\t\
    \tindex--;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9cpboyi5: /tmp/tmp9cpboyi5.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    result = word[j];\n           \
    \         index = j;\n                    break;\n                }\n        \
    \    }\n            if (index != -1) {\n                break;\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp49a_hklo: /tmp/tmp49a_hklo.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            index\
    \ = i;\n            break;\n        }\n    }\n    if (index == -1) {\n       \
    \ return result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjoc821gp: /tmp/tmpjoc821gp.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int i = word.size() -\
    \ 1;\n    while (i >= 0) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            if (i == 0) {\n                return \"\";\n            }\n\
    \            if (vowels.find(word[i - 1]) != std::string::npos) {\n          \
    \      return word.substr(i - 1, 1);\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp6k32jo0v: /tmp/tmp6k32jo0v.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n\
    \    int i = n - 1;\n    while(i >= 0) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i == n - 1) {\n                return \"\";\n            }\n\
    \            if(vowels.find(word[i + 1]) == std::string::npos) {\n           \
    \     return word.substr(i, 1);\n            }\n        }\n        i--;\n    }\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5vwukied: /tmp/tmp5vwukied.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if\
    \ (vowels.find(word[index]) != std::string::npos) {\n            result = word[index];\n\
    \            break;\n        }\n        index--;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7ja_udv0: /tmp/tmp7ja_udv0.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            if (i == word.size() - 1) {\n                return \"\";\n \
    \           }\n            if (word[i - 1] == 'a' || word[i - 1] == 'e' || word[i\
    \ - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u') {\n               \
    \ return \"\";\n            }\n            return word.substr(i, 1);\n       \
    \ }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphsi46x_7: /tmp/tmphsi46x_7.cpp:34: int main(): Assertion `candidate(("eAsy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.size() - 1;\n\
    \    while (pos >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (pos > 0 && vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp08u9yz39: /tmp/tmp08u9yz39.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_index = -1;\n    for (int i = 0; i < word.length(); i++)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i + 1; j < word.length(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (min_index == -1) {\n      \
    \                  min_index = j;\n                        result = word[j];\n\
    \                    } else if (j < min_index) {\n                        min_index\
    \ = j;\n                        result = word[j];\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpl2aciwqm: /tmp/tmpl2aciwqm.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int index = -1;\n   \
    \ for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if (index == -1) return \"\";\n    for (int i = index - 1; i\
    \ >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n   \
    \         return word.substr(index, 1);\n        }\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzvpqm6hs: /tmp/tmpzvpqm6hs.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    int min_index = word.length();\n    for (int\
    \ i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            if (index > 0 && index < min_index) {\n\
    \                if (vowels.find(word[index - 1]) == std::string::npos && vowels.find(word[index\
    \ + 1]) == std::string::npos) {\n                    min_index = index;\n    \
    \                result = word[index];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgw0n5od_: /tmp/tmpgw0n5od_.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    for(int i = len - 1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i == len - 1) {\n                return \"\";\n          \
    \  }\n            if(vowels.find(word[i + 1]) == std::string::npos) {\n      \
    \          return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp4v1sytgb: /tmp/tmp4v1sytgb.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077940
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i - 1;\n            if (distance < min_distance) {\n\
    \                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmppeuqlax2: /tmp/tmppeuqlax2.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077947
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_dist = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            int dist\
    \ = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n            \
    \    if (vowels.find(word[j]) != std::string::npos) {\n                    break;\n\
    \                }\n                dist++;\n            }\n            if (dist\
    \ < min_dist) {\n                min_dist = dist;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvpuan88c: /tmp/tmpvpuan88c.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string result = \"\"\
    ;\n\tint distance = 0;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\t\
    if (vowels.find(word[i]) != std::string::npos) {\n\t\t\tif (i == word.length()\
    \ - 1) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (vowels.find(word[i + 1])\
    \ != std::string::npos) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (result == \"\"\
    ) {\n\t\t\t\tresult = word[i];\n\t\t\t\tdistance = word.length() - i;\n\t\t\t\
    }\n\t\t\telse {\n\t\t\t\tif (word.length() - i < distance) {\n\t\t\t\t\tresult\
    \ = word[i];\n\t\t\t\t\tdistance = word.length() - i;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphaq9p5f1: /tmp/tmphaq9p5f1.cpp:43: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  if (index == -1) {\n                index = i;\n            } else {\n    \
    \            if (vowels.find(word[i + 1]) != std::string::npos) {\n          \
    \          result = word[i + 1];\n                    break;\n               \
    \ }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmfu6m9di: /tmp/tmpmfu6m9di.cpp:43: int main(): Assertion `candidate(("quick"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i; j < word.size(); j++) {\n       \
    \         if (vowels.find(word[j]) != std::string::npos) {\n                 \
    \   distance = 0;\n                } else {\n                    distance++;\n\
    \                }\n                if (distance > 1) {\n                    break;\n\
    \                }\n            }\n            if (distance == 1) {\n        \
    \        if (min_distance > distance) {\n                    min_distance = distance;\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjq8gndvt: /tmp/tmpjq8gndvt.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tint len = word.length();\n\tint\
    \ pos = len - 1;\n\twhile (pos >= 0) {\n\t\tif (vowels.find(word[pos]) != std::string::npos)\
    \ {\n\t\t\tif (pos == 0) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tif (vowels.find(word[pos\
    \ - 1]) == std::string::npos) {\n\t\t\t\treturn word.substr(pos, 1);\n\t\t\t}\n\
    \t\t}\n\t\tpos--;\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpb0dcyx35: /tmp/tmpb0dcyx35.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9cd8_uha: /tmp/tmp9cd8_uha.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    for(int i = len - 1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(i == len - 1) {\n                return \"\";\n          \
    \  }\n            if(vowels.find(word[i + 1]) == std::string::npos) {\n      \
    \          return word.substr(i, 1);\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmxc3tec0: /tmp/tmpmxc3tec0.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077941
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i + 1; j < word.length(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpkjazq7px: /tmp/tmpkjazq7px.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9cd8_uha: /tmp/tmp9cd8_uha.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  index = i;\n            break;\n        }\n    }\n    for (int i = index; i\
    \ >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n   \
    \         result = word[i];\n            break;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpfzauww5j: /tmp/tmpfzauww5j.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    index = j;\n                  \
    \  break;\n                }\n            }\n            break;\n        }\n \
    \   }\n    if (index != -1) {\n        result += word[index];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprb_fo237: /tmp/tmprb_fo237.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n  std::string result = \"\"\
    ;\n  int pos = -1;\n  for (int i = word.length() - 1; i >= 0; i--) {\n    if (consonants.find(word[i])\
    \ != std::string::npos) {\n      for (int j = i - 1; j >= 0; j--) {\n        if\
    \ (vowels.find(word[j]) != std::string::npos) {\n          result = word[j];\n\
    \          pos = j;\n          break;\n        }\n      }\n      if (pos != -1)\
    \ break;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9go48n_r: /tmp/tmp9go48n_r.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = -1;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  if (index == -1) {\n                index = i;\n            } else {\n    \
    \            for (int j = i + 1; j < index; j++) {\n                    if (vowels.find(word[j])\
    \ != std::string::npos) {\n                        result = word[j];\n       \
    \                 break;\n                    }\n                }\n         \
    \       break;\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp380kxqt6: /tmp/tmp380kxqt6.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int index = 0;\n    for (int i = word.length() - 1; i >= 0; i--)\
    \ {\n        if (consonants.find(word[i]) != std::string::npos) {\n          \
    \  index = i;\n            break;\n        }\n    }\n    for (int i = index -\
    \ 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n\
    \            result = word[i];\n            break;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpe7_7l13m: /tmp/tmpe7_7l13m.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result =\
    \ \"\";\n    int distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int j = i - 1;\n            while (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        if (i - j < distance) {\n                    distance = i - j;\n    \
    \                result = word[i];\n                }\n            }\n       \
    \ }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1nljwy_e: /tmp/tmp1nljwy_e.cpp:39: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int j = i - 1;\n            while (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        int distance = i - j;\n                if (distance < min_distance) {\n\
    \                    min_distance = distance;\n                    result = word[i];\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphlk_wwba: /tmp/tmphlk_wwba.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp865s51h5: /tmp/tmp865s51h5.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077936
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            result = word[i];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwleqiqq8: /tmp/tmpwleqiqq8.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int pos = word.size()\
    \ - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (pos == 0) {\n                return \"\";\n            }\n\
    \            if (vowels.find(word[pos - 1]) == std::string::npos) {\n        \
    \        return word.substr(pos, 1);\n            }\n        }\n        pos--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp6tzqi2c_: /tmp/tmp6tzqi2c_.cpp:35: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077948
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (consonants.find(word[i]) != std::string::npos) {\n     \
    \       for (int j = i + 1; j < word.size(); j++) {\n                if (vowels.find(word[j])\
    \ != std::string::npos) {\n                    if (j - i < min_distance) {\n \
    \                       min_distance = j - i;\n                        result\
    \ = word[j];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvdckz3l0: /tmp/tmpvdckz3l0.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077938
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    std::string result =\
    \ \"\";\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    int distance = j - i;\n       \
    \             if (distance < min_distance) {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                    break;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3tw7l_w1: /tmp/tmp3tw7l_w1.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077949
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            result = word[i];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwleqiqq8: /tmp/tmpwleqiqq8.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077943
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int index = -1;\n  for (int i\
    \ = word.size() - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos)\
    \ {\n      index = i;\n      break;\n    }\n  }\n  if (index == -1) {\n    return\
    \ \"\";\n  }\n  for (int i = index - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ == std::string::npos) {\n      return word.substr(index, 1);\n    }\n  }\n \
    \ return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpa8owmdsf: /tmp/tmpa8owmdsf.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077949
