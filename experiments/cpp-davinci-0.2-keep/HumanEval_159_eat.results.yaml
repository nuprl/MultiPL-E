name: HumanEval_159_eat
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    result.push_back(number + std::min(need, remaining));\n    result.push_back(std::max(remaining\
    \ - need, 0L));\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (number + need <= remaining) {\n    result.push_back(number + need);\n \
    \   result.push_back(remaining - (number + need));\n  } else {\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpz3dc_ai8: /tmp/tmpz3dc_ai8.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if (remaining >= need) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> v;\n  \
    \  if(remaining < need) {\n        v.push_back(number + remaining);\n        v.push_back(0);\n\
    \    } else {\n        v.push_back(number + need);\n        v.push_back(remaining\
    \ - need);\n    }\n    return v;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if(remaining >= need)\n \
    \       return {number + need, remaining - need};\n    else\n        return {number\
    \ + remaining, 0};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpjeef0xos: /tmp/tmpjeef0xos.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpsx9xtqom: /tmp/tmpsx9xtqom.cpp:39: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmp7tsecm0e: /tmp/tmp7tsecm0e.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    }\n    else {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  long total = number + remaining;\n\
    \  if (total >= need) {\n    return {need, total - need};\n  } else {\n    return\
    \ {total, 0};\n  }\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpwx3i3aks: /tmp/tmpwx3i3aks.cpp:35: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmphcvkleqc: /tmp/tmphcvkleqc.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(remaining + number);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: "tmpdslagz_x: /tmp/tmpdslagz_x.cpp:43: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    }\n    else {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  // your code here\n  std::vector<long>\
    \ result;\n  if(number+need<=remaining){\n    result.push_back(number+need);\n\
    \    result.push_back(remaining-(number+need));\n  }\n  else{\n    result.push_back(number+remaining);\n\
    \    result.push_back(0);\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpkjnhrkvd: /tmp/tmpkjnhrkvd.cpp:40: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining < need) {\n\
    \        return {number + remaining, 0};\n    } else {\n        return {number\
    \ + need, remaining - need};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    long\
    \ total = number + remaining;\n    if (total >= need) {\n        return {need,\
    \ total - need};\n    } else {\n        return {total, 0};\n    }\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: "tmp2ow8lqss: /tmp/tmp2ow8lqss.cpp:36: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(number + remaining);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: "tmpxj9e3zwo: /tmp/tmpxj9e3zwo.cpp:43: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (number + need <= remaining) {\n    result.push_back(number + need);\n \
    \   result.push_back(remaining - (number + need));\n  } else {\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: "tmp1b17kq75: /tmp/tmp1b17kq75.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  if (remaining < need) {\n \
    \   return {number + remaining, 0};\n  }\n  return {number + need, remaining -\
    \ need};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpleh7ygy9: /tmp/tmpleh7ygy9.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need)\n    {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    }\n    else\n    {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(remaining >= need) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpoli067ve: /tmp/tmpoli067ve.cpp:39: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if(need - number <= remaining) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(number + remaining);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: "tmpkjuz8_1d: /tmp/tmpkjuz8_1d.cpp:43: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    long total = number + remaining;\n\
    \    if (total >= need) {\n        return {need, total - need};\n    } else {\n\
    \        return {total, 0};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: "tmpvcm8kbvb: /tmp/tmpvcm8kbvb.cpp:35: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(need > remaining)\n    {\n        result.push_back(number +\
    \ remaining);\n        result.push_back(0);\n    }\n    else\n    {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number > 1000 || need > 1000 || remaining > 1000) {\n        result.push_back(0);\n\
    \        result.push_back(0);\n        return result;\n    }\n    if (remaining\
    \ >= need) {\n        result.push_back(number + need);\n        result.push_back(remaining\
    \ - need);\n    } else {\n        result.push_back(number + remaining);\n    \
    \    result.push_back(0);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmp23uegi32: /tmp/tmp23uegi32.cpp:39: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need > remaining) {\n        result.push_back(remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - (number + need));\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmp9pi_t_gp: /tmp/tmp9pi_t_gp.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpaghxmt2t: /tmp/tmpaghxmt2t.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining >= need) {\n\
    \        return {number + need, remaining - need};\n    } else {\n        return\
    \ {number + remaining, 0};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpabo154c2: /tmp/tmpabo154c2.cpp:39: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  // your code here\n  std::vector<long>\
    \ result;\n  if(remaining >= need){\n    result.push_back(number + need);\n  \
    \  result.push_back(remaining - need);\n  }\n  else{\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(remaining >= need){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(remaining < need){\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    }\n    else{\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining < need) {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  } else {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  long total = number + need;\n\
    \  long left = 0;\n  if (total > remaining) {\n    total = remaining;\n    left\
    \ = 0;\n  } else {\n    left = remaining - total;\n  }\n  std::vector<long> result\
    \ = {total, left};\n  return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: "tmpvvs7ht5u: /tmp/tmpvvs7ht5u.cpp:39: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n\tstd::vector<long> result;\n\
    \tif (remaining >= need) {\n\t\tresult.push_back(number + need);\n\t\tresult.push_back(remaining\
    \ - need);\n\t}\n\telse {\n\t\tresult.push_back(number + remaining);\n\t\tresult.push_back(0);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpn4cjxn5j: /tmp/tmpn4cjxn5j.cpp:39: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if(remaining >= need)\n \
    \       return {number + need, remaining - need};\n    return {number + remaining,\
    \ 0};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6),\
    \ (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmppkjgik0m: /tmp/tmppkjgik0m.cpp:39: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(remaining + number);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: "tmpchuh_5ax: /tmp/tmpchuh_5ax.cpp:43: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need > remaining) {\n        result.push_back(remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - (number + need));\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpuaio02xk: /tmp/tmpuaio02xk.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  if (remaining < need) {\n \
    \   return {number + remaining, 0};\n  } else {\n    return {number + need, remaining\
    \ - need};\n  }\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  if (remaining >= need) {\n\
    \    return {number + need, remaining - need};\n  } else {\n    return {number\
    \ + remaining, 0};\n  }\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining < need) {\n\
    \        return {number + remaining, 0};\n    }\n    return {number + need, remaining\
    \ - need};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (number + need <= remaining) {\n    result.push_back(number + need);\n \
    \   result.push_back(remaining - (number + need));\n  } else {\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: "tmp2kub5m00: /tmp/tmp2kub5m00.cpp:38: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  // your code here\n  std::vector<long>\
    \ result;\n  if(number + need <= remaining){\n    result.push_back(number + need);\n\
    \    result.push_back(remaining - (number + need));\n  }\n  else{\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  stdout: ''
  stderr: "tmpg_n6ykao: /tmp/tmpg_n6ykao.cpp:40: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining >= need) {\n\
    \        return {number + need, remaining - need};\n    } else {\n        return\
    \ {number + remaining, 0};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    }\n    else {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n\tstd::vector<long> result;\n\
    \tif (remaining >= need) {\n\t\tresult.push_back(number + need);\n\t\tresult.push_back(remaining\
    \ - need);\n\t}\n\telse {\n\t\tresult.push_back(number + remaining);\n\t\tresult.push_back(0);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(remaining + number);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  stdout: ''
  stderr: "tmpthx5p6dg: /tmp/tmpthx5p6dg.cpp:43: int main(): Assertion `candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4}))' failed.\n"
  exit_code: -6
  status: Exception
