language: cpp
name: HumanEval_159_eat
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    result.push_back(number + std::min(need, remaining));\n    result.push_back(std::max(remaining\
    \ - need, 0L));\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (number + need <= remaining) {\n    result.push_back(number + need);\n \
    \   result.push_back(remaining - (number + need));\n  } else {\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: Exception
  stderr: 'tmp_47kpdx8: /tmp/tmp_47kpdx8.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if (remaining >= need) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> v;\n  \
    \  if(remaining < need) {\n        v.push_back(number + remaining);\n        v.push_back(0);\n\
    \    } else {\n        v.push_back(number + need);\n        v.push_back(remaining\
    \ - need);\n    }\n    return v;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if(remaining >= need)\n \
    \       return {number + need, remaining - need};\n    else\n        return {number\
    \ + remaining, 0};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpf_8bccad: /tmp/tmpf_8bccad.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpqcbfmc03: /tmp/tmpqcbfmc03.cpp:39: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpf_8bccad: /tmp/tmpf_8bccad.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    }\n    else {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  long total = number + remaining;\n\
    \  if (total >= need) {\n    return {need, total - need};\n  } else {\n    return\
    \ {total, 0};\n  }\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpsnr5b5s5: /tmp/tmpsnr5b5s5.cpp:35: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpf_8bccad: /tmp/tmpf_8bccad.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(remaining + number);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: Exception
  stderr: 'tmp24j_n25z: /tmp/tmp24j_n25z.cpp:43: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    }\n    else {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  // your code here\n  std::vector<long>\
    \ result;\n  if(number+need<=remaining){\n    result.push_back(number+need);\n\
    \    result.push_back(remaining-(number+need));\n  }\n  else{\n    result.push_back(number+remaining);\n\
    \    result.push_back(0);\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: Exception
  stderr: 'tmp4jybmyt_: /tmp/tmp4jybmyt_.cpp:40: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining < need) {\n\
    \        return {number + remaining, 0};\n    } else {\n        return {number\
    \ + need, remaining - need};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    long\
    \ total = number + remaining;\n    if (total >= need) {\n        return {need,\
    \ total - need};\n    } else {\n        return {total, 0};\n    }\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpjwntuh3k: /tmp/tmpjwntuh3k.cpp:36: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(number + remaining);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: Exception
  stderr: 'tmpklu8mml7: /tmp/tmpklu8mml7.cpp:43: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (number + need <= remaining) {\n    result.push_back(number + need);\n \
    \   result.push_back(remaining - (number + need));\n  } else {\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: Exception
  stderr: 'tmp_47kpdx8: /tmp/tmp_47kpdx8.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  if (remaining < need) {\n \
    \   return {number + remaining, 0};\n  }\n  return {number + need, remaining -\
    \ need};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpf_8bccad: /tmp/tmpf_8bccad.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need)\n    {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    }\n    else\n    {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078713
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(remaining >= need) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpqcbfmc03: /tmp/tmpqcbfmc03.cpp:39: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if(need - number <= remaining) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(number + remaining);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: Exception
  stderr: 'tmpe37nvvel: /tmp/tmpe37nvvel.cpp:43: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    long total = number + remaining;\n\
    \    if (total >= need) {\n        return {need, total - need};\n    } else {\n\
    \        return {total, 0};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: Exception
  stderr: 'tmp_gij22ed: /tmp/tmp_gij22ed.cpp:35: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(need > remaining)\n    {\n        result.push_back(number +\
    \ remaining);\n        result.push_back(0);\n    }\n    else\n    {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number > 1000 || need > 1000 || remaining > 1000) {\n        result.push_back(0);\n\
    \        result.push_back(0);\n        return result;\n    }\n    if (remaining\
    \ >= need) {\n        result.push_back(number + need);\n        result.push_back(remaining\
    \ - need);\n    } else {\n        result.push_back(number + remaining);\n    \
    \    result.push_back(0);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpqcbfmc03: /tmp/tmpqcbfmc03.cpp:39: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need > remaining) {\n        result.push_back(remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - (number + need));\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpw3ksti3g: /tmp/tmpw3ksti3g.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need <= remaining) {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    } else {\n      \
    \  result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpf_8bccad: /tmp/tmpf_8bccad.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining >= need) {\n\
    \        return {number + need, remaining - need};\n    } else {\n        return\
    \ {number + remaining, 0};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpqcbfmc03: /tmp/tmpqcbfmc03.cpp:39: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  // your code here\n  std::vector<long>\
    \ result;\n  if(remaining >= need){\n    result.push_back(number + need);\n  \
    \  result.push_back(remaining - need);\n  }\n  else{\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(remaining >= need){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    // your code here\n    std::vector<long>\
    \ result;\n    if(remaining < need){\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    }\n    else{\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining < need) {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  } else {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  long total = number + need;\n\
    \  long left = 0;\n  if (total > remaining) {\n    total = remaining;\n    left\
    \ = 0;\n  } else {\n    left = remaining - total;\n  }\n  std::vector<long> result\
    \ = {total, left};\n  return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: Exception
  stderr: 'tmpn5jyho51: /tmp/tmpn5jyho51.cpp:39: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n\tstd::vector<long> result;\n\
    \tif (remaining >= need) {\n\t\tresult.push_back(number + need);\n\t\tresult.push_back(remaining\
    \ - need);\n\t}\n\telse {\n\t\tresult.push_back(number + remaining);\n\t\tresult.push_back(0);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpqcbfmc03: /tmp/tmpqcbfmc03.cpp:39: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if(remaining >= need)\n \
    \       return {number + need, remaining - need};\n    return {number + remaining,\
    \ 0};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6),\
    \ (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(number + need <= remaining){\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - (number + need));\n    }\n    else{\n  \
    \      result.push_back(number + remaining);\n        result.push_back(0);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpqcbfmc03: /tmp/tmpqcbfmc03.cpp:39: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(remaining + number);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: Exception
  stderr: 'tmp24j_n25z: /tmp/tmp24j_n25z.cpp:43: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number + need > remaining) {\n        result.push_back(remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - (number + need));\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpw3ksti3g: /tmp/tmpw3ksti3g.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  if (remaining < need) {\n \
    \   return {number + remaining, 0};\n  } else {\n    return {number + need, remaining\
    \ - need};\n  }\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  if (remaining >= need) {\n\
    \    return {number + need, remaining - need};\n  } else {\n    return {number\
    \ + remaining, 0};\n  }\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining < need) {\n\
    \        return {number + remaining, 0};\n    }\n    return {number + need, remaining\
    \ - need};\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (number + need <= remaining) {\n    result.push_back(number + need);\n \
    \   result.push_back(remaining - (number + need));\n  } else {\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: Exception
  stderr: 'tmp_47kpdx8: /tmp/tmp_47kpdx8.cpp:38: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining < need) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  // your code here\n  std::vector<long>\
    \ result;\n  if(number + need <= remaining){\n    result.push_back(number + need);\n\
    \    result.push_back(remaining - (number + need));\n  }\n  else{\n    result.push_back(number\
    \ + remaining);\n    result.push_back(0);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11,\
    \ (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12,\
    \ (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11,\
    \ (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7,\
    \ (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9,\
    \ (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5,\
    \ (long)0})));\n}\n"
  status: Exception
  stderr: 'tmpwjywtqu7: /tmp/tmpwjywtqu7.cpp:40: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    if (remaining >= need) {\n\
    \        return {number + need, remaining - need};\n    } else {\n        return\
    \ {number + remaining, 0};\n    }\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need) {\n        result.push_back(number + need);\n     \
    \   result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n  std::vector<long> result;\n\
    \  if (remaining >= need) {\n    result.push_back(number + need);\n    result.push_back(remaining\
    \ - need);\n  } else {\n    result.push_back(number + remaining);\n    result.push_back(0);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need)\n    {\n        result.push_back(number + need);\n\
    \        result.push_back(remaining - need);\n    }\n    else\n    {\n       \
    \ result.push_back(number + remaining);\n        result.push_back(0);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining >= need){\n        result.push_back(number + need);\n      \
    \  result.push_back(remaining - need);\n    }\n    else{\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if(remaining < need) {\n        result.push_back(number + remaining);\n \
    \       result.push_back(0);\n    }\n    else {\n        result.push_back(number\
    \ + need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (remaining >= need) {\n        result.push_back(number + need);\n    \
    \    result.push_back(remaining - need);\n    } else {\n        result.push_back(number\
    \ + remaining);\n        result.push_back(0);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078711
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (need > remaining) {\n        result.push_back(number + remaining);\n\
    \        result.push_back(0);\n    } else {\n        result.push_back(number +\
    \ need);\n        result.push_back(remaining - need);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10))\
    \ == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8),\
    \ (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078712
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n\tstd::vector<long> result;\n\
    \tif (remaining >= need) {\n\t\tresult.push_back(number + need);\n\t\tresult.push_back(remaining\
    \ - need);\n\t}\n\telse {\n\t\tresult.push_back(number + remaining);\n\t\tresult.push_back(0);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5),\
    \ (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4),\
    \ (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1),\
    \ (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2),\
    \ (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4),\
    \ (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4),\
    \ (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660078714
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit,\
    \ and you already have eaten a certain number of carrots,\n// but now you need\
    \ to eat more carrots to complete the day's meals.\n// you should return an array\
    \ of [ total number of eaten carrots after your meals,\n// the number of carrots\
    \ left after your meals ]\n// if there are not enough remaining carrots, you will\
    \ eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5,\
    \ 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11,\
    \ 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the\
    \ number of carrots that you have eaten.\n// @need : integer\n// the number of\
    \ carrots that you need to eat.\n// @remaining : integer\n// the number of remaining\
    \ carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0\
    \ <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long>\
    \ eat(long number, long need, long remaining) {\n    std::vector<long> result;\n\
    \    if (number >= need) {\n        result.push_back(number);\n        result.push_back(remaining);\n\
    \    } else {\n        if (remaining >= need - number) {\n            result.push_back(need);\n\
    \            result.push_back(remaining - (need - number));\n        } else {\n\
    \            result.push_back(remaining + number);\n            result.push_back(0);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = eat;\n\
    \    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n\
    \    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n\
    \    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n\
    \    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n\
    \    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n\
    \    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n\
    }\n"
  status: Exception
  stderr: 'tmp24j_n25z: /tmp/tmp24j_n25z.cpp:43: int main(): Assertion `candidate((5),
    (6), (10)) == (std::vector<long>({(long)11, (long)4}))'' failed.

    '
  stdout: ''
  timestamp: 1660078711
