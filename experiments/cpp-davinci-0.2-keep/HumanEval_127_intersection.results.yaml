language: cpp
name: HumanEval_127_intersection
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    long length\
    \ = end - start + 1;\n    if (length == 2) {\n        return \"YES\";\n    }\n\
    \    if (length % 2 == 0) {\n        return \"NO\";\n    }\n    for (long i =\
    \ 3; i * i <= length; i += 2) {\n        if (length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmqy1tndp: /tmp/tmpmqy1tndp.cpp:54: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n   \
    \         return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmptuys37yk: /tmp/tmptuys37yk.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmjikw25p: /tmp/tmpmjikw25p.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= std::sqrt(length); i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpr_xcvknl: /tmp/tmpr_xcvknl.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n\tlong start1, end1, start2,\
    \ end2;\n\tstd::tie(start1, end1) = interval1;\n\tstd::tie(start2, end2) = interval2;\n\
    \tlong start = std::max(start1, start2);\n\tlong end = std::min(end1, end2);\n\
    \tif (start > end) {\n\t\treturn \"NO\";\n\t}\n\tlong len = end - start + 1;\n\
    \tif (len == 1) {\n\t\treturn \"NO\";\n\t}\n\tfor (long i = 2; i * i <= len; i++)\
    \ {\n\t\tif (len % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t}\n\treturn \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphvunlcuh: /tmp/tmphvunlcuh.cpp:42: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    long len = end1 - start2 + 1;\n    if(len <= 1)\n\
    \        return \"NO\";\n    if(len == 2)\n        return \"YES\";\n    for(long\
    \ i = 2; i < len; i++)\n        if(len % i == 0)\n            return \"NO\";\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphgbcp3pi: /tmp/tmphgbcp3pi.cpp:44: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    long len = end - start + 1;\n    if (len <= 1) {\n        return\
    \ \"NO\";\n    }\n    for (long i = 2; i * i <= len; ++i) {\n        if (len %\
    \ i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpuegmwwsh: /tmp/tmpuegmwwsh.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    if (start\
    \ + 1 == end) {\n        return \"NO\";\n    }\n    if (start + 2 == end) {\n\
    \        return \"YES\";\n    }\n    for (long i = 2; i <= std::sqrt(end); ++i)\
    \ {\n        if (start % i == 0 || end % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp5zoti72: /tmp/tmpp5zoti72.cpp:53: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    if (start == end) {\n        return \"YES\";\n    }\n  \
    \  long length = end - start + 1;\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    if (length % 2 == 0) {\n        return \"NO\";\n    }\n    for (long\
    \ i = 3; i * i <= length; i += 2) {\n        if (length % i == 0) {\n        \
    \    return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp0ubnaqzd: /tmp/tmp0ubnaqzd.cpp:51: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    for (long i = 2; i * i <= len; i++) {\n       \
    \ if (len % i == 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpbxo1erjz: /tmp/tmpbxo1erjz.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i <= std::sqrt(length); i++) {\n        if (length % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp3paubk5o: /tmp/tmp3paubk5o.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if(start2 > end2) {\n        std::swap(start2, end2);\n \
    \   }\n    if(start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n\
    \    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    if(start == end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start;\n    if(length == 1) {\n        return \"YES\";\n    }\n    for(long\
    \ i = 2; i <= std::sqrt(length); i++) {\n        if(length % i == 0) {\n     \
    \       return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpeftq9jxn: /tmp/tmpeftq9jxn.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if(start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if(start2 > end1) {\n \
    \       return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if(length\
    \ == 1) {\n        return \"NO\";\n    }\n    if(length == 2) {\n        return\
    \ \"YES\";\n    }\n    for(long i = 2; i <= std::sqrt(length); i++) {\n      \
    \  if(length % i == 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpxh2mnbzn: /tmp/tmpxh2mnbzn.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    if(start2 <= end1 && end2 >= start1)\n    {\n   \
    \     long len = end1 - start2 + 1;\n        if(len == 1)\n            return\
    \ \"NO\";\n        for(long i = 2; i <= len / 2; i++)\n        {\n           \
    \ if(len % i == 0)\n                return \"NO\";\n        }\n        return\
    \ \"YES\";\n    }\n    return \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp2gu40o57: /tmp/tmp2gu40o57.cpp:48: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, end1,\
    \ start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    if (start1 > end1) {\n        std::swap(start1, end1);\n\
    \    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n    }\n  \
    \  long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"YES\";\n    }\n    for\
    \ (long i = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n     \
    \       return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp2v_mopym: /tmp/tmp2v_mopym.cpp:47: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (end1 < start2 || end2 < start1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    long len\
    \ = end - start + 1;\n    if (len == 2) {\n        return \"YES\";\n    }\n  \
    \  if (len % 2 == 0) {\n        return \"NO\";\n    }\n    for (long i = 3; i\
    \ * i <= len; i += 2) {\n        if (len % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp7tukdysz: /tmp/tmp7tukdysz.cpp:54: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmjikw25p: /tmp/tmpmjikw25p.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp5exf8oh3: /tmp/tmp5exf8oh3.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long len = end1 - start2 + 1;\n    if (len\
    \ <= 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= len; ++i)\
    \ {\n        if (len % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp07gc59dx: /tmp/tmp07gc59dx.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if(start2 > end2) {\n        std::swap(start2, end2);\n \
    \   }\n    if(end1 < start2 || end2 < start1) {\n        return \"NO\";\n    }\n\
    \    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    long len = end - start + 1;\n    if(len == 1) {\n        return \"NO\";\n\
    \    }\n    for(long i = 2; i * i <= len; i++) {\n        if(len % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmdzpmzgo: /tmp/tmpmdzpmzgo.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long diff = end - start + 1;\n    if (diff == 1) {\n   \
    \     return \"NO\";\n    }\n    if (diff == 2) {\n        return \"YES\";\n \
    \   }\n    if (diff % 2 == 0) {\n        return \"NO\";\n    }\n    for (long\
    \ i = 3; i <= sqrt(diff); i += 2) {\n        if (diff % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp876e02tm: /tmp/tmp876e02tm.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if (length\
    \ <= 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i <= sqrt(length);\
    \ ++i) {\n        if (length % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp4lwhxcop: /tmp/tmp4lwhxcop.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long start = start2;\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"NO\";\n    }\n    if (start\
    \ == 2) {\n        return \"YES\";\n    }\n    if (start % 2 == 0) {\n       \
    \ return \"NO\";\n    }\n    for (long i = 3; i <= std::sqrt(end); i += 2) {\n\
    \        if (start % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpntsf8bvo: /tmp/tmpntsf8bvo.cpp:57: int main(): Assertion `candidate((std::make_tuple(-2,
    2)), (std::make_tuple(-4, 0))) == ("YES")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i < len; i++) {\n        if (len % i == 0) {\n         \
    \   return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n \
    \   auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp4j3823u4: /tmp/tmp4j3823u4.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = std::min(end1, end2) - start2\
    \ + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for (long i\
    \ = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpkmd1cnan: /tmp/tmpkmd1cnan.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, start2,\
    \ end1, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2, end2)\
    \ = interval2;\n    if (start1 > end1) {\n        std::swap(start1, end1);\n \
    \   }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n    }\n   \
    \ if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n    long\
    \ start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n  \
    \  if (start == end) {\n        return \"YES\";\n    }\n    if (start == 0 ||\
    \ end == 0) {\n        return \"NO\";\n    }\n    if (start < 0) {\n        start\
    \ = -start;\n    }\n    if (end < 0) {\n        end = -end;\n    }\n    if (start\
    \ > end) {\n        std::swap(start, end);\n    }\n    for (long i = 2; i <= std::sqrt(end);\
    \ ++i) {\n        if (start % i == 0 || end % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp76c2_7w9: /tmp/tmp76c2_7w9.cpp:58: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long start = start2;\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"NO\";\n    }\n    if (start\
    \ == 2 || start == 3 || start == 5 || start == 7) {\n        return \"YES\";\n\
    \    }\n    if (start % 2 == 0 || start % 3 == 0 || start % 5 == 0 || start %\
    \ 7 == 0) {\n        return \"NO\";\n    }\n    for (long i = start + 1; i < end;\
    \ ++i) {\n        if (i == 2 || i == 3 || i == 5 || i == 7) {\n            return\
    \ \"YES\";\n        }\n        if (i % 2 == 0 || i % 3 == 0 || i % 5 == 0 || i\
    \ % 7 == 0) {\n            return \"NO\";\n        }\n    }\n    return \"NO\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpu_sulc0m: /tmp/tmpu_sulc0m.cpp:59: int main(): Assertion `candidate((std::make_tuple(-3,
    -1)), (std::make_tuple(-5, 5))) == ("YES")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (end1 < start2 || end2 < start1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    long len = end - start + 1;\n    if (len == 1) {\n        return\
    \ \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n    for\
    \ (long i = 2; i * i <= len; ++i) {\n        if (len % i == 0) {\n           \
    \ return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n   \
    \ auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp53wnm0xm: /tmp/tmp53wnm0xm.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    if(start2 <= end1 && start2 >= start1)\n        return\
    \ \"YES\";\n    return \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpaw1mlj_5: /tmp/tmpaw1mlj_5.cpp:38: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if (length\
    \ == 1) {\n        return \"NO\";\n    }\n    if (length == 2) {\n        return\
    \ \"YES\";\n    }\n    for (long i = 2; i * i <= length; ++i) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphi299tpu: /tmp/tmphi299tpu.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp3hcsihmx: /tmp/tmp3hcsihmx.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) return \"NO\";\n \
    \   if (start == end) return \"YES\";\n    if (start == 1) return \"NO\";\n  \
    \  for (long i = 2; i < start; i++) {\n        if (start % i == 0) return \"NO\"\
    ;\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpoj59hpb3: /tmp/tmpoj59hpb3.cpp:36: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= sqrt(length); i++) {\n\
    \        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp45xwg_0_: /tmp/tmp45xwg_0_.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    if (start\
    \ == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= end; ++i)\
    \ {\n        if (start % i == 0) {\n            return \"NO\";\n        }\n  \
    \  }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpcgm2s0y9: /tmp/tmpcgm2s0y9.cpp:50: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    long start = start2;\n    long end = end1;\n    if(start\
    \ == end)\n        return \"YES\";\n    if(start == 1)\n        return \"NO\"\
    ;\n    for(long i = 2; i <= end; i++)\n    {\n        if(start % i == 0 && end\
    \ % i == 0)\n            return \"NO\";\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpzx0hbvqd: /tmp/tmpzx0hbvqd.cpp:47: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  if (start1 > end1 || start2 > end2)\
    \ {\n    return \"NO\";\n  }\n  if (start1 > start2) {\n    std::swap(start1,\
    \ start2);\n    std::swap(end1, end2);\n  }\n  if (start2 > end1) {\n    return\
    \ \"NO\";\n  }\n  long start = start2;\n  long end = end1 < end2 ? end1 : end2;\n\
    \  long length = end - start + 1;\n  if (length == 1) {\n    return \"NO\";\n\
    \  }\n  if (length == 2) {\n    return \"YES\";\n  }\n  for (long i = 2; i < length;\
    \ ++i) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n  return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpku1bz1zk: /tmp/tmpku1bz1zk.cpp:53: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    if (start == end) {\n        return \"YES\";\n    }\n  \
    \  long length = end - start + 1;\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= length / 2; i++) {\n        if (length % i\
    \ == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpre2u3k3q: /tmp/tmpre2u3k3q.cpp:48: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  long start = std::max(start1, start2);\n\
    \  long end = std::min(end1, end2);\n  if (start > end) return \"NO\";\n  if (start\
    \ == end) return \"YES\";\n  for (long i = 2; i < end; i++) {\n    if (start %\
    \ i == 0) return \"NO\";\n  }\n  return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmppjwjqfm9: /tmp/tmppjwjqfm9.cpp:35: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    if (start == end) {\n        return \"YES\";\n    }\n  \
    \  long length = end - start + 1;\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    if (length % 2 == 0) {\n        return \"NO\";\n    }\n    for (long\
    \ i = 3; i * i <= length; i += 2) {\n        if (length % i == 0) {\n        \
    \    return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp0ubnaqzd: /tmp/tmp0ubnaqzd.cpp:51: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) return \"NO\";\n    if (start == end) return \"YES\";\n\
    \    for (long i = 2; i <= end; i++) {\n        if (start % i == 0 && end % i\
    \ == 0) return \"NO\";\n    }\n    return \"YES\";\n}\nint main() {\n    auto\
    \ candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmppxs63n41: /tmp/tmppxs63n41.cpp:31: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long len = std::min(end1, end2) - start2 +\
    \ 1;\n    if (len == 1) {\n        return \"NO\";\n    }\n    for (long i = 2;\
    \ i * i <= len; ++i) {\n        if (len % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp6eo66aur: /tmp/tmp6eo66aur.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    for (long i = 2; i < len; i++) {\n        if (len\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmw29vxg2: /tmp/tmpmw29vxg2.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ return \"NO\";\n    if(start1 > end2 || start2 > end1) return \"NO\";\n    long\
    \ start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n  \
    \  if(start == end) return \"YES\";\n    if(start == 2) return \"YES\";\n    if(start\
    \ % 2 == 0) return \"NO\";\n    for(long i = 3; i <= std::sqrt(end); i += 2) {\n\
    \        if(start % i == 0) return \"NO\";\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpk5kmutmd: /tmp/tmpk5kmutmd.cpp:38: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long intersection_start = start2;\n    long\
    \ intersection_end = std::min(end1, end2);\n    long intersection_length = intersection_end\
    \ - intersection_start + 1;\n    if (intersection_length == 1) {\n        return\
    \ \"NO\";\n    }\n    for (long i = 2; i * i <= intersection_length; ++i) {\n\
    \        if (intersection_length % i == 0) {\n            return \"NO\";\n   \
    \     }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp746mxj20: /tmp/tmp746mxj20.cpp:50: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if (length\
    \ == 1) {\n        return \"NO\";\n    }\n    if (length == 2) {\n        return\
    \ \"YES\";\n    }\n    for (long i = 2; i * i <= length; ++i) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphi299tpu: /tmp/tmphi299tpu.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, end1,\
    \ start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    if (start1 > end1) {\n        std::swap(start1, end1);\n\
    \    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n    }\n  \
    \  if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n    long\
    \ start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n  \
    \  long length = end - start + 1;\n    if (length == 1) {\n        return \"NO\"\
    ;\n    }\n    if (length == 2) {\n        return \"YES\";\n    }\n    for (long\
    \ i = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n           \
    \ return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n   \
    \ auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpfz8eccsf: /tmp/tmpfz8eccsf.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  if (start1 > end1 || start2 > end2)\
    \ {\n    return \"NO\";\n  }\n  long start = std::max(start1, start2);\n  long\
    \ end = std::min(end1, end2);\n  if (start > end) {\n    return \"NO\";\n  }\n\
    \  if (start == end) {\n    return \"YES\";\n  }\n  if (start == 1) {\n    return\
    \ \"NO\";\n  }\n  for (long i = 2; i < end; i++) {\n    if (end % i == 0) {\n\
    \      return \"NO\";\n    }\n  }\n  return \"YES\";\n}\nint main() {\n    auto\
    \ candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpd2xkfvzp: /tmp/tmpd2xkfvzp.cpp:47: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= length / 2; i++) {\n        if (length % i\
    \ == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpqyw5msn4: /tmp/tmpqyw5msn4.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if(start2 > end2) {\n        std::swap(start2, end2);\n \
    \   }\n    if(start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n\
    \    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    if(start == end) {\n        return \"NO\";\n    }\n    long len = end - start;\n\
    \    if(len == 1) {\n        return \"YES\";\n    }\n    if(len % 2 == 0) {\n\
    \        return \"NO\";\n    }\n    for(long i = 3; i * i <= len; i += 2) {\n\
    \        if(len % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp8ic9zi_2: /tmp/tmp8ic9zi_2.cpp:55: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    if (len % 2 == 0) {\n        return \"NO\";\n    }\n    for (long i = 3;\
    \ i * i <= len; i += 2) {\n        if (len % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpt8t9sodg: /tmp/tmpt8t9sodg.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long len = end - start\
    \ + 1;\n    if (len == 1) {\n        return \"NO\";\n    }\n    if (len == 2)\
    \ {\n        return \"YES\";\n    }\n    for (long i = 2; i < len; i++) {\n  \
    \      if (len % i == 0) {\n            return \"NO\";\n        }\n    }\n   \
    \ return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp7ruq3dbi: /tmp/tmp7ruq3dbi.cpp:42: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    long len = end1 - start2 + 1;\n    if(len == 1)\n\
    \        return \"NO\";\n    for(long i = 2; i <= len / 2; i++)\n        if(len\
    \ % i == 0)\n            return \"NO\";\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp0sgo99yo: /tmp/tmp0sgo99yo.cpp:42: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    long len = end1 - start2 + 1;\n    if(len == 1)\n\
    \        return \"NO\";\n    for(long i = 2; i <= sqrt(len); i++)\n        if(len\
    \ % i == 0)\n            return \"NO\";\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp7rwqct2s: /tmp/tmp7rwqct2s.cpp:42: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i * i <= len; i++) {\n        if (len % i == 0) {\n    \
    \        return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpdxu9rj12: /tmp/tmpdxu9rj12.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if (length\
    \ <= 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i <= sqrt(length);\
    \ ++i) {\n        if (length % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp4lwhxcop: /tmp/tmp4lwhxcop.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp5exf8oh3: /tmp/tmp5exf8oh3.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long intersection_start = start2;\n    long\
    \ intersection_end = std::min(end1, end2);\n    long length = intersection_end\
    \ - intersection_start + 1;\n    if (length <= 1) {\n        return \"NO\";\n\
    \    }\n    for (long i = 2; i <= sqrt(length); ++i) {\n        if (length % i\
    \ == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpreitm3t7: /tmp/tmpreitm3t7.cpp:50: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if (length\
    \ <= 1) {\n        return \"NO\";\n    }\n    if (length == 2) {\n        return\
    \ \"YES\";\n    }\n    for (long i = 2; i * i <= length; ++i) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp651fygvc: /tmp/tmp651fygvc.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(end1 < start2 || end2 < start1)\n\
    \        return \"NO\";\n    long start = std::max(start1, start2);\n    long\
    \ end = std::min(end1, end2);\n    long len = end - start + 1;\n    if(len ==\
    \ 1)\n        return \"NO\";\n    for(long i = 2; i <= sqrt(len); i++)\n     \
    \   if(len % i == 0)\n            return \"NO\";\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp3adcnsn0: /tmp/tmp3adcnsn0.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    if\
    \ (length == 2) {\n        return \"YES\";\n    }\n    for (long i = 2; i < length;\
    \ i++) {\n        if (length % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp5qbfkv4n: /tmp/tmp5qbfkv4n.cpp:42: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    if\
    \ (length == 2) {\n        return \"YES\";\n    }\n    for (long i = 2; i < length;\
    \ i++) {\n        if (length % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp5qbfkv4n: /tmp/tmp5qbfkv4n.cpp:42: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = std::min(end1, end2) - start2\
    \ + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for (long i\
    \ = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpkmd1cnan: /tmp/tmpkmd1cnan.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n\tlong start1 = std::get<0>(interval1);\n\
    \tlong end1 = std::get<1>(interval1);\n\tlong start2 = std::get<0>(interval2);\n\
    \tlong end2 = std::get<1>(interval2);\n\tlong start = std::max(start1, start2);\n\
    \tlong end = std::min(end1, end2);\n\tif (start > end) {\n\t\treturn \"NO\";\n\
    \t}\n\tlong length = end - start + 1;\n\tif (length == 1) {\n\t\treturn \"NO\"\
    ;\n\t}\n\tfor (long i = 2; i < length; i++) {\n\t\tif (length % i == 0) {\n\t\t\
    \treturn \"NO\";\n\t\t}\n\t}\n\treturn \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmptn9bbu0_: /tmp/tmptn9bbu0_.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= std::sqrt(length); i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpr_xcvknl: /tmp/tmpr_xcvknl.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (end1 < start2 || end2 < start1)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    long length = end - start + 1;\n  \
    \  if (length == 1) {\n        return \"NO\";\n    }\n    bool isPrime = true;\n\
    \    for (long i = 2; i <= length / 2; i++) {\n        if (length % i == 0) {\n\
    \            isPrime = false;\n            break;\n        }\n    }\n    return\
    \ isPrime ? \"YES\" : \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpzhdwguhm: /tmp/tmpzhdwguhm.cpp:45: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    long len = end - start + 1;\n    if (len == 1) {\n        return\
    \ \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n    for\
    \ (long i = 2; i * i <= len; ++i) {\n        if (len % i == 0) {\n           \
    \ return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n   \
    \ auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpnfz8626p: /tmp/tmpnfz8626p.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i < len; i++) {\n        if (len % i == 0) {\n         \
    \   return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n \
    \   auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpxq8ih3bq: /tmp/tmpxq8ih3bq.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    for (long i = 2; i <= end; i++) {\n \
    \       if (start % i == 0 && end % i == 0) {\n            return \"NO\";\n  \
    \      }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpl6m96q5p: /tmp/tmpl6m96q5p.cpp:37: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    long length\
    \ = end - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n\
    \    if (length == 2) {\n        return \"YES\";\n    }\n    for (long i = 2;\
    \ i < length; i++) {\n        if (length % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpzkmwjg8p: /tmp/tmpzkmwjg8p.cpp:54: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long start = start2;\n    long end = std::min(end1,\
    \ end2);\n    long length = end - start + 1;\n    if (length == 1) {\n       \
    \ return \"YES\";\n    }\n    for (long i = 2; i <= length / 2; ++i) {\n     \
    \   if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n   \
    \ return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpcalhypfy: /tmp/tmpcalhypfy.cpp:49: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) return \"NO\";\n    long len = end - start + 1;\n    if\
    \ (len == 1) return \"NO\";\n    if (len == 2) return \"YES\";\n    for (long\
    \ i = 2; i < len; i++) {\n        if (len % i == 0) return \"NO\";\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp_5tdfpce: /tmp/tmp_5tdfpce.cpp:34: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= sqrt(length); i++) {\n\
    \        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp45xwg_0_: /tmp/tmp45xwg_0_.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    long len = end - start + 1;\n    if (len\
    \ == 2) {\n        return \"YES\";\n    }\n    for (long i = 2; i * i <= len;\
    \ i++) {\n        if (len % i == 0) {\n            return \"NO\";\n        }\n\
    \    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpgciodyia: /tmp/tmpgciodyia.cpp:41: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    long len\
    \ = end - start + 1;\n    if (len == 1) {\n        return \"NO\";\n    }\n   \
    \ if (len == 2) {\n        return \"YES\";\n    }\n    for (long i = 2; i * i\
    \ <= len; ++i) {\n        if (len % i == 0) {\n            return \"NO\";\n  \
    \      }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp05f06d4: /tmp/tmpp05f06d4.cpp:54: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    int start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    int len = end - start\
    \ + 1;\n    if (len < 2) {\n        return \"NO\";\n    }\n    if (len == 2) {\n\
    \        return \"YES\";\n    }\n    for (int i = 2; i < len; i++) {\n       \
    \ if (len % i == 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpave0fya8: /tmp/tmpave0fya8.cpp:42: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i <= std::sqrt(length); i++) {\n        if (length % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp3paubk5o: /tmp/tmp3paubk5o.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1, end1, start2,\
    \ end2;\n  std::tie(start1, end1) = interval1;\n  std::tie(start2, end2) = interval2;\n\
    \  if (start1 > end1) {\n    std::swap(start1, end1);\n  }\n  if (start2 > end2)\
    \ {\n    std::swap(start2, end2);\n  }\n  if (start1 > end2 || start2 > end1)\
    \ {\n    return \"NO\";\n  }\n  long start = std::max(start1, start2);\n  long\
    \ end = std::min(end1, end2);\n  if (start == end) {\n    return \"YES\";\n  }\n\
    \  if (start == 1) {\n    return \"NO\";\n  }\n  for (long i = 2; i * i <= end;\
    \ ++i) {\n    if (start % i == 0) {\n      return \"NO\";\n    }\n  }\n  return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpwqopafpi: /tmp/tmpwqopafpi.cpp:49: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= std::sqrt(length); i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpzyq25k1n: /tmp/tmpzyq25k1n.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082359
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, end1,\
    \ start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    long start = std::max(start1, start2);\n    long end\
    \ = std::min(end1, end2);\n    if (start > end) return \"NO\";\n    if (start\
    \ == end) return \"YES\";\n    if (start == 1) return \"NO\";\n    for (long i\
    \ = 2; i < start; i++) {\n        if (start % i == 0) return \"NO\";\n    }\n\
    \    for (long i = 2; i < end; i++) {\n        if (end % i == 0) return \"NO\"\
    ;\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpr3867klg: /tmp/tmpr3867klg.cpp:38: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082359
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= length / 2; i++) {\n\
    \        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphnwdil5x: /tmp/tmphnwdil5x.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082359
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long len = end - start\
    \ + 1;\n    if (len == 1) {\n        return \"NO\";\n    }\n    for (long i =\
    \ 2; i * i <= len; i++) {\n        if (len % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpv_kn1drv: /tmp/tmpv_kn1drv.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, end1,\
    \ start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    if (start1 > end1) {\n        std::swap(start1, end1);\n\
    \    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n    }\n  \
    \  if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n    long\
    \ start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n  \
    \  if (start == end) {\n        return \"YES\";\n    }\n    long len = end - start\
    \ + 1;\n    if (len == 2) {\n        return \"YES\";\n    }\n    for (long i =\
    \ 2; i * i <= len; ++i) {\n        if (len % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpg1zg_rwc: /tmp/tmpg1zg_rwc.cpp:50: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmjikw25p: /tmp/tmpmjikw25p.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= sqrt(length); i++) {\n\
    \        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp45xwg_0_: /tmp/tmp45xwg_0_.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    long len = end1 - start2 + 1;\n    if(len == 1)\n\
    \        return \"NO\";\n    for(long i = 2; i <= sqrt(len); i++)\n        if(len\
    \ % i == 0)\n            return \"NO\";\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp7rwqct2s: /tmp/tmp7rwqct2s.cpp:42: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082357
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if(start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if(start2 > end1) {\n \
    \       return \"NO\";\n    }\n    long intersectionLength = std::min(end1, end2)\
    \ - start2 + 1;\n    if(intersectionLength == 1) {\n        return \"NO\";\n \
    \   }\n    for(long i = 2; i <= intersectionLength / 2; ++i) {\n        if(intersectionLength\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpe92twy6c: /tmp/tmpe92twy6c.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if(start > end) {\n        return \"\
    NO\";\n    }\n    long length = end - start + 1;\n    if(length == 1) {\n    \
    \    return \"NO\";\n    }\n    if(length == 2) {\n        return \"YES\";\n \
    \   }\n    for(long i = 2; i < length; i++) {\n        if(length % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpdj6qsobv: /tmp/tmpdj6qsobv.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= std::sqrt(length); i++)\
    \ {\n        if (length % i == 0) {\n            return \"NO\";\n        }\n \
    \   }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp9lqh3js5: /tmp/tmp9lqh3js5.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmjikw25p: /tmp/tmpmjikw25p.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n   \
    \         return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmptuys37yk: /tmp/tmptuys37yk.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= std::sqrt(length); i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpr_xcvknl: /tmp/tmpr_xcvknl.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long len = end1 - start2 + 1;\n    if (len\
    \ == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= len; ++i)\
    \ {\n        if (len % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp892pr48k: /tmp/tmp892pr48k.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    long length = end - start + 1;\n    if (length == 1) {\n       \
    \ return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\";\n   \
    \ }\n    for (long i = 2; i * i <= length; ++i) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp0toinh0p: /tmp/tmp0toinh0p.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  long start = std::max(start1, start2);\n\
    \  long end = std::min(end1, end2);\n  if (start > end) {\n    return \"NO\";\n\
    \  }\n  long length = end - start + 1;\n  if (length == 1) {\n    return \"NO\"\
    ;\n  }\n  if (length == 2) {\n    return \"YES\";\n  }\n  for (long i = 2; i <\
    \ length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpwbn46978: /tmp/tmpwbn46978.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long len = std::min(end1, end2) - start2 +\
    \ 1;\n    if (len <= 1) {\n        return \"NO\";\n    }\n    for (long i = 2;\
    \ i * i <= len; ++i) {\n        if (len % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp5zc9l5j4: /tmp/tmp5zc9l5j4.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (end1 < start2 || end2 < start1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    long length = end - start + 1;\n    if (length == 1) {\n       \
    \ return \"NO\";\n    }\n    for (long i = 2; i * i <= length; ++i) {\n      \
    \  if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpwyni3mf2: /tmp/tmpwyni3mf2.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    long length = end - start + 1;\n    if\
    \ (length == 2) {\n        return \"YES\";\n    }\n    for (long i = 2; i < length;\
    \ i++) {\n        if (length % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpdcjf_g84: /tmp/tmpdcjf_g84.cpp:41: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = std::min(end1, end2) - start2\
    \ + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for (long i\
    \ = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpkmd1cnan: /tmp/tmpkmd1cnan.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    for (long i = 2; i <= end; i++) {\n \
    \       if (start % i == 0 && end % i == 0) {\n            return \"NO\";\n  \
    \      }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpl6m96q5p: /tmp/tmpl6m96q5p.cpp:37: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, end1,\
    \ start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    if (start1 > end1) {\n        std::swap(start1, end1);\n\
    \    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n    }\n  \
    \  if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n    long\
    \ start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n  \
    \  long length = end - start + 1;\n    if (length == 1) {\n        return \"NO\"\
    ;\n    }\n    for (long i = 2; i * i <= length; ++i) {\n        if (length % i\
    \ == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmps0gmh1rx: /tmp/tmps0gmh1rx.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= std::sqrt(length); i++)\
    \ {\n        if (length % i == 0) {\n            return \"NO\";\n        }\n \
    \   }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp9lqh3js5: /tmp/tmp9lqh3js5.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n   \
    \         return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmptuys37yk: /tmp/tmptuys37yk.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    if (start\
    \ == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= end; ++i)\
    \ {\n        if (start % i == 0) {\n            return \"NO\";\n        }\n  \
    \  }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpcgm2s0y9: /tmp/tmpcgm2s0y9.cpp:50: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= std::sqrt(length); i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpr_xcvknl: /tmp/tmpr_xcvknl.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= sqrt(length); i++) {\n        if (length %\
    \ i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpbejylfy_: /tmp/tmpbejylfy_.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp5exf8oh3: /tmp/tmp5exf8oh3.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    long start = std::max(start1, start2);\n    long\
    \ end = std::min(end1, end2);\n    if(start > end)\n        return \"NO\";\n \
    \   if(start == end)\n        return \"YES\";\n    long length = end - start +\
    \ 1;\n    if(length == 2)\n        return \"YES\";\n    if(length % 2 == 0)\n\
    \        return \"NO\";\n    for(long i = 3; i <= std::sqrt(length); i += 2)\n\
    \        if(length % i == 0)\n            return \"NO\";\n    return \"YES\";\n\
    }\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpxnck3rob: /tmp/tmpxnck3rob.cpp:44: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long start = start2;\n    long end = std::min(end1,\
    \ end2);\n    long length = end - start + 1;\n    if (length == 1) {\n       \
    \ return \"YES\";\n    }\n    if (length == 2) {\n        return \"NO\";\n   \
    \ }\n    for (long i = 2; i <= std::sqrt(length); ++i) {\n        if (length %\
    \ i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpxabscnuz: /tmp/tmpxabscnuz.cpp:52: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  if (start1 > end1 || start2 > end2)\
    \ {\n    return \"NO\";\n  }\n  long start = std::max(start1, start2);\n  long\
    \ end = std::min(end1, end2);\n  if (start > end) {\n    return \"NO\";\n  }\n\
    \  long length = end - start + 1;\n  if (length == 1) {\n    return \"NO\";\n\
    \  }\n  if (length == 2) {\n    return \"YES\";\n  }\n  for (long i = 2; i < length;\
    \ i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n  return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp7lz00_2q: /tmp/tmp7lz00_2q.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  // your code here\n\
    \  long start1, start2, end1, end2;\n  std::tie(start1, end1) = interval1;\n \
    \ std::tie(start2, end2) = interval2;\n  if (start1 > end1 || start2 > end2) {\n\
    \    return \"NO\";\n  }\n  if (start1 > start2) {\n    std::swap(start1, start2);\n\
    \    std::swap(end1, end2);\n  }\n  if (start2 > end1) {\n    return \"NO\";\n\
    \  }\n  long intersection_start = start2;\n  long intersection_end = std::min(end1,\
    \ end2);\n  long intersection_length = intersection_end - intersection_start +\
    \ 1;\n  if (intersection_length == 1) {\n    return \"NO\";\n  }\n  if (intersection_length\
    \ == 2) {\n    return \"YES\";\n  }\n  for (long i = 2; i <= std::sqrt(intersection_length);\
    \ ++i) {\n    if (intersection_length % i == 0) {\n      return \"NO\";\n    }\n\
    \  }\n  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpg1d68d9h: /tmp/tmpg1d68d9h.cpp:53: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i * i <= len; i++) {\n        if (len % i == 0) {\n    \
    \        return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpdxu9rj12: /tmp/tmpdxu9rj12.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    if (start == end) {\n        return \"YES\";\n    }\n  \
    \  if (start == 2) {\n        return \"YES\";\n    }\n    if (start % 2 == 0)\
    \ {\n        return \"NO\";\n    }\n    for (long i = 3; i <= sqrt(end); i +=\
    \ 2) {\n        if (start % i == 0) {\n            return \"NO\";\n        }\n\
    \    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpw5a5titz: /tmp/tmpw5a5titz.cpp:50: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i < len; i++) {\n        if (len % i == 0) {\n         \
    \   return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n \
    \   auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp4j3823u4: /tmp/tmp4j3823u4.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  long start = std::max(start1, start2);\n\
    \  long end = std::min(end1, end2);\n  if (start > end) {\n    return \"NO\";\n\
    \  }\n  long length = end - start + 1;\n  if (length == 1) {\n    return \"NO\"\
    ;\n  }\n  for (long i = 2; i < length; i++) {\n    if (length % i == 0) {\n  \
    \    return \"NO\";\n    }\n  }\n  return \"YES\";\n}\nint main() {\n    auto\
    \ candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpoxi_ij5_: /tmp/tmpoxi_ij5_.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  if (start1 > end1 || start2 > end2)\
    \ {\n    return \"NO\";\n  }\n  if (start1 > start2) {\n    std::swap(start1,\
    \ start2);\n    std::swap(end1, end2);\n  }\n  if (start2 > end1) {\n    return\
    \ \"NO\";\n  }\n  long start = start2;\n  long end = std::min(end1, end2);\n \
    \ if (start == end) {\n    return \"NO\";\n  }\n  if (start == 2 || start == 3\
    \ || start == 5 || start == 7) {\n    return \"YES\";\n  }\n  if (start % 2 ==\
    \ 0 || start % 3 == 0 || start % 5 == 0 || start % 7 == 0) {\n    return \"NO\"\
    ;\n  }\n  for (long i = start + 1; i <= end; ++i) {\n    if (i == 2 || i == 3\
    \ || i == 5 || i == 7) {\n      return \"YES\";\n    }\n    if (i % 2 == 0 ||\
    \ i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n      return \"NO\";\n    }\n  }\n\
    \  return \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphjeobusz: /tmp/tmphjeobusz.cpp:59: int main(): Assertion `candidate((std::make_tuple(-3,
    -1)), (std::make_tuple(-5, 5))) == ("YES")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long len = end - start\
    \ + 1;\n    if (len == 1) {\n        return \"NO\";\n    }\n    for (long i =\
    \ 2; i * i <= len; i++) {\n        if (len % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpv_kn1drv: /tmp/tmpv_kn1drv.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    long length = end - start + 1;\n    if\
    \ (length == 2) {\n        return \"YES\";\n    }\n    if (length % 2 == 0) {\n\
    \        return \"NO\";\n    }\n    for (long i = 3; i <= sqrt(length); i += 2)\
    \ {\n        if (length % i == 0) {\n            return \"NO\";\n        }\n \
    \   }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1opzx_oy: /tmp/tmp1opzx_oy.cpp:44: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    // your code here\n\
    \    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    if\
    \ (length == 2) {\n        return \"YES\";\n    }\n    for (long i = 2; i < length;\
    \ i++) {\n        if (length % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp5u51b7x9: /tmp/tmp5u51b7x9.cpp:47: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long len = std::min(end1, end2) - start2 +\
    \ 1;\n    if (len == 1) {\n        return \"NO\";\n    }\n    for (long i = 2;\
    \ i <= len / 2; ++i) {\n        if (len % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpprqammd4: /tmp/tmpprqammd4.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    if (start == 2) {\n        return \"\
    YES\";\n    }\n    if (start % 2 == 0) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 3; i <= sqrt(end); i += 2) {\n        if (start % i == 0) {\n    \
    \        return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpzz9w06r2: /tmp/tmpzz9w06r2.cpp:43: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i <= std::sqrt(length); i++) {\n        if (length % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp3paubk5o: /tmp/tmp3paubk5o.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if(start > end) {\n        return \"\
    NO\";\n    }\n    long length = end - start + 1;\n    if(length == 1) {\n    \
    \    return \"NO\";\n    }\n    for(long i = 2; i < length; i++) {\n        if(length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpxakxr4r6: /tmp/tmpxakxr4r6.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    if(start2 <= end1 && start2 >= start1)\n        return\
    \ \"YES\";\n    return \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpaw1mlj_5: /tmp/tmpaw1mlj_5.cpp:38: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= std::sqrt(length); i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpzyq25k1n: /tmp/tmpzyq25k1n.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082359
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (end1 < start2 || end2 < start1)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    long length = end - start + 1;\n  \
    \  if (length == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i <\
    \ length; i++) {\n        if (length % i == 0) {\n            return \"NO\";\n\
    \        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate =\
    \ intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpietku5wk: /tmp/tmpietku5wk.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n\tlong start1 = std::get<0>(interval1);\n\
    \tlong end1 = std::get<1>(interval1);\n\tlong start2 = std::get<0>(interval2);\n\
    \tlong end2 = std::get<1>(interval2);\n\tif (start1 > end1) {\n\t\tstd::swap(start1,\
    \ end1);\n\t}\n\tif (start2 > end2) {\n\t\tstd::swap(start2, end2);\n\t}\n\tif\
    \ (start1 > end2 || start2 > end1) {\n\t\treturn \"NO\";\n\t}\n\tlong start =\
    \ std::max(start1, start2);\n\tlong end = std::min(end1, end2);\n\tlong length\
    \ = end - start + 1;\n\tif (length <= 1) {\n\t\treturn \"NO\";\n\t}\n\tfor (long\
    \ i = 2; i * i <= length; ++i) {\n\t\tif (length % i == 0) {\n\t\t\treturn \"\
    NO\";\n\t\t}\n\t}\n\treturn \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphksvf3yy: /tmp/tmphksvf3yy.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long len = end - start\
    \ + 1;\n    if (len == 1) {\n        return \"NO\";\n    }\n    for (long i =\
    \ 2; i * i <= len; i++) {\n        if (len % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpv_kn1drv: /tmp/tmpv_kn1drv.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if(end1 < start2 || end2 < start1) {\n\
    \        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n \
    \   long end = std::min(end1, end2);\n    long length = end - start + 1;\n   \
    \ if(length == 1) {\n        return \"NO\";\n    }\n    if(length == 2) {\n  \
    \      return \"YES\";\n    }\n    for(long i = 2; i <= sqrt(length); i++) {\n\
    \        if(length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphdo3b8c6: /tmp/tmphdo3b8c6.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n\
    \  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n\
    \  long end2 = std::get<1>(interval2);\n  long start = std::max(start1, start2);\n\
    \  long end = std::min(end1, end2);\n  if (start > end) {\n    return \"NO\";\n\
    \  }\n  long length = end - start + 1;\n  if (length < 2) {\n    return \"NO\"\
    ;\n  }\n  if (length == 2) {\n    return \"YES\";\n  }\n  for (long i = 2; i *\
    \ i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n\
    \  }\n  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpx31jyfq8: /tmp/tmpx31jyfq8.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"NO\";\n    }\n    long len\
    \ = end - start;\n    if (len == 1) {\n        return \"YES\";\n    }\n    for\
    \ (long i = 2; i * i <= len; ++i) {\n        if (len % i == 0) {\n           \
    \ return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n   \
    \ auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmppft8dm04: /tmp/tmppft8dm04.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    if (start\
    \ == 0 || end == 0) {\n        return \"NO\";\n    }\n    if (start < 0) {\n \
    \       start = -start;\n    }\n    if (end < 0) {\n        end = -end;\n    }\n\
    \    for (long i = 2; i <= end; ++i) {\n        if (start % i == 0 && end % i\
    \ == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpw9b39eb4: /tmp/tmpw9b39eb4.cpp:56: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if (length\
    \ <= 1) {\n        return \"NO\";\n    }\n    if (length == 2) {\n        return\
    \ \"YES\";\n    }\n    for (long i = 2; i <= std::sqrt(length); ++i) {\n     \
    \   if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n   \
    \ return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp49j59otf: /tmp/tmp49j59otf.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= std::sqrt(length); i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpzyq25k1n: /tmp/tmpzyq25k1n.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082359
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n  long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n  long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \  if (start > end) {\n    return \"NO\";\n  }\n  if (start == end) {\n    return\
    \ \"YES\";\n  }\n  if (start == 2) {\n    return \"YES\";\n  }\n  for (long i\
    \ = 2; i < start; i++) {\n    if (start % i == 0) {\n      return \"NO\";\n  \
    \  }\n  }\n  for (long i = 2; i < end; i++) {\n    if (end % i == 0) {\n     \
    \ return \"NO\";\n    }\n  }\n  return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpx0y5xelu: /tmp/tmpx0y5xelu.cpp:45: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i < len; i++) {\n        if (len % i == 0) {\n         \
    \   return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n \
    \   auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp4j3823u4: /tmp/tmp4j3823u4.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, end1,\
    \ start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    long start = std::max(start1, start2);\n    long end\
    \ = std::min(end1, end2);\n    if (start > end) {\n        return \"NO\";\n  \
    \  }\n    long length = end - start + 1;\n    if (length == 1) {\n        return\
    \ \"NO\";\n    }\n    for (long i = 2; i * i <= length; i++) {\n        if (length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpkz6j9x7f: /tmp/tmpkz6j9x7f.cpp:42: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    if (start\
    \ == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i < start; i++)\
    \ {\n        if (start % i == 0 && end % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpuxijwugr: /tmp/tmpuxijwugr.cpp:50: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (end1 < start2 || end2 < start1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    long length = end - start + 1;\n    if (length <= 1) {\n       \
    \ return \"NO\";\n    }\n    for (long i = 2; i * i <= length; ++i) {\n      \
    \  if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp196zr1u7: /tmp/tmp196zr1u7.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    if (start == end) {\n        return \"YES\";\n    }\n  \
    \  long length = end - start + 1;\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpbnwaohk4: /tmp/tmpbnwaohk4.cpp:45: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    if(a > b) {\n        std::swap(a, b);\n\
    \    }\n    if(c > d) {\n        std::swap(c, d);\n    }\n    if(b < c || a >\
    \ d) {\n        return \"NO\";\n    }\n    long start = std::max(a, c);\n    long\
    \ end = std::min(b, d);\n    if(start == end) {\n        return \"YES\";\n   \
    \ }\n    if(start == 2 || start == 3) {\n        return \"YES\";\n    }\n    if(start\
    \ % 2 == 0 || start % 3 == 0) {\n        return \"NO\";\n    }\n    long i = 5;\n\
    \    while(i * i <= start) {\n        if(start % i == 0 || start % (i + 2) ==\
    \ 0) {\n            return \"NO\";\n        }\n        i += 6;\n    }\n    return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpfccg6w3o: /tmp/tmpfccg6w3o.cpp:55: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmjikw25p: /tmp/tmpmjikw25p.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i * i <= len; i++) {\n        if (len % i == 0) {\n    \
    \        return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpdxu9rj12: /tmp/tmpdxu9rj12.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= sqrt(length); i++) {\n        if (length %\
    \ i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpbejylfy_: /tmp/tmpbejylfy_.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"NO\";\n    }\n    long length\
    \ = end - start;\n    if (length == 1) {\n        return \"YES\";\n    }\n   \
    \ for (long i = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n \
    \           return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpontg7do7: /tmp/tmpontg7do7.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    if (start == end) {\n        return \"YES\";\n    }\n  \
    \  if (start == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i <=\
    \ std::sqrt(end); i++) {\n        if (start % i == 0 || end % i == 0) {\n    \
    \        return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpchis0utz: /tmp/tmpchis0utz.cpp:47: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    // your code here\n\
    \    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    if (start1 > end1 || start2 > end2) {\n        return \"NO\";\n    }\n  \
    \  if (start1 > start2) {\n        std::swap(start1, start2);\n        std::swap(end1,\
    \ end2);\n    }\n    if (start2 > end1) {\n        return \"NO\";\n    }\n   \
    \ long intersectionStart = start2;\n    long intersectionEnd = std::min(end1,\
    \ end2);\n    long intersectionLength = intersectionEnd - intersectionStart +\
    \ 1;\n    if (intersectionLength == 1) {\n        return \"NO\";\n    }\n    if\
    \ (intersectionLength == 2) {\n        return \"YES\";\n    }\n    for (long i\
    \ = 2; i < intersectionLength; i++) {\n        if (intersectionLength % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmphtur5iir: /tmp/tmphtur5iir.cpp:54: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\n\
    \        return \"NO\";\n    if(start1 > start2)\n        std::swap(start1, start2);\n\
    \    if(end1 < end2)\n        std::swap(end1, end2);\n    if(start2 > end1)\n\
    \        return \"NO\";\n    if(start2 <= end1 && start2 >= start1)\n        return\
    \ \"YES\";\n    return \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpaw1mlj_5: /tmp/tmpaw1mlj_5.cpp:38: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= sqrt(length); i++) {\n        if (length %\
    \ i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpbejylfy_: /tmp/tmpbejylfy_.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if(start > end) {\n        return \"\
    NO\";\n    }\n    long len = end - start + 1;\n    if(len == 1) {\n        return\
    \ \"NO\";\n    }\n    if(len == 2) {\n        return \"YES\";\n    }\n    for(long\
    \ i = 2; i < len; i++) {\n        if(len % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpcwh6oj24: /tmp/tmpcwh6oj24.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082363
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long intersection_start = start2;\n    long\
    \ intersection_end = std::min(end1, end2);\n    long intersection_length = intersection_end\
    \ - intersection_start + 1;\n    if (intersection_length == 1) {\n        return\
    \ \"NO\";\n    }\n    bool is_prime = true;\n    for (long i = 2; i <= std::sqrt(intersection_length);\
    \ ++i) {\n        if (intersection_length % i == 0) {\n            is_prime =\
    \ false;\n            break;\n        }\n    }\n    return is_prime ? \"YES\"\
    \ : \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1e2ex8ae: /tmp/tmp1e2ex8ae.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082362
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if(start2 > end2) {\n        std::swap(start2, end2);\n \
    \   }\n    if(end1 < start2 || end2 < start1) {\n        return \"NO\";\n    }\n\
    \    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    long length = end - start + 1;\n    if(length <= 1) {\n        return \"\
    NO\";\n    }\n    if(length == 2) {\n        return \"YES\";\n    }\n    for(long\
    \ i = 2; i <= std::sqrt(length); ++i) {\n        if(length % i == 0) {\n     \
    \       return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n\
    \    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpgmmgl6rt: /tmp/tmpgmmgl6rt.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n\tlong a = std::get<0>(interval1);\n\
    \tlong b = std::get<1>(interval1);\n\tlong c = std::get<0>(interval2);\n\tlong\
    \ d = std::get<1>(interval2);\n\tif (a > b) {\n\t\tstd::swap(a, b);\n\t}\n\tif\
    \ (c > d) {\n\t\tstd::swap(c, d);\n\t}\n\tif (b < c || a > d) {\n\t\treturn \"\
    NO\";\n\t}\n\tlong start = std::max(a, c);\n\tlong end = std::min(b, d);\n\tlong\
    \ length = end - start + 1;\n\tif (length == 1) {\n\t\treturn \"NO\";\n\t}\n\t\
    for (long i = 2; i * i <= length; ++i) {\n\t\tif (length % i == 0) {\n\t\t\treturn\
    \ \"NO\";\n\t\t}\n\t}\n\treturn \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpoqewggi9: /tmp/tmpoqewggi9.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = std::min(end1, end2) - start2\
    \ + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for (long i\
    \ = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpkmd1cnan: /tmp/tmpkmd1cnan.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp3hcsihmx: /tmp/tmp3hcsihmx.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    if (start == end) {\n        return \"YES\";\n    }\n  \
    \  if (start == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i <\
    \ end; i++) {\n        if (end % i == 0) {\n            return \"NO\";\n     \
    \   }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpm390w_u0: /tmp/tmpm390w_u0.cpp:47: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n\tlong start1 = std::get<0>(interval1);\n\
    \tlong end1 = std::get<1>(interval1);\n\tlong start2 = std::get<0>(interval2);\n\
    \tlong end2 = std::get<1>(interval2);\n\tlong start = std::max(start1, start2);\n\
    \tlong end = std::min(end1, end2);\n\tif (start > end) {\n\t\treturn \"NO\";\n\
    \t}\n\tif (start == end) {\n\t\treturn \"YES\";\n\t}\n\tlong length = end - start\
    \ + 1;\n\tif (length == 2) {\n\t\treturn \"YES\";\n\t}\n\tfor (long i = 2; i <\
    \ length; i++) {\n\t\tif (length % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t\
    }\n\treturn \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpfc6p0fs1: /tmp/tmpfc6p0fs1.cpp:45: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long len = end - start + 1;\n    if (len == 1) {\n     \
    \   return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n    }\n\
    \    for (long i = 2; i < len; i++) {\n        if (len % i == 0) {\n         \
    \   return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n \
    \   auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpxq8ih3bq: /tmp/tmpxq8ih3bq.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082358
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long start = start2;\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"NO\";\n    }\n    for (long\
    \ i = 2; i <= sqrt(end - start); ++i) {\n        if ((end - start) % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main()\
    \ {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1nm3nwi2: /tmp/tmp1nm3nwi2.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= length / 2; i++) {\n\
    \        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpjwngnlt5: /tmp/tmpjwngnlt5.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    if (a > b) {\n        std::swap(a,\
    \ b);\n    }\n    if (c > d) {\n        std::swap(c, d);\n    }\n    if (b < c\
    \ || a > d) {\n        return \"NO\";\n    }\n    long start = std::max(a, c);\n\
    \    long end = std::min(b, d);\n    long length = end - start + 1;\n    if (length\
    \ == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= length;\
    \ ++i) {\n        if (length % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpk5tak0dz: /tmp/tmpk5tak0dz.cpp:49: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i < length; i++) {\n        if (length % i == 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint\
    \ main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpp3qhigth: /tmp/tmpp3qhigth.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmjikw25p: /tmp/tmpmjikw25p.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long intersection_start = start2;\n    long\
    \ intersection_end = std::min(end1, end2);\n    long intersection_length = intersection_end\
    \ - intersection_start + 1;\n    if (intersection_length <= 1) {\n        return\
    \ \"NO\";\n    }\n    bool is_prime = true;\n    for (long i = 2; i < intersection_length;\
    \ ++i) {\n        if (intersection_length % i == 0) {\n            is_prime =\
    \ false;\n            break;\n        }\n    }\n    return is_prime ? \"YES\"\
    \ : \"NO\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpxjfk3apz: /tmp/tmpxjfk3apz.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\"\
    ;\n    }\n    for (long i = 2; i <= sqrt(length); i++) {\n        if (length %\
    \ i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpbejylfy_: /tmp/tmpbejylfy_.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = std::min(end1, end2) - start2\
    \ + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for (long i\
    \ = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpkmd1cnan: /tmp/tmpkmd1cnan.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) return \"NO\";\n    long len = end - start + 1;\n    if\
    \ (len == 1) return \"NO\";\n    if (len == 2) return \"YES\";\n    for (long\
    \ i = 2; i * i <= len; i++) {\n        if (len % i == 0) return \"NO\";\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpud5dd9mf: /tmp/tmpud5dd9mf.cpp:34: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long intersection_start = start2;\n    long\
    \ intersection_end = std::min(end1, end2);\n    long intersection_length = intersection_end\
    \ - intersection_start + 1;\n    if (intersection_length == 1) {\n        return\
    \ \"NO\";\n    }\n    for (long i = 2; i <= intersection_length / 2; ++i) {\n\
    \        if (intersection_length % i == 0) {\n            return \"NO\";\n   \
    \     }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp7yks50l9: /tmp/tmp7yks50l9.cpp:50: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 1) {\n        return \"NO\";\n    }\n    for\
    \ (long i = 2; i < length; i++) {\n        if (length % i == 0) {\n          \
    \  return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n  \
    \  auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)),\
    \ (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp1uwa76lb: /tmp/tmp1uwa76lb.cpp:39: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082353
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (end1 < start2 || end2 < start1)\
    \ {\n        return \"NO\";\n    }\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    long length = end - start + 1;\n  \
    \  if (length == 1) {\n        return \"NO\";\n    }\n    if (length == 2) {\n\
    \        return \"YES\";\n    }\n    for (long i = 2; i <= length / 2; i++) {\n\
    \        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n  \
    \  assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"\
    ));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) ==\
    \ (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmppcgks5q1: /tmp/tmppcgks5q1.cpp:46: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i <= std::sqrt(length); i++)\
    \ {\n        if (length % i == 0) {\n            return \"NO\";\n        }\n \
    \   }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp9lqh3js5: /tmp/tmp9lqh3js5.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082360
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start > end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start + 1;\n    if (length <= 1) {\n\
    \        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n    \
    \    if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n  \
    \  return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpcj9enupm: /tmp/tmpcj9enupm.cpp:43: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"NO\";\n    }\n    if (start\
    \ == 1) {\n        return \"YES\";\n    }\n    for (long i = 2; i < start; ++i)\
    \ {\n        if (start % i == 0 && end % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpnrrojed8: /tmp/tmpnrrojed8.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1, end1,\
    \ start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    if (start1 > end1) std::swap(start1, end1);\n    if\
    \ (start2 > end2) std::swap(start2, end2);\n    if (end1 < start2 || end2 < start1)\
    \ return \"NO\";\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) return \"YES\";\n    if (start == 1) return \"\
    NO\";\n    for (long i = 2; i * i <= end; ++i) {\n        if (start % i == 0)\
    \ return \"NO\";\n        if (end % i == 0) return \"NO\";\n    }\n    return\
    \ \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpmryeaxq9: /tmp/tmpmryeaxq9.cpp:38: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if(start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if(start2 > end1) {\n \
    \       return \"NO\";\n    }\n    long start = start2;\n    long end = std::min(end1,\
    \ end2);\n    if(start == end) {\n        return \"NO\";\n    }\n    if(start\
    \ == 1) {\n        return \"YES\";\n    }\n    for(long i = 2; i <= sqrt(end);\
    \ i++) {\n        if(start % i == 0 || end % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmp69bcnwod: /tmp/tmp69bcnwod.cpp:52: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"YES\";\n    }\n    if (start\
    \ == 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i * i <= end; ++i)\
    \ {\n        if (start % i == 0) {\n            return \"NO\";\n        }\n  \
    \  }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpcgm2s0y9: /tmp/tmpcgm2s0y9.cpp:50: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082355
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    for (long i = 2; i < end; i++) {\n  \
    \      if (end % i == 0) {\n            return \"NO\";\n        }\n    }\n   \
    \ return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
    \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
    \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
    \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
    \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
    \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
    \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpyb5nfist: /tmp/tmpyb5nfist.cpp:37: int main(): Assertion `candidate((std::make_tuple(1,
    2)), (std::make_tuple(2, 3))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if (start2 > end2) {\n        std::swap(start2, end2);\n\
    \    }\n    if (start1 > end2 || start2 > end1) {\n        return \"NO\";\n  \
    \  }\n    long start = std::max(start1, start2);\n    long end = std::min(end1,\
    \ end2);\n    if (start == end) {\n        return \"NO\";\n    }\n    if (start\
    \ == 1) {\n        return \"YES\";\n    }\n    for (long i = 2; i < start; ++i)\
    \ {\n        if (start % i == 0) {\n            return \"NO\";\n        }\n  \
    \  }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpflio_j0n: /tmp/tmpflio_j0n.cpp:51: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if(start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if(start2 > end1) {\n \
    \       return \"NO\";\n    }\n    long length = end1 - start2 + 1;\n    if(length\
    \ == 1) {\n        return \"NO\";\n    }\n    for(long i = 2; i <= sqrt(length);\
    \ i++) {\n        if(length % i == 0) {\n            return \"NO\";\n        }\n\
    \    }\n    return \"YES\";\n}\nint main() {\n    auto candidate = intersection;\n\
    \    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"\
    NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\
    \ == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpkswxfw7u: /tmp/tmpkswxfw7u.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
    // where each interval is a pair of integers. For example, interval = (start,\
    \ end) = (1, 2).\n// The given intervals are closed which means that the interval\
    \ (start, end)\n// includes both start and end.\n// For each given interval, it\
    \ is assumed that its start is less or equal its end.\n// Your task is to determine\
    \ whether the length of intersection of these two \n// intervals is a prime number.\n\
    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
    \ its length is 1, which not a prime number.\n// If the length of the intersection\
    \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the\
    \ two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n\
    // intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==>\
    \ \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long,\
    \ long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1 || start2 > end2)\
    \ {\n        return \"NO\";\n    }\n    if (start1 > start2) {\n        std::swap(start1,\
    \ start2);\n        std::swap(end1, end2);\n    }\n    if (start2 > end1) {\n\
    \        return \"NO\";\n    }\n    long length = std::min(end1, end2) - start2\
    \ + 1;\n    if (length <= 1) {\n        return \"NO\";\n    }\n    for (long i\
    \ = 2; i * i <= length; ++i) {\n        if (length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nint main() {\n    auto candidate\
    \ = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2,\
    \ 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0,\
    \ 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5,\
    \ 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4,\
    \ 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1,\
    \ -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3,\
    \ 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1,\
    \ 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3,\
    \ -2))) == (\"NO\"));\n}\n"
  status: Exception
  stderr: 'tmpc80okdrq: /tmp/tmpc80okdrq.cpp:48: int main(): Assertion `candidate((std::make_tuple(-1,
    1)), (std::make_tuple(0, 4))) == ("NO")'' failed.

    '
  stdout: ''
  timestamp: 1660082364
