language: cpp
name: HumanEval_132_is_nested
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count >\
    \ 0 ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphz146_fu: /tmp/tmphz146_fu.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t// int count = 0;\n\t// for (int i = 0; i < string.length(); i++) {\n\t\
    // \tif (string[i] == '[') {\n\t// \t\tcount++;\n\t// \t}\n\t// \telse if (string[i]\
    \ == ']') {\n\t// \t\tcount--;\n\t// \t}\n\t// \tif (count < 0) {\n\t// \t\treturn\
    \ false;\n\t// \t}\n\t// }\n\t// return count == 0;\n\tstd::stack<char> s;\n\t\
    for (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\
    \ts.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty())\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn s.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp37ofwy_o: /tmp/tmp37ofwy_o.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count >\
    \ 0 ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphz146_fu: /tmp/tmphz146_fu.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stack;\n    for(int i = 0; i < string.length(); i++)\
    \ {\n        if(string[i] == '[') {\n            stack.push(string[i]);\n    \
    \    } else if(string[i] == ']') {\n            if(stack.empty()) {\n        \
    \        return false;\n            } else {\n                stack.pop();\n \
    \           }\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3rvamoka: /tmp/tmp3rvamoka.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1smyqd13: /tmp/tmp1smyqd13.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1smyqd13: /tmp/tmp1smyqd13.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count < 0){\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwkuw3ibv: /tmp/tmpwkuw3ibv.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count < 0){\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwkuw3ibv: /tmp/tmpwkuw3ibv.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> st;\n    for(int i=0;i<string.length();i++){\n     \
    \   if(string[i]=='['){\n            st.push(string[i]);\n        }\n        else\
    \ if(string[i]==']'){\n            if(st.empty()){\n                return false;\n\
    \            }\n            else if(st.top()=='['){\n                st.pop();\n\
    \            }\n        }\n    }\n    if(st.empty()){\n        return true;\n\
    \    }\n    else{\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp2j82cufl: /tmp/tmp2j82cufl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count >\
    \ 0 ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphz146_fu: /tmp/tmphz146_fu.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stack;\n    for(char c : string) {\n        if(c ==\
    \ '[') {\n            stack.push(c);\n        } else {\n            if(stack.empty())\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return !stack.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpy3ltpgz8: /tmp/tmpy3ltpgz8.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpogaq82oi: /tmp/tmpogaq82oi.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count < 0){\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwkuw3ibv: /tmp/tmpwkuw3ibv.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1smyqd13: /tmp/tmp1smyqd13.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stk;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\
    \tif (string[i] == '[') {\n\t\t\tstk.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (stk.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (stk.empty()) {\n\t\treturn\
    \ true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmplnzcsxsu: /tmp/tmplnzcsxsu.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else{\n  \
    \          count--;\n        }\n        if(count < 0){\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp98bdyknc: /tmp/tmp98bdyknc.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stack;\n\tfor (int i = 0; i < string.length(); i++) {\n\
    \t\tif (string[i] == '[') {\n\t\t\tstack.push(string[i]);\n\t\t}\n\t\telse if\
    \ (string[i] == ']') {\n\t\t\tif (stack.empty()) {\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t\telse {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpunkuru40: /tmp/tmpunkuru40.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stack;\n\tfor (int i = 0; i < string.length(); i++) {\n\
    \t\tif (string[i] == '[') {\n\t\t\tstack.push(string[i]);\n\t\t}\n\t\telse if\
    \ (string[i] == ']') {\n\t\t\tif (stack.empty()) {\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t\telse {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpunkuru40: /tmp/tmpunkuru40.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stack;\n    for(auto c : string) {\n        if(c ==\
    \ '[') {\n            stack.push(c);\n        } else {\n            if(stack.empty())\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return !stack.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpgqjbk7eu: /tmp/tmpgqjbk7eu.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpogaq82oi: /tmp/tmpogaq82oi.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count < 0){\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwkuw3ibv: /tmp/tmpwkuw3ibv.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stack;\n\tfor (int i = 0; i < string.length(); i++) {\n\
    \t\tif (string[i] == '[') {\n\t\t\tstack.push(string[i]);\n\t\t}\n\t\telse if\
    \ (string[i] == ']') {\n\t\t\tif (stack.empty()) {\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t\telse {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpunkuru40: /tmp/tmpunkuru40.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count >\
    \ 0 ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphz146_fu: /tmp/tmphz146_fu.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1smyqd13: /tmp/tmp1smyqd13.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpogaq82oi: /tmp/tmpogaq82oi.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpogaq82oi: /tmp/tmpogaq82oi.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count < 0){\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwkuw3ibv: /tmp/tmpwkuw3ibv.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdxs_gpsa: /tmp/tmpdxs_gpsa.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stk;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\
    \tif (string[i] == '[') {\n\t\t\tstk.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (stk.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\
    stk.pop();\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppjl_bkhf: /tmp/tmppjl_bkhf.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else{\n  \
    \          count--;\n        }\n        if(count < 0){\n            return false;\n\
    \        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpq_o81q6h: /tmp/tmpq_o81q6h.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdiqx7gpl: /tmp/tmpdiqx7gpl.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for(int i = 0; i < string.length(); i++) {\n    if(string[i]\
    \ == '[') {\n      count++;\n    }\n    else if(string[i] == ']') {\n      count--;\n\
    \    }\n    if(count < 0) {\n      return false;\n    }\n  }\n  return count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyph3bn9: /tmp/tmpnyph3bn9.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> s;\n    for(auto i : string){\n        if(i == '['){\n\
    \            s.push(i);\n        }\n        else if(i == ']'){\n            if(s.empty()){\n\
    \                return false;\n            }\n            else{\n           \
    \     s.pop();\n            }\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpk61la1yk: /tmp/tmpk61la1yk.cpp:33: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsb53s340: /tmp/tmpsb53s340.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> s;\n    for(int i=0;i<string.length();i++){\n      \
    \  if(string[i]=='['){\n            s.push(string[i]);\n        }\n        else\
    \ if(string[i]==']'){\n            if(s.empty()){\n                return false;\n\
    \            }\n            else{\n                s.pop();\n            }\n \
    \       }\n    }\n    if(s.empty()){\n        return true;\n    }\n    else{\n\
    \        return false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpfhmy585c: /tmp/tmpfhmy585c.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpogaq82oi: /tmp/tmpogaq82oi.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaufin9nq: /tmp/tmpaufin9nq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\
    \t\t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphfdwbh03: /tmp/tmphfdwbh03.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659824087
