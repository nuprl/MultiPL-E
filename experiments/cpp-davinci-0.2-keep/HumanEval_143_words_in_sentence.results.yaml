name: HumanEval_143_words_in_sentence
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1) {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= sqrt(word.size()); i += 2) {\n        if (word.size() % i == 0)\
    \ {\n          is_prime = false;\n          break;\n        }\n      }\n     \
    \ if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp80eo6_to: /tmp/tmp80eo6_to.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::vector<std::string> words;\n    std::copy(std::istream_iterator<std::string>(iss),\n\
    \              std::istream_iterator<std::string>(),\n              std::back_inserter(words));\n\
    \    for (const auto& word : words) {\n        if (word.size() == 2 || word.size()\
    \ == 3 || word.size() == 5 || word.size() == 7) {\n            result += word\
    \ + \" \";\n        }\n    }\n    result.pop_back();\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0uv_5mt7: /tmp/tmp0uv_5mt7.cpp:39: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 == 1) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  if (result.size()\
    \ > 0) {\n    result.pop_back();\n  }\n  return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbuaxw5v8: /tmp/tmpbuaxw5v8.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<std::string>\
    \ result;\n    for (auto& word : words) {\n        if (word.size() == 1) {\n \
    \           result.push_back(word);\n        } else {\n            bool is_prime\
    \ = true;\n            for (int i = 2; i < word.size(); ++i) {\n             \
    \   if (word.size() % i == 0) {\n                    is_prime = false;\n     \
    \               break;\n                }\n            }\n            if (is_prime)\
    \ {\n                result.push_back(word);\n            }\n        }\n    }\n\
    \    std::stringstream ss2;\n    for (auto& word : result) {\n        ss2 << word\
    \ << \" \";\n    }\n    return ss2.str();\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp70xu20d6: /tmp/tmp70xu20d6.cpp:49: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::string result;\n  \
    \  for (auto word : words) {\n        if (word.size() == 2 || word.size() == 3\
    \ || word.size() == 5 || word.size() == 7) {\n            result += word + \"\
    \ \";\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_0ve1av7: /tmp/tmp_0ve1av7.cpp:40: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto &word : words) {\n        if (word.size()\
    \ == 1) {\n            result.append(word);\n            result.push_back(' ');\n\
    \        } else if (word.size() == 2) {\n            result.append(word);\n  \
    \          result.push_back(' ');\n        } else if (word.size() == 3) {\n  \
    \          result.append(word);\n            result.push_back(' ');\n        }\
    \ else if (word.size() == 5) {\n            result.append(word);\n           \
    \ result.push_back(' ');\n        } else if (word.size() == 7) {\n           \
    \ result.append(word);\n            result.push_back(' ');\n        }\n    }\n\
    \    if (result.back() == ' ') {\n        result.pop_back();\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpb800hk7j: /tmp/tmpb800hk7j.cpp:55: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::vector<std::string> result;\n    for (const auto& word : words) {\n\
    \        int length = word.size();\n        bool is_prime = true;\n        for\
    \ (int i = 2; i < length; ++i) {\n            if (length % i == 0) {\n       \
    \         is_prime = false;\n                break;\n            }\n        }\n\
    \        if (is_prime) {\n            result.push_back(word);\n        }\n   \
    \ }\n    std::string output;\n    for (const auto& word : result) {\n        output\
    \ += word + \" \";\n    }\n    return output.substr(0, output.size() - 1);\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8362jvyd: /tmp/tmp8362jvyd.cpp:51: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::string result;\n  for (auto &word\
    \ : words) {\n    if (word.size() == 1) {\n      result += word + \" \";\n   \
    \   continue;\n    }\n    bool is_prime = true;\n    for (int i = 2; i <= word.size()\
    \ / 2; ++i) {\n      if (word.size() % i == 0) {\n        is_prime = false;\n\
    \        break;\n      }\n    }\n    if (is_prime) {\n      result += word + \"\
    \ \";\n    }\n  }\n  result.pop_back();\n  return result;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjplikxx2: /tmp/tmpjplikxx2.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (const std::string& word : words) {\n      \
    \  if (word.size() == 1) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else {\n            bool is_prime = true;\n            for (int\
    \ i = 2; i < word.size(); ++i) {\n                if (word.size() % i == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n            if (is_prime) {\n                result.append(word);\n\
    \                result.push_back(' ');\n            }\n        }\n    }\n   \
    \ result.pop_back();\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0ff6bd_i: /tmp/tmp0ff6bd_i.cpp:53: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpd0qsv2qb: /tmp/tmpd0qsv2qb.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpow53de7b.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpow53de7b.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 1) {\n      result += word + \" \";\n    } else {\n      bool is_prime =\
    \ true;\n      for (int i = 2; i < word.size(); ++i) {\n        if (word.size()\
    \ % i == 0) {\n          is_prime = false;\n          break;\n        }\n    \
    \  }\n      if (is_prime) {\n        result += word + \" \";\n      }\n    }\n\
    \  }\n  result.pop_back();\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzm1822vk: /tmp/tmpzm1822vk.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7) {\n\
    \            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size() ==\
    \ 7 || word.size() == 11 || word.size() == 13 || word.size() == 17 || word.size()\
    \ == 19 || word.size() == 23 || word.size() == 29 || word.size() == 31 || word.size()\
    \ == 37 || word.size() == 41 || word.size() == 43 || word.size() == 47 || word.size()\
    \ == 53 || word.size() == 59 || word.size() == 61 || word.size() == 67 || word.size()\
    \ == 71 || word.size() == 73 || word.size() == 79 || word.size() == 83 || word.size()\
    \ == 89 || word.size() == 97) {\n            result += word + \" \";\n       \
    \ }\n    }\n    return result.substr(0, result.size() - 1);\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpioqkqtih: /tmp/tmpioqkqtih.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk29m24ap: /tmp/tmpk29m24ap.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpy4qs_4hz: /tmp/tmpy4qs_4hz.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (std::string word : words) {\n        int len\
    \ = word.size();\n        bool is_prime = true;\n        for (int i = 2; i <=\
    \ std::sqrt(len); ++i) {\n            if (len % i == 0) {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5vp1zst9: /tmp/tmp5vp1zst9.cpp:48: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1) {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8qts6u8f: /tmp/tmp8qts6u8f.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 1) {\n      result += word + \" \";\n      continue;\n    }\n    bool is_prime\
    \ = true;\n    for (int i = 2; i < word.size(); ++i) {\n      if (word.size()\
    \ % i == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n   \
    \ if (is_prime) {\n      result += word + \" \";\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp087fv2vc: /tmp/tmp087fv2vc.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (const std::string& word : words) {\n      \
    \  if (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size()\
    \ == 7) {\n            result += word + ' ';\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9ldx_rrb: /tmp/tmp9ldx_rrb.cpp:45: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size()\
    \ == 7) {\n            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxr1nmvqj: /tmp/tmpxr1nmvqj.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= sqrt(word.size()); i += 2) {\n        if (word.size() % i == 0)\
    \ {\n          is_prime = false;\n          break;\n        }\n      }\n     \
    \ if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n  if\
    \ (result.size() > 0) {\n    result.pop_back();\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpqzztm8_5: /tmp/tmpqzztm8_5.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        int len = word.size();\n\
    \        if (len == 1) {\n            result.append(word);\n            result.push_back('\
    \ ');\n            continue;\n        }\n        bool is_prime = true;\n     \
    \   for (int i = 2; i < len; ++i) {\n            if (len % i == 0) {\n       \
    \         is_prime = false;\n                break;\n            }\n        }\n\
    \        if (is_prime) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmphd1h883r: /tmp/tmphd1h883r.cpp:54: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1) {\n      bool is_prime = true;\n      for (int i = 2; i < word.size();\
    \ ++i) {\n        if (word.size() % i == 0) {\n          is_prime = false;\n \
    \         break;\n        }\n      }\n      if (is_prime) {\n        result +=\
    \ word + \" \";\n      }\n    }\n  }\n  if (!result.empty()) {\n    result.pop_back();\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (const std::string& word : words) {\n      \
    \  if (word.size() == 1 || word.size() == 2) {\n            result += word + '\
    \ ';\n        } else {\n            bool is_prime = true;\n            for (int\
    \ i = 2; i < word.size(); ++i) {\n                if (word.size() % i == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n            if (is_prime) {\n                result\
    \ += word + ' ';\n            }\n        }\n    }\n    if (!result.empty()) {\n\
    \        result.pop_back();\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpj0hn25gl: /tmp/tmpj0hn25gl.cpp:53: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size()\
    \ == 7) {\n            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    result.pop_back();\n   \
    \ return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvstprw0u: /tmp/tmpvstprw0u.cpp:36: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    if (result.size()\
    \ > 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptss23e1p.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptss23e1p.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1 || word.size() == 2) {\n            result += word + \" \";\n        }\
    \ else {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmphz0sa09f: /tmp/tmphz0sa09f.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1) {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  std::string result;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1) {\n      bool is_prime = true;\n      for (int i = 2; i < word.size();\
    \ i++) {\n        if (word.size() % i == 0) {\n          is_prime = false;\n \
    \         break;\n        }\n      }\n      if (is_prime) {\n        result +=\
    \ word + \" \";\n      }\n    }\n  }\n  return result.substr(0, result.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::string result;\n  \
    \  for (const auto& word : words) {\n        if (word.size() == 2 || word.size()\
    \ == 3 || word.size() == 5 || word.size() == 7) {\n            result += word\
    \ + \" \";\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= sqrt(word.size()); i += 2) {\n        if (word.size() % i == 0)\
    \ {\n          is_prime = false;\n          break;\n        }\n      }\n     \
    \ if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpa6a77t6z: /tmp/tmpa6a77t6z.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8eoecc1v: /tmp/tmp8eoecc1v.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::istringstream\
    \ iss(sentence);\n  std::string word;\n  while (iss >> word) {\n    if (word.length()\
    \ == 1) {\n      result += word + \" \";\n    } else {\n      bool is_prime =\
    \ true;\n      for (int i = 2; i <= word.length() / 2; ++i) {\n        if (word.length()\
    \ % i == 0) {\n          is_prime = false;\n          break;\n        }\n    \
    \  }\n      if (is_prime) {\n        result += word + \" \";\n      }\n    }\n\
    \  }\n  return result.substr(0, result.length() - 1);\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpot6q4x41: /tmp/tmpot6q4x41.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        if (word.size()\
    \ > 1) {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfw7uzost: /tmp/tmpfw7uzost.cpp:54: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  std::string result;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      result\
    \ += word + \" \";\n    }\n  }\n  return result.substr(0, result.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() == 1) {\n            result += word + \" \";\n        } else {\n\
    \            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    return result.substr(0, result.size() - 1);\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpof2tbcsw: /tmp/tmpof2tbcsw.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 == 1) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= sqrt(word.size()); i += 2) {\n        if (word.size() % i == 0)\
    \ {\n          is_prime = false;\n          break;\n        }\n      }\n     \
    \ if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpge4x8cgf: /tmp/tmpge4x8cgf.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1) {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp18fljsxv: /tmp/tmp18fljsxv.cpp:45: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() == 1) {\n            result += word + \" \";\n        } else {\n\
    \            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4j9rr0pi: /tmp/tmp4j9rr0pi.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    std::string result;\n\
    \    for (auto w : words) {\n        if (std::find(primes.begin(), primes.end(),\
    \ w.size()) != primes.end()) {\n            result += w + \" \";\n        }\n\
    \    }\n    if (result.size() > 0) {\n        result.pop_back();\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    if (result.size() > 0) {\n        result.pop_back();\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5v5_c7ku: /tmp/tmp5v5_c7ku.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<int> primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97};\n    std::string result;\n    for (auto word : words) {\n\
    \        if (std::find(primes.begin(), primes.end(), word.size()) != primes.end())\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3p20ryem: /tmp/tmp3p20ryem.cpp:41: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size()\
    \ == 7) {\n            result += word + \" \";\n        }\n    }\n    if (result.size()\
    \ > 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::string result;\n  for (const auto&\
    \ word : words) {\n    if (word.size() == 1) {\n      result += word + \" \";\n\
    \      continue;\n    }\n    bool is_prime = true;\n    for (int i = 2; i < word.size();\
    \ ++i) {\n      if (word.size() % i == 0) {\n        is_prime = false;\n     \
    \   break;\n      }\n    }\n    if (is_prime) {\n      result += word + \" \"\
    ;\n    }\n  }\n  result.pop_back();\n  return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkgzbdmgh: /tmp/tmpkgzbdmgh.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= sqrt(word.size()); i += 2) {\n        if (word.size() % i == 0)\
    \ {\n          is_prime = false;\n          break;\n        }\n      }\n     \
    \ if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmptpzo_vmf: /tmp/tmptpzo_vmf.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word = \"\";\n    for (int i = 0; i < sentence.size(); i++) {\n\
    \        if (sentence[i] == ' ') {\n            words.push_back(word);\n     \
    \       word = \"\";\n        } else {\n            word += sentence[i];\n   \
    \     }\n    }\n    words.push_back(word);\n    std::string result = \"\";\n \
    \   for (int i = 0; i < words.size(); i++) {\n        if (words[i].size() == 1)\
    \ {\n            result += words[i] + \" \";\n        } else if (words[i].size()\
    \ == 2) {\n            result += words[i] + \" \";\n        } else {\n       \
    \     bool prime = true;\n            for (int j = 2; j < words[i].size(); j++)\
    \ {\n                if (words[i].size() % j == 0) {\n                    prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (prime) {\n                result += words[i] + \" \";\n        \
    \    }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5en1sz5a: /tmp/tmp5en1sz5a.cpp:52: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  for (auto c : sentence) {\n    if (c == ' ') {\n     \
    \ words.push_back(word);\n      word.clear();\n    } else {\n      word.push_back(c);\n\
    \    }\n  }\n  words.push_back(word);\n  std::string result;\n  for (auto& word\
    \ : words) {\n    if (word.size() > 1) {\n      bool is_prime = true;\n      for\
    \ (int i = 2; i < word.size(); ++i) {\n        if (word.size() % i == 0) {\n \
    \         is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  if (!result.empty())\
    \ {\n    result.pop_back();\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        if (word.size()\
    \ == 1) {\n            result.append(word);\n            result.push_back(' ');\n\
    \        } else if (word.size() == 2) {\n            result.append(word);\n  \
    \          result.push_back(' ');\n        } else if (word.size() == 3) {\n  \
    \          result.append(word);\n            result.push_back(' ');\n        }\
    \ else if (word.size() == 5) {\n            result.append(word);\n           \
    \ result.push_back(' ');\n        } else if (word.size() == 7) {\n           \
    \ result.append(word);\n            result.push_back(' ');\n        } else if\
    \ (word.size() == 11) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else if (word.size() == 13) {\n            result.append(word);\n\
    \            result.push_back(' ');\n        } else if (word.size() == 17) {\n\
    \            result.append(word);\n            result.push_back(' ');\n      \
    \  } else if (word.size() == 19) {\n            result.append(word);\n       \
    \     result.push_back(' ');\n        } else if (word.size() == 23) {\n      \
    \      result.append(word);\n            result.push_back(' ');\n        } else\
    \ if (word.size() == 29) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else if (word.size() == 31) {\n            result.append(word);\n\
    \            result.push_back(' ');\n        } else if (word.size() == 37) {\n\
    \            result.append(word);\n            result.push\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgzl9s8ih.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpgzl9s8ih.cpp:69:20: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018push\u2019\
    \n   69 |             result.push\n      |                    ^~~~\n/tmp/tmpgzl9s8ih.cpp:71:9:\
    \ warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n\
    \   71 | int main() {\n      |         ^~\n/tmp/tmpgzl9s8ih.cpp:71:9: note: remove\
    \ parentheses to default-initialize a variable\n   71 | int main() {\n      |\
    \         ^~\n      |         --\n/tmp/tmpgzl9s8ih.cpp:71:9: note: or replace\
    \ parentheses with braces to value-initialize a variable\n/tmp/tmpgzl9s8ih.cpp:71:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   71 | int main() {\n      |            ^\n/tmp/tmpgzl9s8ih.cpp:80:2: error:\
    \ expected \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmpgzl9s8ih.cpp:30:29:\
    \ note: to match this \u2018{\u2019\n   30 |     for (auto word : words) {\n \
    \     |                             ^\n/tmp/tmpgzl9s8ih.cpp:80:2: error: expected\
    \ \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmpgzl9s8ih.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpgzl9s8ih.cpp:80:2: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   80 | }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n            bool is_prime = true;\n        \
    \    for (int i = 3; i <= sqrt(word.size()); i += 2) {\n                if (word.size()\
    \ % i == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   result += word + \" \";\n            }\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpgcujafzi: /tmp/tmpgcujafzi.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::vector<std::string>\
    \ words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while\
    \ (ss >> word) {\n        words.push_back(word);\n    }\n    for (auto word :\
    \ words) {\n        if (word.size() == 2 || word.size() == 3 || word.size() ==\
    \ 5 || word.size() == 7) {\n            result += word + \" \";\n        }\n \
    \   }\n    result.pop_back();\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpqh_dj24z: /tmp/tmpqh_dj24z.cpp:40: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n            bool is_prime = true;\n        \
    \    for (int i = 3; i <= std::sqrt(word.size()); i += 2) {\n                if\
    \ (word.size() % i == 0) {\n                    is_prime = false;\n          \
    \          break;\n                }\n            }\n            if (is_prime)\
    \ {\n                result += word + \" \";\n            }\n        }\n    }\n\
    \    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpruopdcoc: /tmp/tmpruopdcoc.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.length() > 1 && word.length() % 2 != 0) {\n            bool is_prime\
    \ = true;\n            for (int i = 3; i < word.length(); i += 2) {\n        \
    \        if (word.length() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    return result.substr(0, result.length() - 1);\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsd3mjg_x: /tmp/tmpsd3mjg_x.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.size() == 1) {\n            result += word + \" \";\n        \
    \    continue;\n        }\n        bool is_prime = true;\n        for (int i =\
    \ 2; i < word.size(); ++i) {\n            if (word.size() % i == 0) {\n      \
    \          is_prime = false;\n                break;\n            }\n        }\n\
    \        if (is_prime) {\n            result += word + \" \";\n        }\n   \
    \ }\n    result.pop_back();\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8wrp2ihf: /tmp/tmp8wrp2ihf.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnumvgp6e.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpnumvgp6e.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  std::string result;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      result\
    \ += word + \" \";\n    }\n  }\n  return result.substr(0, result.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::istringstream\
    \ iss(sentence);\n  std::string word;\n  while (iss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  if (result.size()\
    \ > 0) {\n    result.pop_back();\n  }\n  return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzx9f59w8: /tmp/tmpzx9f59w8.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoi8n20s5.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpoi8n20s5.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n            bool is_prime = true;\n        \
    \    for (int i = 3; i <= sqrt(word.size()); i += 2) {\n                if (word.size()\
    \ % i == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   result += word + \" \";\n            }\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpgr1g1628: /tmp/tmpgr1g1628.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  for (auto c : sentence) {\n    if (c == ' ') {\n     \
    \ words.push_back(word);\n      word.clear();\n    } else {\n      word.push_back(c);\n\
    \    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  std::vector<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n  std::string result;\n  for (auto word : words)\
    \ {\n    if (std::find(primes.begin(), primes.end(), word.size()) != primes.end())\
    \ {\n      result += word + \" \";\n    }\n  }\n  if (!result.empty()) {\n   \
    \ result.pop_back();\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1) {\n      bool is_prime = true;\n      for (int i = 2; i < word.size();\
    \ ++i) {\n        if (word.size() % i == 0) {\n          is_prime = false;\n \
    \         break;\n        }\n      }\n      if (is_prime) {\n        result +=\
    \ word + \" \";\n      }\n    }\n  }\n  return result.substr(0, result.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::string result;\n  \
    \  for (const auto& word : words) {\n        if (word.size() == 2 || word.size()\
    \ == 3 || word.size() == 5 || word.size() == 7) {\n            result += word\
    \ + \" \";\n        }\n    }\n    result.pop_back();\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpz8ipslbr: /tmp/tmpz8ipslbr.cpp:40: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() > 1 && word.size() < 10) {\n            int i = 2;\n          \
    \  for (; i <= word.size() / 2; ++i) {\n                if (word.size() % i ==\
    \ 0) {\n                    break;\n                }\n            }\n       \
    \     if (i > word.size() / 2) {\n                result += word + \" \";\n  \
    \          }\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (is_prime(word.size())) {\n            result += word + \" \";\n   \
    \     }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpimlsqhae.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpimlsqhae.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1 && word.size() % 2 == 1) {\n            bool is_prime = true;\n        \
    \    for (int i = 3; i <= std::sqrt(word.size()); i += 2) {\n                if\
    \ (word.size() % i == 0) {\n                    is_prime = false;\n          \
    \          break;\n                }\n            }\n            if (is_prime)\
    \ {\n                result += word + \" \";\n            }\n        }\n    }\n\
    \    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpelcmquv9: /tmp/tmpelcmquv9.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1) {\n      bool is_prime = true;\n      for (int i = 2; i < word.size();\
    \ ++i) {\n        if (word.size() % i == 0) {\n          is_prime = false;\n \
    \         break;\n        }\n      }\n      if (is_prime) {\n        result +=\
    \ word + \" \";\n      }\n    }\n  }\n  return result.substr(0, result.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpibtsvnh1: /tmp/tmpibtsvnh1.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (std::getline(ss, word, ' '))\
    \ {\n        if (word.length() == 1) {\n            result += word + \" \";\n\
    \        } else {\n            bool is_prime = true;\n            for (int i =\
    \ 2; i < word.length(); i++) {\n                if (word.length() % i == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n            if (is_prime) {\n                result\
    \ += word + \" \";\n            }\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcvkxvva0: /tmp/tmpcvkxvva0.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::istringstream\
    \ iss(sentence);\n  std::string word;\n  while (iss >> word) {\n    if (word.size()\
    \ == 1) {\n      result += word + \" \";\n    } else {\n      bool is_prime =\
    \ true;\n      for (int i = 2; i < word.size(); ++i) {\n        if (word.size()\
    \ % i == 0) {\n          is_prime = false;\n          break;\n        }\n    \
    \  }\n      if (is_prime) {\n        result += word + \" \";\n      }\n    }\n\
    \  }\n  return result.substr(0, result.size() - 1);\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpwhxbb70k: /tmp/tmpwhxbb70k.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() == 1) {\n            result += word + \" \";\n        } else {\n\
    \            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcckiv61z: /tmp/tmpcckiv61z.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  for (auto c : sentence) {\n    if (c == ' ') {\n     \
    \ words.push_back(word);\n      word.clear();\n    } else {\n      word.push_back(c);\n\
    \    }\n  }\n  words.push_back(word);\n  std::string result;\n  for (auto word\
    \ : words) {\n    if (word.size() == 1) {\n      result.append(word);\n      result.push_back('\
    \ ');\n    } else if (word.size() == 2) {\n      result.append(word);\n      result.push_back('\
    \ ');\n    } else if (word.size() == 3) {\n      result.append(word);\n      result.push_back('\
    \ ');\n    } else if (word.size() == 5) {\n      result.append(word);\n      result.push_back('\
    \ ');\n    } else if (word.size() == 7) {\n      result.append(word);\n      result.push_back('\
    \ ');\n    } else if (word.size() == 11) {\n      result.append(word);\n     \
    \ result.push_back(' ');\n    } else if (word.size() == 13) {\n      result.append(word);\n\
    \      result.push_back(' ');\n    } else if (word.size() == 17) {\n      result.append(word);\n\
    \      result.push_back(' ');\n    } else if (word.size() == 19) {\n      result.append(word);\n\
    \      result.push_back(' ');\n    } else if (word.size() == 23) {\n      result.append(word);\n\
    \      result.push_back(' ');\n    } else if (word.size() == 29) {\n      result.append(word);\n\
    \      result.push_back(' ');\n    } else if (word.size() == 31) {\n      result.append(word);\n\
    \      result.push_back(' ');\n    } else if (word.size() == 37) {\n      result.append(word);\n\
    \      result.push\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyourrr5f.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpyourrr5f.cpp:69:14: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018push\u2019\
    \n   69 |       result.push\n      |              ^~~~\n/tmp/tmpyourrr5f.cpp:71:9:\
    \ warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n\
    \   71 | int main() {\n      |         ^~\n/tmp/tmpyourrr5f.cpp:71:9: note: remove\
    \ parentheses to default-initialize a variable\n   71 | int main() {\n      |\
    \         ^~\n      |         --\n/tmp/tmpyourrr5f.cpp:71:9: note: or replace\
    \ parentheses with braces to value-initialize a variable\n/tmp/tmpyourrr5f.cpp:71:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   71 | int main() {\n      |            ^\n/tmp/tmpyourrr5f.cpp:80:2: error:\
    \ expected \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmpyourrr5f.cpp:30:27:\
    \ note: to match this \u2018{\u2019\n   30 |   for (auto word : words) {\n   \
    \   |                           ^\n/tmp/tmpyourrr5f.cpp:80:2: error: expected\
    \ \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmpyourrr5f.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpyourrr5f.cpp:80:2: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   80 | }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() > 1 && word.size() % 2 == 1) {\n            bool is_prime = true;\n\
    \            for (int i = 3; i < word.size(); i += 2) {\n                if (word.size()\
    \ % i == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   result += word + \" \";\n            }\n        }\n    }\n    if (!result.empty())\
    \ {\n        result.pop_back();\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpp_zq857n: /tmp/tmpp_zq857n.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 == 1) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  if (result.size()\
    \ > 0) {\n    result.pop_back();\n  }\n  return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5_tx7hqu: /tmp/tmp5_tx7hqu.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        int length =\
    \ word.size();\n        bool is_prime = true;\n        for (int i = 2; i < length;\
    \ ++i) {\n            if (length % i == 0) {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if (is_prime) {\n \
    \           result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprl2vx4mt: /tmp/tmprl2vx4mt.cpp:48: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (is_prime(word.size())) {\n            result += word + \" \";\n   \
    \     }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbclrxljh.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbclrxljh.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    std::string result;\n\
    \    for (const auto& word : words) {\n        if (std::find(primes.begin(), primes.end(),\
    \ word.size()) != primes.end()) {\n            result += word + \" \";\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpc_61ew_i: /tmp/tmpc_61ew_i.cpp:46: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 1) {\n      result += word + \" \";\n      continue;\n    }\n    bool is_prime\
    \ = true;\n    for (int i = 2; i < word.size(); ++i) {\n      if (word.size()\
    \ % i == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n   \
    \ if (is_prime) {\n      result += word + \" \";\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0h9gyaj4: /tmp/tmp0h9gyaj4.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::string result;\n  \
    \  for (const auto& word : words) {\n        if (word.size() == 1 || word.size()\
    \ == 2) {\n            result += word + \" \";\n            continue;\n      \
    \  }\n        bool is_prime = true;\n        for (int i = 2; i <= std::sqrt(word.size());\
    \ ++i) {\n            if (word.size() % i == 0) {\n                is_prime =\
    \ false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpl9t4o22s: /tmp/tmpl9t4o22s.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf1v_d5c5: /tmp/tmpf1v_d5c5.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (std::getline(ss,\
    \ word, ' ')) {\n    words.push_back(word);\n  }\n  std::string result;\n  for\
    \ (const auto& word : words) {\n    if (word.size() == 1) {\n      result += word\
    \ + \" \";\n      continue;\n    }\n    bool is_prime = true;\n    for (int i\
    \ = 2; i < word.size(); ++i) {\n      if (word.size() % i == 0) {\n        is_prime\
    \ = false;\n        break;\n      }\n    }\n    if (is_prime) {\n      result\
    \ += word + \" \";\n    }\n  }\n  result.pop_back();\n  return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf8mj2hs8: /tmp/tmpf8mj2hs8.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= std::sqrt(word.size()); i += 2) {\n        if (word.size() % i ==\
    \ 0) {\n          is_prime = false;\n          break;\n        }\n      }\n  \
    \    if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n \
    \ if (result.size() > 0) {\n    result.pop_back();\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpj89_kvxw: /tmp/tmpj89_kvxw.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    if (result.size() > 0) {\n\
    \        result.pop_back();\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= sqrt(word.size()); i += 2) {\n        if (word.size() % i == 0)\
    \ {\n          is_prime = false;\n          break;\n        }\n      }\n     \
    \ if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n  if\
    \ (result.size() > 0) {\n    result.pop_back();\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfn_8i6ve: /tmp/tmpfn_8i6ve.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 == 1) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  if (result.size()\
    \ > 0) {\n    result.pop_back();\n  }\n  return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpacqejh92: /tmp/tmpacqejh92.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7) {\n\
    \            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 1) {\n      result += word + \" \";\n    } else {\n      bool is_prime =\
    \ true;\n      for (int i = 2; i < word.size(); ++i) {\n        if (word.size()\
    \ % i == 0) {\n          is_prime = false;\n          break;\n        }\n    \
    \  }\n      if (is_prime) {\n        result += word + \" \";\n      }\n    }\n\
    \  }\n  result.pop_back();\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8dxv7wtf: /tmp/tmp8dxv7wtf.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (const std::string& word : words) {\n      \
    \  if (word.size() == 1) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else {\n            bool is_prime = true;\n            for (int\
    \ i = 2; i < word.size(); ++i) {\n                if (word.size() % i == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n            if (is_prime) {\n                result.append(word);\n\
    \                result.push_back(' ');\n            }\n        }\n    }\n   \
    \ if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdixv5hv_: /tmp/tmpdixv5hv_.cpp:55: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  for (char c : sentence) {\n    if (c == ' ') {\n     \
    \ words.push_back(word);\n      word.clear();\n    } else {\n      word.push_back(c);\n\
    \    }\n  }\n  words.push_back(word);\n  std::string result;\n  for (const std::string&\
    \ word : words) {\n    if (word.size() > 1 && word.size() % 2 == 1) {\n      bool\
    \ is_prime = true;\n      for (int i = 3; i <= std::sqrt(word.size()); i += 2)\
    \ {\n        if (word.size() % i == 0) {\n          is_prime = false;\n      \
    \    break;\n        }\n      }\n      if (is_prime) {\n        result += word\
    \ + ' ';\n      }\n    }\n  }\n  if (!result.empty()) {\n    result.pop_back();\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkpm8hooj: /tmp/tmpkpm8hooj.cpp:51: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjyou6yd2: /tmp/tmpjyou6yd2.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1 || word.size() == 2) {\n            result += word + \" \";\n        }\
    \ else {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpw_nd_i8d: /tmp/tmpw_nd_i8d.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7) {\n\
    \            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpez7czxk_: /tmp/tmpez7czxk_.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size()\
    \ == 7) {\n            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        if (word.size()\
    \ == 1) {\n            result.append(word);\n            result.push_back(' ');\n\
    \        } else if (word.size() == 2) {\n            result.append(word);\n  \
    \          result.push_back(' ');\n        } else if (word.size() == 3) {\n  \
    \          result.append(word);\n            result.push_back(' ');\n        }\
    \ else if (word.size() == 5) {\n            result.append(word);\n           \
    \ result.push_back(' ');\n        } else if (word.size() == 7) {\n           \
    \ result.append(word);\n            result.push_back(' ');\n        }\n    }\n\
    \    if (result.back() == ' ') {\n        result.pop_back();\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkos8zpj7: /tmp/tmpkos8zpj7.cpp:55: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  std::vector<std::string> words;\n  while (ss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::vector<int> primes = {2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97};\n  std::string result;\n  for (auto word : words) {\n    if (std::find(primes.begin(),\
    \ primes.end(), word.size()) != primes.end()) {\n      result += word + \" \"\
    ;\n    }\n  }\n  return result.substr(0, result.size() - 1);\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    if (result.size()\
    \ > 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp08idc1od.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp08idc1od.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 1) {\n      result += word + \" \";\n      continue;\n    }\n    bool is_prime\
    \ = true;\n    for (int i = 2; i < word.size(); ++i) {\n      if (word.size()\
    \ % i == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n   \
    \ if (is_prime) {\n      result += word + \" \";\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpphite15y: /tmp/tmpphite15y.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        if (word.size()\
    \ == 1) {\n            result.append(word);\n            result.push_back(' ');\n\
    \        } else if (word.size() == 2) {\n            result.append(word);\n  \
    \          result.push_back(' ');\n        } else if (word.size() == 3) {\n  \
    \          result.append(word);\n            result.push_back(' ');\n        }\
    \ else if (word.size() == 5) {\n            result.append(word);\n           \
    \ result.push_back(' ');\n        } else if (word.size() == 7) {\n           \
    \ result.append(word);\n            result.push_back(' ');\n        }\n    }\n\
    \    if (result.size() > 0) {\n        result.pop_back();\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdhot6f05: /tmp/tmpdhot6f05.cpp:55: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    result.pop_back();\n   \
    \ return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmppj_4ghjy: /tmp/tmppj_4ghjy.cpp:36: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::istringstream\
    \ iss(sentence);\n  std::string word;\n  while (iss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      result\
    \ += word + \" \";\n    }\n  }\n  return result.substr(0, result.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i <= std::sqrt(word.size()); i += 2) {\n        if (word.size() % i ==\
    \ 0) {\n          is_prime = false;\n          break;\n        }\n      }\n  \
    \    if (is_prime) {\n        result += word + \" \";\n      }\n    }\n  }\n \
    \ result.pop_back();\n  return result;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpm3pvc6az: /tmp/tmpm3pvc6az.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_zz_4rts: /tmp/tmp_zz_4rts.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::string result;\n  for (const auto&\
    \ word : words) {\n    if (word.size() == 2 || word.size() == 3 || word.size()\
    \ == 5 || word.size() == 7) {\n      result += word + \" \";\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpuab30bz_: /tmp/tmpuab30bz_.cpp:40: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n            bool is_prime = true;\n        \
    \    for (int i = 3; i < word.size(); i += 2) {\n                if (word.size()\
    \ % i == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   result += word + \" \";\n            }\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpul82eh_f: /tmp/tmpul82eh_f.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcfy4oepa: /tmp/tmpcfy4oepa.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::vector<std::string> words;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<int> primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97};\n    std::string result;\n    for (const auto& word : words)\
    \ {\n        if (std::find(primes.begin(), primes.end(), word.size()) != primes.end())\
    \ {\n            result += word + \" \";\n        }\n    }\n    if (result.size()\
    \ > 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (const std::string& word : words) {\n      \
    \  if (word.size() > 1 && word.size() % 2 != 0) {\n            result += word\
    \ + ' ';\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpufhe5k8e: /tmp/tmpufhe5k8e.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  std::istringstream iss(sentence);\n  while (iss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::string result;\n  for (auto w : words)\
    \ {\n    if (w.size() == 1 || w.size() == 2) {\n      result += w + \" \";\n \
    \   } else {\n      bool is_prime = true;\n      for (int i = 2; i <= w.size()\
    \ / 2; ++i) {\n        if (w.size() % i == 0) {\n          is_prime = false;\n\
    \          break;\n        }\n      }\n      if (is_prime) {\n        result +=\
    \ w + \" \";\n      }\n    }\n  }\n  return result.substr(0, result.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmzu9kwfu: /tmp/tmpmzu9kwfu.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8hvzwfp3: /tmp/tmp8hvzwfp3.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1 || word.size() == 2) {\n            result += word + \" \";\n        }\
    \ else {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvftfiyj_: /tmp/tmpvftfiyj_.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1) {\n            bool is_prime = true;\n            for (int i = 2; i <=\
    \ word.size() / 2; ++i) {\n                if (word.size() % i == 0) {\n     \
    \               is_prime = false;\n                    break;\n              \
    \  }\n            }\n            if (is_prime) {\n                result += word\
    \ + \" \";\n            }\n        }\n    }\n    if (!result.empty()) {\n    \
    \    result.pop_back();\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::istringstream\
    \ iss(sentence);\n  std::string word;\n  while (iss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4v8edvos: /tmp/tmp4v8edvos.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::vector<std::string> words;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<int> primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97};\n    std::string result;\n    for (auto& word : words)\
    \ {\n        if (std::find(primes.begin(), primes.end(), word.size()) != primes.end())\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprf5y2rih: /tmp/tmprf5y2rih.cpp:41: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1 && word.size() % 2 != 0) {\n            bool is_prime = true;\n        \
    \    for (int i = 3; i <= std::sqrt(word.size()); i += 2) {\n                if\
    \ (word.size() % i == 0) {\n                    is_prime = false;\n          \
    \          break;\n                }\n            }\n            if (is_prime)\
    \ {\n                result += word + \" \";\n            }\n        }\n    }\n\
    \    result.pop_back();\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6607ucjl: /tmp/tmp6607ucjl.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    if (result.size() > 0) {\n\
    \        result.pop_back();\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    if (!word.empty())\
    \ {\n        words.push_back(word);\n    }\n    std::vector<std::string> result;\n\
    \    for (auto word : words) {\n        int len = word.size();\n        if (len\
    \ == 1) {\n            result.push_back(word);\n            continue;\n      \
    \  }\n        bool is_prime = true;\n        for (int i = 2; i < len; ++i) {\n\
    \            if (len % i == 0) {\n                is_prime = false;\n        \
    \        break;\n            }\n        }\n        if (is_prime) {\n         \
    \   result.push_back(word);\n        }\n    }\n    std::string res;\n    for (auto\
    \ word : result) {\n        res += word;\n        res += ' ';\n    }\n    if (!res.empty())\
    \ {\n        res.pop_back();\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbbo2rgqm: /tmp/tmpbbo2rgqm.cpp:61: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  for (char c : sentence) {\n    if (c == ' ') {\n     \
    \ words.push_back(word);\n      word.clear();\n    } else {\n      word.push_back(c);\n\
    \    }\n  }\n  words.push_back(word);\n  std::vector<int> primes = {2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97};\n  std::string result;\n  for (std::string word : words) {\n    if\
    \ (std::find(primes.begin(), primes.end(), word.size()) != primes.end()) {\n \
    \     result += word + \" \";\n    }\n  }\n  result.pop_back();\n  return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp17qyyqxw: /tmp/tmp17qyyqxw.cpp:46: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::string result;\n  for (const auto&\
    \ word : words) {\n    if (word.size() == 1) {\n      result += word + \" \";\n\
    \      continue;\n    }\n    bool is_prime = true;\n    for (int i = 2; i < word.size();\
    \ ++i) {\n      if (word.size() % i == 0) {\n        is_prime = false;\n     \
    \   break;\n      }\n    }\n    if (is_prime) {\n      result += word + \" \"\
    ;\n    }\n  }\n  result.pop_back();\n  return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp65brqn_u: /tmp/tmp65brqn_u.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9r16irpx: /tmp/tmp9r16irpx.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        if (word.size()\
    \ == 1) {\n            result.append(word);\n            result.push_back(' ');\n\
    \        } else if (word.size() == 2) {\n            result.append(word);\n  \
    \          result.push_back(' ');\n        } else if (word.size() == 3) {\n  \
    \          result.append(word);\n            result.push_back(' ');\n        }\
    \ else if (word.size() == 5) {\n            result.append(word);\n           \
    \ result.push_back(' ');\n        } else if (word.size() == 7) {\n           \
    \ result.append(word);\n            result.push_back(' ');\n        } else if\
    \ (word.size() == 11) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else if (word.size() == 13) {\n            result.append(word);\n\
    \            result.push_back(' ');\n        } else if (word.size() == 17) {\n\
    \            result.append(word);\n            result.push_back(' ');\n      \
    \  } else if (word.size() == 19) {\n            result.append(word);\n       \
    \     result.push_back(' ');\n        } else if (word.size() == 23) {\n      \
    \      result.append(word);\n            result.push_back(' ');\n        } else\
    \ if (word.size() == 29) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else if (word.size() == 31) {\n            result.append(word);\n\
    \            result.push_back(' ');\n        } else if (word.size() == 37) {\n\
    \            result.append(word);\n            result.push\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp467507lw.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp467507lw.cpp:69:20: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018push\u2019\
    \n   69 |             result.push\n      |                    ^~~~\n/tmp/tmp467507lw.cpp:71:9:\
    \ warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n\
    \   71 | int main() {\n      |         ^~\n/tmp/tmp467507lw.cpp:71:9: note: remove\
    \ parentheses to default-initialize a variable\n   71 | int main() {\n      |\
    \         ^~\n      |         --\n/tmp/tmp467507lw.cpp:71:9: note: or replace\
    \ parentheses with braces to value-initialize a variable\n/tmp/tmp467507lw.cpp:71:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   71 | int main() {\n      |            ^\n/tmp/tmp467507lw.cpp:80:2: error:\
    \ expected \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmp467507lw.cpp:30:29:\
    \ note: to match this \u2018{\u2019\n   30 |     for (auto word : words) {\n \
    \     |                             ^\n/tmp/tmp467507lw.cpp:80:2: error: expected\
    \ \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmp467507lw.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmp467507lw.cpp:80:2: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   80 | }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.size() == 1) {\n            result += word + \" \";\n        \
    \    continue;\n        }\n        bool is_prime = true;\n        for (int i =\
    \ 2; i <= word.size() / 2; ++i) {\n            if (word.size() % i == 0) {\n \
    \               is_prime = false;\n                break;\n            }\n   \
    \     }\n        if (is_prime) {\n            result += word + \" \";\n      \
    \  }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfuudt4bq: /tmp/tmpfuudt4bq.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmperc81rd3: /tmp/tmperc81rd3.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (auto word : words) {\n        if (word.size()\
    \ == 1) {\n            result.append(word);\n            result.push_back(' ');\n\
    \        } else if (word.size() == 2) {\n            result.append(word);\n  \
    \          result.push_back(' ');\n        } else if (word.size() == 3) {\n  \
    \          result.append(word);\n            result.push_back(' ');\n        }\
    \ else if (word.size() == 5) {\n            result.append(word);\n           \
    \ result.push_back(' ');\n        } else if (word.size() == 7) {\n           \
    \ result.append(word);\n            result.push_back(' ');\n        } else if\
    \ (word.size() == 11) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else if (word.size() == 13) {\n            result.append(word);\n\
    \            result.push_back(' ');\n        } else if (word.size() == 17) {\n\
    \            result.append(word);\n            result.push_back(' ');\n      \
    \  } else if (word.size() == 19) {\n            result.append(word);\n       \
    \     result.push_back(' ');\n        } else if (word.size() == 23) {\n      \
    \      result.append(word);\n            result.push_back(' ');\n        } else\
    \ if (word.size() == 29) {\n            result.append(word);\n            result.push_back('\
    \ ');\n        } else if (word.size() == 31) {\n            result.append(word);\n\
    \            result.push_back(' ');\n        } else if (word.size() == 37) {\n\
    \            result.append(word);\n            result.push\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc83t7xd4.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpc83t7xd4.cpp:69:20: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018push\u2019\
    \n   69 |             result.push\n      |                    ^~~~\n/tmp/tmpc83t7xd4.cpp:71:9:\
    \ warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse]\n\
    \   71 | int main() {\n      |         ^~\n/tmp/tmpc83t7xd4.cpp:71:9: note: remove\
    \ parentheses to default-initialize a variable\n   71 | int main() {\n      |\
    \         ^~\n      |         --\n/tmp/tmpc83t7xd4.cpp:71:9: note: or replace\
    \ parentheses with braces to value-initialize a variable\n/tmp/tmpc83t7xd4.cpp:71:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   71 | int main() {\n      |            ^\n/tmp/tmpc83t7xd4.cpp:80:2: error:\
    \ expected \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmpc83t7xd4.cpp:30:29:\
    \ note: to match this \u2018{\u2019\n   30 |     for (auto word : words) {\n \
    \     |                             ^\n/tmp/tmpc83t7xd4.cpp:80:2: error: expected\
    \ \u2018}\u2019 at end of input\n   80 | }\n      |  ^\n/tmp/tmpc83t7xd4.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpc83t7xd4.cpp:80:2: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   80 | }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size() ==\
    \ 7 || word.size() == 11 || word.size() == 13 || word.size() == 17 || word.size()\
    \ == 19 || word.size() == 23 || word.size() == 29 || word.size() == 31 || word.size()\
    \ == 37 || word.size() == 41 || word.size() == 43 || word.size() == 47 || word.size()\
    \ == 53 || word.size() == 59 || word.size() == 61 || word.size() == 67 || word.size()\
    \ == 71 || word.size() == 73 || word.size() == 79 || word.size() == 83 || word.size()\
    \ == 89 || word.size() == 97) {\n            result += word + \" \";\n       \
    \ }\n    }\n    return result.substr(0, result.size() - 1);\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpts2e9yb2: /tmp/tmpts2e9yb2.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7 || word.length()\
    \ == 11 || word.length() == 13 || word.length() == 17 || word.length() == 19 ||\
    \ word.length() == 23 || word.length() == 29 || word.length() == 31 || word.length()\
    \ == 37 || word.length() == 41 || word.length() == 43 || word.length() == 47 ||\
    \ word.length() == 53 || word.length() == 59 || word.length() == 61 || word.length()\
    \ == 67 || word.length() == 71 || word.length() == 73 || word.length() == 79 ||\
    \ word.length() == 83 || word.length() == 89 || word.length() == 97) {\n     \
    \       result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        if (word.size() == 2 || word.size() == 3 || word.size() ==\
    \ 5 || word.size() == 7 || word.size() == 11 || word.size() == 13 || word.size()\
    \ == 17 || word.size() == 19 || word.size() == 23 || word.size() == 29 || word.size()\
    \ == 31 || word.size() == 37 || word.size() == 41 || word.size() == 43 || word.size()\
    \ == 47 || word.size() == 53 || word.size() == 59 || word.size() == 61 || word.size()\
    \ == 67 || word.size() == 71 || word.size() == 73 || word.size() == 79 || word.size()\
    \ == 83 || word.size() == 89 || word.size() == 97) {\n            result += word\
    \ + \" \";\n        }\n    }\n    return result.substr(0, result.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.length(); ++i) {\n\
    \                if (word.length() % i == 0) {\n                    is_prime =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       if (is_prime) {\n                result += word + \" \";\n           \
    \ }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf20rd8oh: /tmp/tmpf20rd8oh.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7) {\n\
    \            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        if (word.size() == 1) {\n            result += word + \" \"\
    ;\n        } else {\n            bool is_prime = true;\n            for (int i\
    \ = 2; i < word.size(); i++) {\n                if (word.size() % i == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n            if (is_prime) {\n                result\
    \ += word + \" \";\n            }\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp854leey0: /tmp/tmp854leey0.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    std::string result;\n\
    \    for (std::string word : words) {\n        if (std::find(primes.begin(), primes.end(),\
    \ word.size()) != primes.end()) {\n            result += word + \" \";\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8oyogqvg: /tmp/tmp8oyogqvg.cpp:46: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (word.size() == 1) {\n            result += word + \" \";\n        } else {\n\
    \            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpn8iognw_: /tmp/tmpn8iognw_.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxjcuzq91: /tmp/tmpxjcuzq91.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (std::getline(ss,\
    \ word, ' ')) {\n        words.push_back(word);\n    }\n    std::string result;\n\
    \    for (const auto& word : words) {\n        if (word.size() == 2 || word.size()\
    \ == 3 || word.size() == 5 || word.size() == 7) {\n            result += word\
    \ + \" \";\n        }\n    }\n    result.pop_back();\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpyt6w83ww: /tmp/tmpyt6w83ww.cpp:40: int main(): Assertion `candidate((\"\
    here\")) == (\"\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1 || word.size() == 2) {\n            result += word + \" \";\n        }\
    \ else {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdfa7m7nr: /tmp/tmpdfa7m7nr.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1 && word.size() % 2 == 1) {\n            bool is_prime = true;\n        \
    \    for (int i = 3; i <= sqrt(word.size()); i += 2) {\n                if (word.size()\
    \ % i == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   result += word + \" \";\n            }\n        }\n    }\n    if (result.size()\
    \ > 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfovab_4u: /tmp/tmpfovab_4u.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (iss >> word) {\n        if\
    \ (is_prime(word.size())) {\n            result += word + \" \";\n        }\n\
    \    }\n    result.pop_back();\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpedc9qvvd.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpedc9qvvd.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size()\
    \ == 7) {\n            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::string result;\n    for (const std::string& word : words) {\n      \
    \  if (word.size() == 1 || word.size() == 2) {\n            result += word + '\
    \ ';\n        } else {\n            bool is_prime = true;\n            for (int\
    \ i = 2; i < word.size(); ++i) {\n                if (word.size() % i == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n            if (is_prime) {\n                result\
    \ += word + ' ';\n            }\n        }\n    }\n    if (!result.empty()) {\n\
    \        result.pop_back();\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmppe4mzqt2: /tmp/tmppe4mzqt2.cpp:53: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::istringstream\
    \ iss(sentence);\n  std::string word;\n  while (iss >> word) {\n    if (word.size()\
    \ > 1 && word.size() % 2 == 1) {\n      bool is_prime = true;\n      for (int\
    \ i = 3; i < word.size(); i += 2) {\n        if (word.size() % i == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += word + \" \";\n      }\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp79pfgi6k: /tmp/tmp79pfgi6k.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      \
    \      result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuw3d3zxf.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpuw3d3zxf.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ > 1) {\n            bool is_prime = true;\n            for (int i = 2; i < word.size();\
    \ ++i) {\n                if (word.size() % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result += word + \" \";\n         \
    \   }\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7) {\n\
    \            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7) {\n\
    \            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.length()\
    \ == 2 || word.length() == 3 || word.length() == 5 || word.length() == 7) {\n\
    \            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.length() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::vector<std::string>\
    \ words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while\
    \ (ss >> word) {\n        words.push_back(word);\n    }\n    for (int i = 0; i\
    \ < words.size(); i++) {\n        if (words[i].size() == 1) {\n            result\
    \ += words[i] + \" \";\n        } else {\n            bool is_prime = true;\n\
    \            for (int j = 2; j < words[i].size(); j++) {\n                if (words[i].size()\
    \ % j == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   result += words[i] + \" \";\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0anqpcgy: /tmp/tmp0anqpcgy.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (word.size()\
    \ == 1) {\n            result += word + \" \";\n        } else {\n           \
    \ bool is_prime = true;\n            for (int i = 2; i < word.size(); ++i) {\n\
    \                if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    return result.substr(0, result.size() - 1);\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp28adadyw: /tmp/tmp28adadyw.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7 || word.size()\
    \ == 11 || word.size() == 13 || word.size() == 17 || word.size() == 19 || word.size()\
    \ == 23 || word.size() == 29 || word.size() == 31 || word.size() == 37 || word.size()\
    \ == 41 || word.size() == 43 || word.size() == 47 || word.size() == 53 || word.size()\
    \ == 59 || word.size() == 61 || word.size() == 67 || word.size() == 71 || word.size()\
    \ == 73 || word.size() == 79 || word.size() == 83 || word.size() == 89 || word.size()\
    \ == 97) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  std::istringstream iss(sentence);\n  while (iss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::vector<int> primes = {2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97};\n  std::string result;\n  for (auto word : words) {\n    if (std::find(primes.begin(),\
    \ primes.end(), word.size()) != primes.end()) {\n      result += word + \" \"\
    ;\n    }\n  }\n  return result.substr(0, result.size() - 1);\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
